<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: regexp.go in package regexp/syntax</title>
<link href="../../../css/light-v0.1.6.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.1.6.js"></script>
<body><div>

<pre id="header"><code><span class="title">Source File</span>
	regexp.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/regexp/syntax.html">regexp/syntax</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2011 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>package syntax</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>// Note to implementers:</code></span>
<span class="codeline" id="line-8"><code>// In this package, re is always a *Regexp and r is always a rune.</code></span>
<span class="codeline" id="line-9"><code></code></span>
<span class="codeline" id="line-10"><code>import (</code></span>
<span class="codeline" id="line-11"><code>	"strconv"</code></span>
<span class="codeline" id="line-12"><code>	"strings"</code></span>
<span class="codeline" id="line-13"><code>	"unicode"</code></span>
<span class="codeline" id="line-14"><code>)</code></span>
<span class="codeline" id="line-15"><code></code></span>
<span class="codeline" id="line-16"><code>// A Regexp is a node in a regular expression syntax tree.</code></span>
<span class="codeline" id="line-17"><code>type Regexp struct {</code></span>
<span class="codeline" id="line-18"><code>	Op       Op // operator</code></span>
<span class="codeline" id="line-19"><code>	Flags    Flags</code></span>
<span class="codeline" id="line-20"><code>	Sub      []*Regexp  // subexpressions, if any</code></span>
<span class="codeline" id="line-21"><code>	Sub0     [1]*Regexp // storage for short Sub</code></span>
<span class="codeline" id="line-22"><code>	Rune     []rune     // matched runes, for OpLiteral, OpCharClass</code></span>
<span class="codeline" id="line-23"><code>	Rune0    [2]rune    // storage for short Rune</code></span>
<span class="codeline" id="line-24"><code>	Min, Max int        // min, max for OpRepeat</code></span>
<span class="codeline" id="line-25"><code>	Cap      int        // capturing index, for OpCapture</code></span>
<span class="codeline" id="line-26"><code>	Name     string     // capturing name, for OpCapture</code></span>
<span class="codeline" id="line-27"><code>}</code></span>
<span class="codeline" id="line-28"><code></code></span>
<span class="codeline" id="line-29"><code>//go:generate stringer -type Op -trimprefix Op</code></span>
<span class="codeline" id="line-30"><code></code></span>
<span class="codeline" id="line-31"><code>// An Op is a single regular expression operator.</code></span>
<span class="codeline" id="line-32"><code>type Op uint8</code></span>
<span class="codeline" id="line-33"><code></code></span>
<span class="codeline" id="line-34"><code>// Operators are listed in precedence order, tightest binding to weakest.</code></span>
<span class="codeline" id="line-35"><code>// Character class operators are listed simplest to most complex</code></span>
<span class="codeline" id="line-36"><code>// (OpLiteral, OpCharClass, OpAnyCharNotNL, OpAnyChar).</code></span>
<span class="codeline" id="line-37"><code></code></span>
<span class="codeline" id="line-38"><code>const (</code></span>
<span class="codeline" id="line-39"><code>	OpNoMatch        Op = 1 + iota // matches no strings</code></span>
<span class="codeline" id="line-40"><code>	OpEmptyMatch                   // matches empty string</code></span>
<span class="codeline" id="line-41"><code>	OpLiteral                      // matches Runes sequence</code></span>
<span class="codeline" id="line-42"><code>	OpCharClass                    // matches Runes interpreted as range pair list</code></span>
<span class="codeline" id="line-43"><code>	OpAnyCharNotNL                 // matches any character except newline</code></span>
<span class="codeline" id="line-44"><code>	OpAnyChar                      // matches any character</code></span>
<span class="codeline" id="line-45"><code>	OpBeginLine                    // matches empty string at beginning of line</code></span>
<span class="codeline" id="line-46"><code>	OpEndLine                      // matches empty string at end of line</code></span>
<span class="codeline" id="line-47"><code>	OpBeginText                    // matches empty string at beginning of text</code></span>
<span class="codeline" id="line-48"><code>	OpEndText                      // matches empty string at end of text</code></span>
<span class="codeline" id="line-49"><code>	OpWordBoundary                 // matches word boundary `\b`</code></span>
<span class="codeline" id="line-50"><code>	OpNoWordBoundary               // matches word non-boundary `\B`</code></span>
<span class="codeline" id="line-51"><code>	OpCapture                      // capturing subexpression with index Cap, optional name Name</code></span>
<span class="codeline" id="line-52"><code>	OpStar                         // matches Sub[0] zero or more times</code></span>
<span class="codeline" id="line-53"><code>	OpPlus                         // matches Sub[0] one or more times</code></span>
<span class="codeline" id="line-54"><code>	OpQuest                        // matches Sub[0] zero or one times</code></span>
<span class="codeline" id="line-55"><code>	OpRepeat                       // matches Sub[0] at least Min times, at most Max (Max == -1 is no limit)</code></span>
<span class="codeline" id="line-56"><code>	OpConcat                       // matches concatenation of Subs</code></span>
<span class="codeline" id="line-57"><code>	OpAlternate                    // matches alternation of Subs</code></span>
<span class="codeline" id="line-58"><code>)</code></span>
<span class="codeline" id="line-59"><code></code></span>
<span class="codeline" id="line-60"><code>const opPseudo Op = 128 // where pseudo-ops start</code></span>
<span class="codeline" id="line-61"><code></code></span>
<span class="codeline" id="line-62"><code>// Equal reports whether x and y have identical structure.</code></span>
<span class="codeline" id="line-63"><code>func (x *Regexp) Equal(y *Regexp) bool {</code></span>
<span class="codeline" id="line-64"><code>	if x == nil || y == nil {</code></span>
<span class="codeline" id="line-65"><code>		return x == y</code></span>
<span class="codeline" id="line-66"><code>	}</code></span>
<span class="codeline" id="line-67"><code>	if x.Op != y.Op {</code></span>
<span class="codeline" id="line-68"><code>		return false</code></span>
<span class="codeline" id="line-69"><code>	}</code></span>
<span class="codeline" id="line-70"><code>	switch x.Op {</code></span>
<span class="codeline" id="line-71"><code>	case OpEndText:</code></span>
<span class="codeline" id="line-72"><code>		// The parse flags remember whether this is \z or \Z.</code></span>
<span class="codeline" id="line-73"><code>		if x.Flags&amp;WasDollar != y.Flags&amp;WasDollar {</code></span>
<span class="codeline" id="line-74"><code>			return false</code></span>
<span class="codeline" id="line-75"><code>		}</code></span>
<span class="codeline" id="line-76"><code></code></span>
<span class="codeline" id="line-77"><code>	case OpLiteral, OpCharClass:</code></span>
<span class="codeline" id="line-78"><code>		if len(x.Rune) != len(y.Rune) {</code></span>
<span class="codeline" id="line-79"><code>			return false</code></span>
<span class="codeline" id="line-80"><code>		}</code></span>
<span class="codeline" id="line-81"><code>		for i, r := range x.Rune {</code></span>
<span class="codeline" id="line-82"><code>			if r != y.Rune[i] {</code></span>
<span class="codeline" id="line-83"><code>				return false</code></span>
<span class="codeline" id="line-84"><code>			}</code></span>
<span class="codeline" id="line-85"><code>		}</code></span>
<span class="codeline" id="line-86"><code></code></span>
<span class="codeline" id="line-87"><code>	case OpAlternate, OpConcat:</code></span>
<span class="codeline" id="line-88"><code>		if len(x.Sub) != len(y.Sub) {</code></span>
<span class="codeline" id="line-89"><code>			return false</code></span>
<span class="codeline" id="line-90"><code>		}</code></span>
<span class="codeline" id="line-91"><code>		for i, sub := range x.Sub {</code></span>
<span class="codeline" id="line-92"><code>			if !sub.Equal(y.Sub[i]) {</code></span>
<span class="codeline" id="line-93"><code>				return false</code></span>
<span class="codeline" id="line-94"><code>			}</code></span>
<span class="codeline" id="line-95"><code>		}</code></span>
<span class="codeline" id="line-96"><code></code></span>
<span class="codeline" id="line-97"><code>	case OpStar, OpPlus, OpQuest:</code></span>
<span class="codeline" id="line-98"><code>		if x.Flags&amp;NonGreedy != y.Flags&amp;NonGreedy || !x.Sub[0].Equal(y.Sub[0]) {</code></span>
<span class="codeline" id="line-99"><code>			return false</code></span>
<span class="codeline" id="line-100"><code>		}</code></span>
<span class="codeline" id="line-101"><code></code></span>
<span class="codeline" id="line-102"><code>	case OpRepeat:</code></span>
<span class="codeline" id="line-103"><code>		if x.Flags&amp;NonGreedy != y.Flags&amp;NonGreedy || x.Min != y.Min || x.Max != y.Max || !x.Sub[0].Equal(y.Sub[0]) {</code></span>
<span class="codeline" id="line-104"><code>			return false</code></span>
<span class="codeline" id="line-105"><code>		}</code></span>
<span class="codeline" id="line-106"><code></code></span>
<span class="codeline" id="line-107"><code>	case OpCapture:</code></span>
<span class="codeline" id="line-108"><code>		if x.Cap != y.Cap || x.Name != y.Name || !x.Sub[0].Equal(y.Sub[0]) {</code></span>
<span class="codeline" id="line-109"><code>			return false</code></span>
<span class="codeline" id="line-110"><code>		}</code></span>
<span class="codeline" id="line-111"><code>	}</code></span>
<span class="codeline" id="line-112"><code>	return true</code></span>
<span class="codeline" id="line-113"><code>}</code></span>
<span class="codeline" id="line-114"><code></code></span>
<span class="codeline" id="line-115"><code>// writeRegexp writes the Perl syntax for the regular expression re to b.</code></span>
<span class="codeline" id="line-116"><code>func writeRegexp(b *strings.Builder, re *Regexp) {</code></span>
<span class="codeline" id="line-117"><code>	switch re.Op {</code></span>
<span class="codeline" id="line-118"><code>	default:</code></span>
<span class="codeline" id="line-119"><code>		b.WriteString("&lt;invalid op" + strconv.Itoa(int(re.Op)) + "&gt;")</code></span>
<span class="codeline" id="line-120"><code>	case OpNoMatch:</code></span>
<span class="codeline" id="line-121"><code>		b.WriteString(`[^\x00-\x{10FFFF}]`)</code></span>
<span class="codeline" id="line-122"><code>	case OpEmptyMatch:</code></span>
<span class="codeline" id="line-123"><code>		b.WriteString(`(?:)`)</code></span>
<span class="codeline" id="line-124"><code>	case OpLiteral:</code></span>
<span class="codeline" id="line-125"><code>		if re.Flags&amp;FoldCase != 0 {</code></span>
<span class="codeline" id="line-126"><code>			b.WriteString(`(?i:`)</code></span>
<span class="codeline" id="line-127"><code>		}</code></span>
<span class="codeline" id="line-128"><code>		for _, r := range re.Rune {</code></span>
<span class="codeline" id="line-129"><code>			escape(b, r, false)</code></span>
<span class="codeline" id="line-130"><code>		}</code></span>
<span class="codeline" id="line-131"><code>		if re.Flags&amp;FoldCase != 0 {</code></span>
<span class="codeline" id="line-132"><code>			b.WriteString(`)`)</code></span>
<span class="codeline" id="line-133"><code>		}</code></span>
<span class="codeline" id="line-134"><code>	case OpCharClass:</code></span>
<span class="codeline" id="line-135"><code>		if len(re.Rune)%2 != 0 {</code></span>
<span class="codeline" id="line-136"><code>			b.WriteString(`[invalid char class]`)</code></span>
<span class="codeline" id="line-137"><code>			break</code></span>
<span class="codeline" id="line-138"><code>		}</code></span>
<span class="codeline" id="line-139"><code>		b.WriteRune('[')</code></span>
<span class="codeline" id="line-140"><code>		if len(re.Rune) == 0 {</code></span>
<span class="codeline" id="line-141"><code>			b.WriteString(`^\x00-\x{10FFFF}`)</code></span>
<span class="codeline" id="line-142"><code>		} else if re.Rune[0] == 0 &amp;&amp; re.Rune[len(re.Rune)-1] == unicode.MaxRune &amp;&amp; len(re.Rune) &gt; 2 {</code></span>
<span class="codeline" id="line-143"><code>			// Contains 0 and MaxRune. Probably a negated class.</code></span>
<span class="codeline" id="line-144"><code>			// Print the gaps.</code></span>
<span class="codeline" id="line-145"><code>			b.WriteRune('^')</code></span>
<span class="codeline" id="line-146"><code>			for i := 1; i &lt; len(re.Rune)-1; i += 2 {</code></span>
<span class="codeline" id="line-147"><code>				lo, hi := re.Rune[i]+1, re.Rune[i+1]-1</code></span>
<span class="codeline" id="line-148"><code>				escape(b, lo, lo == '-')</code></span>
<span class="codeline" id="line-149"><code>				if lo != hi {</code></span>
<span class="codeline" id="line-150"><code>					b.WriteRune('-')</code></span>
<span class="codeline" id="line-151"><code>					escape(b, hi, hi == '-')</code></span>
<span class="codeline" id="line-152"><code>				}</code></span>
<span class="codeline" id="line-153"><code>			}</code></span>
<span class="codeline" id="line-154"><code>		} else {</code></span>
<span class="codeline" id="line-155"><code>			for i := 0; i &lt; len(re.Rune); i += 2 {</code></span>
<span class="codeline" id="line-156"><code>				lo, hi := re.Rune[i], re.Rune[i+1]</code></span>
<span class="codeline" id="line-157"><code>				escape(b, lo, lo == '-')</code></span>
<span class="codeline" id="line-158"><code>				if lo != hi {</code></span>
<span class="codeline" id="line-159"><code>					b.WriteRune('-')</code></span>
<span class="codeline" id="line-160"><code>					escape(b, hi, hi == '-')</code></span>
<span class="codeline" id="line-161"><code>				}</code></span>
<span class="codeline" id="line-162"><code>			}</code></span>
<span class="codeline" id="line-163"><code>		}</code></span>
<span class="codeline" id="line-164"><code>		b.WriteRune(']')</code></span>
<span class="codeline" id="line-165"><code>	case OpAnyCharNotNL:</code></span>
<span class="codeline" id="line-166"><code>		b.WriteString(`(?-s:.)`)</code></span>
<span class="codeline" id="line-167"><code>	case OpAnyChar:</code></span>
<span class="codeline" id="line-168"><code>		b.WriteString(`(?s:.)`)</code></span>
<span class="codeline" id="line-169"><code>	case OpBeginLine:</code></span>
<span class="codeline" id="line-170"><code>		b.WriteString(`(?m:^)`)</code></span>
<span class="codeline" id="line-171"><code>	case OpEndLine:</code></span>
<span class="codeline" id="line-172"><code>		b.WriteString(`(?m:$)`)</code></span>
<span class="codeline" id="line-173"><code>	case OpBeginText:</code></span>
<span class="codeline" id="line-174"><code>		b.WriteString(`\A`)</code></span>
<span class="codeline" id="line-175"><code>	case OpEndText:</code></span>
<span class="codeline" id="line-176"><code>		if re.Flags&amp;WasDollar != 0 {</code></span>
<span class="codeline" id="line-177"><code>			b.WriteString(`(?-m:$)`)</code></span>
<span class="codeline" id="line-178"><code>		} else {</code></span>
<span class="codeline" id="line-179"><code>			b.WriteString(`\z`)</code></span>
<span class="codeline" id="line-180"><code>		}</code></span>
<span class="codeline" id="line-181"><code>	case OpWordBoundary:</code></span>
<span class="codeline" id="line-182"><code>		b.WriteString(`\b`)</code></span>
<span class="codeline" id="line-183"><code>	case OpNoWordBoundary:</code></span>
<span class="codeline" id="line-184"><code>		b.WriteString(`\B`)</code></span>
<span class="codeline" id="line-185"><code>	case OpCapture:</code></span>
<span class="codeline" id="line-186"><code>		if re.Name != "" {</code></span>
<span class="codeline" id="line-187"><code>			b.WriteString(`(?P&lt;`)</code></span>
<span class="codeline" id="line-188"><code>			b.WriteString(re.Name)</code></span>
<span class="codeline" id="line-189"><code>			b.WriteRune('&gt;')</code></span>
<span class="codeline" id="line-190"><code>		} else {</code></span>
<span class="codeline" id="line-191"><code>			b.WriteRune('(')</code></span>
<span class="codeline" id="line-192"><code>		}</code></span>
<span class="codeline" id="line-193"><code>		if re.Sub[0].Op != OpEmptyMatch {</code></span>
<span class="codeline" id="line-194"><code>			writeRegexp(b, re.Sub[0])</code></span>
<span class="codeline" id="line-195"><code>		}</code></span>
<span class="codeline" id="line-196"><code>		b.WriteRune(')')</code></span>
<span class="codeline" id="line-197"><code>	case OpStar, OpPlus, OpQuest, OpRepeat:</code></span>
<span class="codeline" id="line-198"><code>		if sub := re.Sub[0]; sub.Op &gt; OpCapture || sub.Op == OpLiteral &amp;&amp; len(sub.Rune) &gt; 1 {</code></span>
<span class="codeline" id="line-199"><code>			b.WriteString(`(?:`)</code></span>
<span class="codeline" id="line-200"><code>			writeRegexp(b, sub)</code></span>
<span class="codeline" id="line-201"><code>			b.WriteString(`)`)</code></span>
<span class="codeline" id="line-202"><code>		} else {</code></span>
<span class="codeline" id="line-203"><code>			writeRegexp(b, sub)</code></span>
<span class="codeline" id="line-204"><code>		}</code></span>
<span class="codeline" id="line-205"><code>		switch re.Op {</code></span>
<span class="codeline" id="line-206"><code>		case OpStar:</code></span>
<span class="codeline" id="line-207"><code>			b.WriteRune('*')</code></span>
<span class="codeline" id="line-208"><code>		case OpPlus:</code></span>
<span class="codeline" id="line-209"><code>			b.WriteRune('+')</code></span>
<span class="codeline" id="line-210"><code>		case OpQuest:</code></span>
<span class="codeline" id="line-211"><code>			b.WriteRune('?')</code></span>
<span class="codeline" id="line-212"><code>		case OpRepeat:</code></span>
<span class="codeline" id="line-213"><code>			b.WriteRune('{')</code></span>
<span class="codeline" id="line-214"><code>			b.WriteString(strconv.Itoa(re.Min))</code></span>
<span class="codeline" id="line-215"><code>			if re.Max != re.Min {</code></span>
<span class="codeline" id="line-216"><code>				b.WriteRune(',')</code></span>
<span class="codeline" id="line-217"><code>				if re.Max &gt;= 0 {</code></span>
<span class="codeline" id="line-218"><code>					b.WriteString(strconv.Itoa(re.Max))</code></span>
<span class="codeline" id="line-219"><code>				}</code></span>
<span class="codeline" id="line-220"><code>			}</code></span>
<span class="codeline" id="line-221"><code>			b.WriteRune('}')</code></span>
<span class="codeline" id="line-222"><code>		}</code></span>
<span class="codeline" id="line-223"><code>		if re.Flags&amp;NonGreedy != 0 {</code></span>
<span class="codeline" id="line-224"><code>			b.WriteRune('?')</code></span>
<span class="codeline" id="line-225"><code>		}</code></span>
<span class="codeline" id="line-226"><code>	case OpConcat:</code></span>
<span class="codeline" id="line-227"><code>		for _, sub := range re.Sub {</code></span>
<span class="codeline" id="line-228"><code>			if sub.Op == OpAlternate {</code></span>
<span class="codeline" id="line-229"><code>				b.WriteString(`(?:`)</code></span>
<span class="codeline" id="line-230"><code>				writeRegexp(b, sub)</code></span>
<span class="codeline" id="line-231"><code>				b.WriteString(`)`)</code></span>
<span class="codeline" id="line-232"><code>			} else {</code></span>
<span class="codeline" id="line-233"><code>				writeRegexp(b, sub)</code></span>
<span class="codeline" id="line-234"><code>			}</code></span>
<span class="codeline" id="line-235"><code>		}</code></span>
<span class="codeline" id="line-236"><code>	case OpAlternate:</code></span>
<span class="codeline" id="line-237"><code>		for i, sub := range re.Sub {</code></span>
<span class="codeline" id="line-238"><code>			if i &gt; 0 {</code></span>
<span class="codeline" id="line-239"><code>				b.WriteRune('|')</code></span>
<span class="codeline" id="line-240"><code>			}</code></span>
<span class="codeline" id="line-241"><code>			writeRegexp(b, sub)</code></span>
<span class="codeline" id="line-242"><code>		}</code></span>
<span class="codeline" id="line-243"><code>	}</code></span>
<span class="codeline" id="line-244"><code>}</code></span>
<span class="codeline" id="line-245"><code></code></span>
<span class="codeline" id="line-246"><code>func (re *Regexp) String() string {</code></span>
<span class="codeline" id="line-247"><code>	var b strings.Builder</code></span>
<span class="codeline" id="line-248"><code>	writeRegexp(&amp;b, re)</code></span>
<span class="codeline" id="line-249"><code>	return b.String()</code></span>
<span class="codeline" id="line-250"><code>}</code></span>
<span class="codeline" id="line-251"><code></code></span>
<span class="codeline" id="line-252"><code>const meta = `\.+*?()|[]{}^$`</code></span>
<span class="codeline" id="line-253"><code></code></span>
<span class="codeline" id="line-254"><code>func escape(b *strings.Builder, r rune, force bool) {</code></span>
<span class="codeline" id="line-255"><code>	if unicode.IsPrint(r) {</code></span>
<span class="codeline" id="line-256"><code>		if strings.ContainsRune(meta, r) || force {</code></span>
<span class="codeline" id="line-257"><code>			b.WriteRune('\\')</code></span>
<span class="codeline" id="line-258"><code>		}</code></span>
<span class="codeline" id="line-259"><code>		b.WriteRune(r)</code></span>
<span class="codeline" id="line-260"><code>		return</code></span>
<span class="codeline" id="line-261"><code>	}</code></span>
<span class="codeline" id="line-262"><code></code></span>
<span class="codeline" id="line-263"><code>	switch r {</code></span>
<span class="codeline" id="line-264"><code>	case '\a':</code></span>
<span class="codeline" id="line-265"><code>		b.WriteString(`\a`)</code></span>
<span class="codeline" id="line-266"><code>	case '\f':</code></span>
<span class="codeline" id="line-267"><code>		b.WriteString(`\f`)</code></span>
<span class="codeline" id="line-268"><code>	case '\n':</code></span>
<span class="codeline" id="line-269"><code>		b.WriteString(`\n`)</code></span>
<span class="codeline" id="line-270"><code>	case '\r':</code></span>
<span class="codeline" id="line-271"><code>		b.WriteString(`\r`)</code></span>
<span class="codeline" id="line-272"><code>	case '\t':</code></span>
<span class="codeline" id="line-273"><code>		b.WriteString(`\t`)</code></span>
<span class="codeline" id="line-274"><code>	case '\v':</code></span>
<span class="codeline" id="line-275"><code>		b.WriteString(`\v`)</code></span>
<span class="codeline" id="line-276"><code>	default:</code></span>
<span class="codeline" id="line-277"><code>		if r &lt; 0x100 {</code></span>
<span class="codeline" id="line-278"><code>			b.WriteString(`\x`)</code></span>
<span class="codeline" id="line-279"><code>			s := strconv.FormatInt(int64(r), 16)</code></span>
<span class="codeline" id="line-280"><code>			if len(s) == 1 {</code></span>
<span class="codeline" id="line-281"><code>				b.WriteRune('0')</code></span>
<span class="codeline" id="line-282"><code>			}</code></span>
<span class="codeline" id="line-283"><code>			b.WriteString(s)</code></span>
<span class="codeline" id="line-284"><code>			break</code></span>
<span class="codeline" id="line-285"><code>		}</code></span>
<span class="codeline" id="line-286"><code>		b.WriteString(`\x{`)</code></span>
<span class="codeline" id="line-287"><code>		b.WriteString(strconv.FormatInt(int64(r), 16))</code></span>
<span class="codeline" id="line-288"><code>		b.WriteString(`}`)</code></span>
<span class="codeline" id="line-289"><code>	}</code></span>
<span class="codeline" id="line-290"><code>}</code></span>
<span class="codeline" id="line-291"><code></code></span>
<span class="codeline" id="line-292"><code>// MaxCap walks the regexp to find the maximum capture index.</code></span>
<span class="codeline" id="line-293"><code>func (re *Regexp) MaxCap() int {</code></span>
<span class="codeline" id="line-294"><code>	m := 0</code></span>
<span class="codeline" id="line-295"><code>	if re.Op == OpCapture {</code></span>
<span class="codeline" id="line-296"><code>		m = re.Cap</code></span>
<span class="codeline" id="line-297"><code>	}</code></span>
<span class="codeline" id="line-298"><code>	for _, sub := range re.Sub {</code></span>
<span class="codeline" id="line-299"><code>		if n := sub.MaxCap(); m &lt; n {</code></span>
<span class="codeline" id="line-300"><code>			m = n</code></span>
<span class="codeline" id="line-301"><code>		}</code></span>
<span class="codeline" id="line-302"><code>	}</code></span>
<span class="codeline" id="line-303"><code>	return m</code></span>
<span class="codeline" id="line-304"><code>}</code></span>
<span class="codeline" id="line-305"><code></code></span>
<span class="codeline" id="line-306"><code>// CapNames walks the regexp to find the names of capturing groups.</code></span>
<span class="codeline" id="line-307"><code>func (re *Regexp) CapNames() []string {</code></span>
<span class="codeline" id="line-308"><code>	names := make([]string, re.MaxCap()+1)</code></span>
<span class="codeline" id="line-309"><code>	re.capNames(names)</code></span>
<span class="codeline" id="line-310"><code>	return names</code></span>
<span class="codeline" id="line-311"><code>}</code></span>
<span class="codeline" id="line-312"><code></code></span>
<span class="codeline" id="line-313"><code>func (re *Regexp) capNames(names []string) {</code></span>
<span class="codeline" id="line-314"><code>	if re.Op == OpCapture {</code></span>
<span class="codeline" id="line-315"><code>		names[re.Cap] = re.Name</code></span>
<span class="codeline" id="line-316"><code>	}</code></span>
<span class="codeline" id="line-317"><code>	for _, sub := range re.Sub {</code></span>
<span class="codeline" id="line-318"><code>		sub.capNames(names)</code></span>
<span class="codeline" id="line-319"><code>	}</code></span>
<span class="codeline" id="line-320"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.1.6</i>. (GOOS=darwin GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project and developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table
</pre>
</div></body></html>