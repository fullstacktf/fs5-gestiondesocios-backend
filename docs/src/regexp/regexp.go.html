<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: regexp.go in package regexp</title>
<link href="../../css/light-v0.1.6.css" rel="stylesheet">
<script src="../../jvs/golds-v0.1.6.js"></script>
<body><div>

<pre id="header"><code><span class="title">Source File</span>
	regexp.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/regexp.html">regexp</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>// Package regexp implements regular expression search.</code></span>
<span class="codeline" id="line-6"><code>//</code></span>
<span class="codeline" id="line-7"><code>// The syntax of the regular expressions accepted is the same</code></span>
<span class="codeline" id="line-8"><code>// general syntax used by Perl, Python, and other languages.</code></span>
<span class="codeline" id="line-9"><code>// More precisely, it is the syntax accepted by RE2 and described at</code></span>
<span class="codeline" id="line-10"><code>// https://golang.org/s/re2syntax, except for \C.</code></span>
<span class="codeline" id="line-11"><code>// For an overview of the syntax, run</code></span>
<span class="codeline" id="line-12"><code>//   go doc regexp/syntax</code></span>
<span class="codeline" id="line-13"><code>//</code></span>
<span class="codeline" id="line-14"><code>// The regexp implementation provided by this package is</code></span>
<span class="codeline" id="line-15"><code>// guaranteed to run in time linear in the size of the input.</code></span>
<span class="codeline" id="line-16"><code>// (This is a property not guaranteed by most open source</code></span>
<span class="codeline" id="line-17"><code>// implementations of regular expressions.) For more information</code></span>
<span class="codeline" id="line-18"><code>// about this property, see</code></span>
<span class="codeline" id="line-19"><code>//	https://swtch.com/~rsc/regexp/regexp1.html</code></span>
<span class="codeline" id="line-20"><code>// or any book about automata theory.</code></span>
<span class="codeline" id="line-21"><code>//</code></span>
<span class="codeline" id="line-22"><code>// All characters are UTF-8-encoded code points.</code></span>
<span class="codeline" id="line-23"><code>//</code></span>
<span class="codeline" id="line-24"><code>// There are 16 methods of Regexp that match a regular expression and identify</code></span>
<span class="codeline" id="line-25"><code>// the matched text. Their names are matched by this regular expression:</code></span>
<span class="codeline" id="line-26"><code>//</code></span>
<span class="codeline" id="line-27"><code>//	Find(All)?(String)?(Submatch)?(Index)?</code></span>
<span class="codeline" id="line-28"><code>//</code></span>
<span class="codeline" id="line-29"><code>// If 'All' is present, the routine matches successive non-overlapping</code></span>
<span class="codeline" id="line-30"><code>// matches of the entire expression. Empty matches abutting a preceding</code></span>
<span class="codeline" id="line-31"><code>// match are ignored. The return value is a slice containing the successive</code></span>
<span class="codeline" id="line-32"><code>// return values of the corresponding non-'All' routine. These routines take</code></span>
<span class="codeline" id="line-33"><code>// an extra integer argument, n. If n &gt;= 0, the function returns at most n</code></span>
<span class="codeline" id="line-34"><code>// matches/submatches; otherwise, it returns all of them.</code></span>
<span class="codeline" id="line-35"><code>//</code></span>
<span class="codeline" id="line-36"><code>// If 'String' is present, the argument is a string; otherwise it is a slice</code></span>
<span class="codeline" id="line-37"><code>// of bytes; return values are adjusted as appropriate.</code></span>
<span class="codeline" id="line-38"><code>//</code></span>
<span class="codeline" id="line-39"><code>// If 'Submatch' is present, the return value is a slice identifying the</code></span>
<span class="codeline" id="line-40"><code>// successive submatches of the expression. Submatches are matches of</code></span>
<span class="codeline" id="line-41"><code>// parenthesized subexpressions (also known as capturing groups) within the</code></span>
<span class="codeline" id="line-42"><code>// regular expression, numbered from left to right in order of opening</code></span>
<span class="codeline" id="line-43"><code>// parenthesis. Submatch 0 is the match of the entire expression, submatch 1</code></span>
<span class="codeline" id="line-44"><code>// the match of the first parenthesized subexpression, and so on.</code></span>
<span class="codeline" id="line-45"><code>//</code></span>
<span class="codeline" id="line-46"><code>// If 'Index' is present, matches and submatches are identified by byte index</code></span>
<span class="codeline" id="line-47"><code>// pairs within the input string: result[2*n:2*n+1] identifies the indexes of</code></span>
<span class="codeline" id="line-48"><code>// the nth submatch. The pair for n==0 identifies the match of the entire</code></span>
<span class="codeline" id="line-49"><code>// expression. If 'Index' is not present, the match is identified by the text</code></span>
<span class="codeline" id="line-50"><code>// of the match/submatch. If an index is negative or text is nil, it means that</code></span>
<span class="codeline" id="line-51"><code>// subexpression did not match any string in the input. For 'String' versions</code></span>
<span class="codeline" id="line-52"><code>// an empty string means either no match or an empty match.</code></span>
<span class="codeline" id="line-53"><code>//</code></span>
<span class="codeline" id="line-54"><code>// There is also a subset of the methods that can be applied to text read</code></span>
<span class="codeline" id="line-55"><code>// from a RuneReader:</code></span>
<span class="codeline" id="line-56"><code>//</code></span>
<span class="codeline" id="line-57"><code>//	MatchReader, FindReaderIndex, FindReaderSubmatchIndex</code></span>
<span class="codeline" id="line-58"><code>//</code></span>
<span class="codeline" id="line-59"><code>// This set may grow. Note that regular expression matches may need to</code></span>
<span class="codeline" id="line-60"><code>// examine text beyond the text returned by a match, so the methods that</code></span>
<span class="codeline" id="line-61"><code>// match text from a RuneReader may read arbitrarily far into the input</code></span>
<span class="codeline" id="line-62"><code>// before returning.</code></span>
<span class="codeline" id="line-63"><code>//</code></span>
<span class="codeline" id="line-64"><code>// (There are a few other methods that do not match this pattern.)</code></span>
<span class="codeline" id="line-65"><code>//</code></span></div><span class="codeline" id="line-66"><code>package regexp</code></span>
<span class="codeline" id="line-67"><code></code></span>
<span class="codeline" id="line-68"><code>import (</code></span>
<span class="codeline" id="line-69"><code>	"bytes"</code></span>
<span class="codeline" id="line-70"><code>	"io"</code></span>
<span class="codeline" id="line-71"><code>	"regexp/syntax"</code></span>
<span class="codeline" id="line-72"><code>	"strconv"</code></span>
<span class="codeline" id="line-73"><code>	"strings"</code></span>
<span class="codeline" id="line-74"><code>	"sync"</code></span>
<span class="codeline" id="line-75"><code>	"unicode"</code></span>
<span class="codeline" id="line-76"><code>	"unicode/utf8"</code></span>
<span class="codeline" id="line-77"><code>)</code></span>
<span class="codeline" id="line-78"><code></code></span>
<span class="codeline" id="line-79"><code>// Regexp is the representation of a compiled regular expression.</code></span>
<span class="codeline" id="line-80"><code>// A Regexp is safe for concurrent use by multiple goroutines,</code></span>
<span class="codeline" id="line-81"><code>// except for configuration methods, such as Longest.</code></span>
<span class="codeline" id="line-82"><code>type Regexp struct {</code></span>
<span class="codeline" id="line-83"><code>	expr           string       // as passed to Compile</code></span>
<span class="codeline" id="line-84"><code>	prog           *syntax.Prog // compiled program</code></span>
<span class="codeline" id="line-85"><code>	onepass        *onePassProg // onepass program or nil</code></span>
<span class="codeline" id="line-86"><code>	numSubexp      int</code></span>
<span class="codeline" id="line-87"><code>	maxBitStateLen int</code></span>
<span class="codeline" id="line-88"><code>	subexpNames    []string</code></span>
<span class="codeline" id="line-89"><code>	prefix         string         // required prefix in unanchored matches</code></span>
<span class="codeline" id="line-90"><code>	prefixBytes    []byte         // prefix, as a []byte</code></span>
<span class="codeline" id="line-91"><code>	prefixRune     rune           // first rune in prefix</code></span>
<span class="codeline" id="line-92"><code>	prefixEnd      uint32         // pc for last rune in prefix</code></span>
<span class="codeline" id="line-93"><code>	mpool          int            // pool for machines</code></span>
<span class="codeline" id="line-94"><code>	matchcap       int            // size of recorded match lengths</code></span>
<span class="codeline" id="line-95"><code>	prefixComplete bool           // prefix is the entire regexp</code></span>
<span class="codeline" id="line-96"><code>	cond           syntax.EmptyOp // empty-width conditions required at start of match</code></span>
<span class="codeline" id="line-97"><code>	minInputLen    int            // minimum length of the input in bytes</code></span>
<span class="codeline" id="line-98"><code></code></span>
<span class="codeline" id="line-99"><code>	// This field can be modified by the Longest method,</code></span>
<span class="codeline" id="line-100"><code>	// but it is otherwise read-only.</code></span>
<span class="codeline" id="line-101"><code>	longest bool // whether regexp prefers leftmost-longest match</code></span>
<span class="codeline" id="line-102"><code>}</code></span>
<span class="codeline" id="line-103"><code></code></span>
<span class="codeline" id="line-104"><code>// String returns the source text used to compile the regular expression.</code></span>
<span class="codeline" id="line-105"><code>func (re *Regexp) String() string {</code></span>
<span class="codeline" id="line-106"><code>	return re.expr</code></span>
<span class="codeline" id="line-107"><code>}</code></span>
<span class="codeline" id="line-108"><code></code></span>
<span class="codeline" id="line-109"><code>// Copy returns a new Regexp object copied from re.</code></span>
<span class="codeline" id="line-110"><code>// Calling Longest on one copy does not affect another.</code></span>
<span class="codeline" id="line-111"><code>//</code></span>
<span class="codeline" id="line-112"><code>// Deprecated: In earlier releases, when using a Regexp in multiple goroutines,</code></span>
<span class="codeline" id="line-113"><code>// giving each goroutine its own copy helped to avoid lock contention.</code></span>
<span class="codeline" id="line-114"><code>// As of Go 1.12, using Copy is no longer necessary to avoid lock contention.</code></span>
<span class="codeline" id="line-115"><code>// Copy may still be appropriate if the reason for its use is to make</code></span>
<span class="codeline" id="line-116"><code>// two copies with different Longest settings.</code></span>
<span class="codeline" id="line-117"><code>func (re *Regexp) Copy() *Regexp {</code></span>
<span class="codeline" id="line-118"><code>	re2 := *re</code></span>
<span class="codeline" id="line-119"><code>	return &amp;re2</code></span>
<span class="codeline" id="line-120"><code>}</code></span>
<span class="codeline" id="line-121"><code></code></span>
<span class="codeline" id="line-122"><code>// Compile parses a regular expression and returns, if successful,</code></span>
<span class="codeline" id="line-123"><code>// a Regexp object that can be used to match against text.</code></span>
<span class="codeline" id="line-124"><code>//</code></span>
<span class="codeline" id="line-125"><code>// When matching against text, the regexp returns a match that</code></span>
<span class="codeline" id="line-126"><code>// begins as early as possible in the input (leftmost), and among those</code></span>
<span class="codeline" id="line-127"><code>// it chooses the one that a backtracking search would have found first.</code></span>
<span class="codeline" id="line-128"><code>// This so-called leftmost-first matching is the same semantics</code></span>
<span class="codeline" id="line-129"><code>// that Perl, Python, and other implementations use, although this</code></span>
<span class="codeline" id="line-130"><code>// package implements it without the expense of backtracking.</code></span>
<span class="codeline" id="line-131"><code>// For POSIX leftmost-longest matching, see CompilePOSIX.</code></span>
<span class="codeline" id="line-132"><code>func Compile(expr string) (*Regexp, error) {</code></span>
<span class="codeline" id="line-133"><code>	return compile(expr, syntax.Perl, false)</code></span>
<span class="codeline" id="line-134"><code>}</code></span>
<span class="codeline" id="line-135"><code></code></span>
<span class="codeline" id="line-136"><code>// CompilePOSIX is like Compile but restricts the regular expression</code></span>
<span class="codeline" id="line-137"><code>// to POSIX ERE (egrep) syntax and changes the match semantics to</code></span>
<span class="codeline" id="line-138"><code>// leftmost-longest.</code></span>
<span class="codeline" id="line-139"><code>//</code></span>
<span class="codeline" id="line-140"><code>// That is, when matching against text, the regexp returns a match that</code></span>
<span class="codeline" id="line-141"><code>// begins as early as possible in the input (leftmost), and among those</code></span>
<span class="codeline" id="line-142"><code>// it chooses a match that is as long as possible.</code></span>
<span class="codeline" id="line-143"><code>// This so-called leftmost-longest matching is the same semantics</code></span>
<span class="codeline" id="line-144"><code>// that early regular expression implementations used and that POSIX</code></span>
<span class="codeline" id="line-145"><code>// specifies.</code></span>
<span class="codeline" id="line-146"><code>//</code></span>
<span class="codeline" id="line-147"><code>// However, there can be multiple leftmost-longest matches, with different</code></span>
<span class="codeline" id="line-148"><code>// submatch choices, and here this package diverges from POSIX.</code></span>
<span class="codeline" id="line-149"><code>// Among the possible leftmost-longest matches, this package chooses</code></span>
<span class="codeline" id="line-150"><code>// the one that a backtracking search would have found first, while POSIX</code></span>
<span class="codeline" id="line-151"><code>// specifies that the match be chosen to maximize the length of the first</code></span>
<span class="codeline" id="line-152"><code>// subexpression, then the second, and so on from left to right.</code></span>
<span class="codeline" id="line-153"><code>// The POSIX rule is computationally prohibitive and not even well-defined.</code></span>
<span class="codeline" id="line-154"><code>// See https://swtch.com/~rsc/regexp/regexp2.html#posix for details.</code></span>
<span class="codeline" id="line-155"><code>func CompilePOSIX(expr string) (*Regexp, error) {</code></span>
<span class="codeline" id="line-156"><code>	return compile(expr, syntax.POSIX, true)</code></span>
<span class="codeline" id="line-157"><code>}</code></span>
<span class="codeline" id="line-158"><code></code></span>
<span class="codeline" id="line-159"><code>// Longest makes future searches prefer the leftmost-longest match.</code></span>
<span class="codeline" id="line-160"><code>// That is, when matching against text, the regexp returns a match that</code></span>
<span class="codeline" id="line-161"><code>// begins as early as possible in the input (leftmost), and among those</code></span>
<span class="codeline" id="line-162"><code>// it chooses a match that is as long as possible.</code></span>
<span class="codeline" id="line-163"><code>// This method modifies the Regexp and may not be called concurrently</code></span>
<span class="codeline" id="line-164"><code>// with any other methods.</code></span>
<span class="codeline" id="line-165"><code>func (re *Regexp) Longest() {</code></span>
<span class="codeline" id="line-166"><code>	re.longest = true</code></span>
<span class="codeline" id="line-167"><code>}</code></span>
<span class="codeline" id="line-168"><code></code></span>
<span class="codeline" id="line-169"><code>func compile(expr string, mode syntax.Flags, longest bool) (*Regexp, error) {</code></span>
<span class="codeline" id="line-170"><code>	re, err := syntax.Parse(expr, mode)</code></span>
<span class="codeline" id="line-171"><code>	if err != nil {</code></span>
<span class="codeline" id="line-172"><code>		return nil, err</code></span>
<span class="codeline" id="line-173"><code>	}</code></span>
<span class="codeline" id="line-174"><code>	maxCap := re.MaxCap()</code></span>
<span class="codeline" id="line-175"><code>	capNames := re.CapNames()</code></span>
<span class="codeline" id="line-176"><code></code></span>
<span class="codeline" id="line-177"><code>	re = re.Simplify()</code></span>
<span class="codeline" id="line-178"><code>	prog, err := syntax.Compile(re)</code></span>
<span class="codeline" id="line-179"><code>	if err != nil {</code></span>
<span class="codeline" id="line-180"><code>		return nil, err</code></span>
<span class="codeline" id="line-181"><code>	}</code></span>
<span class="codeline" id="line-182"><code>	matchcap := prog.NumCap</code></span>
<span class="codeline" id="line-183"><code>	if matchcap &lt; 2 {</code></span>
<span class="codeline" id="line-184"><code>		matchcap = 2</code></span>
<span class="codeline" id="line-185"><code>	}</code></span>
<span class="codeline" id="line-186"><code>	regexp := &amp;Regexp{</code></span>
<span class="codeline" id="line-187"><code>		expr:        expr,</code></span>
<span class="codeline" id="line-188"><code>		prog:        prog,</code></span>
<span class="codeline" id="line-189"><code>		onepass:     compileOnePass(prog),</code></span>
<span class="codeline" id="line-190"><code>		numSubexp:   maxCap,</code></span>
<span class="codeline" id="line-191"><code>		subexpNames: capNames,</code></span>
<span class="codeline" id="line-192"><code>		cond:        prog.StartCond(),</code></span>
<span class="codeline" id="line-193"><code>		longest:     longest,</code></span>
<span class="codeline" id="line-194"><code>		matchcap:    matchcap,</code></span>
<span class="codeline" id="line-195"><code>		minInputLen: minInputLen(re),</code></span>
<span class="codeline" id="line-196"><code>	}</code></span>
<span class="codeline" id="line-197"><code>	if regexp.onepass == nil {</code></span>
<span class="codeline" id="line-198"><code>		regexp.prefix, regexp.prefixComplete = prog.Prefix()</code></span>
<span class="codeline" id="line-199"><code>		regexp.maxBitStateLen = maxBitStateLen(prog)</code></span>
<span class="codeline" id="line-200"><code>	} else {</code></span>
<span class="codeline" id="line-201"><code>		regexp.prefix, regexp.prefixComplete, regexp.prefixEnd = onePassPrefix(prog)</code></span>
<span class="codeline" id="line-202"><code>	}</code></span>
<span class="codeline" id="line-203"><code>	if regexp.prefix != "" {</code></span>
<span class="codeline" id="line-204"><code>		// TODO(rsc): Remove this allocation by adding</code></span>
<span class="codeline" id="line-205"><code>		// IndexString to package bytes.</code></span>
<span class="codeline" id="line-206"><code>		regexp.prefixBytes = []byte(regexp.prefix)</code></span>
<span class="codeline" id="line-207"><code>		regexp.prefixRune, _ = utf8.DecodeRuneInString(regexp.prefix)</code></span>
<span class="codeline" id="line-208"><code>	}</code></span>
<span class="codeline" id="line-209"><code></code></span>
<span class="codeline" id="line-210"><code>	n := len(prog.Inst)</code></span>
<span class="codeline" id="line-211"><code>	i := 0</code></span>
<span class="codeline" id="line-212"><code>	for matchSize[i] != 0 &amp;&amp; matchSize[i] &lt; n {</code></span>
<span class="codeline" id="line-213"><code>		i++</code></span>
<span class="codeline" id="line-214"><code>	}</code></span>
<span class="codeline" id="line-215"><code>	regexp.mpool = i</code></span>
<span class="codeline" id="line-216"><code></code></span>
<span class="codeline" id="line-217"><code>	return regexp, nil</code></span>
<span class="codeline" id="line-218"><code>}</code></span>
<span class="codeline" id="line-219"><code></code></span>
<span class="codeline" id="line-220"><code>// Pools of *machine for use during (*Regexp).doExecute,</code></span>
<span class="codeline" id="line-221"><code>// split up by the size of the execution queues.</code></span>
<span class="codeline" id="line-222"><code>// matchPool[i] machines have queue size matchSize[i].</code></span>
<span class="codeline" id="line-223"><code>// On a 64-bit system each queue entry is 16 bytes,</code></span>
<span class="codeline" id="line-224"><code>// so matchPool[0] has 16*2*128 = 4kB queues, etc.</code></span>
<span class="codeline" id="line-225"><code>// The final matchPool is a catch-all for very large queues.</code></span>
<span class="codeline" id="line-226"><code>var (</code></span>
<span class="codeline" id="line-227"><code>	matchSize = [...]int{128, 512, 2048, 16384, 0}</code></span>
<span class="codeline" id="line-228"><code>	matchPool [len(matchSize)]sync.Pool</code></span>
<span class="codeline" id="line-229"><code>)</code></span>
<span class="codeline" id="line-230"><code></code></span>
<span class="codeline" id="line-231"><code>// get returns a machine to use for matching re.</code></span>
<span class="codeline" id="line-232"><code>// It uses the re's machine cache if possible, to avoid</code></span>
<span class="codeline" id="line-233"><code>// unnecessary allocation.</code></span>
<span class="codeline" id="line-234"><code>func (re *Regexp) get() *machine {</code></span>
<span class="codeline" id="line-235"><code>	m, ok := matchPool[re.mpool].Get().(*machine)</code></span>
<span class="codeline" id="line-236"><code>	if !ok {</code></span>
<span class="codeline" id="line-237"><code>		m = new(machine)</code></span>
<span class="codeline" id="line-238"><code>	}</code></span>
<span class="codeline" id="line-239"><code>	m.re = re</code></span>
<span class="codeline" id="line-240"><code>	m.p = re.prog</code></span>
<span class="codeline" id="line-241"><code>	if cap(m.matchcap) &lt; re.matchcap {</code></span>
<span class="codeline" id="line-242"><code>		m.matchcap = make([]int, re.matchcap)</code></span>
<span class="codeline" id="line-243"><code>		for _, t := range m.pool {</code></span>
<span class="codeline" id="line-244"><code>			t.cap = make([]int, re.matchcap)</code></span>
<span class="codeline" id="line-245"><code>		}</code></span>
<span class="codeline" id="line-246"><code>	}</code></span>
<span class="codeline" id="line-247"><code></code></span>
<span class="codeline" id="line-248"><code>	// Allocate queues if needed.</code></span>
<span class="codeline" id="line-249"><code>	// Or reallocate, for "large" match pool.</code></span>
<span class="codeline" id="line-250"><code>	n := matchSize[re.mpool]</code></span>
<span class="codeline" id="line-251"><code>	if n == 0 { // large pool</code></span>
<span class="codeline" id="line-252"><code>		n = len(re.prog.Inst)</code></span>
<span class="codeline" id="line-253"><code>	}</code></span>
<span class="codeline" id="line-254"><code>	if len(m.q0.sparse) &lt; n {</code></span>
<span class="codeline" id="line-255"><code>		m.q0 = queue{make([]uint32, n), make([]entry, 0, n)}</code></span>
<span class="codeline" id="line-256"><code>		m.q1 = queue{make([]uint32, n), make([]entry, 0, n)}</code></span>
<span class="codeline" id="line-257"><code>	}</code></span>
<span class="codeline" id="line-258"><code>	return m</code></span>
<span class="codeline" id="line-259"><code>}</code></span>
<span class="codeline" id="line-260"><code></code></span>
<span class="codeline" id="line-261"><code>// put returns a machine to the correct machine pool.</code></span>
<span class="codeline" id="line-262"><code>func (re *Regexp) put(m *machine) {</code></span>
<span class="codeline" id="line-263"><code>	m.re = nil</code></span>
<span class="codeline" id="line-264"><code>	m.p = nil</code></span>
<span class="codeline" id="line-265"><code>	m.inputs.clear()</code></span>
<span class="codeline" id="line-266"><code>	matchPool[re.mpool].Put(m)</code></span>
<span class="codeline" id="line-267"><code>}</code></span>
<span class="codeline" id="line-268"><code></code></span>
<span class="codeline" id="line-269"><code>// minInputLen walks the regexp to find the minimum length of any matchable input</code></span>
<span class="codeline" id="line-270"><code>func minInputLen(re *syntax.Regexp) int {</code></span>
<span class="codeline" id="line-271"><code>	switch re.Op {</code></span>
<span class="codeline" id="line-272"><code>	default:</code></span>
<span class="codeline" id="line-273"><code>		return 0</code></span>
<span class="codeline" id="line-274"><code>	case syntax.OpAnyChar, syntax.OpAnyCharNotNL, syntax.OpCharClass:</code></span>
<span class="codeline" id="line-275"><code>		return 1</code></span>
<span class="codeline" id="line-276"><code>	case syntax.OpLiteral:</code></span>
<span class="codeline" id="line-277"><code>		l := 0</code></span>
<span class="codeline" id="line-278"><code>		for _, r := range re.Rune {</code></span>
<span class="codeline" id="line-279"><code>			l += utf8.RuneLen(r)</code></span>
<span class="codeline" id="line-280"><code>		}</code></span>
<span class="codeline" id="line-281"><code>		return l</code></span>
<span class="codeline" id="line-282"><code>	case syntax.OpCapture, syntax.OpPlus:</code></span>
<span class="codeline" id="line-283"><code>		return minInputLen(re.Sub[0])</code></span>
<span class="codeline" id="line-284"><code>	case syntax.OpRepeat:</code></span>
<span class="codeline" id="line-285"><code>		return re.Min * minInputLen(re.Sub[0])</code></span>
<span class="codeline" id="line-286"><code>	case syntax.OpConcat:</code></span>
<span class="codeline" id="line-287"><code>		l := 0</code></span>
<span class="codeline" id="line-288"><code>		for _, sub := range re.Sub {</code></span>
<span class="codeline" id="line-289"><code>			l += minInputLen(sub)</code></span>
<span class="codeline" id="line-290"><code>		}</code></span>
<span class="codeline" id="line-291"><code>		return l</code></span>
<span class="codeline" id="line-292"><code>	case syntax.OpAlternate:</code></span>
<span class="codeline" id="line-293"><code>		l := minInputLen(re.Sub[0])</code></span>
<span class="codeline" id="line-294"><code>		var lnext int</code></span>
<span class="codeline" id="line-295"><code>		for _, sub := range re.Sub[1:] {</code></span>
<span class="codeline" id="line-296"><code>			lnext = minInputLen(sub)</code></span>
<span class="codeline" id="line-297"><code>			if lnext &lt; l {</code></span>
<span class="codeline" id="line-298"><code>				l = lnext</code></span>
<span class="codeline" id="line-299"><code>			}</code></span>
<span class="codeline" id="line-300"><code>		}</code></span>
<span class="codeline" id="line-301"><code>		return l</code></span>
<span class="codeline" id="line-302"><code>	}</code></span>
<span class="codeline" id="line-303"><code>}</code></span>
<span class="codeline" id="line-304"><code></code></span>
<span class="codeline" id="line-305"><code>// MustCompile is like Compile but panics if the expression cannot be parsed.</code></span>
<span class="codeline" id="line-306"><code>// It simplifies safe initialization of global variables holding compiled regular</code></span>
<span class="codeline" id="line-307"><code>// expressions.</code></span>
<span class="codeline" id="line-308"><code>func MustCompile(str string) *Regexp {</code></span>
<span class="codeline" id="line-309"><code>	regexp, err := Compile(str)</code></span>
<span class="codeline" id="line-310"><code>	if err != nil {</code></span>
<span class="codeline" id="line-311"><code>		panic(`regexp: Compile(` + quote(str) + `): ` + err.Error())</code></span>
<span class="codeline" id="line-312"><code>	}</code></span>
<span class="codeline" id="line-313"><code>	return regexp</code></span>
<span class="codeline" id="line-314"><code>}</code></span>
<span class="codeline" id="line-315"><code></code></span>
<span class="codeline" id="line-316"><code>// MustCompilePOSIX is like CompilePOSIX but panics if the expression cannot be parsed.</code></span>
<span class="codeline" id="line-317"><code>// It simplifies safe initialization of global variables holding compiled regular</code></span>
<span class="codeline" id="line-318"><code>// expressions.</code></span>
<span class="codeline" id="line-319"><code>func MustCompilePOSIX(str string) *Regexp {</code></span>
<span class="codeline" id="line-320"><code>	regexp, err := CompilePOSIX(str)</code></span>
<span class="codeline" id="line-321"><code>	if err != nil {</code></span>
<span class="codeline" id="line-322"><code>		panic(`regexp: CompilePOSIX(` + quote(str) + `): ` + err.Error())</code></span>
<span class="codeline" id="line-323"><code>	}</code></span>
<span class="codeline" id="line-324"><code>	return regexp</code></span>
<span class="codeline" id="line-325"><code>}</code></span>
<span class="codeline" id="line-326"><code></code></span>
<span class="codeline" id="line-327"><code>func quote(s string) string {</code></span>
<span class="codeline" id="line-328"><code>	if strconv.CanBackquote(s) {</code></span>
<span class="codeline" id="line-329"><code>		return "`" + s + "`"</code></span>
<span class="codeline" id="line-330"><code>	}</code></span>
<span class="codeline" id="line-331"><code>	return strconv.Quote(s)</code></span>
<span class="codeline" id="line-332"><code>}</code></span>
<span class="codeline" id="line-333"><code></code></span>
<span class="codeline" id="line-334"><code>// NumSubexp returns the number of parenthesized subexpressions in this Regexp.</code></span>
<span class="codeline" id="line-335"><code>func (re *Regexp) NumSubexp() int {</code></span>
<span class="codeline" id="line-336"><code>	return re.numSubexp</code></span>
<span class="codeline" id="line-337"><code>}</code></span>
<span class="codeline" id="line-338"><code></code></span>
<span class="codeline" id="line-339"><code>// SubexpNames returns the names of the parenthesized subexpressions</code></span>
<span class="codeline" id="line-340"><code>// in this Regexp. The name for the first sub-expression is names[1],</code></span>
<span class="codeline" id="line-341"><code>// so that if m is a match slice, the name for m[i] is SubexpNames()[i].</code></span>
<span class="codeline" id="line-342"><code>// Since the Regexp as a whole cannot be named, names[0] is always</code></span>
<span class="codeline" id="line-343"><code>// the empty string. The slice should not be modified.</code></span>
<span class="codeline" id="line-344"><code>func (re *Regexp) SubexpNames() []string {</code></span>
<span class="codeline" id="line-345"><code>	return re.subexpNames</code></span>
<span class="codeline" id="line-346"><code>}</code></span>
<span class="codeline" id="line-347"><code></code></span>
<span class="codeline" id="line-348"><code>// SubexpIndex returns the index of the first subexpression with the given name,</code></span>
<span class="codeline" id="line-349"><code>// or -1 if there is no subexpression with that name.</code></span>
<span class="codeline" id="line-350"><code>//</code></span>
<span class="codeline" id="line-351"><code>// Note that multiple subexpressions can be written using the same name, as in</code></span>
<span class="codeline" id="line-352"><code>// (?P&lt;bob&gt;a+)(?P&lt;bob&gt;b+), which declares two subexpressions named "bob".</code></span>
<span class="codeline" id="line-353"><code>// In this case, SubexpIndex returns the index of the leftmost such subexpression</code></span>
<span class="codeline" id="line-354"><code>// in the regular expression.</code></span>
<span class="codeline" id="line-355"><code>func (re *Regexp) SubexpIndex(name string) int {</code></span>
<span class="codeline" id="line-356"><code>	if name != "" {</code></span>
<span class="codeline" id="line-357"><code>		for i, s := range re.subexpNames {</code></span>
<span class="codeline" id="line-358"><code>			if name == s {</code></span>
<span class="codeline" id="line-359"><code>				return i</code></span>
<span class="codeline" id="line-360"><code>			}</code></span>
<span class="codeline" id="line-361"><code>		}</code></span>
<span class="codeline" id="line-362"><code>	}</code></span>
<span class="codeline" id="line-363"><code>	return -1</code></span>
<span class="codeline" id="line-364"><code>}</code></span>
<span class="codeline" id="line-365"><code></code></span>
<span class="codeline" id="line-366"><code>const endOfText rune = -1</code></span>
<span class="codeline" id="line-367"><code></code></span>
<span class="codeline" id="line-368"><code>// input abstracts different representations of the input text. It provides</code></span>
<span class="codeline" id="line-369"><code>// one-character lookahead.</code></span>
<span class="codeline" id="line-370"><code>type input interface {</code></span>
<span class="codeline" id="line-371"><code>	step(pos int) (r rune, width int) // advance one rune</code></span>
<span class="codeline" id="line-372"><code>	canCheckPrefix() bool             // can we look ahead without losing info?</code></span>
<span class="codeline" id="line-373"><code>	hasPrefix(re *Regexp) bool</code></span>
<span class="codeline" id="line-374"><code>	index(re *Regexp, pos int) int</code></span>
<span class="codeline" id="line-375"><code>	context(pos int) lazyFlag</code></span>
<span class="codeline" id="line-376"><code>}</code></span>
<span class="codeline" id="line-377"><code></code></span>
<span class="codeline" id="line-378"><code>// inputString scans a string.</code></span>
<span class="codeline" id="line-379"><code>type inputString struct {</code></span>
<span class="codeline" id="line-380"><code>	str string</code></span>
<span class="codeline" id="line-381"><code>}</code></span>
<span class="codeline" id="line-382"><code></code></span>
<span class="codeline" id="line-383"><code>func (i *inputString) step(pos int) (rune, int) {</code></span>
<span class="codeline" id="line-384"><code>	if pos &lt; len(i.str) {</code></span>
<span class="codeline" id="line-385"><code>		c := i.str[pos]</code></span>
<span class="codeline" id="line-386"><code>		if c &lt; utf8.RuneSelf {</code></span>
<span class="codeline" id="line-387"><code>			return rune(c), 1</code></span>
<span class="codeline" id="line-388"><code>		}</code></span>
<span class="codeline" id="line-389"><code>		return utf8.DecodeRuneInString(i.str[pos:])</code></span>
<span class="codeline" id="line-390"><code>	}</code></span>
<span class="codeline" id="line-391"><code>	return endOfText, 0</code></span>
<span class="codeline" id="line-392"><code>}</code></span>
<span class="codeline" id="line-393"><code></code></span>
<span class="codeline" id="line-394"><code>func (i *inputString) canCheckPrefix() bool {</code></span>
<span class="codeline" id="line-395"><code>	return true</code></span>
<span class="codeline" id="line-396"><code>}</code></span>
<span class="codeline" id="line-397"><code></code></span>
<span class="codeline" id="line-398"><code>func (i *inputString) hasPrefix(re *Regexp) bool {</code></span>
<span class="codeline" id="line-399"><code>	return strings.HasPrefix(i.str, re.prefix)</code></span>
<span class="codeline" id="line-400"><code>}</code></span>
<span class="codeline" id="line-401"><code></code></span>
<span class="codeline" id="line-402"><code>func (i *inputString) index(re *Regexp, pos int) int {</code></span>
<span class="codeline" id="line-403"><code>	return strings.Index(i.str[pos:], re.prefix)</code></span>
<span class="codeline" id="line-404"><code>}</code></span>
<span class="codeline" id="line-405"><code></code></span>
<span class="codeline" id="line-406"><code>func (i *inputString) context(pos int) lazyFlag {</code></span>
<span class="codeline" id="line-407"><code>	r1, r2 := endOfText, endOfText</code></span>
<span class="codeline" id="line-408"><code>	// 0 &lt; pos &amp;&amp; pos &lt;= len(i.str)</code></span>
<span class="codeline" id="line-409"><code>	if uint(pos-1) &lt; uint(len(i.str)) {</code></span>
<span class="codeline" id="line-410"><code>		r1 = rune(i.str[pos-1])</code></span>
<span class="codeline" id="line-411"><code>		if r1 &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-412"><code>			r1, _ = utf8.DecodeLastRuneInString(i.str[:pos])</code></span>
<span class="codeline" id="line-413"><code>		}</code></span>
<span class="codeline" id="line-414"><code>	}</code></span>
<span class="codeline" id="line-415"><code>	// 0 &lt;= pos &amp;&amp; pos &lt; len(i.str)</code></span>
<span class="codeline" id="line-416"><code>	if uint(pos) &lt; uint(len(i.str)) {</code></span>
<span class="codeline" id="line-417"><code>		r2 = rune(i.str[pos])</code></span>
<span class="codeline" id="line-418"><code>		if r2 &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-419"><code>			r2, _ = utf8.DecodeRuneInString(i.str[pos:])</code></span>
<span class="codeline" id="line-420"><code>		}</code></span>
<span class="codeline" id="line-421"><code>	}</code></span>
<span class="codeline" id="line-422"><code>	return newLazyFlag(r1, r2)</code></span>
<span class="codeline" id="line-423"><code>}</code></span>
<span class="codeline" id="line-424"><code></code></span>
<span class="codeline" id="line-425"><code>// inputBytes scans a byte slice.</code></span>
<span class="codeline" id="line-426"><code>type inputBytes struct {</code></span>
<span class="codeline" id="line-427"><code>	str []byte</code></span>
<span class="codeline" id="line-428"><code>}</code></span>
<span class="codeline" id="line-429"><code></code></span>
<span class="codeline" id="line-430"><code>func (i *inputBytes) step(pos int) (rune, int) {</code></span>
<span class="codeline" id="line-431"><code>	if pos &lt; len(i.str) {</code></span>
<span class="codeline" id="line-432"><code>		c := i.str[pos]</code></span>
<span class="codeline" id="line-433"><code>		if c &lt; utf8.RuneSelf {</code></span>
<span class="codeline" id="line-434"><code>			return rune(c), 1</code></span>
<span class="codeline" id="line-435"><code>		}</code></span>
<span class="codeline" id="line-436"><code>		return utf8.DecodeRune(i.str[pos:])</code></span>
<span class="codeline" id="line-437"><code>	}</code></span>
<span class="codeline" id="line-438"><code>	return endOfText, 0</code></span>
<span class="codeline" id="line-439"><code>}</code></span>
<span class="codeline" id="line-440"><code></code></span>
<span class="codeline" id="line-441"><code>func (i *inputBytes) canCheckPrefix() bool {</code></span>
<span class="codeline" id="line-442"><code>	return true</code></span>
<span class="codeline" id="line-443"><code>}</code></span>
<span class="codeline" id="line-444"><code></code></span>
<span class="codeline" id="line-445"><code>func (i *inputBytes) hasPrefix(re *Regexp) bool {</code></span>
<span class="codeline" id="line-446"><code>	return bytes.HasPrefix(i.str, re.prefixBytes)</code></span>
<span class="codeline" id="line-447"><code>}</code></span>
<span class="codeline" id="line-448"><code></code></span>
<span class="codeline" id="line-449"><code>func (i *inputBytes) index(re *Regexp, pos int) int {</code></span>
<span class="codeline" id="line-450"><code>	return bytes.Index(i.str[pos:], re.prefixBytes)</code></span>
<span class="codeline" id="line-451"><code>}</code></span>
<span class="codeline" id="line-452"><code></code></span>
<span class="codeline" id="line-453"><code>func (i *inputBytes) context(pos int) lazyFlag {</code></span>
<span class="codeline" id="line-454"><code>	r1, r2 := endOfText, endOfText</code></span>
<span class="codeline" id="line-455"><code>	// 0 &lt; pos &amp;&amp; pos &lt;= len(i.str)</code></span>
<span class="codeline" id="line-456"><code>	if uint(pos-1) &lt; uint(len(i.str)) {</code></span>
<span class="codeline" id="line-457"><code>		r1 = rune(i.str[pos-1])</code></span>
<span class="codeline" id="line-458"><code>		if r1 &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-459"><code>			r1, _ = utf8.DecodeLastRune(i.str[:pos])</code></span>
<span class="codeline" id="line-460"><code>		}</code></span>
<span class="codeline" id="line-461"><code>	}</code></span>
<span class="codeline" id="line-462"><code>	// 0 &lt;= pos &amp;&amp; pos &lt; len(i.str)</code></span>
<span class="codeline" id="line-463"><code>	if uint(pos) &lt; uint(len(i.str)) {</code></span>
<span class="codeline" id="line-464"><code>		r2 = rune(i.str[pos])</code></span>
<span class="codeline" id="line-465"><code>		if r2 &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-466"><code>			r2, _ = utf8.DecodeRune(i.str[pos:])</code></span>
<span class="codeline" id="line-467"><code>		}</code></span>
<span class="codeline" id="line-468"><code>	}</code></span>
<span class="codeline" id="line-469"><code>	return newLazyFlag(r1, r2)</code></span>
<span class="codeline" id="line-470"><code>}</code></span>
<span class="codeline" id="line-471"><code></code></span>
<span class="codeline" id="line-472"><code>// inputReader scans a RuneReader.</code></span>
<span class="codeline" id="line-473"><code>type inputReader struct {</code></span>
<span class="codeline" id="line-474"><code>	r     io.RuneReader</code></span>
<span class="codeline" id="line-475"><code>	atEOT bool</code></span>
<span class="codeline" id="line-476"><code>	pos   int</code></span>
<span class="codeline" id="line-477"><code>}</code></span>
<span class="codeline" id="line-478"><code></code></span>
<span class="codeline" id="line-479"><code>func (i *inputReader) step(pos int) (rune, int) {</code></span>
<span class="codeline" id="line-480"><code>	if !i.atEOT &amp;&amp; pos != i.pos {</code></span>
<span class="codeline" id="line-481"><code>		return endOfText, 0</code></span>
<span class="codeline" id="line-482"><code></code></span>
<span class="codeline" id="line-483"><code>	}</code></span>
<span class="codeline" id="line-484"><code>	r, w, err := i.r.ReadRune()</code></span>
<span class="codeline" id="line-485"><code>	if err != nil {</code></span>
<span class="codeline" id="line-486"><code>		i.atEOT = true</code></span>
<span class="codeline" id="line-487"><code>		return endOfText, 0</code></span>
<span class="codeline" id="line-488"><code>	}</code></span>
<span class="codeline" id="line-489"><code>	i.pos += w</code></span>
<span class="codeline" id="line-490"><code>	return r, w</code></span>
<span class="codeline" id="line-491"><code>}</code></span>
<span class="codeline" id="line-492"><code></code></span>
<span class="codeline" id="line-493"><code>func (i *inputReader) canCheckPrefix() bool {</code></span>
<span class="codeline" id="line-494"><code>	return false</code></span>
<span class="codeline" id="line-495"><code>}</code></span>
<span class="codeline" id="line-496"><code></code></span>
<span class="codeline" id="line-497"><code>func (i *inputReader) hasPrefix(re *Regexp) bool {</code></span>
<span class="codeline" id="line-498"><code>	return false</code></span>
<span class="codeline" id="line-499"><code>}</code></span>
<span class="codeline" id="line-500"><code></code></span>
<span class="codeline" id="line-501"><code>func (i *inputReader) index(re *Regexp, pos int) int {</code></span>
<span class="codeline" id="line-502"><code>	return -1</code></span>
<span class="codeline" id="line-503"><code>}</code></span>
<span class="codeline" id="line-504"><code></code></span>
<span class="codeline" id="line-505"><code>func (i *inputReader) context(pos int) lazyFlag {</code></span>
<span class="codeline" id="line-506"><code>	return 0 // not used</code></span>
<span class="codeline" id="line-507"><code>}</code></span>
<span class="codeline" id="line-508"><code></code></span>
<span class="codeline" id="line-509"><code>// LiteralPrefix returns a literal string that must begin any match</code></span>
<span class="codeline" id="line-510"><code>// of the regular expression re. It returns the boolean true if the</code></span>
<span class="codeline" id="line-511"><code>// literal string comprises the entire regular expression.</code></span>
<span class="codeline" id="line-512"><code>func (re *Regexp) LiteralPrefix() (prefix string, complete bool) {</code></span>
<span class="codeline" id="line-513"><code>	return re.prefix, re.prefixComplete</code></span>
<span class="codeline" id="line-514"><code>}</code></span>
<span class="codeline" id="line-515"><code></code></span>
<span class="codeline" id="line-516"><code>// MatchReader reports whether the text returned by the RuneReader</code></span>
<span class="codeline" id="line-517"><code>// contains any match of the regular expression re.</code></span>
<span class="codeline" id="line-518"><code>func (re *Regexp) MatchReader(r io.RuneReader) bool {</code></span>
<span class="codeline" id="line-519"><code>	return re.doMatch(r, nil, "")</code></span>
<span class="codeline" id="line-520"><code>}</code></span>
<span class="codeline" id="line-521"><code></code></span>
<span class="codeline" id="line-522"><code>// MatchString reports whether the string s</code></span>
<span class="codeline" id="line-523"><code>// contains any match of the regular expression re.</code></span>
<span class="codeline" id="line-524"><code>func (re *Regexp) MatchString(s string) bool {</code></span>
<span class="codeline" id="line-525"><code>	return re.doMatch(nil, nil, s)</code></span>
<span class="codeline" id="line-526"><code>}</code></span>
<span class="codeline" id="line-527"><code></code></span>
<span class="codeline" id="line-528"><code>// Match reports whether the byte slice b</code></span>
<span class="codeline" id="line-529"><code>// contains any match of the regular expression re.</code></span>
<span class="codeline" id="line-530"><code>func (re *Regexp) Match(b []byte) bool {</code></span>
<span class="codeline" id="line-531"><code>	return re.doMatch(nil, b, "")</code></span>
<span class="codeline" id="line-532"><code>}</code></span>
<span class="codeline" id="line-533"><code></code></span>
<span class="codeline" id="line-534"><code>// MatchReader reports whether the text returned by the RuneReader</code></span>
<span class="codeline" id="line-535"><code>// contains any match of the regular expression pattern.</code></span>
<span class="codeline" id="line-536"><code>// More complicated queries need to use Compile and the full Regexp interface.</code></span>
<span class="codeline" id="line-537"><code>func MatchReader(pattern string, r io.RuneReader) (matched bool, err error) {</code></span>
<span class="codeline" id="line-538"><code>	re, err := Compile(pattern)</code></span>
<span class="codeline" id="line-539"><code>	if err != nil {</code></span>
<span class="codeline" id="line-540"><code>		return false, err</code></span>
<span class="codeline" id="line-541"><code>	}</code></span>
<span class="codeline" id="line-542"><code>	return re.MatchReader(r), nil</code></span>
<span class="codeline" id="line-543"><code>}</code></span>
<span class="codeline" id="line-544"><code></code></span>
<span class="codeline" id="line-545"><code>// MatchString reports whether the string s</code></span>
<span class="codeline" id="line-546"><code>// contains any match of the regular expression pattern.</code></span>
<span class="codeline" id="line-547"><code>// More complicated queries need to use Compile and the full Regexp interface.</code></span>
<span class="codeline" id="line-548"><code>func MatchString(pattern string, s string) (matched bool, err error) {</code></span>
<span class="codeline" id="line-549"><code>	re, err := Compile(pattern)</code></span>
<span class="codeline" id="line-550"><code>	if err != nil {</code></span>
<span class="codeline" id="line-551"><code>		return false, err</code></span>
<span class="codeline" id="line-552"><code>	}</code></span>
<span class="codeline" id="line-553"><code>	return re.MatchString(s), nil</code></span>
<span class="codeline" id="line-554"><code>}</code></span>
<span class="codeline" id="line-555"><code></code></span>
<span class="codeline" id="line-556"><code>// Match reports whether the byte slice b</code></span>
<span class="codeline" id="line-557"><code>// contains any match of the regular expression pattern.</code></span>
<span class="codeline" id="line-558"><code>// More complicated queries need to use Compile and the full Regexp interface.</code></span>
<span class="codeline" id="line-559"><code>func Match(pattern string, b []byte) (matched bool, err error) {</code></span>
<span class="codeline" id="line-560"><code>	re, err := Compile(pattern)</code></span>
<span class="codeline" id="line-561"><code>	if err != nil {</code></span>
<span class="codeline" id="line-562"><code>		return false, err</code></span>
<span class="codeline" id="line-563"><code>	}</code></span>
<span class="codeline" id="line-564"><code>	return re.Match(b), nil</code></span>
<span class="codeline" id="line-565"><code>}</code></span>
<span class="codeline" id="line-566"><code></code></span>
<span class="codeline" id="line-567"><code>// ReplaceAllString returns a copy of src, replacing matches of the Regexp</code></span>
<span class="codeline" id="line-568"><code>// with the replacement string repl. Inside repl, $ signs are interpreted as</code></span>
<span class="codeline" id="line-569"><code>// in Expand, so for instance $1 represents the text of the first submatch.</code></span>
<span class="codeline" id="line-570"><code>func (re *Regexp) ReplaceAllString(src, repl string) string {</code></span>
<span class="codeline" id="line-571"><code>	n := 2</code></span>
<span class="codeline" id="line-572"><code>	if strings.Contains(repl, "$") {</code></span>
<span class="codeline" id="line-573"><code>		n = 2 * (re.numSubexp + 1)</code></span>
<span class="codeline" id="line-574"><code>	}</code></span>
<span class="codeline" id="line-575"><code>	b := re.replaceAll(nil, src, n, func(dst []byte, match []int) []byte {</code></span>
<span class="codeline" id="line-576"><code>		return re.expand(dst, repl, nil, src, match)</code></span>
<span class="codeline" id="line-577"><code>	})</code></span>
<span class="codeline" id="line-578"><code>	return string(b)</code></span>
<span class="codeline" id="line-579"><code>}</code></span>
<span class="codeline" id="line-580"><code></code></span>
<span class="codeline" id="line-581"><code>// ReplaceAllLiteralString returns a copy of src, replacing matches of the Regexp</code></span>
<span class="codeline" id="line-582"><code>// with the replacement string repl. The replacement repl is substituted directly,</code></span>
<span class="codeline" id="line-583"><code>// without using Expand.</code></span>
<span class="codeline" id="line-584"><code>func (re *Regexp) ReplaceAllLiteralString(src, repl string) string {</code></span>
<span class="codeline" id="line-585"><code>	return string(re.replaceAll(nil, src, 2, func(dst []byte, match []int) []byte {</code></span>
<span class="codeline" id="line-586"><code>		return append(dst, repl...)</code></span>
<span class="codeline" id="line-587"><code>	}))</code></span>
<span class="codeline" id="line-588"><code>}</code></span>
<span class="codeline" id="line-589"><code></code></span>
<span class="codeline" id="line-590"><code>// ReplaceAllStringFunc returns a copy of src in which all matches of the</code></span>
<span class="codeline" id="line-591"><code>// Regexp have been replaced by the return value of function repl applied</code></span>
<span class="codeline" id="line-592"><code>// to the matched substring. The replacement returned by repl is substituted</code></span>
<span class="codeline" id="line-593"><code>// directly, without using Expand.</code></span>
<span class="codeline" id="line-594"><code>func (re *Regexp) ReplaceAllStringFunc(src string, repl func(string) string) string {</code></span>
<span class="codeline" id="line-595"><code>	b := re.replaceAll(nil, src, 2, func(dst []byte, match []int) []byte {</code></span>
<span class="codeline" id="line-596"><code>		return append(dst, repl(src[match[0]:match[1]])...)</code></span>
<span class="codeline" id="line-597"><code>	})</code></span>
<span class="codeline" id="line-598"><code>	return string(b)</code></span>
<span class="codeline" id="line-599"><code>}</code></span>
<span class="codeline" id="line-600"><code></code></span>
<span class="codeline" id="line-601"><code>func (re *Regexp) replaceAll(bsrc []byte, src string, nmatch int, repl func(dst []byte, m []int) []byte) []byte {</code></span>
<span class="codeline" id="line-602"><code>	lastMatchEnd := 0 // end position of the most recent match</code></span>
<span class="codeline" id="line-603"><code>	searchPos := 0    // position where we next look for a match</code></span>
<span class="codeline" id="line-604"><code>	var buf []byte</code></span>
<span class="codeline" id="line-605"><code>	var endPos int</code></span>
<span class="codeline" id="line-606"><code>	if bsrc != nil {</code></span>
<span class="codeline" id="line-607"><code>		endPos = len(bsrc)</code></span>
<span class="codeline" id="line-608"><code>	} else {</code></span>
<span class="codeline" id="line-609"><code>		endPos = len(src)</code></span>
<span class="codeline" id="line-610"><code>	}</code></span>
<span class="codeline" id="line-611"><code>	if nmatch &gt; re.prog.NumCap {</code></span>
<span class="codeline" id="line-612"><code>		nmatch = re.prog.NumCap</code></span>
<span class="codeline" id="line-613"><code>	}</code></span>
<span class="codeline" id="line-614"><code></code></span>
<span class="codeline" id="line-615"><code>	var dstCap [2]int</code></span>
<span class="codeline" id="line-616"><code>	for searchPos &lt;= endPos {</code></span>
<span class="codeline" id="line-617"><code>		a := re.doExecute(nil, bsrc, src, searchPos, nmatch, dstCap[:0])</code></span>
<span class="codeline" id="line-618"><code>		if len(a) == 0 {</code></span>
<span class="codeline" id="line-619"><code>			break // no more matches</code></span>
<span class="codeline" id="line-620"><code>		}</code></span>
<span class="codeline" id="line-621"><code></code></span>
<span class="codeline" id="line-622"><code>		// Copy the unmatched characters before this match.</code></span>
<span class="codeline" id="line-623"><code>		if bsrc != nil {</code></span>
<span class="codeline" id="line-624"><code>			buf = append(buf, bsrc[lastMatchEnd:a[0]]...)</code></span>
<span class="codeline" id="line-625"><code>		} else {</code></span>
<span class="codeline" id="line-626"><code>			buf = append(buf, src[lastMatchEnd:a[0]]...)</code></span>
<span class="codeline" id="line-627"><code>		}</code></span>
<span class="codeline" id="line-628"><code></code></span>
<span class="codeline" id="line-629"><code>		// Now insert a copy of the replacement string, but not for a</code></span>
<span class="codeline" id="line-630"><code>		// match of the empty string immediately after another match.</code></span>
<span class="codeline" id="line-631"><code>		// (Otherwise, we get double replacement for patterns that</code></span>
<span class="codeline" id="line-632"><code>		// match both empty and nonempty strings.)</code></span>
<span class="codeline" id="line-633"><code>		if a[1] &gt; lastMatchEnd || a[0] == 0 {</code></span>
<span class="codeline" id="line-634"><code>			buf = repl(buf, a)</code></span>
<span class="codeline" id="line-635"><code>		}</code></span>
<span class="codeline" id="line-636"><code>		lastMatchEnd = a[1]</code></span>
<span class="codeline" id="line-637"><code></code></span>
<span class="codeline" id="line-638"><code>		// Advance past this match; always advance at least one character.</code></span>
<span class="codeline" id="line-639"><code>		var width int</code></span>
<span class="codeline" id="line-640"><code>		if bsrc != nil {</code></span>
<span class="codeline" id="line-641"><code>			_, width = utf8.DecodeRune(bsrc[searchPos:])</code></span>
<span class="codeline" id="line-642"><code>		} else {</code></span>
<span class="codeline" id="line-643"><code>			_, width = utf8.DecodeRuneInString(src[searchPos:])</code></span>
<span class="codeline" id="line-644"><code>		}</code></span>
<span class="codeline" id="line-645"><code>		if searchPos+width &gt; a[1] {</code></span>
<span class="codeline" id="line-646"><code>			searchPos += width</code></span>
<span class="codeline" id="line-647"><code>		} else if searchPos+1 &gt; a[1] {</code></span>
<span class="codeline" id="line-648"><code>			// This clause is only needed at the end of the input</code></span>
<span class="codeline" id="line-649"><code>			// string. In that case, DecodeRuneInString returns width=0.</code></span>
<span class="codeline" id="line-650"><code>			searchPos++</code></span>
<span class="codeline" id="line-651"><code>		} else {</code></span>
<span class="codeline" id="line-652"><code>			searchPos = a[1]</code></span>
<span class="codeline" id="line-653"><code>		}</code></span>
<span class="codeline" id="line-654"><code>	}</code></span>
<span class="codeline" id="line-655"><code></code></span>
<span class="codeline" id="line-656"><code>	// Copy the unmatched characters after the last match.</code></span>
<span class="codeline" id="line-657"><code>	if bsrc != nil {</code></span>
<span class="codeline" id="line-658"><code>		buf = append(buf, bsrc[lastMatchEnd:]...)</code></span>
<span class="codeline" id="line-659"><code>	} else {</code></span>
<span class="codeline" id="line-660"><code>		buf = append(buf, src[lastMatchEnd:]...)</code></span>
<span class="codeline" id="line-661"><code>	}</code></span>
<span class="codeline" id="line-662"><code></code></span>
<span class="codeline" id="line-663"><code>	return buf</code></span>
<span class="codeline" id="line-664"><code>}</code></span>
<span class="codeline" id="line-665"><code></code></span>
<span class="codeline" id="line-666"><code>// ReplaceAll returns a copy of src, replacing matches of the Regexp</code></span>
<span class="codeline" id="line-667"><code>// with the replacement text repl. Inside repl, $ signs are interpreted as</code></span>
<span class="codeline" id="line-668"><code>// in Expand, so for instance $1 represents the text of the first submatch.</code></span>
<span class="codeline" id="line-669"><code>func (re *Regexp) ReplaceAll(src, repl []byte) []byte {</code></span>
<span class="codeline" id="line-670"><code>	n := 2</code></span>
<span class="codeline" id="line-671"><code>	if bytes.IndexByte(repl, '$') &gt;= 0 {</code></span>
<span class="codeline" id="line-672"><code>		n = 2 * (re.numSubexp + 1)</code></span>
<span class="codeline" id="line-673"><code>	}</code></span>
<span class="codeline" id="line-674"><code>	srepl := ""</code></span>
<span class="codeline" id="line-675"><code>	b := re.replaceAll(src, "", n, func(dst []byte, match []int) []byte {</code></span>
<span class="codeline" id="line-676"><code>		if len(srepl) != len(repl) {</code></span>
<span class="codeline" id="line-677"><code>			srepl = string(repl)</code></span>
<span class="codeline" id="line-678"><code>		}</code></span>
<span class="codeline" id="line-679"><code>		return re.expand(dst, srepl, src, "", match)</code></span>
<span class="codeline" id="line-680"><code>	})</code></span>
<span class="codeline" id="line-681"><code>	return b</code></span>
<span class="codeline" id="line-682"><code>}</code></span>
<span class="codeline" id="line-683"><code></code></span>
<span class="codeline" id="line-684"><code>// ReplaceAllLiteral returns a copy of src, replacing matches of the Regexp</code></span>
<span class="codeline" id="line-685"><code>// with the replacement bytes repl. The replacement repl is substituted directly,</code></span>
<span class="codeline" id="line-686"><code>// without using Expand.</code></span>
<span class="codeline" id="line-687"><code>func (re *Regexp) ReplaceAllLiteral(src, repl []byte) []byte {</code></span>
<span class="codeline" id="line-688"><code>	return re.replaceAll(src, "", 2, func(dst []byte, match []int) []byte {</code></span>
<span class="codeline" id="line-689"><code>		return append(dst, repl...)</code></span>
<span class="codeline" id="line-690"><code>	})</code></span>
<span class="codeline" id="line-691"><code>}</code></span>
<span class="codeline" id="line-692"><code></code></span>
<span class="codeline" id="line-693"><code>// ReplaceAllFunc returns a copy of src in which all matches of the</code></span>
<span class="codeline" id="line-694"><code>// Regexp have been replaced by the return value of function repl applied</code></span>
<span class="codeline" id="line-695"><code>// to the matched byte slice. The replacement returned by repl is substituted</code></span>
<span class="codeline" id="line-696"><code>// directly, without using Expand.</code></span>
<span class="codeline" id="line-697"><code>func (re *Regexp) ReplaceAllFunc(src []byte, repl func([]byte) []byte) []byte {</code></span>
<span class="codeline" id="line-698"><code>	return re.replaceAll(src, "", 2, func(dst []byte, match []int) []byte {</code></span>
<span class="codeline" id="line-699"><code>		return append(dst, repl(src[match[0]:match[1]])...)</code></span>
<span class="codeline" id="line-700"><code>	})</code></span>
<span class="codeline" id="line-701"><code>}</code></span>
<span class="codeline" id="line-702"><code></code></span>
<span class="codeline" id="line-703"><code>// Bitmap used by func special to check whether a character needs to be escaped.</code></span>
<span class="codeline" id="line-704"><code>var specialBytes [16]byte</code></span>
<span class="codeline" id="line-705"><code></code></span>
<span class="codeline" id="line-706"><code>// special reports whether byte b needs to be escaped by QuoteMeta.</code></span>
<span class="codeline" id="line-707"><code>func special(b byte) bool {</code></span>
<span class="codeline" id="line-708"><code>	return b &lt; utf8.RuneSelf &amp;&amp; specialBytes[b%16]&amp;(1&lt;&lt;(b/16)) != 0</code></span>
<span class="codeline" id="line-709"><code>}</code></span>
<span class="codeline" id="line-710"><code></code></span>
<span class="codeline" id="line-711"><code>func init() {</code></span>
<span class="codeline" id="line-712"><code>	for _, b := range []byte(`\.+*?()|[]{}^$`) {</code></span>
<span class="codeline" id="line-713"><code>		specialBytes[b%16] |= 1 &lt;&lt; (b / 16)</code></span>
<span class="codeline" id="line-714"><code>	}</code></span>
<span class="codeline" id="line-715"><code>}</code></span>
<span class="codeline" id="line-716"><code></code></span>
<span class="codeline" id="line-717"><code>// QuoteMeta returns a string that escapes all regular expression metacharacters</code></span>
<span class="codeline" id="line-718"><code>// inside the argument text; the returned string is a regular expression matching</code></span>
<span class="codeline" id="line-719"><code>// the literal text.</code></span>
<span class="codeline" id="line-720"><code>func QuoteMeta(s string) string {</code></span>
<span class="codeline" id="line-721"><code>	// A byte loop is correct because all metacharacters are ASCII.</code></span>
<span class="codeline" id="line-722"><code>	var i int</code></span>
<span class="codeline" id="line-723"><code>	for i = 0; i &lt; len(s); i++ {</code></span>
<span class="codeline" id="line-724"><code>		if special(s[i]) {</code></span>
<span class="codeline" id="line-725"><code>			break</code></span>
<span class="codeline" id="line-726"><code>		}</code></span>
<span class="codeline" id="line-727"><code>	}</code></span>
<span class="codeline" id="line-728"><code>	// No meta characters found, so return original string.</code></span>
<span class="codeline" id="line-729"><code>	if i &gt;= len(s) {</code></span>
<span class="codeline" id="line-730"><code>		return s</code></span>
<span class="codeline" id="line-731"><code>	}</code></span>
<span class="codeline" id="line-732"><code></code></span>
<span class="codeline" id="line-733"><code>	b := make([]byte, 2*len(s)-i)</code></span>
<span class="codeline" id="line-734"><code>	copy(b, s[:i])</code></span>
<span class="codeline" id="line-735"><code>	j := i</code></span>
<span class="codeline" id="line-736"><code>	for ; i &lt; len(s); i++ {</code></span>
<span class="codeline" id="line-737"><code>		if special(s[i]) {</code></span>
<span class="codeline" id="line-738"><code>			b[j] = '\\'</code></span>
<span class="codeline" id="line-739"><code>			j++</code></span>
<span class="codeline" id="line-740"><code>		}</code></span>
<span class="codeline" id="line-741"><code>		b[j] = s[i]</code></span>
<span class="codeline" id="line-742"><code>		j++</code></span>
<span class="codeline" id="line-743"><code>	}</code></span>
<span class="codeline" id="line-744"><code>	return string(b[:j])</code></span>
<span class="codeline" id="line-745"><code>}</code></span>
<span class="codeline" id="line-746"><code></code></span>
<span class="codeline" id="line-747"><code>// The number of capture values in the program may correspond</code></span>
<span class="codeline" id="line-748"><code>// to fewer capturing expressions than are in the regexp.</code></span>
<span class="codeline" id="line-749"><code>// For example, "(a){0}" turns into an empty program, so the</code></span>
<span class="codeline" id="line-750"><code>// maximum capture in the program is 0 but we need to return</code></span>
<span class="codeline" id="line-751"><code>// an expression for \1.  Pad appends -1s to the slice a as needed.</code></span>
<span class="codeline" id="line-752"><code>func (re *Regexp) pad(a []int) []int {</code></span>
<span class="codeline" id="line-753"><code>	if a == nil {</code></span>
<span class="codeline" id="line-754"><code>		// No match.</code></span>
<span class="codeline" id="line-755"><code>		return nil</code></span>
<span class="codeline" id="line-756"><code>	}</code></span>
<span class="codeline" id="line-757"><code>	n := (1 + re.numSubexp) * 2</code></span>
<span class="codeline" id="line-758"><code>	for len(a) &lt; n {</code></span>
<span class="codeline" id="line-759"><code>		a = append(a, -1)</code></span>
<span class="codeline" id="line-760"><code>	}</code></span>
<span class="codeline" id="line-761"><code>	return a</code></span>
<span class="codeline" id="line-762"><code>}</code></span>
<span class="codeline" id="line-763"><code></code></span>
<span class="codeline" id="line-764"><code>// allMatches calls deliver at most n times</code></span>
<span class="codeline" id="line-765"><code>// with the location of successive matches in the input text.</code></span>
<span class="codeline" id="line-766"><code>// The input text is b if non-nil, otherwise s.</code></span>
<span class="codeline" id="line-767"><code>func (re *Regexp) allMatches(s string, b []byte, n int, deliver func([]int)) {</code></span>
<span class="codeline" id="line-768"><code>	var end int</code></span>
<span class="codeline" id="line-769"><code>	if b == nil {</code></span>
<span class="codeline" id="line-770"><code>		end = len(s)</code></span>
<span class="codeline" id="line-771"><code>	} else {</code></span>
<span class="codeline" id="line-772"><code>		end = len(b)</code></span>
<span class="codeline" id="line-773"><code>	}</code></span>
<span class="codeline" id="line-774"><code></code></span>
<span class="codeline" id="line-775"><code>	for pos, i, prevMatchEnd := 0, 0, -1; i &lt; n &amp;&amp; pos &lt;= end; {</code></span>
<span class="codeline" id="line-776"><code>		matches := re.doExecute(nil, b, s, pos, re.prog.NumCap, nil)</code></span>
<span class="codeline" id="line-777"><code>		if len(matches) == 0 {</code></span>
<span class="codeline" id="line-778"><code>			break</code></span>
<span class="codeline" id="line-779"><code>		}</code></span>
<span class="codeline" id="line-780"><code></code></span>
<span class="codeline" id="line-781"><code>		accept := true</code></span>
<span class="codeline" id="line-782"><code>		if matches[1] == pos {</code></span>
<span class="codeline" id="line-783"><code>			// We've found an empty match.</code></span>
<span class="codeline" id="line-784"><code>			if matches[0] == prevMatchEnd {</code></span>
<span class="codeline" id="line-785"><code>				// We don't allow an empty match right</code></span>
<span class="codeline" id="line-786"><code>				// after a previous match, so ignore it.</code></span>
<span class="codeline" id="line-787"><code>				accept = false</code></span>
<span class="codeline" id="line-788"><code>			}</code></span>
<span class="codeline" id="line-789"><code>			var width int</code></span>
<span class="codeline" id="line-790"><code>			// TODO: use step()</code></span>
<span class="codeline" id="line-791"><code>			if b == nil {</code></span>
<span class="codeline" id="line-792"><code>				_, width = utf8.DecodeRuneInString(s[pos:end])</code></span>
<span class="codeline" id="line-793"><code>			} else {</code></span>
<span class="codeline" id="line-794"><code>				_, width = utf8.DecodeRune(b[pos:end])</code></span>
<span class="codeline" id="line-795"><code>			}</code></span>
<span class="codeline" id="line-796"><code>			if width &gt; 0 {</code></span>
<span class="codeline" id="line-797"><code>				pos += width</code></span>
<span class="codeline" id="line-798"><code>			} else {</code></span>
<span class="codeline" id="line-799"><code>				pos = end + 1</code></span>
<span class="codeline" id="line-800"><code>			}</code></span>
<span class="codeline" id="line-801"><code>		} else {</code></span>
<span class="codeline" id="line-802"><code>			pos = matches[1]</code></span>
<span class="codeline" id="line-803"><code>		}</code></span>
<span class="codeline" id="line-804"><code>		prevMatchEnd = matches[1]</code></span>
<span class="codeline" id="line-805"><code></code></span>
<span class="codeline" id="line-806"><code>		if accept {</code></span>
<span class="codeline" id="line-807"><code>			deliver(re.pad(matches))</code></span>
<span class="codeline" id="line-808"><code>			i++</code></span>
<span class="codeline" id="line-809"><code>		}</code></span>
<span class="codeline" id="line-810"><code>	}</code></span>
<span class="codeline" id="line-811"><code>}</code></span>
<span class="codeline" id="line-812"><code></code></span>
<span class="codeline" id="line-813"><code>// Find returns a slice holding the text of the leftmost match in b of the regular expression.</code></span>
<span class="codeline" id="line-814"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-815"><code>func (re *Regexp) Find(b []byte) []byte {</code></span>
<span class="codeline" id="line-816"><code>	var dstCap [2]int</code></span>
<span class="codeline" id="line-817"><code>	a := re.doExecute(nil, b, "", 0, 2, dstCap[:0])</code></span>
<span class="codeline" id="line-818"><code>	if a == nil {</code></span>
<span class="codeline" id="line-819"><code>		return nil</code></span>
<span class="codeline" id="line-820"><code>	}</code></span>
<span class="codeline" id="line-821"><code>	return b[a[0]:a[1]:a[1]]</code></span>
<span class="codeline" id="line-822"><code>}</code></span>
<span class="codeline" id="line-823"><code></code></span>
<span class="codeline" id="line-824"><code>// FindIndex returns a two-element slice of integers defining the location of</code></span>
<span class="codeline" id="line-825"><code>// the leftmost match in b of the regular expression. The match itself is at</code></span>
<span class="codeline" id="line-826"><code>// b[loc[0]:loc[1]].</code></span>
<span class="codeline" id="line-827"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-828"><code>func (re *Regexp) FindIndex(b []byte) (loc []int) {</code></span>
<span class="codeline" id="line-829"><code>	a := re.doExecute(nil, b, "", 0, 2, nil)</code></span>
<span class="codeline" id="line-830"><code>	if a == nil {</code></span>
<span class="codeline" id="line-831"><code>		return nil</code></span>
<span class="codeline" id="line-832"><code>	}</code></span>
<span class="codeline" id="line-833"><code>	return a[0:2]</code></span>
<span class="codeline" id="line-834"><code>}</code></span>
<span class="codeline" id="line-835"><code></code></span>
<span class="codeline" id="line-836"><code>// FindString returns a string holding the text of the leftmost match in s of the regular</code></span>
<span class="codeline" id="line-837"><code>// expression. If there is no match, the return value is an empty string,</code></span>
<span class="codeline" id="line-838"><code>// but it will also be empty if the regular expression successfully matches</code></span>
<span class="codeline" id="line-839"><code>// an empty string. Use FindStringIndex or FindStringSubmatch if it is</code></span>
<span class="codeline" id="line-840"><code>// necessary to distinguish these cases.</code></span>
<span class="codeline" id="line-841"><code>func (re *Regexp) FindString(s string) string {</code></span>
<span class="codeline" id="line-842"><code>	var dstCap [2]int</code></span>
<span class="codeline" id="line-843"><code>	a := re.doExecute(nil, nil, s, 0, 2, dstCap[:0])</code></span>
<span class="codeline" id="line-844"><code>	if a == nil {</code></span>
<span class="codeline" id="line-845"><code>		return ""</code></span>
<span class="codeline" id="line-846"><code>	}</code></span>
<span class="codeline" id="line-847"><code>	return s[a[0]:a[1]]</code></span>
<span class="codeline" id="line-848"><code>}</code></span>
<span class="codeline" id="line-849"><code></code></span>
<span class="codeline" id="line-850"><code>// FindStringIndex returns a two-element slice of integers defining the</code></span>
<span class="codeline" id="line-851"><code>// location of the leftmost match in s of the regular expression. The match</code></span>
<span class="codeline" id="line-852"><code>// itself is at s[loc[0]:loc[1]].</code></span>
<span class="codeline" id="line-853"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-854"><code>func (re *Regexp) FindStringIndex(s string) (loc []int) {</code></span>
<span class="codeline" id="line-855"><code>	a := re.doExecute(nil, nil, s, 0, 2, nil)</code></span>
<span class="codeline" id="line-856"><code>	if a == nil {</code></span>
<span class="codeline" id="line-857"><code>		return nil</code></span>
<span class="codeline" id="line-858"><code>	}</code></span>
<span class="codeline" id="line-859"><code>	return a[0:2]</code></span>
<span class="codeline" id="line-860"><code>}</code></span>
<span class="codeline" id="line-861"><code></code></span>
<span class="codeline" id="line-862"><code>// FindReaderIndex returns a two-element slice of integers defining the</code></span>
<span class="codeline" id="line-863"><code>// location of the leftmost match of the regular expression in text read from</code></span>
<span class="codeline" id="line-864"><code>// the RuneReader. The match text was found in the input stream at</code></span>
<span class="codeline" id="line-865"><code>// byte offset loc[0] through loc[1]-1.</code></span>
<span class="codeline" id="line-866"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-867"><code>func (re *Regexp) FindReaderIndex(r io.RuneReader) (loc []int) {</code></span>
<span class="codeline" id="line-868"><code>	a := re.doExecute(r, nil, "", 0, 2, nil)</code></span>
<span class="codeline" id="line-869"><code>	if a == nil {</code></span>
<span class="codeline" id="line-870"><code>		return nil</code></span>
<span class="codeline" id="line-871"><code>	}</code></span>
<span class="codeline" id="line-872"><code>	return a[0:2]</code></span>
<span class="codeline" id="line-873"><code>}</code></span>
<span class="codeline" id="line-874"><code></code></span>
<span class="codeline" id="line-875"><code>// FindSubmatch returns a slice of slices holding the text of the leftmost</code></span>
<span class="codeline" id="line-876"><code>// match of the regular expression in b and the matches, if any, of its</code></span>
<span class="codeline" id="line-877"><code>// subexpressions, as defined by the 'Submatch' descriptions in the package</code></span>
<span class="codeline" id="line-878"><code>// comment.</code></span>
<span class="codeline" id="line-879"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-880"><code>func (re *Regexp) FindSubmatch(b []byte) [][]byte {</code></span>
<span class="codeline" id="line-881"><code>	var dstCap [4]int</code></span>
<span class="codeline" id="line-882"><code>	a := re.doExecute(nil, b, "", 0, re.prog.NumCap, dstCap[:0])</code></span>
<span class="codeline" id="line-883"><code>	if a == nil {</code></span>
<span class="codeline" id="line-884"><code>		return nil</code></span>
<span class="codeline" id="line-885"><code>	}</code></span>
<span class="codeline" id="line-886"><code>	ret := make([][]byte, 1+re.numSubexp)</code></span>
<span class="codeline" id="line-887"><code>	for i := range ret {</code></span>
<span class="codeline" id="line-888"><code>		if 2*i &lt; len(a) &amp;&amp; a[2*i] &gt;= 0 {</code></span>
<span class="codeline" id="line-889"><code>			ret[i] = b[a[2*i]:a[2*i+1]:a[2*i+1]]</code></span>
<span class="codeline" id="line-890"><code>		}</code></span>
<span class="codeline" id="line-891"><code>	}</code></span>
<span class="codeline" id="line-892"><code>	return ret</code></span>
<span class="codeline" id="line-893"><code>}</code></span>
<span class="codeline" id="line-894"><code></code></span>
<span class="codeline" id="line-895"><code>// Expand appends template to dst and returns the result; during the</code></span>
<span class="codeline" id="line-896"><code>// append, Expand replaces variables in the template with corresponding</code></span>
<span class="codeline" id="line-897"><code>// matches drawn from src. The match slice should have been returned by</code></span>
<span class="codeline" id="line-898"><code>// FindSubmatchIndex.</code></span>
<span class="codeline" id="line-899"><code>//</code></span>
<span class="codeline" id="line-900"><code>// In the template, a variable is denoted by a substring of the form</code></span>
<span class="codeline" id="line-901"><code>// $name or ${name}, where name is a non-empty sequence of letters,</code></span>
<span class="codeline" id="line-902"><code>// digits, and underscores. A purely numeric name like $1 refers to</code></span>
<span class="codeline" id="line-903"><code>// the submatch with the corresponding index; other names refer to</code></span>
<span class="codeline" id="line-904"><code>// capturing parentheses named with the (?P&lt;name&gt;...) syntax. A</code></span>
<span class="codeline" id="line-905"><code>// reference to an out of range or unmatched index or a name that is not</code></span>
<span class="codeline" id="line-906"><code>// present in the regular expression is replaced with an empty slice.</code></span>
<span class="codeline" id="line-907"><code>//</code></span>
<span class="codeline" id="line-908"><code>// In the $name form, name is taken to be as long as possible: $1x is</code></span>
<span class="codeline" id="line-909"><code>// equivalent to ${1x}, not ${1}x, and, $10 is equivalent to ${10}, not ${1}0.</code></span>
<span class="codeline" id="line-910"><code>//</code></span>
<span class="codeline" id="line-911"><code>// To insert a literal $ in the output, use $$ in the template.</code></span>
<span class="codeline" id="line-912"><code>func (re *Regexp) Expand(dst []byte, template []byte, src []byte, match []int) []byte {</code></span>
<span class="codeline" id="line-913"><code>	return re.expand(dst, string(template), src, "", match)</code></span>
<span class="codeline" id="line-914"><code>}</code></span>
<span class="codeline" id="line-915"><code></code></span>
<span class="codeline" id="line-916"><code>// ExpandString is like Expand but the template and source are strings.</code></span>
<span class="codeline" id="line-917"><code>// It appends to and returns a byte slice in order to give the calling</code></span>
<span class="codeline" id="line-918"><code>// code control over allocation.</code></span>
<span class="codeline" id="line-919"><code>func (re *Regexp) ExpandString(dst []byte, template string, src string, match []int) []byte {</code></span>
<span class="codeline" id="line-920"><code>	return re.expand(dst, template, nil, src, match)</code></span>
<span class="codeline" id="line-921"><code>}</code></span>
<span class="codeline" id="line-922"><code></code></span>
<span class="codeline" id="line-923"><code>func (re *Regexp) expand(dst []byte, template string, bsrc []byte, src string, match []int) []byte {</code></span>
<span class="codeline" id="line-924"><code>	for len(template) &gt; 0 {</code></span>
<span class="codeline" id="line-925"><code>		i := strings.Index(template, "$")</code></span>
<span class="codeline" id="line-926"><code>		if i &lt; 0 {</code></span>
<span class="codeline" id="line-927"><code>			break</code></span>
<span class="codeline" id="line-928"><code>		}</code></span>
<span class="codeline" id="line-929"><code>		dst = append(dst, template[:i]...)</code></span>
<span class="codeline" id="line-930"><code>		template = template[i:]</code></span>
<span class="codeline" id="line-931"><code>		if len(template) &gt; 1 &amp;&amp; template[1] == '$' {</code></span>
<span class="codeline" id="line-932"><code>			// Treat $$ as $.</code></span>
<span class="codeline" id="line-933"><code>			dst = append(dst, '$')</code></span>
<span class="codeline" id="line-934"><code>			template = template[2:]</code></span>
<span class="codeline" id="line-935"><code>			continue</code></span>
<span class="codeline" id="line-936"><code>		}</code></span>
<span class="codeline" id="line-937"><code>		name, num, rest, ok := extract(template)</code></span>
<span class="codeline" id="line-938"><code>		if !ok {</code></span>
<span class="codeline" id="line-939"><code>			// Malformed; treat $ as raw text.</code></span>
<span class="codeline" id="line-940"><code>			dst = append(dst, '$')</code></span>
<span class="codeline" id="line-941"><code>			template = template[1:]</code></span>
<span class="codeline" id="line-942"><code>			continue</code></span>
<span class="codeline" id="line-943"><code>		}</code></span>
<span class="codeline" id="line-944"><code>		template = rest</code></span>
<span class="codeline" id="line-945"><code>		if num &gt;= 0 {</code></span>
<span class="codeline" id="line-946"><code>			if 2*num+1 &lt; len(match) &amp;&amp; match[2*num] &gt;= 0 {</code></span>
<span class="codeline" id="line-947"><code>				if bsrc != nil {</code></span>
<span class="codeline" id="line-948"><code>					dst = append(dst, bsrc[match[2*num]:match[2*num+1]]...)</code></span>
<span class="codeline" id="line-949"><code>				} else {</code></span>
<span class="codeline" id="line-950"><code>					dst = append(dst, src[match[2*num]:match[2*num+1]]...)</code></span>
<span class="codeline" id="line-951"><code>				}</code></span>
<span class="codeline" id="line-952"><code>			}</code></span>
<span class="codeline" id="line-953"><code>		} else {</code></span>
<span class="codeline" id="line-954"><code>			for i, namei := range re.subexpNames {</code></span>
<span class="codeline" id="line-955"><code>				if name == namei &amp;&amp; 2*i+1 &lt; len(match) &amp;&amp; match[2*i] &gt;= 0 {</code></span>
<span class="codeline" id="line-956"><code>					if bsrc != nil {</code></span>
<span class="codeline" id="line-957"><code>						dst = append(dst, bsrc[match[2*i]:match[2*i+1]]...)</code></span>
<span class="codeline" id="line-958"><code>					} else {</code></span>
<span class="codeline" id="line-959"><code>						dst = append(dst, src[match[2*i]:match[2*i+1]]...)</code></span>
<span class="codeline" id="line-960"><code>					}</code></span>
<span class="codeline" id="line-961"><code>					break</code></span>
<span class="codeline" id="line-962"><code>				}</code></span>
<span class="codeline" id="line-963"><code>			}</code></span>
<span class="codeline" id="line-964"><code>		}</code></span>
<span class="codeline" id="line-965"><code>	}</code></span>
<span class="codeline" id="line-966"><code>	dst = append(dst, template...)</code></span>
<span class="codeline" id="line-967"><code>	return dst</code></span>
<span class="codeline" id="line-968"><code>}</code></span>
<span class="codeline" id="line-969"><code></code></span>
<span class="codeline" id="line-970"><code>// extract returns the name from a leading "$name" or "${name}" in str.</code></span>
<span class="codeline" id="line-971"><code>// If it is a number, extract returns num set to that number; otherwise num = -1.</code></span>
<span class="codeline" id="line-972"><code>func extract(str string) (name string, num int, rest string, ok bool) {</code></span>
<span class="codeline" id="line-973"><code>	if len(str) &lt; 2 || str[0] != '$' {</code></span>
<span class="codeline" id="line-974"><code>		return</code></span>
<span class="codeline" id="line-975"><code>	}</code></span>
<span class="codeline" id="line-976"><code>	brace := false</code></span>
<span class="codeline" id="line-977"><code>	if str[1] == '{' {</code></span>
<span class="codeline" id="line-978"><code>		brace = true</code></span>
<span class="codeline" id="line-979"><code>		str = str[2:]</code></span>
<span class="codeline" id="line-980"><code>	} else {</code></span>
<span class="codeline" id="line-981"><code>		str = str[1:]</code></span>
<span class="codeline" id="line-982"><code>	}</code></span>
<span class="codeline" id="line-983"><code>	i := 0</code></span>
<span class="codeline" id="line-984"><code>	for i &lt; len(str) {</code></span>
<span class="codeline" id="line-985"><code>		rune, size := utf8.DecodeRuneInString(str[i:])</code></span>
<span class="codeline" id="line-986"><code>		if !unicode.IsLetter(rune) &amp;&amp; !unicode.IsDigit(rune) &amp;&amp; rune != '_' {</code></span>
<span class="codeline" id="line-987"><code>			break</code></span>
<span class="codeline" id="line-988"><code>		}</code></span>
<span class="codeline" id="line-989"><code>		i += size</code></span>
<span class="codeline" id="line-990"><code>	}</code></span>
<span class="codeline" id="line-991"><code>	if i == 0 {</code></span>
<span class="codeline" id="line-992"><code>		// empty name is not okay</code></span>
<span class="codeline" id="line-993"><code>		return</code></span>
<span class="codeline" id="line-994"><code>	}</code></span>
<span class="codeline" id="line-995"><code>	name = str[:i]</code></span>
<span class="codeline" id="line-996"><code>	if brace {</code></span>
<span class="codeline" id="line-997"><code>		if i &gt;= len(str) || str[i] != '}' {</code></span>
<span class="codeline" id="line-998"><code>			// missing closing brace</code></span>
<span class="codeline" id="line-999"><code>			return</code></span>
<span class="codeline" id="line-1000"><code>		}</code></span>
<span class="codeline" id="line-1001"><code>		i++</code></span>
<span class="codeline" id="line-1002"><code>	}</code></span>
<span class="codeline" id="line-1003"><code></code></span>
<span class="codeline" id="line-1004"><code>	// Parse number.</code></span>
<span class="codeline" id="line-1005"><code>	num = 0</code></span>
<span class="codeline" id="line-1006"><code>	for i := 0; i &lt; len(name); i++ {</code></span>
<span class="codeline" id="line-1007"><code>		if name[i] &lt; '0' || '9' &lt; name[i] || num &gt;= 1e8 {</code></span>
<span class="codeline" id="line-1008"><code>			num = -1</code></span>
<span class="codeline" id="line-1009"><code>			break</code></span>
<span class="codeline" id="line-1010"><code>		}</code></span>
<span class="codeline" id="line-1011"><code>		num = num*10 + int(name[i]) - '0'</code></span>
<span class="codeline" id="line-1012"><code>	}</code></span>
<span class="codeline" id="line-1013"><code>	// Disallow leading zeros.</code></span>
<span class="codeline" id="line-1014"><code>	if name[0] == '0' &amp;&amp; len(name) &gt; 1 {</code></span>
<span class="codeline" id="line-1015"><code>		num = -1</code></span>
<span class="codeline" id="line-1016"><code>	}</code></span>
<span class="codeline" id="line-1017"><code></code></span>
<span class="codeline" id="line-1018"><code>	rest = str[i:]</code></span>
<span class="codeline" id="line-1019"><code>	ok = true</code></span>
<span class="codeline" id="line-1020"><code>	return</code></span>
<span class="codeline" id="line-1021"><code>}</code></span>
<span class="codeline" id="line-1022"><code></code></span>
<span class="codeline" id="line-1023"><code>// FindSubmatchIndex returns a slice holding the index pairs identifying the</code></span>
<span class="codeline" id="line-1024"><code>// leftmost match of the regular expression in b and the matches, if any, of</code></span>
<span class="codeline" id="line-1025"><code>// its subexpressions, as defined by the 'Submatch' and 'Index' descriptions</code></span>
<span class="codeline" id="line-1026"><code>// in the package comment.</code></span>
<span class="codeline" id="line-1027"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-1028"><code>func (re *Regexp) FindSubmatchIndex(b []byte) []int {</code></span>
<span class="codeline" id="line-1029"><code>	return re.pad(re.doExecute(nil, b, "", 0, re.prog.NumCap, nil))</code></span>
<span class="codeline" id="line-1030"><code>}</code></span>
<span class="codeline" id="line-1031"><code></code></span>
<span class="codeline" id="line-1032"><code>// FindStringSubmatch returns a slice of strings holding the text of the</code></span>
<span class="codeline" id="line-1033"><code>// leftmost match of the regular expression in s and the matches, if any, of</code></span>
<span class="codeline" id="line-1034"><code>// its subexpressions, as defined by the 'Submatch' description in the</code></span>
<span class="codeline" id="line-1035"><code>// package comment.</code></span>
<span class="codeline" id="line-1036"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-1037"><code>func (re *Regexp) FindStringSubmatch(s string) []string {</code></span>
<span class="codeline" id="line-1038"><code>	var dstCap [4]int</code></span>
<span class="codeline" id="line-1039"><code>	a := re.doExecute(nil, nil, s, 0, re.prog.NumCap, dstCap[:0])</code></span>
<span class="codeline" id="line-1040"><code>	if a == nil {</code></span>
<span class="codeline" id="line-1041"><code>		return nil</code></span>
<span class="codeline" id="line-1042"><code>	}</code></span>
<span class="codeline" id="line-1043"><code>	ret := make([]string, 1+re.numSubexp)</code></span>
<span class="codeline" id="line-1044"><code>	for i := range ret {</code></span>
<span class="codeline" id="line-1045"><code>		if 2*i &lt; len(a) &amp;&amp; a[2*i] &gt;= 0 {</code></span>
<span class="codeline" id="line-1046"><code>			ret[i] = s[a[2*i]:a[2*i+1]]</code></span>
<span class="codeline" id="line-1047"><code>		}</code></span>
<span class="codeline" id="line-1048"><code>	}</code></span>
<span class="codeline" id="line-1049"><code>	return ret</code></span>
<span class="codeline" id="line-1050"><code>}</code></span>
<span class="codeline" id="line-1051"><code></code></span>
<span class="codeline" id="line-1052"><code>// FindStringSubmatchIndex returns a slice holding the index pairs</code></span>
<span class="codeline" id="line-1053"><code>// identifying the leftmost match of the regular expression in s and the</code></span>
<span class="codeline" id="line-1054"><code>// matches, if any, of its subexpressions, as defined by the 'Submatch' and</code></span>
<span class="codeline" id="line-1055"><code>// 'Index' descriptions in the package comment.</code></span>
<span class="codeline" id="line-1056"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-1057"><code>func (re *Regexp) FindStringSubmatchIndex(s string) []int {</code></span>
<span class="codeline" id="line-1058"><code>	return re.pad(re.doExecute(nil, nil, s, 0, re.prog.NumCap, nil))</code></span>
<span class="codeline" id="line-1059"><code>}</code></span>
<span class="codeline" id="line-1060"><code></code></span>
<span class="codeline" id="line-1061"><code>// FindReaderSubmatchIndex returns a slice holding the index pairs</code></span>
<span class="codeline" id="line-1062"><code>// identifying the leftmost match of the regular expression of text read by</code></span>
<span class="codeline" id="line-1063"><code>// the RuneReader, and the matches, if any, of its subexpressions, as defined</code></span>
<span class="codeline" id="line-1064"><code>// by the 'Submatch' and 'Index' descriptions in the package comment. A</code></span>
<span class="codeline" id="line-1065"><code>// return value of nil indicates no match.</code></span>
<span class="codeline" id="line-1066"><code>func (re *Regexp) FindReaderSubmatchIndex(r io.RuneReader) []int {</code></span>
<span class="codeline" id="line-1067"><code>	return re.pad(re.doExecute(r, nil, "", 0, re.prog.NumCap, nil))</code></span>
<span class="codeline" id="line-1068"><code>}</code></span>
<span class="codeline" id="line-1069"><code></code></span>
<span class="codeline" id="line-1070"><code>const startSize = 10 // The size at which to start a slice in the 'All' routines.</code></span>
<span class="codeline" id="line-1071"><code></code></span>
<span class="codeline" id="line-1072"><code>// FindAll is the 'All' version of Find; it returns a slice of all successive</code></span>
<span class="codeline" id="line-1073"><code>// matches of the expression, as defined by the 'All' description in the</code></span>
<span class="codeline" id="line-1074"><code>// package comment.</code></span>
<span class="codeline" id="line-1075"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-1076"><code>func (re *Regexp) FindAll(b []byte, n int) [][]byte {</code></span>
<span class="codeline" id="line-1077"><code>	if n &lt; 0 {</code></span>
<span class="codeline" id="line-1078"><code>		n = len(b) + 1</code></span>
<span class="codeline" id="line-1079"><code>	}</code></span>
<span class="codeline" id="line-1080"><code>	var result [][]byte</code></span>
<span class="codeline" id="line-1081"><code>	re.allMatches("", b, n, func(match []int) {</code></span>
<span class="codeline" id="line-1082"><code>		if result == nil {</code></span>
<span class="codeline" id="line-1083"><code>			result = make([][]byte, 0, startSize)</code></span>
<span class="codeline" id="line-1084"><code>		}</code></span>
<span class="codeline" id="line-1085"><code>		result = append(result, b[match[0]:match[1]:match[1]])</code></span>
<span class="codeline" id="line-1086"><code>	})</code></span>
<span class="codeline" id="line-1087"><code>	return result</code></span>
<span class="codeline" id="line-1088"><code>}</code></span>
<span class="codeline" id="line-1089"><code></code></span>
<span class="codeline" id="line-1090"><code>// FindAllIndex is the 'All' version of FindIndex; it returns a slice of all</code></span>
<span class="codeline" id="line-1091"><code>// successive matches of the expression, as defined by the 'All' description</code></span>
<span class="codeline" id="line-1092"><code>// in the package comment.</code></span>
<span class="codeline" id="line-1093"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-1094"><code>func (re *Regexp) FindAllIndex(b []byte, n int) [][]int {</code></span>
<span class="codeline" id="line-1095"><code>	if n &lt; 0 {</code></span>
<span class="codeline" id="line-1096"><code>		n = len(b) + 1</code></span>
<span class="codeline" id="line-1097"><code>	}</code></span>
<span class="codeline" id="line-1098"><code>	var result [][]int</code></span>
<span class="codeline" id="line-1099"><code>	re.allMatches("", b, n, func(match []int) {</code></span>
<span class="codeline" id="line-1100"><code>		if result == nil {</code></span>
<span class="codeline" id="line-1101"><code>			result = make([][]int, 0, startSize)</code></span>
<span class="codeline" id="line-1102"><code>		}</code></span>
<span class="codeline" id="line-1103"><code>		result = append(result, match[0:2])</code></span>
<span class="codeline" id="line-1104"><code>	})</code></span>
<span class="codeline" id="line-1105"><code>	return result</code></span>
<span class="codeline" id="line-1106"><code>}</code></span>
<span class="codeline" id="line-1107"><code></code></span>
<span class="codeline" id="line-1108"><code>// FindAllString is the 'All' version of FindString; it returns a slice of all</code></span>
<span class="codeline" id="line-1109"><code>// successive matches of the expression, as defined by the 'All' description</code></span>
<span class="codeline" id="line-1110"><code>// in the package comment.</code></span>
<span class="codeline" id="line-1111"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-1112"><code>func (re *Regexp) FindAllString(s string, n int) []string {</code></span>
<span class="codeline" id="line-1113"><code>	if n &lt; 0 {</code></span>
<span class="codeline" id="line-1114"><code>		n = len(s) + 1</code></span>
<span class="codeline" id="line-1115"><code>	}</code></span>
<span class="codeline" id="line-1116"><code>	var result []string</code></span>
<span class="codeline" id="line-1117"><code>	re.allMatches(s, nil, n, func(match []int) {</code></span>
<span class="codeline" id="line-1118"><code>		if result == nil {</code></span>
<span class="codeline" id="line-1119"><code>			result = make([]string, 0, startSize)</code></span>
<span class="codeline" id="line-1120"><code>		}</code></span>
<span class="codeline" id="line-1121"><code>		result = append(result, s[match[0]:match[1]])</code></span>
<span class="codeline" id="line-1122"><code>	})</code></span>
<span class="codeline" id="line-1123"><code>	return result</code></span>
<span class="codeline" id="line-1124"><code>}</code></span>
<span class="codeline" id="line-1125"><code></code></span>
<span class="codeline" id="line-1126"><code>// FindAllStringIndex is the 'All' version of FindStringIndex; it returns a</code></span>
<span class="codeline" id="line-1127"><code>// slice of all successive matches of the expression, as defined by the 'All'</code></span>
<span class="codeline" id="line-1128"><code>// description in the package comment.</code></span>
<span class="codeline" id="line-1129"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-1130"><code>func (re *Regexp) FindAllStringIndex(s string, n int) [][]int {</code></span>
<span class="codeline" id="line-1131"><code>	if n &lt; 0 {</code></span>
<span class="codeline" id="line-1132"><code>		n = len(s) + 1</code></span>
<span class="codeline" id="line-1133"><code>	}</code></span>
<span class="codeline" id="line-1134"><code>	var result [][]int</code></span>
<span class="codeline" id="line-1135"><code>	re.allMatches(s, nil, n, func(match []int) {</code></span>
<span class="codeline" id="line-1136"><code>		if result == nil {</code></span>
<span class="codeline" id="line-1137"><code>			result = make([][]int, 0, startSize)</code></span>
<span class="codeline" id="line-1138"><code>		}</code></span>
<span class="codeline" id="line-1139"><code>		result = append(result, match[0:2])</code></span>
<span class="codeline" id="line-1140"><code>	})</code></span>
<span class="codeline" id="line-1141"><code>	return result</code></span>
<span class="codeline" id="line-1142"><code>}</code></span>
<span class="codeline" id="line-1143"><code></code></span>
<span class="codeline" id="line-1144"><code>// FindAllSubmatch is the 'All' version of FindSubmatch; it returns a slice</code></span>
<span class="codeline" id="line-1145"><code>// of all successive matches of the expression, as defined by the 'All'</code></span>
<span class="codeline" id="line-1146"><code>// description in the package comment.</code></span>
<span class="codeline" id="line-1147"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-1148"><code>func (re *Regexp) FindAllSubmatch(b []byte, n int) [][][]byte {</code></span>
<span class="codeline" id="line-1149"><code>	if n &lt; 0 {</code></span>
<span class="codeline" id="line-1150"><code>		n = len(b) + 1</code></span>
<span class="codeline" id="line-1151"><code>	}</code></span>
<span class="codeline" id="line-1152"><code>	var result [][][]byte</code></span>
<span class="codeline" id="line-1153"><code>	re.allMatches("", b, n, func(match []int) {</code></span>
<span class="codeline" id="line-1154"><code>		if result == nil {</code></span>
<span class="codeline" id="line-1155"><code>			result = make([][][]byte, 0, startSize)</code></span>
<span class="codeline" id="line-1156"><code>		}</code></span>
<span class="codeline" id="line-1157"><code>		slice := make([][]byte, len(match)/2)</code></span>
<span class="codeline" id="line-1158"><code>		for j := range slice {</code></span>
<span class="codeline" id="line-1159"><code>			if match[2*j] &gt;= 0 {</code></span>
<span class="codeline" id="line-1160"><code>				slice[j] = b[match[2*j]:match[2*j+1]:match[2*j+1]]</code></span>
<span class="codeline" id="line-1161"><code>			}</code></span>
<span class="codeline" id="line-1162"><code>		}</code></span>
<span class="codeline" id="line-1163"><code>		result = append(result, slice)</code></span>
<span class="codeline" id="line-1164"><code>	})</code></span>
<span class="codeline" id="line-1165"><code>	return result</code></span>
<span class="codeline" id="line-1166"><code>}</code></span>
<span class="codeline" id="line-1167"><code></code></span>
<span class="codeline" id="line-1168"><code>// FindAllSubmatchIndex is the 'All' version of FindSubmatchIndex; it returns</code></span>
<span class="codeline" id="line-1169"><code>// a slice of all successive matches of the expression, as defined by the</code></span>
<span class="codeline" id="line-1170"><code>// 'All' description in the package comment.</code></span>
<span class="codeline" id="line-1171"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-1172"><code>func (re *Regexp) FindAllSubmatchIndex(b []byte, n int) [][]int {</code></span>
<span class="codeline" id="line-1173"><code>	if n &lt; 0 {</code></span>
<span class="codeline" id="line-1174"><code>		n = len(b) + 1</code></span>
<span class="codeline" id="line-1175"><code>	}</code></span>
<span class="codeline" id="line-1176"><code>	var result [][]int</code></span>
<span class="codeline" id="line-1177"><code>	re.allMatches("", b, n, func(match []int) {</code></span>
<span class="codeline" id="line-1178"><code>		if result == nil {</code></span>
<span class="codeline" id="line-1179"><code>			result = make([][]int, 0, startSize)</code></span>
<span class="codeline" id="line-1180"><code>		}</code></span>
<span class="codeline" id="line-1181"><code>		result = append(result, match)</code></span>
<span class="codeline" id="line-1182"><code>	})</code></span>
<span class="codeline" id="line-1183"><code>	return result</code></span>
<span class="codeline" id="line-1184"><code>}</code></span>
<span class="codeline" id="line-1185"><code></code></span>
<span class="codeline" id="line-1186"><code>// FindAllStringSubmatch is the 'All' version of FindStringSubmatch; it</code></span>
<span class="codeline" id="line-1187"><code>// returns a slice of all successive matches of the expression, as defined by</code></span>
<span class="codeline" id="line-1188"><code>// the 'All' description in the package comment.</code></span>
<span class="codeline" id="line-1189"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-1190"><code>func (re *Regexp) FindAllStringSubmatch(s string, n int) [][]string {</code></span>
<span class="codeline" id="line-1191"><code>	if n &lt; 0 {</code></span>
<span class="codeline" id="line-1192"><code>		n = len(s) + 1</code></span>
<span class="codeline" id="line-1193"><code>	}</code></span>
<span class="codeline" id="line-1194"><code>	var result [][]string</code></span>
<span class="codeline" id="line-1195"><code>	re.allMatches(s, nil, n, func(match []int) {</code></span>
<span class="codeline" id="line-1196"><code>		if result == nil {</code></span>
<span class="codeline" id="line-1197"><code>			result = make([][]string, 0, startSize)</code></span>
<span class="codeline" id="line-1198"><code>		}</code></span>
<span class="codeline" id="line-1199"><code>		slice := make([]string, len(match)/2)</code></span>
<span class="codeline" id="line-1200"><code>		for j := range slice {</code></span>
<span class="codeline" id="line-1201"><code>			if match[2*j] &gt;= 0 {</code></span>
<span class="codeline" id="line-1202"><code>				slice[j] = s[match[2*j]:match[2*j+1]]</code></span>
<span class="codeline" id="line-1203"><code>			}</code></span>
<span class="codeline" id="line-1204"><code>		}</code></span>
<span class="codeline" id="line-1205"><code>		result = append(result, slice)</code></span>
<span class="codeline" id="line-1206"><code>	})</code></span>
<span class="codeline" id="line-1207"><code>	return result</code></span>
<span class="codeline" id="line-1208"><code>}</code></span>
<span class="codeline" id="line-1209"><code></code></span>
<span class="codeline" id="line-1210"><code>// FindAllStringSubmatchIndex is the 'All' version of</code></span>
<span class="codeline" id="line-1211"><code>// FindStringSubmatchIndex; it returns a slice of all successive matches of</code></span>
<span class="codeline" id="line-1212"><code>// the expression, as defined by the 'All' description in the package</code></span>
<span class="codeline" id="line-1213"><code>// comment.</code></span>
<span class="codeline" id="line-1214"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-1215"><code>func (re *Regexp) FindAllStringSubmatchIndex(s string, n int) [][]int {</code></span>
<span class="codeline" id="line-1216"><code>	if n &lt; 0 {</code></span>
<span class="codeline" id="line-1217"><code>		n = len(s) + 1</code></span>
<span class="codeline" id="line-1218"><code>	}</code></span>
<span class="codeline" id="line-1219"><code>	var result [][]int</code></span>
<span class="codeline" id="line-1220"><code>	re.allMatches(s, nil, n, func(match []int) {</code></span>
<span class="codeline" id="line-1221"><code>		if result == nil {</code></span>
<span class="codeline" id="line-1222"><code>			result = make([][]int, 0, startSize)</code></span>
<span class="codeline" id="line-1223"><code>		}</code></span>
<span class="codeline" id="line-1224"><code>		result = append(result, match)</code></span>
<span class="codeline" id="line-1225"><code>	})</code></span>
<span class="codeline" id="line-1226"><code>	return result</code></span>
<span class="codeline" id="line-1227"><code>}</code></span>
<span class="codeline" id="line-1228"><code></code></span>
<span class="codeline" id="line-1229"><code>// Split slices s into substrings separated by the expression and returns a slice of</code></span>
<span class="codeline" id="line-1230"><code>// the substrings between those expression matches.</code></span>
<span class="codeline" id="line-1231"><code>//</code></span>
<span class="codeline" id="line-1232"><code>// The slice returned by this method consists of all the substrings of s</code></span>
<span class="codeline" id="line-1233"><code>// not contained in the slice returned by FindAllString. When called on an expression</code></span>
<span class="codeline" id="line-1234"><code>// that contains no metacharacters, it is equivalent to strings.SplitN.</code></span>
<span class="codeline" id="line-1235"><code>//</code></span>
<span class="codeline" id="line-1236"><code>// Example:</code></span>
<span class="codeline" id="line-1237"><code>//   s := regexp.MustCompile("a*").Split("abaabaccadaaae", 5)</code></span>
<span class="codeline" id="line-1238"><code>//   // s: ["", "b", "b", "c", "cadaaae"]</code></span>
<span class="codeline" id="line-1239"><code>//</code></span>
<span class="codeline" id="line-1240"><code>// The count determines the number of substrings to return:</code></span>
<span class="codeline" id="line-1241"><code>//   n &gt; 0: at most n substrings; the last substring will be the unsplit remainder.</code></span>
<span class="codeline" id="line-1242"><code>//   n == 0: the result is nil (zero substrings)</code></span>
<span class="codeline" id="line-1243"><code>//   n &lt; 0: all substrings</code></span>
<span class="codeline" id="line-1244"><code>func (re *Regexp) Split(s string, n int) []string {</code></span>
<span class="codeline" id="line-1245"><code></code></span>
<span class="codeline" id="line-1246"><code>	if n == 0 {</code></span>
<span class="codeline" id="line-1247"><code>		return nil</code></span>
<span class="codeline" id="line-1248"><code>	}</code></span>
<span class="codeline" id="line-1249"><code></code></span>
<span class="codeline" id="line-1250"><code>	if len(re.expr) &gt; 0 &amp;&amp; len(s) == 0 {</code></span>
<span class="codeline" id="line-1251"><code>		return []string{""}</code></span>
<span class="codeline" id="line-1252"><code>	}</code></span>
<span class="codeline" id="line-1253"><code></code></span>
<span class="codeline" id="line-1254"><code>	matches := re.FindAllStringIndex(s, n)</code></span>
<span class="codeline" id="line-1255"><code>	strings := make([]string, 0, len(matches))</code></span>
<span class="codeline" id="line-1256"><code></code></span>
<span class="codeline" id="line-1257"><code>	beg := 0</code></span>
<span class="codeline" id="line-1258"><code>	end := 0</code></span>
<span class="codeline" id="line-1259"><code>	for _, match := range matches {</code></span>
<span class="codeline" id="line-1260"><code>		if n &gt; 0 &amp;&amp; len(strings) &gt;= n-1 {</code></span>
<span class="codeline" id="line-1261"><code>			break</code></span>
<span class="codeline" id="line-1262"><code>		}</code></span>
<span class="codeline" id="line-1263"><code></code></span>
<span class="codeline" id="line-1264"><code>		end = match[0]</code></span>
<span class="codeline" id="line-1265"><code>		if match[1] != 0 {</code></span>
<span class="codeline" id="line-1266"><code>			strings = append(strings, s[beg:end])</code></span>
<span class="codeline" id="line-1267"><code>		}</code></span>
<span class="codeline" id="line-1268"><code>		beg = match[1]</code></span>
<span class="codeline" id="line-1269"><code>	}</code></span>
<span class="codeline" id="line-1270"><code></code></span>
<span class="codeline" id="line-1271"><code>	if end != len(s) {</code></span>
<span class="codeline" id="line-1272"><code>		strings = append(strings, s[beg:])</code></span>
<span class="codeline" id="line-1273"><code>	}</code></span>
<span class="codeline" id="line-1274"><code></code></span>
<span class="codeline" id="line-1275"><code>	return strings</code></span>
<span class="codeline" id="line-1276"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.1.6</i>. (GOOS=darwin GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project and developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table
</pre>
</div></body></html>