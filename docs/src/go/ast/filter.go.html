<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: filter.go in package go/ast</title>
<link href="../../../css/light-v0.1.6.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.1.6.js"></script>
<body><div>

<pre id="header"><code><span class="title">Source File</span>
	filter.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/go/ast.html">go/ast</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>package ast</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>import (</code></span>
<span class="codeline" id="line-8"><code>	"go/token"</code></span>
<span class="codeline" id="line-9"><code>	"sort"</code></span>
<span class="codeline" id="line-10"><code>)</code></span>
<span class="codeline" id="line-11"><code></code></span>
<span class="codeline" id="line-12"><code>// ----------------------------------------------------------------------------</code></span>
<span class="codeline" id="line-13"><code>// Export filtering</code></span>
<span class="codeline" id="line-14"><code></code></span>
<span class="codeline" id="line-15"><code>// exportFilter is a special filter function to extract exported nodes.</code></span>
<span class="codeline" id="line-16"><code>func exportFilter(name string) bool {</code></span>
<span class="codeline" id="line-17"><code>	return IsExported(name)</code></span>
<span class="codeline" id="line-18"><code>}</code></span>
<span class="codeline" id="line-19"><code></code></span>
<span class="codeline" id="line-20"><code>// FileExports trims the AST for a Go source file in place such that</code></span>
<span class="codeline" id="line-21"><code>// only exported nodes remain: all top-level identifiers which are not exported</code></span>
<span class="codeline" id="line-22"><code>// and their associated information (such as type, initial value, or function</code></span>
<span class="codeline" id="line-23"><code>// body) are removed. Non-exported fields and methods of exported types are</code></span>
<span class="codeline" id="line-24"><code>// stripped. The File.Comments list is not changed.</code></span>
<span class="codeline" id="line-25"><code>//</code></span>
<span class="codeline" id="line-26"><code>// FileExports reports whether there are exported declarations.</code></span>
<span class="codeline" id="line-27"><code>//</code></span>
<span class="codeline" id="line-28"><code>func FileExports(src *File) bool {</code></span>
<span class="codeline" id="line-29"><code>	return filterFile(src, exportFilter, true)</code></span>
<span class="codeline" id="line-30"><code>}</code></span>
<span class="codeline" id="line-31"><code></code></span>
<span class="codeline" id="line-32"><code>// PackageExports trims the AST for a Go package in place such that</code></span>
<span class="codeline" id="line-33"><code>// only exported nodes remain. The pkg.Files list is not changed, so that</code></span>
<span class="codeline" id="line-34"><code>// file names and top-level package comments don't get lost.</code></span>
<span class="codeline" id="line-35"><code>//</code></span>
<span class="codeline" id="line-36"><code>// PackageExports reports whether there are exported declarations;</code></span>
<span class="codeline" id="line-37"><code>// it returns false otherwise.</code></span>
<span class="codeline" id="line-38"><code>//</code></span>
<span class="codeline" id="line-39"><code>func PackageExports(pkg *Package) bool {</code></span>
<span class="codeline" id="line-40"><code>	return filterPackage(pkg, exportFilter, true)</code></span>
<span class="codeline" id="line-41"><code>}</code></span>
<span class="codeline" id="line-42"><code></code></span>
<span class="codeline" id="line-43"><code>// ----------------------------------------------------------------------------</code></span>
<span class="codeline" id="line-44"><code>// General filtering</code></span>
<span class="codeline" id="line-45"><code></code></span>
<span class="codeline" id="line-46"><code>type Filter func(string) bool</code></span>
<span class="codeline" id="line-47"><code></code></span>
<span class="codeline" id="line-48"><code>func filterIdentList(list []*Ident, f Filter) []*Ident {</code></span>
<span class="codeline" id="line-49"><code>	j := 0</code></span>
<span class="codeline" id="line-50"><code>	for _, x := range list {</code></span>
<span class="codeline" id="line-51"><code>		if f(x.Name) {</code></span>
<span class="codeline" id="line-52"><code>			list[j] = x</code></span>
<span class="codeline" id="line-53"><code>			j++</code></span>
<span class="codeline" id="line-54"><code>		}</code></span>
<span class="codeline" id="line-55"><code>	}</code></span>
<span class="codeline" id="line-56"><code>	return list[0:j]</code></span>
<span class="codeline" id="line-57"><code>}</code></span>
<span class="codeline" id="line-58"><code></code></span>
<span class="codeline" id="line-59"><code>// fieldName assumes that x is the type of an anonymous field and</code></span>
<span class="codeline" id="line-60"><code>// returns the corresponding field name. If x is not an acceptable</code></span>
<span class="codeline" id="line-61"><code>// anonymous field, the result is nil.</code></span>
<span class="codeline" id="line-62"><code>//</code></span>
<span class="codeline" id="line-63"><code>func fieldName(x Expr) *Ident {</code></span>
<span class="codeline" id="line-64"><code>	switch t := x.(type) {</code></span>
<span class="codeline" id="line-65"><code>	case *Ident:</code></span>
<span class="codeline" id="line-66"><code>		return t</code></span>
<span class="codeline" id="line-67"><code>	case *SelectorExpr:</code></span>
<span class="codeline" id="line-68"><code>		if _, ok := t.X.(*Ident); ok {</code></span>
<span class="codeline" id="line-69"><code>			return t.Sel</code></span>
<span class="codeline" id="line-70"><code>		}</code></span>
<span class="codeline" id="line-71"><code>	case *StarExpr:</code></span>
<span class="codeline" id="line-72"><code>		return fieldName(t.X)</code></span>
<span class="codeline" id="line-73"><code>	}</code></span>
<span class="codeline" id="line-74"><code>	return nil</code></span>
<span class="codeline" id="line-75"><code>}</code></span>
<span class="codeline" id="line-76"><code></code></span>
<span class="codeline" id="line-77"><code>func filterFieldList(fields *FieldList, filter Filter, export bool) (removedFields bool) {</code></span>
<span class="codeline" id="line-78"><code>	if fields == nil {</code></span>
<span class="codeline" id="line-79"><code>		return false</code></span>
<span class="codeline" id="line-80"><code>	}</code></span>
<span class="codeline" id="line-81"><code>	list := fields.List</code></span>
<span class="codeline" id="line-82"><code>	j := 0</code></span>
<span class="codeline" id="line-83"><code>	for _, f := range list {</code></span>
<span class="codeline" id="line-84"><code>		keepField := false</code></span>
<span class="codeline" id="line-85"><code>		if len(f.Names) == 0 {</code></span>
<span class="codeline" id="line-86"><code>			// anonymous field</code></span>
<span class="codeline" id="line-87"><code>			name := fieldName(f.Type)</code></span>
<span class="codeline" id="line-88"><code>			keepField = name != nil &amp;&amp; filter(name.Name)</code></span>
<span class="codeline" id="line-89"><code>		} else {</code></span>
<span class="codeline" id="line-90"><code>			n := len(f.Names)</code></span>
<span class="codeline" id="line-91"><code>			f.Names = filterIdentList(f.Names, filter)</code></span>
<span class="codeline" id="line-92"><code>			if len(f.Names) &lt; n {</code></span>
<span class="codeline" id="line-93"><code>				removedFields = true</code></span>
<span class="codeline" id="line-94"><code>			}</code></span>
<span class="codeline" id="line-95"><code>			keepField = len(f.Names) &gt; 0</code></span>
<span class="codeline" id="line-96"><code>		}</code></span>
<span class="codeline" id="line-97"><code>		if keepField {</code></span>
<span class="codeline" id="line-98"><code>			if export {</code></span>
<span class="codeline" id="line-99"><code>				filterType(f.Type, filter, export)</code></span>
<span class="codeline" id="line-100"><code>			}</code></span>
<span class="codeline" id="line-101"><code>			list[j] = f</code></span>
<span class="codeline" id="line-102"><code>			j++</code></span>
<span class="codeline" id="line-103"><code>		}</code></span>
<span class="codeline" id="line-104"><code>	}</code></span>
<span class="codeline" id="line-105"><code>	if j &lt; len(list) {</code></span>
<span class="codeline" id="line-106"><code>		removedFields = true</code></span>
<span class="codeline" id="line-107"><code>	}</code></span>
<span class="codeline" id="line-108"><code>	fields.List = list[0:j]</code></span>
<span class="codeline" id="line-109"><code>	return</code></span>
<span class="codeline" id="line-110"><code>}</code></span>
<span class="codeline" id="line-111"><code></code></span>
<span class="codeline" id="line-112"><code>func filterCompositeLit(lit *CompositeLit, filter Filter, export bool) {</code></span>
<span class="codeline" id="line-113"><code>	n := len(lit.Elts)</code></span>
<span class="codeline" id="line-114"><code>	lit.Elts = filterExprList(lit.Elts, filter, export)</code></span>
<span class="codeline" id="line-115"><code>	if len(lit.Elts) &lt; n {</code></span>
<span class="codeline" id="line-116"><code>		lit.Incomplete = true</code></span>
<span class="codeline" id="line-117"><code>	}</code></span>
<span class="codeline" id="line-118"><code>}</code></span>
<span class="codeline" id="line-119"><code></code></span>
<span class="codeline" id="line-120"><code>func filterExprList(list []Expr, filter Filter, export bool) []Expr {</code></span>
<span class="codeline" id="line-121"><code>	j := 0</code></span>
<span class="codeline" id="line-122"><code>	for _, exp := range list {</code></span>
<span class="codeline" id="line-123"><code>		switch x := exp.(type) {</code></span>
<span class="codeline" id="line-124"><code>		case *CompositeLit:</code></span>
<span class="codeline" id="line-125"><code>			filterCompositeLit(x, filter, export)</code></span>
<span class="codeline" id="line-126"><code>		case *KeyValueExpr:</code></span>
<span class="codeline" id="line-127"><code>			if x, ok := x.Key.(*Ident); ok &amp;&amp; !filter(x.Name) {</code></span>
<span class="codeline" id="line-128"><code>				continue</code></span>
<span class="codeline" id="line-129"><code>			}</code></span>
<span class="codeline" id="line-130"><code>			if x, ok := x.Value.(*CompositeLit); ok {</code></span>
<span class="codeline" id="line-131"><code>				filterCompositeLit(x, filter, export)</code></span>
<span class="codeline" id="line-132"><code>			}</code></span>
<span class="codeline" id="line-133"><code>		}</code></span>
<span class="codeline" id="line-134"><code>		list[j] = exp</code></span>
<span class="codeline" id="line-135"><code>		j++</code></span>
<span class="codeline" id="line-136"><code>	}</code></span>
<span class="codeline" id="line-137"><code>	return list[0:j]</code></span>
<span class="codeline" id="line-138"><code>}</code></span>
<span class="codeline" id="line-139"><code></code></span>
<span class="codeline" id="line-140"><code>func filterParamList(fields *FieldList, filter Filter, export bool) bool {</code></span>
<span class="codeline" id="line-141"><code>	if fields == nil {</code></span>
<span class="codeline" id="line-142"><code>		return false</code></span>
<span class="codeline" id="line-143"><code>	}</code></span>
<span class="codeline" id="line-144"><code>	var b bool</code></span>
<span class="codeline" id="line-145"><code>	for _, f := range fields.List {</code></span>
<span class="codeline" id="line-146"><code>		if filterType(f.Type, filter, export) {</code></span>
<span class="codeline" id="line-147"><code>			b = true</code></span>
<span class="codeline" id="line-148"><code>		}</code></span>
<span class="codeline" id="line-149"><code>	}</code></span>
<span class="codeline" id="line-150"><code>	return b</code></span>
<span class="codeline" id="line-151"><code>}</code></span>
<span class="codeline" id="line-152"><code></code></span>
<span class="codeline" id="line-153"><code>func filterType(typ Expr, f Filter, export bool) bool {</code></span>
<span class="codeline" id="line-154"><code>	switch t := typ.(type) {</code></span>
<span class="codeline" id="line-155"><code>	case *Ident:</code></span>
<span class="codeline" id="line-156"><code>		return f(t.Name)</code></span>
<span class="codeline" id="line-157"><code>	case *ParenExpr:</code></span>
<span class="codeline" id="line-158"><code>		return filterType(t.X, f, export)</code></span>
<span class="codeline" id="line-159"><code>	case *ArrayType:</code></span>
<span class="codeline" id="line-160"><code>		return filterType(t.Elt, f, export)</code></span>
<span class="codeline" id="line-161"><code>	case *StructType:</code></span>
<span class="codeline" id="line-162"><code>		if filterFieldList(t.Fields, f, export) {</code></span>
<span class="codeline" id="line-163"><code>			t.Incomplete = true</code></span>
<span class="codeline" id="line-164"><code>		}</code></span>
<span class="codeline" id="line-165"><code>		return len(t.Fields.List) &gt; 0</code></span>
<span class="codeline" id="line-166"><code>	case *FuncType:</code></span>
<span class="codeline" id="line-167"><code>		b1 := filterParamList(t.Params, f, export)</code></span>
<span class="codeline" id="line-168"><code>		b2 := filterParamList(t.Results, f, export)</code></span>
<span class="codeline" id="line-169"><code>		return b1 || b2</code></span>
<span class="codeline" id="line-170"><code>	case *InterfaceType:</code></span>
<span class="codeline" id="line-171"><code>		if filterFieldList(t.Methods, f, export) {</code></span>
<span class="codeline" id="line-172"><code>			t.Incomplete = true</code></span>
<span class="codeline" id="line-173"><code>		}</code></span>
<span class="codeline" id="line-174"><code>		return len(t.Methods.List) &gt; 0</code></span>
<span class="codeline" id="line-175"><code>	case *MapType:</code></span>
<span class="codeline" id="line-176"><code>		b1 := filterType(t.Key, f, export)</code></span>
<span class="codeline" id="line-177"><code>		b2 := filterType(t.Value, f, export)</code></span>
<span class="codeline" id="line-178"><code>		return b1 || b2</code></span>
<span class="codeline" id="line-179"><code>	case *ChanType:</code></span>
<span class="codeline" id="line-180"><code>		return filterType(t.Value, f, export)</code></span>
<span class="codeline" id="line-181"><code>	}</code></span>
<span class="codeline" id="line-182"><code>	return false</code></span>
<span class="codeline" id="line-183"><code>}</code></span>
<span class="codeline" id="line-184"><code></code></span>
<span class="codeline" id="line-185"><code>func filterSpec(spec Spec, f Filter, export bool) bool {</code></span>
<span class="codeline" id="line-186"><code>	switch s := spec.(type) {</code></span>
<span class="codeline" id="line-187"><code>	case *ValueSpec:</code></span>
<span class="codeline" id="line-188"><code>		s.Names = filterIdentList(s.Names, f)</code></span>
<span class="codeline" id="line-189"><code>		s.Values = filterExprList(s.Values, f, export)</code></span>
<span class="codeline" id="line-190"><code>		if len(s.Names) &gt; 0 {</code></span>
<span class="codeline" id="line-191"><code>			if export {</code></span>
<span class="codeline" id="line-192"><code>				filterType(s.Type, f, export)</code></span>
<span class="codeline" id="line-193"><code>			}</code></span>
<span class="codeline" id="line-194"><code>			return true</code></span>
<span class="codeline" id="line-195"><code>		}</code></span>
<span class="codeline" id="line-196"><code>	case *TypeSpec:</code></span>
<span class="codeline" id="line-197"><code>		if f(s.Name.Name) {</code></span>
<span class="codeline" id="line-198"><code>			if export {</code></span>
<span class="codeline" id="line-199"><code>				filterType(s.Type, f, export)</code></span>
<span class="codeline" id="line-200"><code>			}</code></span>
<span class="codeline" id="line-201"><code>			return true</code></span>
<span class="codeline" id="line-202"><code>		}</code></span>
<span class="codeline" id="line-203"><code>		if !export {</code></span>
<span class="codeline" id="line-204"><code>			// For general filtering (not just exports),</code></span>
<span class="codeline" id="line-205"><code>			// filter type even if name is not filtered</code></span>
<span class="codeline" id="line-206"><code>			// out.</code></span>
<span class="codeline" id="line-207"><code>			// If the type contains filtered elements,</code></span>
<span class="codeline" id="line-208"><code>			// keep the declaration.</code></span>
<span class="codeline" id="line-209"><code>			return filterType(s.Type, f, export)</code></span>
<span class="codeline" id="line-210"><code>		}</code></span>
<span class="codeline" id="line-211"><code>	}</code></span>
<span class="codeline" id="line-212"><code>	return false</code></span>
<span class="codeline" id="line-213"><code>}</code></span>
<span class="codeline" id="line-214"><code></code></span>
<span class="codeline" id="line-215"><code>func filterSpecList(list []Spec, f Filter, export bool) []Spec {</code></span>
<span class="codeline" id="line-216"><code>	j := 0</code></span>
<span class="codeline" id="line-217"><code>	for _, s := range list {</code></span>
<span class="codeline" id="line-218"><code>		if filterSpec(s, f, export) {</code></span>
<span class="codeline" id="line-219"><code>			list[j] = s</code></span>
<span class="codeline" id="line-220"><code>			j++</code></span>
<span class="codeline" id="line-221"><code>		}</code></span>
<span class="codeline" id="line-222"><code>	}</code></span>
<span class="codeline" id="line-223"><code>	return list[0:j]</code></span>
<span class="codeline" id="line-224"><code>}</code></span>
<span class="codeline" id="line-225"><code></code></span>
<span class="codeline" id="line-226"><code>// FilterDecl trims the AST for a Go declaration in place by removing</code></span>
<span class="codeline" id="line-227"><code>// all names (including struct field and interface method names, but</code></span>
<span class="codeline" id="line-228"><code>// not from parameter lists) that don't pass through the filter f.</code></span>
<span class="codeline" id="line-229"><code>//</code></span>
<span class="codeline" id="line-230"><code>// FilterDecl reports whether there are any declared names left after</code></span>
<span class="codeline" id="line-231"><code>// filtering.</code></span>
<span class="codeline" id="line-232"><code>//</code></span>
<span class="codeline" id="line-233"><code>func FilterDecl(decl Decl, f Filter) bool {</code></span>
<span class="codeline" id="line-234"><code>	return filterDecl(decl, f, false)</code></span>
<span class="codeline" id="line-235"><code>}</code></span>
<span class="codeline" id="line-236"><code></code></span>
<span class="codeline" id="line-237"><code>func filterDecl(decl Decl, f Filter, export bool) bool {</code></span>
<span class="codeline" id="line-238"><code>	switch d := decl.(type) {</code></span>
<span class="codeline" id="line-239"><code>	case *GenDecl:</code></span>
<span class="codeline" id="line-240"><code>		d.Specs = filterSpecList(d.Specs, f, export)</code></span>
<span class="codeline" id="line-241"><code>		return len(d.Specs) &gt; 0</code></span>
<span class="codeline" id="line-242"><code>	case *FuncDecl:</code></span>
<span class="codeline" id="line-243"><code>		return f(d.Name.Name)</code></span>
<span class="codeline" id="line-244"><code>	}</code></span>
<span class="codeline" id="line-245"><code>	return false</code></span>
<span class="codeline" id="line-246"><code>}</code></span>
<span class="codeline" id="line-247"><code></code></span>
<span class="codeline" id="line-248"><code>// FilterFile trims the AST for a Go file in place by removing all</code></span>
<span class="codeline" id="line-249"><code>// names from top-level declarations (including struct field and</code></span>
<span class="codeline" id="line-250"><code>// interface method names, but not from parameter lists) that don't</code></span>
<span class="codeline" id="line-251"><code>// pass through the filter f. If the declaration is empty afterwards,</code></span>
<span class="codeline" id="line-252"><code>// the declaration is removed from the AST. Import declarations are</code></span>
<span class="codeline" id="line-253"><code>// always removed. The File.Comments list is not changed.</code></span>
<span class="codeline" id="line-254"><code>//</code></span>
<span class="codeline" id="line-255"><code>// FilterFile reports whether there are any top-level declarations</code></span>
<span class="codeline" id="line-256"><code>// left after filtering.</code></span>
<span class="codeline" id="line-257"><code>//</code></span>
<span class="codeline" id="line-258"><code>func FilterFile(src *File, f Filter) bool {</code></span>
<span class="codeline" id="line-259"><code>	return filterFile(src, f, false)</code></span>
<span class="codeline" id="line-260"><code>}</code></span>
<span class="codeline" id="line-261"><code></code></span>
<span class="codeline" id="line-262"><code>func filterFile(src *File, f Filter, export bool) bool {</code></span>
<span class="codeline" id="line-263"><code>	j := 0</code></span>
<span class="codeline" id="line-264"><code>	for _, d := range src.Decls {</code></span>
<span class="codeline" id="line-265"><code>		if filterDecl(d, f, export) {</code></span>
<span class="codeline" id="line-266"><code>			src.Decls[j] = d</code></span>
<span class="codeline" id="line-267"><code>			j++</code></span>
<span class="codeline" id="line-268"><code>		}</code></span>
<span class="codeline" id="line-269"><code>	}</code></span>
<span class="codeline" id="line-270"><code>	src.Decls = src.Decls[0:j]</code></span>
<span class="codeline" id="line-271"><code>	return j &gt; 0</code></span>
<span class="codeline" id="line-272"><code>}</code></span>
<span class="codeline" id="line-273"><code></code></span>
<span class="codeline" id="line-274"><code>// FilterPackage trims the AST for a Go package in place by removing</code></span>
<span class="codeline" id="line-275"><code>// all names from top-level declarations (including struct field and</code></span>
<span class="codeline" id="line-276"><code>// interface method names, but not from parameter lists) that don't</code></span>
<span class="codeline" id="line-277"><code>// pass through the filter f. If the declaration is empty afterwards,</code></span>
<span class="codeline" id="line-278"><code>// the declaration is removed from the AST. The pkg.Files list is not</code></span>
<span class="codeline" id="line-279"><code>// changed, so that file names and top-level package comments don't get</code></span>
<span class="codeline" id="line-280"><code>// lost.</code></span>
<span class="codeline" id="line-281"><code>//</code></span>
<span class="codeline" id="line-282"><code>// FilterPackage reports whether there are any top-level declarations</code></span>
<span class="codeline" id="line-283"><code>// left after filtering.</code></span>
<span class="codeline" id="line-284"><code>//</code></span>
<span class="codeline" id="line-285"><code>func FilterPackage(pkg *Package, f Filter) bool {</code></span>
<span class="codeline" id="line-286"><code>	return filterPackage(pkg, f, false)</code></span>
<span class="codeline" id="line-287"><code>}</code></span>
<span class="codeline" id="line-288"><code></code></span>
<span class="codeline" id="line-289"><code>func filterPackage(pkg *Package, f Filter, export bool) bool {</code></span>
<span class="codeline" id="line-290"><code>	hasDecls := false</code></span>
<span class="codeline" id="line-291"><code>	for _, src := range pkg.Files {</code></span>
<span class="codeline" id="line-292"><code>		if filterFile(src, f, export) {</code></span>
<span class="codeline" id="line-293"><code>			hasDecls = true</code></span>
<span class="codeline" id="line-294"><code>		}</code></span>
<span class="codeline" id="line-295"><code>	}</code></span>
<span class="codeline" id="line-296"><code>	return hasDecls</code></span>
<span class="codeline" id="line-297"><code>}</code></span>
<span class="codeline" id="line-298"><code></code></span>
<span class="codeline" id="line-299"><code>// ----------------------------------------------------------------------------</code></span>
<span class="codeline" id="line-300"><code>// Merging of package files</code></span>
<span class="codeline" id="line-301"><code></code></span>
<span class="codeline" id="line-302"><code>// The MergeMode flags control the behavior of MergePackageFiles.</code></span>
<span class="codeline" id="line-303"><code>type MergeMode uint</code></span>
<span class="codeline" id="line-304"><code></code></span>
<span class="codeline" id="line-305"><code>const (</code></span>
<span class="codeline" id="line-306"><code>	// If set, duplicate function declarations are excluded.</code></span>
<span class="codeline" id="line-307"><code>	FilterFuncDuplicates MergeMode = 1 &lt;&lt; iota</code></span>
<span class="codeline" id="line-308"><code>	// If set, comments that are not associated with a specific</code></span>
<span class="codeline" id="line-309"><code>	// AST node (as Doc or Comment) are excluded.</code></span>
<span class="codeline" id="line-310"><code>	FilterUnassociatedComments</code></span>
<span class="codeline" id="line-311"><code>	// If set, duplicate import declarations are excluded.</code></span>
<span class="codeline" id="line-312"><code>	FilterImportDuplicates</code></span>
<span class="codeline" id="line-313"><code>)</code></span>
<span class="codeline" id="line-314"><code></code></span>
<span class="codeline" id="line-315"><code>// nameOf returns the function (foo) or method name (foo.bar) for</code></span>
<span class="codeline" id="line-316"><code>// the given function declaration. If the AST is incorrect for the</code></span>
<span class="codeline" id="line-317"><code>// receiver, it assumes a function instead.</code></span>
<span class="codeline" id="line-318"><code>//</code></span>
<span class="codeline" id="line-319"><code>func nameOf(f *FuncDecl) string {</code></span>
<span class="codeline" id="line-320"><code>	if r := f.Recv; r != nil &amp;&amp; len(r.List) == 1 {</code></span>
<span class="codeline" id="line-321"><code>		// looks like a correct receiver declaration</code></span>
<span class="codeline" id="line-322"><code>		t := r.List[0].Type</code></span>
<span class="codeline" id="line-323"><code>		// dereference pointer receiver types</code></span>
<span class="codeline" id="line-324"><code>		if p, _ := t.(*StarExpr); p != nil {</code></span>
<span class="codeline" id="line-325"><code>			t = p.X</code></span>
<span class="codeline" id="line-326"><code>		}</code></span>
<span class="codeline" id="line-327"><code>		// the receiver type must be a type name</code></span>
<span class="codeline" id="line-328"><code>		if p, _ := t.(*Ident); p != nil {</code></span>
<span class="codeline" id="line-329"><code>			return p.Name + "." + f.Name.Name</code></span>
<span class="codeline" id="line-330"><code>		}</code></span>
<span class="codeline" id="line-331"><code>		// otherwise assume a function instead</code></span>
<span class="codeline" id="line-332"><code>	}</code></span>
<span class="codeline" id="line-333"><code>	return f.Name.Name</code></span>
<span class="codeline" id="line-334"><code>}</code></span>
<span class="codeline" id="line-335"><code></code></span>
<span class="codeline" id="line-336"><code>// separator is an empty //-style comment that is interspersed between</code></span>
<span class="codeline" id="line-337"><code>// different comment groups when they are concatenated into a single group</code></span>
<span class="codeline" id="line-338"><code>//</code></span>
<span class="codeline" id="line-339"><code>var separator = &amp;Comment{token.NoPos, "//"}</code></span>
<span class="codeline" id="line-340"><code></code></span>
<span class="codeline" id="line-341"><code>// MergePackageFiles creates a file AST by merging the ASTs of the</code></span>
<span class="codeline" id="line-342"><code>// files belonging to a package. The mode flags control merging behavior.</code></span>
<span class="codeline" id="line-343"><code>//</code></span>
<span class="codeline" id="line-344"><code>func MergePackageFiles(pkg *Package, mode MergeMode) *File {</code></span>
<span class="codeline" id="line-345"><code>	// Count the number of package docs, comments and declarations across</code></span>
<span class="codeline" id="line-346"><code>	// all package files. Also, compute sorted list of filenames, so that</code></span>
<span class="codeline" id="line-347"><code>	// subsequent iterations can always iterate in the same order.</code></span>
<span class="codeline" id="line-348"><code>	ndocs := 0</code></span>
<span class="codeline" id="line-349"><code>	ncomments := 0</code></span>
<span class="codeline" id="line-350"><code>	ndecls := 0</code></span>
<span class="codeline" id="line-351"><code>	filenames := make([]string, len(pkg.Files))</code></span>
<span class="codeline" id="line-352"><code>	i := 0</code></span>
<span class="codeline" id="line-353"><code>	for filename, f := range pkg.Files {</code></span>
<span class="codeline" id="line-354"><code>		filenames[i] = filename</code></span>
<span class="codeline" id="line-355"><code>		i++</code></span>
<span class="codeline" id="line-356"><code>		if f.Doc != nil {</code></span>
<span class="codeline" id="line-357"><code>			ndocs += len(f.Doc.List) + 1 // +1 for separator</code></span>
<span class="codeline" id="line-358"><code>		}</code></span>
<span class="codeline" id="line-359"><code>		ncomments += len(f.Comments)</code></span>
<span class="codeline" id="line-360"><code>		ndecls += len(f.Decls)</code></span>
<span class="codeline" id="line-361"><code>	}</code></span>
<span class="codeline" id="line-362"><code>	sort.Strings(filenames)</code></span>
<span class="codeline" id="line-363"><code></code></span>
<span class="codeline" id="line-364"><code>	// Collect package comments from all package files into a single</code></span>
<span class="codeline" id="line-365"><code>	// CommentGroup - the collected package documentation. In general</code></span>
<span class="codeline" id="line-366"><code>	// there should be only one file with a package comment; but it's</code></span>
<span class="codeline" id="line-367"><code>	// better to collect extra comments than drop them on the floor.</code></span>
<span class="codeline" id="line-368"><code>	var doc *CommentGroup</code></span>
<span class="codeline" id="line-369"><code>	var pos token.Pos</code></span>
<span class="codeline" id="line-370"><code>	if ndocs &gt; 0 {</code></span>
<span class="codeline" id="line-371"><code>		list := make([]*Comment, ndocs-1) // -1: no separator before first group</code></span>
<span class="codeline" id="line-372"><code>		i := 0</code></span>
<span class="codeline" id="line-373"><code>		for _, filename := range filenames {</code></span>
<span class="codeline" id="line-374"><code>			f := pkg.Files[filename]</code></span>
<span class="codeline" id="line-375"><code>			if f.Doc != nil {</code></span>
<span class="codeline" id="line-376"><code>				if i &gt; 0 {</code></span>
<span class="codeline" id="line-377"><code>					// not the first group - add separator</code></span>
<span class="codeline" id="line-378"><code>					list[i] = separator</code></span>
<span class="codeline" id="line-379"><code>					i++</code></span>
<span class="codeline" id="line-380"><code>				}</code></span>
<span class="codeline" id="line-381"><code>				for _, c := range f.Doc.List {</code></span>
<span class="codeline" id="line-382"><code>					list[i] = c</code></span>
<span class="codeline" id="line-383"><code>					i++</code></span>
<span class="codeline" id="line-384"><code>				}</code></span>
<span class="codeline" id="line-385"><code>				if f.Package &gt; pos {</code></span>
<span class="codeline" id="line-386"><code>					// Keep the maximum package clause position as</code></span>
<span class="codeline" id="line-387"><code>					// position for the package clause of the merged</code></span>
<span class="codeline" id="line-388"><code>					// files.</code></span>
<span class="codeline" id="line-389"><code>					pos = f.Package</code></span>
<span class="codeline" id="line-390"><code>				}</code></span>
<span class="codeline" id="line-391"><code>			}</code></span>
<span class="codeline" id="line-392"><code>		}</code></span>
<span class="codeline" id="line-393"><code>		doc = &amp;CommentGroup{list}</code></span>
<span class="codeline" id="line-394"><code>	}</code></span>
<span class="codeline" id="line-395"><code></code></span>
<span class="codeline" id="line-396"><code>	// Collect declarations from all package files.</code></span>
<span class="codeline" id="line-397"><code>	var decls []Decl</code></span>
<span class="codeline" id="line-398"><code>	if ndecls &gt; 0 {</code></span>
<span class="codeline" id="line-399"><code>		decls = make([]Decl, ndecls)</code></span>
<span class="codeline" id="line-400"><code>		funcs := make(map[string]int) // map of func name -&gt; decls index</code></span>
<span class="codeline" id="line-401"><code>		i := 0                        // current index</code></span>
<span class="codeline" id="line-402"><code>		n := 0                        // number of filtered entries</code></span>
<span class="codeline" id="line-403"><code>		for _, filename := range filenames {</code></span>
<span class="codeline" id="line-404"><code>			f := pkg.Files[filename]</code></span>
<span class="codeline" id="line-405"><code>			for _, d := range f.Decls {</code></span>
<span class="codeline" id="line-406"><code>				if mode&amp;FilterFuncDuplicates != 0 {</code></span>
<span class="codeline" id="line-407"><code>					// A language entity may be declared multiple</code></span>
<span class="codeline" id="line-408"><code>					// times in different package files; only at</code></span>
<span class="codeline" id="line-409"><code>					// build time declarations must be unique.</code></span>
<span class="codeline" id="line-410"><code>					// For now, exclude multiple declarations of</code></span>
<span class="codeline" id="line-411"><code>					// functions - keep the one with documentation.</code></span>
<span class="codeline" id="line-412"><code>					//</code></span>
<span class="codeline" id="line-413"><code>					// TODO(gri): Expand this filtering to other</code></span>
<span class="codeline" id="line-414"><code>					//            entities (const, type, vars) if</code></span>
<span class="codeline" id="line-415"><code>					//            multiple declarations are common.</code></span>
<span class="codeline" id="line-416"><code>					if f, isFun := d.(*FuncDecl); isFun {</code></span>
<span class="codeline" id="line-417"><code>						name := nameOf(f)</code></span>
<span class="codeline" id="line-418"><code>						if j, exists := funcs[name]; exists {</code></span>
<span class="codeline" id="line-419"><code>							// function declared already</code></span>
<span class="codeline" id="line-420"><code>							if decls[j] != nil &amp;&amp; decls[j].(*FuncDecl).Doc == nil {</code></span>
<span class="codeline" id="line-421"><code>								// existing declaration has no documentation;</code></span>
<span class="codeline" id="line-422"><code>								// ignore the existing declaration</code></span>
<span class="codeline" id="line-423"><code>								decls[j] = nil</code></span>
<span class="codeline" id="line-424"><code>							} else {</code></span>
<span class="codeline" id="line-425"><code>								// ignore the new declaration</code></span>
<span class="codeline" id="line-426"><code>								d = nil</code></span>
<span class="codeline" id="line-427"><code>							}</code></span>
<span class="codeline" id="line-428"><code>							n++ // filtered an entry</code></span>
<span class="codeline" id="line-429"><code>						} else {</code></span>
<span class="codeline" id="line-430"><code>							funcs[name] = i</code></span>
<span class="codeline" id="line-431"><code>						}</code></span>
<span class="codeline" id="line-432"><code>					}</code></span>
<span class="codeline" id="line-433"><code>				}</code></span>
<span class="codeline" id="line-434"><code>				decls[i] = d</code></span>
<span class="codeline" id="line-435"><code>				i++</code></span>
<span class="codeline" id="line-436"><code>			}</code></span>
<span class="codeline" id="line-437"><code>		}</code></span>
<span class="codeline" id="line-438"><code></code></span>
<span class="codeline" id="line-439"><code>		// Eliminate nil entries from the decls list if entries were</code></span>
<span class="codeline" id="line-440"><code>		// filtered. We do this using a 2nd pass in order to not disturb</code></span>
<span class="codeline" id="line-441"><code>		// the original declaration order in the source (otherwise, this</code></span>
<span class="codeline" id="line-442"><code>		// would also invalidate the monotonically increasing position</code></span>
<span class="codeline" id="line-443"><code>		// info within a single file).</code></span>
<span class="codeline" id="line-444"><code>		if n &gt; 0 {</code></span>
<span class="codeline" id="line-445"><code>			i = 0</code></span>
<span class="codeline" id="line-446"><code>			for _, d := range decls {</code></span>
<span class="codeline" id="line-447"><code>				if d != nil {</code></span>
<span class="codeline" id="line-448"><code>					decls[i] = d</code></span>
<span class="codeline" id="line-449"><code>					i++</code></span>
<span class="codeline" id="line-450"><code>				}</code></span>
<span class="codeline" id="line-451"><code>			}</code></span>
<span class="codeline" id="line-452"><code>			decls = decls[0:i]</code></span>
<span class="codeline" id="line-453"><code>		}</code></span>
<span class="codeline" id="line-454"><code>	}</code></span>
<span class="codeline" id="line-455"><code></code></span>
<span class="codeline" id="line-456"><code>	// Collect import specs from all package files.</code></span>
<span class="codeline" id="line-457"><code>	var imports []*ImportSpec</code></span>
<span class="codeline" id="line-458"><code>	if mode&amp;FilterImportDuplicates != 0 {</code></span>
<span class="codeline" id="line-459"><code>		seen := make(map[string]bool)</code></span>
<span class="codeline" id="line-460"><code>		for _, filename := range filenames {</code></span>
<span class="codeline" id="line-461"><code>			f := pkg.Files[filename]</code></span>
<span class="codeline" id="line-462"><code>			for _, imp := range f.Imports {</code></span>
<span class="codeline" id="line-463"><code>				if path := imp.Path.Value; !seen[path] {</code></span>
<span class="codeline" id="line-464"><code>					// TODO: consider handling cases where:</code></span>
<span class="codeline" id="line-465"><code>					// - 2 imports exist with the same import path but</code></span>
<span class="codeline" id="line-466"><code>					//   have different local names (one should probably</code></span>
<span class="codeline" id="line-467"><code>					//   keep both of them)</code></span>
<span class="codeline" id="line-468"><code>					// - 2 imports exist but only one has a comment</code></span>
<span class="codeline" id="line-469"><code>					// - 2 imports exist and they both have (possibly</code></span>
<span class="codeline" id="line-470"><code>					//   different) comments</code></span>
<span class="codeline" id="line-471"><code>					imports = append(imports, imp)</code></span>
<span class="codeline" id="line-472"><code>					seen[path] = true</code></span>
<span class="codeline" id="line-473"><code>				}</code></span>
<span class="codeline" id="line-474"><code>			}</code></span>
<span class="codeline" id="line-475"><code>		}</code></span>
<span class="codeline" id="line-476"><code>	} else {</code></span>
<span class="codeline" id="line-477"><code>		// Iterate over filenames for deterministic order.</code></span>
<span class="codeline" id="line-478"><code>		for _, filename := range filenames {</code></span>
<span class="codeline" id="line-479"><code>			f := pkg.Files[filename]</code></span>
<span class="codeline" id="line-480"><code>			imports = append(imports, f.Imports...)</code></span>
<span class="codeline" id="line-481"><code>		}</code></span>
<span class="codeline" id="line-482"><code>	}</code></span>
<span class="codeline" id="line-483"><code></code></span>
<span class="codeline" id="line-484"><code>	// Collect comments from all package files.</code></span>
<span class="codeline" id="line-485"><code>	var comments []*CommentGroup</code></span>
<span class="codeline" id="line-486"><code>	if mode&amp;FilterUnassociatedComments == 0 {</code></span>
<span class="codeline" id="line-487"><code>		comments = make([]*CommentGroup, ncomments)</code></span>
<span class="codeline" id="line-488"><code>		i := 0</code></span>
<span class="codeline" id="line-489"><code>		for _, filename := range filenames {</code></span>
<span class="codeline" id="line-490"><code>			f := pkg.Files[filename]</code></span>
<span class="codeline" id="line-491"><code>			i += copy(comments[i:], f.Comments)</code></span>
<span class="codeline" id="line-492"><code>		}</code></span>
<span class="codeline" id="line-493"><code>	}</code></span>
<span class="codeline" id="line-494"><code></code></span>
<span class="codeline" id="line-495"><code>	// TODO(gri) need to compute unresolved identifiers!</code></span>
<span class="codeline" id="line-496"><code>	return &amp;File{doc, pos, NewIdent(pkg.Name), decls, pkg.Scope, imports, nil, comments}</code></span>
<span class="codeline" id="line-497"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.1.6</i>. (GOOS=darwin GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project and developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table
</pre>
</div></body></html>