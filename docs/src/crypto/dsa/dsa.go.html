<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: dsa.go in package crypto/dsa</title>
<link href="../../../css/light-v0.1.6.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.1.6.js"></script>
<body><div>

<pre id="header"><code><span class="title">Source File</span>
	dsa.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/crypto/dsa.html">crypto/dsa</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2011 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>// Package dsa implements the Digital Signature Algorithm, as defined in FIPS 186-3.</code></span>
<span class="codeline" id="line-6"><code>//</code></span>
<span class="codeline" id="line-7"><code>// The DSA operations in this package are not implemented using constant-time algorithms.</code></span></div><span class="codeline" id="line-8"><code>package dsa</code></span>
<span class="codeline" id="line-9"><code></code></span>
<span class="codeline" id="line-10"><code>import (</code></span>
<span class="codeline" id="line-11"><code>	"errors"</code></span>
<span class="codeline" id="line-12"><code>	"io"</code></span>
<span class="codeline" id="line-13"><code>	"math/big"</code></span>
<span class="codeline" id="line-14"><code></code></span>
<span class="codeline" id="line-15"><code>	"crypto/internal/randutil"</code></span>
<span class="codeline" id="line-16"><code>)</code></span>
<span class="codeline" id="line-17"><code></code></span>
<span class="codeline" id="line-18"><code>// Parameters represents the domain parameters for a key. These parameters can</code></span>
<span class="codeline" id="line-19"><code>// be shared across many keys. The bit length of Q must be a multiple of 8.</code></span>
<span class="codeline" id="line-20"><code>type Parameters struct {</code></span>
<span class="codeline" id="line-21"><code>	P, Q, G *big.Int</code></span>
<span class="codeline" id="line-22"><code>}</code></span>
<span class="codeline" id="line-23"><code></code></span>
<span class="codeline" id="line-24"><code>// PublicKey represents a DSA public key.</code></span>
<span class="codeline" id="line-25"><code>type PublicKey struct {</code></span>
<span class="codeline" id="line-26"><code>	Parameters</code></span>
<span class="codeline" id="line-27"><code>	Y *big.Int</code></span>
<span class="codeline" id="line-28"><code>}</code></span>
<span class="codeline" id="line-29"><code></code></span>
<span class="codeline" id="line-30"><code>// PrivateKey represents a DSA private key.</code></span>
<span class="codeline" id="line-31"><code>type PrivateKey struct {</code></span>
<span class="codeline" id="line-32"><code>	PublicKey</code></span>
<span class="codeline" id="line-33"><code>	X *big.Int</code></span>
<span class="codeline" id="line-34"><code>}</code></span>
<span class="codeline" id="line-35"><code></code></span>
<span class="codeline" id="line-36"><code>// ErrInvalidPublicKey results when a public key is not usable by this code.</code></span>
<span class="codeline" id="line-37"><code>// FIPS is quite strict about the format of DSA keys, but other code may be</code></span>
<span class="codeline" id="line-38"><code>// less so. Thus, when using keys which may have been generated by other code,</code></span>
<span class="codeline" id="line-39"><code>// this error must be handled.</code></span>
<span class="codeline" id="line-40"><code>var ErrInvalidPublicKey = errors.New("crypto/dsa: invalid public key")</code></span>
<span class="codeline" id="line-41"><code></code></span>
<span class="codeline" id="line-42"><code>// ParameterSizes is an enumeration of the acceptable bit lengths of the primes</code></span>
<span class="codeline" id="line-43"><code>// in a set of DSA parameters. See FIPS 186-3, section 4.2.</code></span>
<span class="codeline" id="line-44"><code>type ParameterSizes int</code></span>
<span class="codeline" id="line-45"><code></code></span>
<span class="codeline" id="line-46"><code>const (</code></span>
<span class="codeline" id="line-47"><code>	L1024N160 ParameterSizes = iota</code></span>
<span class="codeline" id="line-48"><code>	L2048N224</code></span>
<span class="codeline" id="line-49"><code>	L2048N256</code></span>
<span class="codeline" id="line-50"><code>	L3072N256</code></span>
<span class="codeline" id="line-51"><code>)</code></span>
<span class="codeline" id="line-52"><code></code></span>
<span class="codeline" id="line-53"><code>// numMRTests is the number of Miller-Rabin primality tests that we perform. We</code></span>
<span class="codeline" id="line-54"><code>// pick the largest recommended number from table C.1 of FIPS 186-3.</code></span>
<span class="codeline" id="line-55"><code>const numMRTests = 64</code></span>
<span class="codeline" id="line-56"><code></code></span>
<span class="codeline" id="line-57"><code>// GenerateParameters puts a random, valid set of DSA parameters into params.</code></span>
<span class="codeline" id="line-58"><code>// This function can take many seconds, even on fast machines.</code></span>
<span class="codeline" id="line-59"><code>func GenerateParameters(params *Parameters, rand io.Reader, sizes ParameterSizes) error {</code></span>
<span class="codeline" id="line-60"><code>	// This function doesn't follow FIPS 186-3 exactly in that it doesn't</code></span>
<span class="codeline" id="line-61"><code>	// use a verification seed to generate the primes. The verification</code></span>
<span class="codeline" id="line-62"><code>	// seed doesn't appear to be exported or used by other code and</code></span>
<span class="codeline" id="line-63"><code>	// omitting it makes the code cleaner.</code></span>
<span class="codeline" id="line-64"><code></code></span>
<span class="codeline" id="line-65"><code>	var L, N int</code></span>
<span class="codeline" id="line-66"><code>	switch sizes {</code></span>
<span class="codeline" id="line-67"><code>	case L1024N160:</code></span>
<span class="codeline" id="line-68"><code>		L = 1024</code></span>
<span class="codeline" id="line-69"><code>		N = 160</code></span>
<span class="codeline" id="line-70"><code>	case L2048N224:</code></span>
<span class="codeline" id="line-71"><code>		L = 2048</code></span>
<span class="codeline" id="line-72"><code>		N = 224</code></span>
<span class="codeline" id="line-73"><code>	case L2048N256:</code></span>
<span class="codeline" id="line-74"><code>		L = 2048</code></span>
<span class="codeline" id="line-75"><code>		N = 256</code></span>
<span class="codeline" id="line-76"><code>	case L3072N256:</code></span>
<span class="codeline" id="line-77"><code>		L = 3072</code></span>
<span class="codeline" id="line-78"><code>		N = 256</code></span>
<span class="codeline" id="line-79"><code>	default:</code></span>
<span class="codeline" id="line-80"><code>		return errors.New("crypto/dsa: invalid ParameterSizes")</code></span>
<span class="codeline" id="line-81"><code>	}</code></span>
<span class="codeline" id="line-82"><code></code></span>
<span class="codeline" id="line-83"><code>	qBytes := make([]byte, N/8)</code></span>
<span class="codeline" id="line-84"><code>	pBytes := make([]byte, L/8)</code></span>
<span class="codeline" id="line-85"><code></code></span>
<span class="codeline" id="line-86"><code>	q := new(big.Int)</code></span>
<span class="codeline" id="line-87"><code>	p := new(big.Int)</code></span>
<span class="codeline" id="line-88"><code>	rem := new(big.Int)</code></span>
<span class="codeline" id="line-89"><code>	one := new(big.Int)</code></span>
<span class="codeline" id="line-90"><code>	one.SetInt64(1)</code></span>
<span class="codeline" id="line-91"><code></code></span>
<span class="codeline" id="line-92"><code>GeneratePrimes:</code></span>
<span class="codeline" id="line-93"><code>	for {</code></span>
<span class="codeline" id="line-94"><code>		if _, err := io.ReadFull(rand, qBytes); err != nil {</code></span>
<span class="codeline" id="line-95"><code>			return err</code></span>
<span class="codeline" id="line-96"><code>		}</code></span>
<span class="codeline" id="line-97"><code></code></span>
<span class="codeline" id="line-98"><code>		qBytes[len(qBytes)-1] |= 1</code></span>
<span class="codeline" id="line-99"><code>		qBytes[0] |= 0x80</code></span>
<span class="codeline" id="line-100"><code>		q.SetBytes(qBytes)</code></span>
<span class="codeline" id="line-101"><code></code></span>
<span class="codeline" id="line-102"><code>		if !q.ProbablyPrime(numMRTests) {</code></span>
<span class="codeline" id="line-103"><code>			continue</code></span>
<span class="codeline" id="line-104"><code>		}</code></span>
<span class="codeline" id="line-105"><code></code></span>
<span class="codeline" id="line-106"><code>		for i := 0; i &lt; 4*L; i++ {</code></span>
<span class="codeline" id="line-107"><code>			if _, err := io.ReadFull(rand, pBytes); err != nil {</code></span>
<span class="codeline" id="line-108"><code>				return err</code></span>
<span class="codeline" id="line-109"><code>			}</code></span>
<span class="codeline" id="line-110"><code></code></span>
<span class="codeline" id="line-111"><code>			pBytes[len(pBytes)-1] |= 1</code></span>
<span class="codeline" id="line-112"><code>			pBytes[0] |= 0x80</code></span>
<span class="codeline" id="line-113"><code></code></span>
<span class="codeline" id="line-114"><code>			p.SetBytes(pBytes)</code></span>
<span class="codeline" id="line-115"><code>			rem.Mod(p, q)</code></span>
<span class="codeline" id="line-116"><code>			rem.Sub(rem, one)</code></span>
<span class="codeline" id="line-117"><code>			p.Sub(p, rem)</code></span>
<span class="codeline" id="line-118"><code>			if p.BitLen() &lt; L {</code></span>
<span class="codeline" id="line-119"><code>				continue</code></span>
<span class="codeline" id="line-120"><code>			}</code></span>
<span class="codeline" id="line-121"><code></code></span>
<span class="codeline" id="line-122"><code>			if !p.ProbablyPrime(numMRTests) {</code></span>
<span class="codeline" id="line-123"><code>				continue</code></span>
<span class="codeline" id="line-124"><code>			}</code></span>
<span class="codeline" id="line-125"><code></code></span>
<span class="codeline" id="line-126"><code>			params.P = p</code></span>
<span class="codeline" id="line-127"><code>			params.Q = q</code></span>
<span class="codeline" id="line-128"><code>			break GeneratePrimes</code></span>
<span class="codeline" id="line-129"><code>		}</code></span>
<span class="codeline" id="line-130"><code>	}</code></span>
<span class="codeline" id="line-131"><code></code></span>
<span class="codeline" id="line-132"><code>	h := new(big.Int)</code></span>
<span class="codeline" id="line-133"><code>	h.SetInt64(2)</code></span>
<span class="codeline" id="line-134"><code>	g := new(big.Int)</code></span>
<span class="codeline" id="line-135"><code></code></span>
<span class="codeline" id="line-136"><code>	pm1 := new(big.Int).Sub(p, one)</code></span>
<span class="codeline" id="line-137"><code>	e := new(big.Int).Div(pm1, q)</code></span>
<span class="codeline" id="line-138"><code></code></span>
<span class="codeline" id="line-139"><code>	for {</code></span>
<span class="codeline" id="line-140"><code>		g.Exp(h, e, p)</code></span>
<span class="codeline" id="line-141"><code>		if g.Cmp(one) == 0 {</code></span>
<span class="codeline" id="line-142"><code>			h.Add(h, one)</code></span>
<span class="codeline" id="line-143"><code>			continue</code></span>
<span class="codeline" id="line-144"><code>		}</code></span>
<span class="codeline" id="line-145"><code></code></span>
<span class="codeline" id="line-146"><code>		params.G = g</code></span>
<span class="codeline" id="line-147"><code>		return nil</code></span>
<span class="codeline" id="line-148"><code>	}</code></span>
<span class="codeline" id="line-149"><code>}</code></span>
<span class="codeline" id="line-150"><code></code></span>
<span class="codeline" id="line-151"><code>// GenerateKey generates a public&amp;private key pair. The Parameters of the</code></span>
<span class="codeline" id="line-152"><code>// PrivateKey must already be valid (see GenerateParameters).</code></span>
<span class="codeline" id="line-153"><code>func GenerateKey(priv *PrivateKey, rand io.Reader) error {</code></span>
<span class="codeline" id="line-154"><code>	if priv.P == nil || priv.Q == nil || priv.G == nil {</code></span>
<span class="codeline" id="line-155"><code>		return errors.New("crypto/dsa: parameters not set up before generating key")</code></span>
<span class="codeline" id="line-156"><code>	}</code></span>
<span class="codeline" id="line-157"><code></code></span>
<span class="codeline" id="line-158"><code>	x := new(big.Int)</code></span>
<span class="codeline" id="line-159"><code>	xBytes := make([]byte, priv.Q.BitLen()/8)</code></span>
<span class="codeline" id="line-160"><code></code></span>
<span class="codeline" id="line-161"><code>	for {</code></span>
<span class="codeline" id="line-162"><code>		_, err := io.ReadFull(rand, xBytes)</code></span>
<span class="codeline" id="line-163"><code>		if err != nil {</code></span>
<span class="codeline" id="line-164"><code>			return err</code></span>
<span class="codeline" id="line-165"><code>		}</code></span>
<span class="codeline" id="line-166"><code>		x.SetBytes(xBytes)</code></span>
<span class="codeline" id="line-167"><code>		if x.Sign() != 0 &amp;&amp; x.Cmp(priv.Q) &lt; 0 {</code></span>
<span class="codeline" id="line-168"><code>			break</code></span>
<span class="codeline" id="line-169"><code>		}</code></span>
<span class="codeline" id="line-170"><code>	}</code></span>
<span class="codeline" id="line-171"><code></code></span>
<span class="codeline" id="line-172"><code>	priv.X = x</code></span>
<span class="codeline" id="line-173"><code>	priv.Y = new(big.Int)</code></span>
<span class="codeline" id="line-174"><code>	priv.Y.Exp(priv.G, x, priv.P)</code></span>
<span class="codeline" id="line-175"><code>	return nil</code></span>
<span class="codeline" id="line-176"><code>}</code></span>
<span class="codeline" id="line-177"><code></code></span>
<span class="codeline" id="line-178"><code>// fermatInverse calculates the inverse of k in GF(P) using Fermat's method.</code></span>
<span class="codeline" id="line-179"><code>// This has better constant-time properties than Euclid's method (implemented</code></span>
<span class="codeline" id="line-180"><code>// in math/big.Int.ModInverse) although math/big itself isn't strictly</code></span>
<span class="codeline" id="line-181"><code>// constant-time so it's not perfect.</code></span>
<span class="codeline" id="line-182"><code>func fermatInverse(k, P *big.Int) *big.Int {</code></span>
<span class="codeline" id="line-183"><code>	two := big.NewInt(2)</code></span>
<span class="codeline" id="line-184"><code>	pMinus2 := new(big.Int).Sub(P, two)</code></span>
<span class="codeline" id="line-185"><code>	return new(big.Int).Exp(k, pMinus2, P)</code></span>
<span class="codeline" id="line-186"><code>}</code></span>
<span class="codeline" id="line-187"><code></code></span>
<span class="codeline" id="line-188"><code>// Sign signs an arbitrary length hash (which should be the result of hashing a</code></span>
<span class="codeline" id="line-189"><code>// larger message) using the private key, priv. It returns the signature as a</code></span>
<span class="codeline" id="line-190"><code>// pair of integers. The security of the private key depends on the entropy of</code></span>
<span class="codeline" id="line-191"><code>// rand.</code></span>
<span class="codeline" id="line-192"><code>//</code></span>
<span class="codeline" id="line-193"><code>// Note that FIPS 186-3 section 4.6 specifies that the hash should be truncated</code></span>
<span class="codeline" id="line-194"><code>// to the byte-length of the subgroup. This function does not perform that</code></span>
<span class="codeline" id="line-195"><code>// truncation itself.</code></span>
<span class="codeline" id="line-196"><code>//</code></span>
<span class="codeline" id="line-197"><code>// Be aware that calling Sign with an attacker-controlled PrivateKey may</code></span>
<span class="codeline" id="line-198"><code>// require an arbitrary amount of CPU.</code></span>
<span class="codeline" id="line-199"><code>func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error) {</code></span>
<span class="codeline" id="line-200"><code>	randutil.MaybeReadByte(rand)</code></span>
<span class="codeline" id="line-201"><code></code></span>
<span class="codeline" id="line-202"><code>	// FIPS 186-3, section 4.6</code></span>
<span class="codeline" id="line-203"><code></code></span>
<span class="codeline" id="line-204"><code>	n := priv.Q.BitLen()</code></span>
<span class="codeline" id="line-205"><code>	if priv.Q.Sign() &lt;= 0 || priv.P.Sign() &lt;= 0 || priv.G.Sign() &lt;= 0 || priv.X.Sign() &lt;= 0 || n%8 != 0 {</code></span>
<span class="codeline" id="line-206"><code>		err = ErrInvalidPublicKey</code></span>
<span class="codeline" id="line-207"><code>		return</code></span>
<span class="codeline" id="line-208"><code>	}</code></span>
<span class="codeline" id="line-209"><code>	n &gt;&gt;= 3</code></span>
<span class="codeline" id="line-210"><code></code></span>
<span class="codeline" id="line-211"><code>	var attempts int</code></span>
<span class="codeline" id="line-212"><code>	for attempts = 10; attempts &gt; 0; attempts-- {</code></span>
<span class="codeline" id="line-213"><code>		k := new(big.Int)</code></span>
<span class="codeline" id="line-214"><code>		buf := make([]byte, n)</code></span>
<span class="codeline" id="line-215"><code>		for {</code></span>
<span class="codeline" id="line-216"><code>			_, err = io.ReadFull(rand, buf)</code></span>
<span class="codeline" id="line-217"><code>			if err != nil {</code></span>
<span class="codeline" id="line-218"><code>				return</code></span>
<span class="codeline" id="line-219"><code>			}</code></span>
<span class="codeline" id="line-220"><code>			k.SetBytes(buf)</code></span>
<span class="codeline" id="line-221"><code>			// priv.Q must be &gt;= 128 because the test above</code></span>
<span class="codeline" id="line-222"><code>			// requires it to be &gt; 0 and that</code></span>
<span class="codeline" id="line-223"><code>			//    ceil(log_2(Q)) mod 8 = 0</code></span>
<span class="codeline" id="line-224"><code>			// Thus this loop will quickly terminate.</code></span>
<span class="codeline" id="line-225"><code>			if k.Sign() &gt; 0 &amp;&amp; k.Cmp(priv.Q) &lt; 0 {</code></span>
<span class="codeline" id="line-226"><code>				break</code></span>
<span class="codeline" id="line-227"><code>			}</code></span>
<span class="codeline" id="line-228"><code>		}</code></span>
<span class="codeline" id="line-229"><code></code></span>
<span class="codeline" id="line-230"><code>		kInv := fermatInverse(k, priv.Q)</code></span>
<span class="codeline" id="line-231"><code></code></span>
<span class="codeline" id="line-232"><code>		r = new(big.Int).Exp(priv.G, k, priv.P)</code></span>
<span class="codeline" id="line-233"><code>		r.Mod(r, priv.Q)</code></span>
<span class="codeline" id="line-234"><code></code></span>
<span class="codeline" id="line-235"><code>		if r.Sign() == 0 {</code></span>
<span class="codeline" id="line-236"><code>			continue</code></span>
<span class="codeline" id="line-237"><code>		}</code></span>
<span class="codeline" id="line-238"><code></code></span>
<span class="codeline" id="line-239"><code>		z := k.SetBytes(hash)</code></span>
<span class="codeline" id="line-240"><code></code></span>
<span class="codeline" id="line-241"><code>		s = new(big.Int).Mul(priv.X, r)</code></span>
<span class="codeline" id="line-242"><code>		s.Add(s, z)</code></span>
<span class="codeline" id="line-243"><code>		s.Mod(s, priv.Q)</code></span>
<span class="codeline" id="line-244"><code>		s.Mul(s, kInv)</code></span>
<span class="codeline" id="line-245"><code>		s.Mod(s, priv.Q)</code></span>
<span class="codeline" id="line-246"><code></code></span>
<span class="codeline" id="line-247"><code>		if s.Sign() != 0 {</code></span>
<span class="codeline" id="line-248"><code>			break</code></span>
<span class="codeline" id="line-249"><code>		}</code></span>
<span class="codeline" id="line-250"><code>	}</code></span>
<span class="codeline" id="line-251"><code></code></span>
<span class="codeline" id="line-252"><code>	// Only degenerate private keys will require more than a handful of</code></span>
<span class="codeline" id="line-253"><code>	// attempts.</code></span>
<span class="codeline" id="line-254"><code>	if attempts == 0 {</code></span>
<span class="codeline" id="line-255"><code>		return nil, nil, ErrInvalidPublicKey</code></span>
<span class="codeline" id="line-256"><code>	}</code></span>
<span class="codeline" id="line-257"><code></code></span>
<span class="codeline" id="line-258"><code>	return</code></span>
<span class="codeline" id="line-259"><code>}</code></span>
<span class="codeline" id="line-260"><code></code></span>
<span class="codeline" id="line-261"><code>// Verify verifies the signature in r, s of hash using the public key, pub. It</code></span>
<span class="codeline" id="line-262"><code>// reports whether the signature is valid.</code></span>
<span class="codeline" id="line-263"><code>//</code></span>
<span class="codeline" id="line-264"><code>// Note that FIPS 186-3 section 4.6 specifies that the hash should be truncated</code></span>
<span class="codeline" id="line-265"><code>// to the byte-length of the subgroup. This function does not perform that</code></span>
<span class="codeline" id="line-266"><code>// truncation itself.</code></span>
<span class="codeline" id="line-267"><code>func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool {</code></span>
<span class="codeline" id="line-268"><code>	// FIPS 186-3, section 4.7</code></span>
<span class="codeline" id="line-269"><code></code></span>
<span class="codeline" id="line-270"><code>	if pub.P.Sign() == 0 {</code></span>
<span class="codeline" id="line-271"><code>		return false</code></span>
<span class="codeline" id="line-272"><code>	}</code></span>
<span class="codeline" id="line-273"><code></code></span>
<span class="codeline" id="line-274"><code>	if r.Sign() &lt; 1 || r.Cmp(pub.Q) &gt;= 0 {</code></span>
<span class="codeline" id="line-275"><code>		return false</code></span>
<span class="codeline" id="line-276"><code>	}</code></span>
<span class="codeline" id="line-277"><code>	if s.Sign() &lt; 1 || s.Cmp(pub.Q) &gt;= 0 {</code></span>
<span class="codeline" id="line-278"><code>		return false</code></span>
<span class="codeline" id="line-279"><code>	}</code></span>
<span class="codeline" id="line-280"><code></code></span>
<span class="codeline" id="line-281"><code>	w := new(big.Int).ModInverse(s, pub.Q)</code></span>
<span class="codeline" id="line-282"><code>	if w == nil {</code></span>
<span class="codeline" id="line-283"><code>		return false</code></span>
<span class="codeline" id="line-284"><code>	}</code></span>
<span class="codeline" id="line-285"><code></code></span>
<span class="codeline" id="line-286"><code>	n := pub.Q.BitLen()</code></span>
<span class="codeline" id="line-287"><code>	if n%8 != 0 {</code></span>
<span class="codeline" id="line-288"><code>		return false</code></span>
<span class="codeline" id="line-289"><code>	}</code></span>
<span class="codeline" id="line-290"><code>	z := new(big.Int).SetBytes(hash)</code></span>
<span class="codeline" id="line-291"><code></code></span>
<span class="codeline" id="line-292"><code>	u1 := new(big.Int).Mul(z, w)</code></span>
<span class="codeline" id="line-293"><code>	u1.Mod(u1, pub.Q)</code></span>
<span class="codeline" id="line-294"><code>	u2 := w.Mul(r, w)</code></span>
<span class="codeline" id="line-295"><code>	u2.Mod(u2, pub.Q)</code></span>
<span class="codeline" id="line-296"><code>	v := u1.Exp(pub.G, u1, pub.P)</code></span>
<span class="codeline" id="line-297"><code>	u2.Exp(pub.Y, u2, pub.P)</code></span>
<span class="codeline" id="line-298"><code>	v.Mul(v, u2)</code></span>
<span class="codeline" id="line-299"><code>	v.Mod(v, pub.P)</code></span>
<span class="codeline" id="line-300"><code>	v.Mod(v, pub.Q)</code></span>
<span class="codeline" id="line-301"><code></code></span>
<span class="codeline" id="line-302"><code>	return v.Cmp(r) == 0</code></span>
<span class="codeline" id="line-303"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.1.6</i>. (GOOS=darwin GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project and developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table
</pre>
</div></body></html>