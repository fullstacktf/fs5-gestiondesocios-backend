<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: cgo_unix.go in package net</title>
<link href="../../css/light-v0.1.6.css" rel="stylesheet">
<script src="../../jvs/golds-v0.1.6.js"></script>
<body><div>

<pre id="header"><code><span class="title">Source File</span>
	cgo_unix.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/net.html">net</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Code generated by cmd/cgo; DO NOT EDIT.</code></span>
<span class="codeline" id="line-2"><code></code></span>
<span class="codeline" id="line-3"><code>//line /usr/local/go/src/net/cgo_unix.go:1:1</code></span>
<span class="codeline" id="line-4"><code>// Copyright 2011 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-5"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-6"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-7"><code></code></span>
<span class="codeline" id="line-8"><code>// +build cgo,!netgo</code></span>
<span class="codeline" id="line-9"><code>// +build aix darwin dragonfly freebsd linux netbsd openbsd solaris</code></span>
<span class="codeline" id="line-10"><code></code></span>
<span class="codeline" id="line-11"><code>package net</code></span>
<span class="codeline" id="line-12"><code></code></span>
<span class="codeline" id="line-13"><code>/*</code></span>
<span class="codeline" id="line-14"><code>#include &lt;sys/types.h&gt;</code></span>
<span class="codeline" id="line-15"><code>#include &lt;sys/socket.h&gt;</code></span>
<span class="codeline" id="line-16"><code>#include &lt;netinet/in.h&gt;</code></span>
<span class="codeline" id="line-17"><code>#include &lt;netdb.h&gt;</code></span>
<span class="codeline" id="line-18"><code>#include &lt;unistd.h&gt;</code></span>
<span class="codeline" id="line-19"><code>#include &lt;string.h&gt;</code></span>
<span class="codeline" id="line-20"><code></code></span>
<span class="codeline" id="line-21"><code>// If nothing else defined EAI_OVERFLOW, make sure it has a value.</code></span>
<span class="codeline" id="line-22"><code>#ifndef EAI_OVERFLOW</code></span>
<span class="codeline" id="line-23"><code>#define EAI_OVERFLOW -12</code></span>
<span class="codeline" id="line-24"><code>#endif</code></span>
<span class="codeline" id="line-25"><code>*/</code></span>
<span class="codeline" id="line-26"><code>import _ "unsafe"</code></span>
<span class="codeline" id="line-27"><code></code></span>
<span class="codeline" id="line-28"><code>import (</code></span>
<span class="codeline" id="line-29"><code>	"context"</code></span>
<span class="codeline" id="line-30"><code>	"syscall"</code></span>
<span class="codeline" id="line-31"><code>	"unsafe"</code></span>
<span class="codeline" id="line-32"><code>)</code></span>
<span class="codeline" id="line-33"><code></code></span>
<span class="codeline" id="line-34"><code>// An addrinfoErrno represents a getaddrinfo, getnameinfo-specific</code></span>
<span class="codeline" id="line-35"><code>// error number. It's a signed number and a zero value is a non-error</code></span>
<span class="codeline" id="line-36"><code>// by convention.</code></span>
<span class="codeline" id="line-37"><code>type addrinfoErrno int</code></span>
<span class="codeline" id="line-38"><code></code></span>
<span class="codeline" id="line-39"><code>func (eai addrinfoErrno) Error() string   { return ( /*line :36:52*/_Cfunc_GoString /*line :36:61*/)(( /*line :36:63*/_Cfunc_gai_strerror /*line :36:76*/)( /*line :36:78*/_Ctype_int /*line :36:83*/(eai))) }</code></span>
<span class="codeline" id="line-40"><code>func (eai addrinfoErrno) Temporary() bool { return eai == ( /*line :37:59*/_Ciconst_EAI_AGAIN /*line :37:69*/) }</code></span>
<span class="codeline" id="line-41"><code>func (eai addrinfoErrno) Timeout() bool   { return false }</code></span>
<span class="codeline" id="line-42"><code></code></span>
<span class="codeline" id="line-43"><code>type portLookupResult struct {</code></span>
<span class="codeline" id="line-44"><code>	port int</code></span>
<span class="codeline" id="line-45"><code>	err  error</code></span>
<span class="codeline" id="line-46"><code>}</code></span>
<span class="codeline" id="line-47"><code></code></span>
<span class="codeline" id="line-48"><code>type ipLookupResult struct {</code></span>
<span class="codeline" id="line-49"><code>	addrs []IPAddr</code></span>
<span class="codeline" id="line-50"><code>	cname string</code></span>
<span class="codeline" id="line-51"><code>	err   error</code></span>
<span class="codeline" id="line-52"><code>}</code></span>
<span class="codeline" id="line-53"><code></code></span>
<span class="codeline" id="line-54"><code>type reverseLookupResult struct {</code></span>
<span class="codeline" id="line-55"><code>	names []string</code></span>
<span class="codeline" id="line-56"><code>	err   error</code></span>
<span class="codeline" id="line-57"><code>}</code></span>
<span class="codeline" id="line-58"><code></code></span>
<span class="codeline" id="line-59"><code>func cgoLookupHost(ctx context.Context, name string) (hosts []string, err error, completed bool) {</code></span>
<span class="codeline" id="line-60"><code>	addrs, err, completed := cgoLookupIP(ctx, "ip", name)</code></span>
<span class="codeline" id="line-61"><code>	for _, addr := range addrs {</code></span>
<span class="codeline" id="line-62"><code>		hosts = append(hosts, addr.String())</code></span>
<span class="codeline" id="line-63"><code>	}</code></span>
<span class="codeline" id="line-64"><code>	return</code></span>
<span class="codeline" id="line-65"><code>}</code></span>
<span class="codeline" id="line-66"><code></code></span>
<span class="codeline" id="line-67"><code>func cgoLookupPort(ctx context.Context, network, service string) (port int, err error, completed bool) {</code></span>
<span class="codeline" id="line-68"><code>	var hints  /*line :65:12*/_Ctype_struct_addrinfo /*line :65:29*/</code></span>
<span class="codeline" id="line-69"><code>	switch network {</code></span>
<span class="codeline" id="line-70"><code>	case "": // no hints</code></span>
<span class="codeline" id="line-71"><code>	case "tcp", "tcp4", "tcp6":</code></span>
<span class="codeline" id="line-72"><code>		hints.ai_socktype = ( /*line :69:23*/_Ciconst_SOCK_STREAM /*line :69:35*/)</code></span>
<span class="codeline" id="line-73"><code>		hints.ai_protocol = ( /*line :70:23*/_Ciconst_IPPROTO_TCP /*line :70:35*/)</code></span>
<span class="codeline" id="line-74"><code>	case "udp", "udp4", "udp6":</code></span>
<span class="codeline" id="line-75"><code>		hints.ai_socktype = ( /*line :72:23*/_Ciconst_SOCK_DGRAM /*line :72:34*/)</code></span>
<span class="codeline" id="line-76"><code>		hints.ai_protocol = ( /*line :73:23*/_Ciconst_IPPROTO_UDP /*line :73:35*/)</code></span>
<span class="codeline" id="line-77"><code>	default:</code></span>
<span class="codeline" id="line-78"><code>		return 0, &amp;DNSError{Err: "unknown network", Name: network + "/" + service}, true</code></span>
<span class="codeline" id="line-79"><code>	}</code></span>
<span class="codeline" id="line-80"><code>	switch ipVersion(network) {</code></span>
<span class="codeline" id="line-81"><code>	case '4':</code></span>
<span class="codeline" id="line-82"><code>		hints.ai_family = ( /*line :79:21*/_Ciconst_AF_INET /*line :79:29*/)</code></span>
<span class="codeline" id="line-83"><code>	case '6':</code></span>
<span class="codeline" id="line-84"><code>		hints.ai_family = ( /*line :81:21*/_Ciconst_AF_INET6 /*line :81:30*/)</code></span>
<span class="codeline" id="line-85"><code>	}</code></span>
<span class="codeline" id="line-86"><code>	if ctx.Done() == nil {</code></span>
<span class="codeline" id="line-87"><code>		port, err := cgoLookupServicePort(&amp;hints, network, service)</code></span>
<span class="codeline" id="line-88"><code>		return port, err, true</code></span>
<span class="codeline" id="line-89"><code>	}</code></span>
<span class="codeline" id="line-90"><code>	result := make(chan portLookupResult, 1)</code></span>
<span class="codeline" id="line-91"><code>	go cgoPortLookup(result, &amp;hints, network, service)</code></span>
<span class="codeline" id="line-92"><code>	select {</code></span>
<span class="codeline" id="line-93"><code>	case r := &lt;-result:</code></span>
<span class="codeline" id="line-94"><code>		return r.port, r.err, true</code></span>
<span class="codeline" id="line-95"><code>	case &lt;-ctx.Done():</code></span>
<span class="codeline" id="line-96"><code>		// Since there isn't a portable way to cancel the lookup,</code></span>
<span class="codeline" id="line-97"><code>		// we just let it finish and write to the buffered channel.</code></span>
<span class="codeline" id="line-98"><code>		return 0, mapErr(ctx.Err()), false</code></span>
<span class="codeline" id="line-99"><code>	}</code></span>
<span class="codeline" id="line-100"><code>}</code></span>
<span class="codeline" id="line-101"><code></code></span>
<span class="codeline" id="line-102"><code>func cgoLookupServicePort(hints * /*line :99:34*/_Ctype_struct_addrinfo /*line :99:51*/, network, service string) (port int, err error) {</code></span>
<span class="codeline" id="line-103"><code>	cservice := make([]byte, len(service)+1)</code></span>
<span class="codeline" id="line-104"><code>	copy(cservice, service)</code></span>
<span class="codeline" id="line-105"><code>	// Lowercase the C service name.</code></span>
<span class="codeline" id="line-106"><code>	for i, b := range cservice[:len(service)] {</code></span>
<span class="codeline" id="line-107"><code>		cservice[i] = lowerASCII(b)</code></span>
<span class="codeline" id="line-108"><code>	}</code></span>
<span class="codeline" id="line-109"><code>	var res * /*line :106:11*/_Ctype_struct_addrinfo /*line :106:28*/</code></span>
<span class="codeline" id="line-110"><code>	gerrno, err := func() (_Ctype_int, error){ var _cgo0 *_Ctype_char = /*line :107:31*/nil; var _cgo1 *_Ctype_char = /*line :107:36*/(*_Ctype_char)(unsafe.Pointer(&amp;cservice[0])); _cgo2 := /*line :107:77*/hints; _cgoBase3 := /*line :107:84*/&amp;res; _cgo3 := _cgoBase3; _cgoCheckPointer(_cgo2, nil); _cgoCheckPointer(_cgoBase3, 0 == 0); return _C2func_getaddrinfo(_cgo0, _cgo1, _cgo2, _cgo3); }()</code></span>
<span class="codeline" id="line-111"><code>	if gerrno != 0 {</code></span>
<span class="codeline" id="line-112"><code>		isTemporary := false</code></span>
<span class="codeline" id="line-113"><code>		switch gerrno {</code></span>
<span class="codeline" id="line-114"><code>		case ( /*line :111:8*/_Ciconst_EAI_SYSTEM /*line :111:19*/):</code></span>
<span class="codeline" id="line-115"><code>			if err == nil { // see golang.org/issue/6232</code></span>
<span class="codeline" id="line-116"><code>				err = syscall.EMFILE</code></span>
<span class="codeline" id="line-117"><code>			}</code></span>
<span class="codeline" id="line-118"><code>		default:</code></span>
<span class="codeline" id="line-119"><code>			err = addrinfoErrno(gerrno)</code></span>
<span class="codeline" id="line-120"><code>			isTemporary = addrinfoErrno(gerrno).Temporary()</code></span>
<span class="codeline" id="line-121"><code>		}</code></span>
<span class="codeline" id="line-122"><code>		return 0, &amp;DNSError{Err: err.Error(), Name: network + "/" + service, IsTemporary: isTemporary}</code></span>
<span class="codeline" id="line-123"><code>	}</code></span>
<span class="codeline" id="line-124"><code>	defer func() func() { _cgo0 := /*line :121:23*/res; return func() { _cgoCheckPointer(_cgo0, nil); _Cfunc_freeaddrinfo(_cgo0); }}()()</code></span>
<span class="codeline" id="line-125"><code></code></span>
<span class="codeline" id="line-126"><code>	for r := res; r != nil; r = r.ai_next {</code></span>
<span class="codeline" id="line-127"><code>		switch r.ai_family {</code></span>
<span class="codeline" id="line-128"><code>		case ( /*line :125:8*/_Ciconst_AF_INET /*line :125:16*/):</code></span>
<span class="codeline" id="line-129"><code>			sa := (*syscall.RawSockaddrInet4)(unsafe.Pointer(r.ai_addr))</code></span>
<span class="codeline" id="line-130"><code>			p := (*[2]byte)(unsafe.Pointer(&amp;sa.Port))</code></span>
<span class="codeline" id="line-131"><code>			return int(p[0])&lt;&lt;8 | int(p[1]), nil</code></span>
<span class="codeline" id="line-132"><code>		case ( /*line :129:8*/_Ciconst_AF_INET6 /*line :129:17*/):</code></span>
<span class="codeline" id="line-133"><code>			sa := (*syscall.RawSockaddrInet6)(unsafe.Pointer(r.ai_addr))</code></span>
<span class="codeline" id="line-134"><code>			p := (*[2]byte)(unsafe.Pointer(&amp;sa.Port))</code></span>
<span class="codeline" id="line-135"><code>			return int(p[0])&lt;&lt;8 | int(p[1]), nil</code></span>
<span class="codeline" id="line-136"><code>		}</code></span>
<span class="codeline" id="line-137"><code>	}</code></span>
<span class="codeline" id="line-138"><code>	return 0, &amp;DNSError{Err: "unknown port", Name: network + "/" + service}</code></span>
<span class="codeline" id="line-139"><code>}</code></span>
<span class="codeline" id="line-140"><code></code></span>
<span class="codeline" id="line-141"><code>func cgoPortLookup(result chan&lt;- portLookupResult, hints * /*line :138:59*/_Ctype_struct_addrinfo /*line :138:76*/, network, service string) {</code></span>
<span class="codeline" id="line-142"><code>	port, err := cgoLookupServicePort(hints, network, service)</code></span>
<span class="codeline" id="line-143"><code>	result &lt;- portLookupResult{port, err}</code></span>
<span class="codeline" id="line-144"><code>}</code></span>
<span class="codeline" id="line-145"><code></code></span>
<span class="codeline" id="line-146"><code>func cgoLookupIPCNAME(network, name string) (addrs []IPAddr, cname string, err error) {</code></span>
<span class="codeline" id="line-147"><code>	acquireThread()</code></span>
<span class="codeline" id="line-148"><code>	defer releaseThread()</code></span>
<span class="codeline" id="line-149"><code></code></span>
<span class="codeline" id="line-150"><code>	var hints  /*line :147:12*/_Ctype_struct_addrinfo /*line :147:29*/</code></span>
<span class="codeline" id="line-151"><code>	hints.ai_flags = cgoAddrInfoFlags</code></span>
<span class="codeline" id="line-152"><code>	hints.ai_socktype = ( /*line :149:22*/_Ciconst_SOCK_STREAM /*line :149:34*/)</code></span>
<span class="codeline" id="line-153"><code>	hints.ai_family = ( /*line :150:20*/_Ciconst_AF_UNSPEC /*line :150:30*/)</code></span>
<span class="codeline" id="line-154"><code>	switch ipVersion(network) {</code></span>
<span class="codeline" id="line-155"><code>	case '4':</code></span>
<span class="codeline" id="line-156"><code>		hints.ai_family = ( /*line :153:21*/_Ciconst_AF_INET /*line :153:29*/)</code></span>
<span class="codeline" id="line-157"><code>	case '6':</code></span>
<span class="codeline" id="line-158"><code>		hints.ai_family = ( /*line :155:21*/_Ciconst_AF_INET6 /*line :155:30*/)</code></span>
<span class="codeline" id="line-159"><code>	}</code></span>
<span class="codeline" id="line-160"><code></code></span>
<span class="codeline" id="line-161"><code>	h := make([]byte, len(name)+1)</code></span>
<span class="codeline" id="line-162"><code>	copy(h, name)</code></span>
<span class="codeline" id="line-163"><code>	var res * /*line :160:11*/_Ctype_struct_addrinfo /*line :160:28*/</code></span>
<span class="codeline" id="line-164"><code>	gerrno, err := func() (_Ctype_int, error){ var _cgo0 *_Ctype_char = /*line :161:31*/(*_Ctype_char)(unsafe.Pointer(&amp;h[0])); var _cgo1 *_Ctype_char = /*line :161:65*/nil; _cgoBase2 := /*line :161:70*/&amp;hints; _cgo2 := _cgoBase2; _cgoBase3 := /*line :161:78*/&amp;res; _cgo3 := _cgoBase3; _cgoCheckPointer(_cgoBase2, 0 == 0); _cgoCheckPointer(_cgoBase3, 0 == 0); return _C2func_getaddrinfo(_cgo0, _cgo1, _cgo2, _cgo3); }()</code></span>
<span class="codeline" id="line-165"><code>	if gerrno != 0 {</code></span>
<span class="codeline" id="line-166"><code>		isErrorNoSuchHost := false</code></span>
<span class="codeline" id="line-167"><code>		isTemporary := false</code></span>
<span class="codeline" id="line-168"><code>		switch gerrno {</code></span>
<span class="codeline" id="line-169"><code>		case ( /*line :166:8*/_Ciconst_EAI_SYSTEM /*line :166:19*/):</code></span>
<span class="codeline" id="line-170"><code>			if err == nil {</code></span>
<span class="codeline" id="line-171"><code>				// err should not be nil, but sometimes getaddrinfo returns</code></span>
<span class="codeline" id="line-172"><code>				// gerrno == C.EAI_SYSTEM with err == nil on Linux.</code></span>
<span class="codeline" id="line-173"><code>				// The report claims that it happens when we have too many</code></span>
<span class="codeline" id="line-174"><code>				// open files, so use syscall.EMFILE (too many open files in system).</code></span>
<span class="codeline" id="line-175"><code>				// Most system calls would return ENFILE (too many open files),</code></span>
<span class="codeline" id="line-176"><code>				// so at the least EMFILE should be easy to recognize if this</code></span>
<span class="codeline" id="line-177"><code>				// comes up again. golang.org/issue/6232.</code></span>
<span class="codeline" id="line-178"><code>				err = syscall.EMFILE</code></span>
<span class="codeline" id="line-179"><code>			}</code></span>
<span class="codeline" id="line-180"><code>		case ( /*line :177:8*/_Ciconst_EAI_NONAME /*line :177:19*/):</code></span>
<span class="codeline" id="line-181"><code>			err = errNoSuchHost</code></span>
<span class="codeline" id="line-182"><code>			isErrorNoSuchHost = true</code></span>
<span class="codeline" id="line-183"><code>		default:</code></span>
<span class="codeline" id="line-184"><code>			err = addrinfoErrno(gerrno)</code></span>
<span class="codeline" id="line-185"><code>			isTemporary = addrinfoErrno(gerrno).Temporary()</code></span>
<span class="codeline" id="line-186"><code>		}</code></span>
<span class="codeline" id="line-187"><code></code></span>
<span class="codeline" id="line-188"><code>		return nil, "", &amp;DNSError{Err: err.Error(), Name: name, IsNotFound: isErrorNoSuchHost, IsTemporary: isTemporary}</code></span>
<span class="codeline" id="line-189"><code>	}</code></span>
<span class="codeline" id="line-190"><code>	defer func() func() { _cgo0 := /*line :187:23*/res; return func() { _cgoCheckPointer(_cgo0, nil); _Cfunc_freeaddrinfo(_cgo0); }}()()</code></span>
<span class="codeline" id="line-191"><code></code></span>
<span class="codeline" id="line-192"><code>	if res != nil {</code></span>
<span class="codeline" id="line-193"><code>		cname = ( /*line :190:11*/_Cfunc_GoString /*line :190:20*/)(res.ai_canonname)</code></span>
<span class="codeline" id="line-194"><code>		if cname == "" {</code></span>
<span class="codeline" id="line-195"><code>			cname = name</code></span>
<span class="codeline" id="line-196"><code>		}</code></span>
<span class="codeline" id="line-197"><code>		if len(cname) &gt; 0 &amp;&amp; cname[len(cname)-1] != '.' {</code></span>
<span class="codeline" id="line-198"><code>			cname += "."</code></span>
<span class="codeline" id="line-199"><code>		}</code></span>
<span class="codeline" id="line-200"><code>	}</code></span>
<span class="codeline" id="line-201"><code>	for r := res; r != nil; r = r.ai_next {</code></span>
<span class="codeline" id="line-202"><code>		// We only asked for SOCK_STREAM, but check anyhow.</code></span>
<span class="codeline" id="line-203"><code>		if r.ai_socktype != ( /*line :200:23*/_Ciconst_SOCK_STREAM /*line :200:35*/) {</code></span>
<span class="codeline" id="line-204"><code>			continue</code></span>
<span class="codeline" id="line-205"><code>		}</code></span>
<span class="codeline" id="line-206"><code>		switch r.ai_family {</code></span>
<span class="codeline" id="line-207"><code>		case ( /*line :204:8*/_Ciconst_AF_INET /*line :204:16*/):</code></span>
<span class="codeline" id="line-208"><code>			sa := (*syscall.RawSockaddrInet4)(unsafe.Pointer(r.ai_addr))</code></span>
<span class="codeline" id="line-209"><code>			addr := IPAddr{IP: copyIP(sa.Addr[:])}</code></span>
<span class="codeline" id="line-210"><code>			addrs = append(addrs, addr)</code></span>
<span class="codeline" id="line-211"><code>		case ( /*line :208:8*/_Ciconst_AF_INET6 /*line :208:17*/):</code></span>
<span class="codeline" id="line-212"><code>			sa := (*syscall.RawSockaddrInet6)(unsafe.Pointer(r.ai_addr))</code></span>
<span class="codeline" id="line-213"><code>			addr := IPAddr{IP: copyIP(sa.Addr[:]), Zone: zoneCache.name(int(sa.Scope_id))}</code></span>
<span class="codeline" id="line-214"><code>			addrs = append(addrs, addr)</code></span>
<span class="codeline" id="line-215"><code>		}</code></span>
<span class="codeline" id="line-216"><code>	}</code></span>
<span class="codeline" id="line-217"><code>	return addrs, cname, nil</code></span>
<span class="codeline" id="line-218"><code>}</code></span>
<span class="codeline" id="line-219"><code></code></span>
<span class="codeline" id="line-220"><code>func cgoIPLookup(result chan&lt;- ipLookupResult, network, name string) {</code></span>
<span class="codeline" id="line-221"><code>	addrs, cname, err := cgoLookupIPCNAME(network, name)</code></span>
<span class="codeline" id="line-222"><code>	result &lt;- ipLookupResult{addrs, cname, err}</code></span>
<span class="codeline" id="line-223"><code>}</code></span>
<span class="codeline" id="line-224"><code></code></span>
<span class="codeline" id="line-225"><code>func cgoLookupIP(ctx context.Context, network, name string) (addrs []IPAddr, err error, completed bool) {</code></span>
<span class="codeline" id="line-226"><code>	if ctx.Done() == nil {</code></span>
<span class="codeline" id="line-227"><code>		addrs, _, err = cgoLookupIPCNAME(network, name)</code></span>
<span class="codeline" id="line-228"><code>		return addrs, err, true</code></span>
<span class="codeline" id="line-229"><code>	}</code></span>
<span class="codeline" id="line-230"><code>	result := make(chan ipLookupResult, 1)</code></span>
<span class="codeline" id="line-231"><code>	go cgoIPLookup(result, network, name)</code></span>
<span class="codeline" id="line-232"><code>	select {</code></span>
<span class="codeline" id="line-233"><code>	case r := &lt;-result:</code></span>
<span class="codeline" id="line-234"><code>		return r.addrs, r.err, true</code></span>
<span class="codeline" id="line-235"><code>	case &lt;-ctx.Done():</code></span>
<span class="codeline" id="line-236"><code>		return nil, mapErr(ctx.Err()), false</code></span>
<span class="codeline" id="line-237"><code>	}</code></span>
<span class="codeline" id="line-238"><code>}</code></span>
<span class="codeline" id="line-239"><code></code></span>
<span class="codeline" id="line-240"><code>func cgoLookupCNAME(ctx context.Context, name string) (cname string, err error, completed bool) {</code></span>
<span class="codeline" id="line-241"><code>	if ctx.Done() == nil {</code></span>
<span class="codeline" id="line-242"><code>		_, cname, err = cgoLookupIPCNAME("ip", name)</code></span>
<span class="codeline" id="line-243"><code>		return cname, err, true</code></span>
<span class="codeline" id="line-244"><code>	}</code></span>
<span class="codeline" id="line-245"><code>	result := make(chan ipLookupResult, 1)</code></span>
<span class="codeline" id="line-246"><code>	go cgoIPLookup(result, "ip", name)</code></span>
<span class="codeline" id="line-247"><code>	select {</code></span>
<span class="codeline" id="line-248"><code>	case r := &lt;-result:</code></span>
<span class="codeline" id="line-249"><code>		return r.cname, r.err, true</code></span>
<span class="codeline" id="line-250"><code>	case &lt;-ctx.Done():</code></span>
<span class="codeline" id="line-251"><code>		return "", mapErr(ctx.Err()), false</code></span>
<span class="codeline" id="line-252"><code>	}</code></span>
<span class="codeline" id="line-253"><code>}</code></span>
<span class="codeline" id="line-254"><code></code></span>
<span class="codeline" id="line-255"><code>// These are roughly enough for the following:</code></span>
<span class="codeline" id="line-256"><code>//</code></span>
<span class="codeline" id="line-257"><code>// Source		Encoding			Maximum length of single name entry</code></span>
<span class="codeline" id="line-258"><code>// Unicast DNS		ASCII or			&lt;=253 + a NUL terminator</code></span>
<span class="codeline" id="line-259"><code>//			Unicode in RFC 5892		252 * total number of labels + delimiters + a NUL terminator</code></span>
<span class="codeline" id="line-260"><code>// Multicast DNS	UTF-8 in RFC 5198 or		&lt;=253 + a NUL terminator</code></span>
<span class="codeline" id="line-261"><code>//			the same as unicast DNS ASCII	&lt;=253 + a NUL terminator</code></span>
<span class="codeline" id="line-262"><code>// Local database	various				depends on implementation</code></span>
<span class="codeline" id="line-263"><code>const (</code></span>
<span class="codeline" id="line-264"><code>	nameinfoLen    = 64</code></span>
<span class="codeline" id="line-265"><code>	maxNameinfoLen = 4096</code></span>
<span class="codeline" id="line-266"><code>)</code></span>
<span class="codeline" id="line-267"><code></code></span>
<span class="codeline" id="line-268"><code>func cgoLookupPTR(ctx context.Context, addr string) (names []string, err error, completed bool) {</code></span>
<span class="codeline" id="line-269"><code>	var zone string</code></span>
<span class="codeline" id="line-270"><code>	ip := parseIPv4(addr)</code></span>
<span class="codeline" id="line-271"><code>	if ip == nil {</code></span>
<span class="codeline" id="line-272"><code>		ip, zone = parseIPv6Zone(addr)</code></span>
<span class="codeline" id="line-273"><code>	}</code></span>
<span class="codeline" id="line-274"><code>	if ip == nil {</code></span>
<span class="codeline" id="line-275"><code>		return nil, &amp;DNSError{Err: "invalid address", Name: addr}, true</code></span>
<span class="codeline" id="line-276"><code>	}</code></span>
<span class="codeline" id="line-277"><code>	sa, salen := cgoSockaddr(ip, zone)</code></span>
<span class="codeline" id="line-278"><code>	if sa == nil {</code></span>
<span class="codeline" id="line-279"><code>		return nil, &amp;DNSError{Err: "invalid address " + ip.String(), Name: addr}, true</code></span>
<span class="codeline" id="line-280"><code>	}</code></span>
<span class="codeline" id="line-281"><code>	if ctx.Done() == nil {</code></span>
<span class="codeline" id="line-282"><code>		names, err := cgoLookupAddrPTR(addr, sa, salen)</code></span>
<span class="codeline" id="line-283"><code>		return names, err, true</code></span>
<span class="codeline" id="line-284"><code>	}</code></span>
<span class="codeline" id="line-285"><code>	result := make(chan reverseLookupResult, 1)</code></span>
<span class="codeline" id="line-286"><code>	go cgoReverseLookup(result, addr, sa, salen)</code></span>
<span class="codeline" id="line-287"><code>	select {</code></span>
<span class="codeline" id="line-288"><code>	case r := &lt;-result:</code></span>
<span class="codeline" id="line-289"><code>		return r.names, r.err, true</code></span>
<span class="codeline" id="line-290"><code>	case &lt;-ctx.Done():</code></span>
<span class="codeline" id="line-291"><code>		return nil, mapErr(ctx.Err()), false</code></span>
<span class="codeline" id="line-292"><code>	}</code></span>
<span class="codeline" id="line-293"><code>}</code></span>
<span class="codeline" id="line-294"><code></code></span>
<span class="codeline" id="line-295"><code>func cgoLookupAddrPTR(addr string, sa * /*line :292:40*/_Ctype_struct_sockaddr /*line :292:57*/, salen  /*line :292:65*/_Ctype_socklen_t /*line :292:76*/) (names []string, err error) {</code></span>
<span class="codeline" id="line-296"><code>	acquireThread()</code></span>
<span class="codeline" id="line-297"><code>	defer releaseThread()</code></span>
<span class="codeline" id="line-298"><code></code></span>
<span class="codeline" id="line-299"><code>	var gerrno int</code></span>
<span class="codeline" id="line-300"><code>	var b []byte</code></span>
<span class="codeline" id="line-301"><code>	for l := nameinfoLen; l &lt;= maxNameinfoLen; l *= 2 {</code></span>
<span class="codeline" id="line-302"><code>		b = make([]byte, l)</code></span>
<span class="codeline" id="line-303"><code>		gerrno, err = cgoNameinfoPTR(b, sa, salen)</code></span>
<span class="codeline" id="line-304"><code>		if gerrno == 0 || gerrno != ( /*line :301:31*/_Ciconst_EAI_OVERFLOW /*line :301:44*/) {</code></span>
<span class="codeline" id="line-305"><code>			break</code></span>
<span class="codeline" id="line-306"><code>		}</code></span>
<span class="codeline" id="line-307"><code>	}</code></span>
<span class="codeline" id="line-308"><code>	if gerrno != 0 {</code></span>
<span class="codeline" id="line-309"><code>		isTemporary := false</code></span>
<span class="codeline" id="line-310"><code>		switch gerrno {</code></span>
<span class="codeline" id="line-311"><code>		case ( /*line :308:8*/_Ciconst_EAI_SYSTEM /*line :308:19*/):</code></span>
<span class="codeline" id="line-312"><code>			if err == nil { // see golang.org/issue/6232</code></span>
<span class="codeline" id="line-313"><code>				err = syscall.EMFILE</code></span>
<span class="codeline" id="line-314"><code>			}</code></span>
<span class="codeline" id="line-315"><code>		default:</code></span>
<span class="codeline" id="line-316"><code>			err = addrinfoErrno(gerrno)</code></span>
<span class="codeline" id="line-317"><code>			isTemporary = addrinfoErrno(gerrno).Temporary()</code></span>
<span class="codeline" id="line-318"><code>		}</code></span>
<span class="codeline" id="line-319"><code>		return nil, &amp;DNSError{Err: err.Error(), Name: addr, IsTemporary: isTemporary}</code></span>
<span class="codeline" id="line-320"><code>	}</code></span>
<span class="codeline" id="line-321"><code>	for i := 0; i &lt; len(b); i++ {</code></span>
<span class="codeline" id="line-322"><code>		if b[i] == 0 {</code></span>
<span class="codeline" id="line-323"><code>			b = b[:i]</code></span>
<span class="codeline" id="line-324"><code>			break</code></span>
<span class="codeline" id="line-325"><code>		}</code></span>
<span class="codeline" id="line-326"><code>	}</code></span>
<span class="codeline" id="line-327"><code>	return []string{absDomainName(b)}, nil</code></span>
<span class="codeline" id="line-328"><code>}</code></span>
<span class="codeline" id="line-329"><code></code></span>
<span class="codeline" id="line-330"><code>func cgoReverseLookup(result chan&lt;- reverseLookupResult, addr string, sa * /*line :327:75*/_Ctype_struct_sockaddr /*line :327:92*/, salen  /*line :327:100*/_Ctype_socklen_t /*line :327:111*/) {</code></span>
<span class="codeline" id="line-331"><code>	names, err := cgoLookupAddrPTR(addr, sa, salen)</code></span>
<span class="codeline" id="line-332"><code>	result &lt;- reverseLookupResult{names, err}</code></span>
<span class="codeline" id="line-333"><code>}</code></span>
<span class="codeline" id="line-334"><code></code></span>
<span class="codeline" id="line-335"><code>func cgoSockaddr(ip IP, zone string) (* /*line :332:40*/_Ctype_struct_sockaddr /*line :332:57*/,  /*line :332:59*/_Ctype_socklen_t /*line :332:70*/) {</code></span>
<span class="codeline" id="line-336"><code>	if ip4 := ip.To4(); ip4 != nil {</code></span>
<span class="codeline" id="line-337"><code>		return cgoSockaddrInet4(ip4),  /*line :334:33*/_Ctype_socklen_t /*line :334:44*/(syscall.SizeofSockaddrInet4)</code></span>
<span class="codeline" id="line-338"><code>	}</code></span>
<span class="codeline" id="line-339"><code>	if ip6 := ip.To16(); ip6 != nil {</code></span>
<span class="codeline" id="line-340"><code>		return cgoSockaddrInet6(ip6, zoneCache.index(zone)),  /*line :337:56*/_Ctype_socklen_t /*line :337:67*/(syscall.SizeofSockaddrInet6)</code></span>
<span class="codeline" id="line-341"><code>	}</code></span>
<span class="codeline" id="line-342"><code>	return nil, 0</code></span>
<span class="codeline" id="line-343"><code>}</code></span>
<span class="codeline" id="line-344"><code></code></span>
<span class="codeline" id="line-345"><code>func copyIP(x IP) IP {</code></span>
<span class="codeline" id="line-346"><code>	if len(x) &lt; 16 {</code></span>
<span class="codeline" id="line-347"><code>		return x.To16()</code></span>
<span class="codeline" id="line-348"><code>	}</code></span>
<span class="codeline" id="line-349"><code>	y := make(IP, len(x))</code></span>
<span class="codeline" id="line-350"><code>	copy(y, x)</code></span>
<span class="codeline" id="line-351"><code>	return y</code></span>
<span class="codeline" id="line-352"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.1.6</i>. (GOOS=darwin GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project and developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table
</pre>
</div></body></html>