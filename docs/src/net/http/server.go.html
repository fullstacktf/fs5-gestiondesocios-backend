<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: server.go in package net/http</title>
<link href="../../../css/light-v0.1.6.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.1.6.js"></script>
<body><div>

<pre id="header"><code><span class="title">Source File</span>
	server.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/net/http.html">net/http</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>// HTTP server. See RFC 7230 through 7235.</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>package http</code></span>
<span class="codeline" id="line-8"><code></code></span>
<span class="codeline" id="line-9"><code>import (</code></span>
<span class="codeline" id="line-10"><code>	"bufio"</code></span>
<span class="codeline" id="line-11"><code>	"bytes"</code></span>
<span class="codeline" id="line-12"><code>	"context"</code></span>
<span class="codeline" id="line-13"><code>	"crypto/tls"</code></span>
<span class="codeline" id="line-14"><code>	"errors"</code></span>
<span class="codeline" id="line-15"><code>	"fmt"</code></span>
<span class="codeline" id="line-16"><code>	"io"</code></span>
<span class="codeline" id="line-17"><code>	"io/ioutil"</code></span>
<span class="codeline" id="line-18"><code>	"log"</code></span>
<span class="codeline" id="line-19"><code>	"net"</code></span>
<span class="codeline" id="line-20"><code>	"net/textproto"</code></span>
<span class="codeline" id="line-21"><code>	"net/url"</code></span>
<span class="codeline" id="line-22"><code>	urlpkg "net/url"</code></span>
<span class="codeline" id="line-23"><code>	"os"</code></span>
<span class="codeline" id="line-24"><code>	"path"</code></span>
<span class="codeline" id="line-25"><code>	"runtime"</code></span>
<span class="codeline" id="line-26"><code>	"sort"</code></span>
<span class="codeline" id="line-27"><code>	"strconv"</code></span>
<span class="codeline" id="line-28"><code>	"strings"</code></span>
<span class="codeline" id="line-29"><code>	"sync"</code></span>
<span class="codeline" id="line-30"><code>	"sync/atomic"</code></span>
<span class="codeline" id="line-31"><code>	"time"</code></span>
<span class="codeline" id="line-32"><code></code></span>
<span class="codeline" id="line-33"><code>	"golang.org/x/net/http/httpguts"</code></span>
<span class="codeline" id="line-34"><code>)</code></span>
<span class="codeline" id="line-35"><code></code></span>
<span class="codeline" id="line-36"><code>// Errors used by the HTTP server.</code></span>
<span class="codeline" id="line-37"><code>var (</code></span>
<span class="codeline" id="line-38"><code>	// ErrBodyNotAllowed is returned by ResponseWriter.Write calls</code></span>
<span class="codeline" id="line-39"><code>	// when the HTTP method or response code does not permit a</code></span>
<span class="codeline" id="line-40"><code>	// body.</code></span>
<span class="codeline" id="line-41"><code>	ErrBodyNotAllowed = errors.New("http: request method or response status code does not allow body")</code></span>
<span class="codeline" id="line-42"><code></code></span>
<span class="codeline" id="line-43"><code>	// ErrHijacked is returned by ResponseWriter.Write calls when</code></span>
<span class="codeline" id="line-44"><code>	// the underlying connection has been hijacked using the</code></span>
<span class="codeline" id="line-45"><code>	// Hijacker interface. A zero-byte write on a hijacked</code></span>
<span class="codeline" id="line-46"><code>	// connection will return ErrHijacked without any other side</code></span>
<span class="codeline" id="line-47"><code>	// effects.</code></span>
<span class="codeline" id="line-48"><code>	ErrHijacked = errors.New("http: connection has been hijacked")</code></span>
<span class="codeline" id="line-49"><code></code></span>
<span class="codeline" id="line-50"><code>	// ErrContentLength is returned by ResponseWriter.Write calls</code></span>
<span class="codeline" id="line-51"><code>	// when a Handler set a Content-Length response header with a</code></span>
<span class="codeline" id="line-52"><code>	// declared size and then attempted to write more bytes than</code></span>
<span class="codeline" id="line-53"><code>	// declared.</code></span>
<span class="codeline" id="line-54"><code>	ErrContentLength = errors.New("http: wrote more than the declared Content-Length")</code></span>
<span class="codeline" id="line-55"><code></code></span>
<span class="codeline" id="line-56"><code>	// Deprecated: ErrWriteAfterFlush is no longer returned by</code></span>
<span class="codeline" id="line-57"><code>	// anything in the net/http package. Callers should not</code></span>
<span class="codeline" id="line-58"><code>	// compare errors against this variable.</code></span>
<span class="codeline" id="line-59"><code>	ErrWriteAfterFlush = errors.New("unused")</code></span>
<span class="codeline" id="line-60"><code>)</code></span>
<span class="codeline" id="line-61"><code></code></span>
<span class="codeline" id="line-62"><code>// A Handler responds to an HTTP request.</code></span>
<span class="codeline" id="line-63"><code>//</code></span>
<span class="codeline" id="line-64"><code>// ServeHTTP should write reply headers and data to the ResponseWriter</code></span>
<span class="codeline" id="line-65"><code>// and then return. Returning signals that the request is finished; it</code></span>
<span class="codeline" id="line-66"><code>// is not valid to use the ResponseWriter or read from the</code></span>
<span class="codeline" id="line-67"><code>// Request.Body after or concurrently with the completion of the</code></span>
<span class="codeline" id="line-68"><code>// ServeHTTP call.</code></span>
<span class="codeline" id="line-69"><code>//</code></span>
<span class="codeline" id="line-70"><code>// Depending on the HTTP client software, HTTP protocol version, and</code></span>
<span class="codeline" id="line-71"><code>// any intermediaries between the client and the Go server, it may not</code></span>
<span class="codeline" id="line-72"><code>// be possible to read from the Request.Body after writing to the</code></span>
<span class="codeline" id="line-73"><code>// ResponseWriter. Cautious handlers should read the Request.Body</code></span>
<span class="codeline" id="line-74"><code>// first, and then reply.</code></span>
<span class="codeline" id="line-75"><code>//</code></span>
<span class="codeline" id="line-76"><code>// Except for reading the body, handlers should not modify the</code></span>
<span class="codeline" id="line-77"><code>// provided Request.</code></span>
<span class="codeline" id="line-78"><code>//</code></span>
<span class="codeline" id="line-79"><code>// If ServeHTTP panics, the server (the caller of ServeHTTP) assumes</code></span>
<span class="codeline" id="line-80"><code>// that the effect of the panic was isolated to the active request.</code></span>
<span class="codeline" id="line-81"><code>// It recovers the panic, logs a stack trace to the server error log,</code></span>
<span class="codeline" id="line-82"><code>// and either closes the network connection or sends an HTTP/2</code></span>
<span class="codeline" id="line-83"><code>// RST_STREAM, depending on the HTTP protocol. To abort a handler so</code></span>
<span class="codeline" id="line-84"><code>// the client sees an interrupted response but the server doesn't log</code></span>
<span class="codeline" id="line-85"><code>// an error, panic with the value ErrAbortHandler.</code></span>
<span class="codeline" id="line-86"><code>type Handler interface {</code></span>
<span class="codeline" id="line-87"><code>	ServeHTTP(ResponseWriter, *Request)</code></span>
<span class="codeline" id="line-88"><code>}</code></span>
<span class="codeline" id="line-89"><code></code></span>
<span class="codeline" id="line-90"><code>// A ResponseWriter interface is used by an HTTP handler to</code></span>
<span class="codeline" id="line-91"><code>// construct an HTTP response.</code></span>
<span class="codeline" id="line-92"><code>//</code></span>
<span class="codeline" id="line-93"><code>// A ResponseWriter may not be used after the Handler.ServeHTTP method</code></span>
<span class="codeline" id="line-94"><code>// has returned.</code></span>
<span class="codeline" id="line-95"><code>type ResponseWriter interface {</code></span>
<span class="codeline" id="line-96"><code>	// Header returns the header map that will be sent by</code></span>
<span class="codeline" id="line-97"><code>	// WriteHeader. The Header map also is the mechanism with which</code></span>
<span class="codeline" id="line-98"><code>	// Handlers can set HTTP trailers.</code></span>
<span class="codeline" id="line-99"><code>	//</code></span>
<span class="codeline" id="line-100"><code>	// Changing the header map after a call to WriteHeader (or</code></span>
<span class="codeline" id="line-101"><code>	// Write) has no effect unless the modified headers are</code></span>
<span class="codeline" id="line-102"><code>	// trailers.</code></span>
<span class="codeline" id="line-103"><code>	//</code></span>
<span class="codeline" id="line-104"><code>	// There are two ways to set Trailers. The preferred way is to</code></span>
<span class="codeline" id="line-105"><code>	// predeclare in the headers which trailers you will later</code></span>
<span class="codeline" id="line-106"><code>	// send by setting the "Trailer" header to the names of the</code></span>
<span class="codeline" id="line-107"><code>	// trailer keys which will come later. In this case, those</code></span>
<span class="codeline" id="line-108"><code>	// keys of the Header map are treated as if they were</code></span>
<span class="codeline" id="line-109"><code>	// trailers. See the example. The second way, for trailer</code></span>
<span class="codeline" id="line-110"><code>	// keys not known to the Handler until after the first Write,</code></span>
<span class="codeline" id="line-111"><code>	// is to prefix the Header map keys with the TrailerPrefix</code></span>
<span class="codeline" id="line-112"><code>	// constant value. See TrailerPrefix.</code></span>
<span class="codeline" id="line-113"><code>	//</code></span>
<span class="codeline" id="line-114"><code>	// To suppress automatic response headers (such as "Date"), set</code></span>
<span class="codeline" id="line-115"><code>	// their value to nil.</code></span>
<span class="codeline" id="line-116"><code>	Header() Header</code></span>
<span class="codeline" id="line-117"><code></code></span>
<span class="codeline" id="line-118"><code>	// Write writes the data to the connection as part of an HTTP reply.</code></span>
<span class="codeline" id="line-119"><code>	//</code></span>
<span class="codeline" id="line-120"><code>	// If WriteHeader has not yet been called, Write calls</code></span>
<span class="codeline" id="line-121"><code>	// WriteHeader(http.StatusOK) before writing the data. If the Header</code></span>
<span class="codeline" id="line-122"><code>	// does not contain a Content-Type line, Write adds a Content-Type set</code></span>
<span class="codeline" id="line-123"><code>	// to the result of passing the initial 512 bytes of written data to</code></span>
<span class="codeline" id="line-124"><code>	// DetectContentType. Additionally, if the total size of all written</code></span>
<span class="codeline" id="line-125"><code>	// data is under a few KB and there are no Flush calls, the</code></span>
<span class="codeline" id="line-126"><code>	// Content-Length header is added automatically.</code></span>
<span class="codeline" id="line-127"><code>	//</code></span>
<span class="codeline" id="line-128"><code>	// Depending on the HTTP protocol version and the client, calling</code></span>
<span class="codeline" id="line-129"><code>	// Write or WriteHeader may prevent future reads on the</code></span>
<span class="codeline" id="line-130"><code>	// Request.Body. For HTTP/1.x requests, handlers should read any</code></span>
<span class="codeline" id="line-131"><code>	// needed request body data before writing the response. Once the</code></span>
<span class="codeline" id="line-132"><code>	// headers have been flushed (due to either an explicit Flusher.Flush</code></span>
<span class="codeline" id="line-133"><code>	// call or writing enough data to trigger a flush), the request body</code></span>
<span class="codeline" id="line-134"><code>	// may be unavailable. For HTTP/2 requests, the Go HTTP server permits</code></span>
<span class="codeline" id="line-135"><code>	// handlers to continue to read the request body while concurrently</code></span>
<span class="codeline" id="line-136"><code>	// writing the response. However, such behavior may not be supported</code></span>
<span class="codeline" id="line-137"><code>	// by all HTTP/2 clients. Handlers should read before writing if</code></span>
<span class="codeline" id="line-138"><code>	// possible to maximize compatibility.</code></span>
<span class="codeline" id="line-139"><code>	Write([]byte) (int, error)</code></span>
<span class="codeline" id="line-140"><code></code></span>
<span class="codeline" id="line-141"><code>	// WriteHeader sends an HTTP response header with the provided</code></span>
<span class="codeline" id="line-142"><code>	// status code.</code></span>
<span class="codeline" id="line-143"><code>	//</code></span>
<span class="codeline" id="line-144"><code>	// If WriteHeader is not called explicitly, the first call to Write</code></span>
<span class="codeline" id="line-145"><code>	// will trigger an implicit WriteHeader(http.StatusOK).</code></span>
<span class="codeline" id="line-146"><code>	// Thus explicit calls to WriteHeader are mainly used to</code></span>
<span class="codeline" id="line-147"><code>	// send error codes.</code></span>
<span class="codeline" id="line-148"><code>	//</code></span>
<span class="codeline" id="line-149"><code>	// The provided code must be a valid HTTP 1xx-5xx status code.</code></span>
<span class="codeline" id="line-150"><code>	// Only one header may be written. Go does not currently</code></span>
<span class="codeline" id="line-151"><code>	// support sending user-defined 1xx informational headers,</code></span>
<span class="codeline" id="line-152"><code>	// with the exception of 100-continue response header that the</code></span>
<span class="codeline" id="line-153"><code>	// Server sends automatically when the Request.Body is read.</code></span>
<span class="codeline" id="line-154"><code>	WriteHeader(statusCode int)</code></span>
<span class="codeline" id="line-155"><code>}</code></span>
<span class="codeline" id="line-156"><code></code></span>
<span class="codeline" id="line-157"><code>// The Flusher interface is implemented by ResponseWriters that allow</code></span>
<span class="codeline" id="line-158"><code>// an HTTP handler to flush buffered data to the client.</code></span>
<span class="codeline" id="line-159"><code>//</code></span>
<span class="codeline" id="line-160"><code>// The default HTTP/1.x and HTTP/2 ResponseWriter implementations</code></span>
<span class="codeline" id="line-161"><code>// support Flusher, but ResponseWriter wrappers may not. Handlers</code></span>
<span class="codeline" id="line-162"><code>// should always test for this ability at runtime.</code></span>
<span class="codeline" id="line-163"><code>//</code></span>
<span class="codeline" id="line-164"><code>// Note that even for ResponseWriters that support Flush,</code></span>
<span class="codeline" id="line-165"><code>// if the client is connected through an HTTP proxy,</code></span>
<span class="codeline" id="line-166"><code>// the buffered data may not reach the client until the response</code></span>
<span class="codeline" id="line-167"><code>// completes.</code></span>
<span class="codeline" id="line-168"><code>type Flusher interface {</code></span>
<span class="codeline" id="line-169"><code>	// Flush sends any buffered data to the client.</code></span>
<span class="codeline" id="line-170"><code>	Flush()</code></span>
<span class="codeline" id="line-171"><code>}</code></span>
<span class="codeline" id="line-172"><code></code></span>
<span class="codeline" id="line-173"><code>// The Hijacker interface is implemented by ResponseWriters that allow</code></span>
<span class="codeline" id="line-174"><code>// an HTTP handler to take over the connection.</code></span>
<span class="codeline" id="line-175"><code>//</code></span>
<span class="codeline" id="line-176"><code>// The default ResponseWriter for HTTP/1.x connections supports</code></span>
<span class="codeline" id="line-177"><code>// Hijacker, but HTTP/2 connections intentionally do not.</code></span>
<span class="codeline" id="line-178"><code>// ResponseWriter wrappers may also not support Hijacker. Handlers</code></span>
<span class="codeline" id="line-179"><code>// should always test for this ability at runtime.</code></span>
<span class="codeline" id="line-180"><code>type Hijacker interface {</code></span>
<span class="codeline" id="line-181"><code>	// Hijack lets the caller take over the connection.</code></span>
<span class="codeline" id="line-182"><code>	// After a call to Hijack the HTTP server library</code></span>
<span class="codeline" id="line-183"><code>	// will not do anything else with the connection.</code></span>
<span class="codeline" id="line-184"><code>	//</code></span>
<span class="codeline" id="line-185"><code>	// It becomes the caller's responsibility to manage</code></span>
<span class="codeline" id="line-186"><code>	// and close the connection.</code></span>
<span class="codeline" id="line-187"><code>	//</code></span>
<span class="codeline" id="line-188"><code>	// The returned net.Conn may have read or write deadlines</code></span>
<span class="codeline" id="line-189"><code>	// already set, depending on the configuration of the</code></span>
<span class="codeline" id="line-190"><code>	// Server. It is the caller's responsibility to set</code></span>
<span class="codeline" id="line-191"><code>	// or clear those deadlines as needed.</code></span>
<span class="codeline" id="line-192"><code>	//</code></span>
<span class="codeline" id="line-193"><code>	// The returned bufio.Reader may contain unprocessed buffered</code></span>
<span class="codeline" id="line-194"><code>	// data from the client.</code></span>
<span class="codeline" id="line-195"><code>	//</code></span>
<span class="codeline" id="line-196"><code>	// After a call to Hijack, the original Request.Body must not</code></span>
<span class="codeline" id="line-197"><code>	// be used. The original Request's Context remains valid and</code></span>
<span class="codeline" id="line-198"><code>	// is not canceled until the Request's ServeHTTP method</code></span>
<span class="codeline" id="line-199"><code>	// returns.</code></span>
<span class="codeline" id="line-200"><code>	Hijack() (net.Conn, *bufio.ReadWriter, error)</code></span>
<span class="codeline" id="line-201"><code>}</code></span>
<span class="codeline" id="line-202"><code></code></span>
<span class="codeline" id="line-203"><code>// The CloseNotifier interface is implemented by ResponseWriters which</code></span>
<span class="codeline" id="line-204"><code>// allow detecting when the underlying connection has gone away.</code></span>
<span class="codeline" id="line-205"><code>//</code></span>
<span class="codeline" id="line-206"><code>// This mechanism can be used to cancel long operations on the server</code></span>
<span class="codeline" id="line-207"><code>// if the client has disconnected before the response is ready.</code></span>
<span class="codeline" id="line-208"><code>//</code></span>
<span class="codeline" id="line-209"><code>// Deprecated: the CloseNotifier interface predates Go's context package.</code></span>
<span class="codeline" id="line-210"><code>// New code should use Request.Context instead.</code></span>
<span class="codeline" id="line-211"><code>type CloseNotifier interface {</code></span>
<span class="codeline" id="line-212"><code>	// CloseNotify returns a channel that receives at most a</code></span>
<span class="codeline" id="line-213"><code>	// single value (true) when the client connection has gone</code></span>
<span class="codeline" id="line-214"><code>	// away.</code></span>
<span class="codeline" id="line-215"><code>	//</code></span>
<span class="codeline" id="line-216"><code>	// CloseNotify may wait to notify until Request.Body has been</code></span>
<span class="codeline" id="line-217"><code>	// fully read.</code></span>
<span class="codeline" id="line-218"><code>	//</code></span>
<span class="codeline" id="line-219"><code>	// After the Handler has returned, there is no guarantee</code></span>
<span class="codeline" id="line-220"><code>	// that the channel receives a value.</code></span>
<span class="codeline" id="line-221"><code>	//</code></span>
<span class="codeline" id="line-222"><code>	// If the protocol is HTTP/1.1 and CloseNotify is called while</code></span>
<span class="codeline" id="line-223"><code>	// processing an idempotent request (such a GET) while</code></span>
<span class="codeline" id="line-224"><code>	// HTTP/1.1 pipelining is in use, the arrival of a subsequent</code></span>
<span class="codeline" id="line-225"><code>	// pipelined request may cause a value to be sent on the</code></span>
<span class="codeline" id="line-226"><code>	// returned channel. In practice HTTP/1.1 pipelining is not</code></span>
<span class="codeline" id="line-227"><code>	// enabled in browsers and not seen often in the wild. If this</code></span>
<span class="codeline" id="line-228"><code>	// is a problem, use HTTP/2 or only use CloseNotify on methods</code></span>
<span class="codeline" id="line-229"><code>	// such as POST.</code></span>
<span class="codeline" id="line-230"><code>	CloseNotify() &lt;-chan bool</code></span>
<span class="codeline" id="line-231"><code>}</code></span>
<span class="codeline" id="line-232"><code></code></span>
<span class="codeline" id="line-233"><code>var (</code></span>
<span class="codeline" id="line-234"><code>	// ServerContextKey is a context key. It can be used in HTTP</code></span>
<span class="codeline" id="line-235"><code>	// handlers with Context.Value to access the server that</code></span>
<span class="codeline" id="line-236"><code>	// started the handler. The associated value will be of</code></span>
<span class="codeline" id="line-237"><code>	// type *Server.</code></span>
<span class="codeline" id="line-238"><code>	ServerContextKey = &amp;contextKey{"http-server"}</code></span>
<span class="codeline" id="line-239"><code></code></span>
<span class="codeline" id="line-240"><code>	// LocalAddrContextKey is a context key. It can be used in</code></span>
<span class="codeline" id="line-241"><code>	// HTTP handlers with Context.Value to access the local</code></span>
<span class="codeline" id="line-242"><code>	// address the connection arrived on.</code></span>
<span class="codeline" id="line-243"><code>	// The associated value will be of type net.Addr.</code></span>
<span class="codeline" id="line-244"><code>	LocalAddrContextKey = &amp;contextKey{"local-addr"}</code></span>
<span class="codeline" id="line-245"><code>)</code></span>
<span class="codeline" id="line-246"><code></code></span>
<span class="codeline" id="line-247"><code>// A conn represents the server side of an HTTP connection.</code></span>
<span class="codeline" id="line-248"><code>type conn struct {</code></span>
<span class="codeline" id="line-249"><code>	// server is the server on which the connection arrived.</code></span>
<span class="codeline" id="line-250"><code>	// Immutable; never nil.</code></span>
<span class="codeline" id="line-251"><code>	server *Server</code></span>
<span class="codeline" id="line-252"><code></code></span>
<span class="codeline" id="line-253"><code>	// cancelCtx cancels the connection-level context.</code></span>
<span class="codeline" id="line-254"><code>	cancelCtx context.CancelFunc</code></span>
<span class="codeline" id="line-255"><code></code></span>
<span class="codeline" id="line-256"><code>	// rwc is the underlying network connection.</code></span>
<span class="codeline" id="line-257"><code>	// This is never wrapped by other types and is the value given out</code></span>
<span class="codeline" id="line-258"><code>	// to CloseNotifier callers. It is usually of type *net.TCPConn or</code></span>
<span class="codeline" id="line-259"><code>	// *tls.Conn.</code></span>
<span class="codeline" id="line-260"><code>	rwc net.Conn</code></span>
<span class="codeline" id="line-261"><code></code></span>
<span class="codeline" id="line-262"><code>	// remoteAddr is rwc.RemoteAddr().String(). It is not populated synchronously</code></span>
<span class="codeline" id="line-263"><code>	// inside the Listener's Accept goroutine, as some implementations block.</code></span>
<span class="codeline" id="line-264"><code>	// It is populated immediately inside the (*conn).serve goroutine.</code></span>
<span class="codeline" id="line-265"><code>	// This is the value of a Handler's (*Request).RemoteAddr.</code></span>
<span class="codeline" id="line-266"><code>	remoteAddr string</code></span>
<span class="codeline" id="line-267"><code></code></span>
<span class="codeline" id="line-268"><code>	// tlsState is the TLS connection state when using TLS.</code></span>
<span class="codeline" id="line-269"><code>	// nil means not TLS.</code></span>
<span class="codeline" id="line-270"><code>	tlsState *tls.ConnectionState</code></span>
<span class="codeline" id="line-271"><code></code></span>
<span class="codeline" id="line-272"><code>	// werr is set to the first write error to rwc.</code></span>
<span class="codeline" id="line-273"><code>	// It is set via checkConnErrorWriter{w}, where bufw writes.</code></span>
<span class="codeline" id="line-274"><code>	werr error</code></span>
<span class="codeline" id="line-275"><code></code></span>
<span class="codeline" id="line-276"><code>	// r is bufr's read source. It's a wrapper around rwc that provides</code></span>
<span class="codeline" id="line-277"><code>	// io.LimitedReader-style limiting (while reading request headers)</code></span>
<span class="codeline" id="line-278"><code>	// and functionality to support CloseNotifier. See *connReader docs.</code></span>
<span class="codeline" id="line-279"><code>	r *connReader</code></span>
<span class="codeline" id="line-280"><code></code></span>
<span class="codeline" id="line-281"><code>	// bufr reads from r.</code></span>
<span class="codeline" id="line-282"><code>	bufr *bufio.Reader</code></span>
<span class="codeline" id="line-283"><code></code></span>
<span class="codeline" id="line-284"><code>	// bufw writes to checkConnErrorWriter{c}, which populates werr on error.</code></span>
<span class="codeline" id="line-285"><code>	bufw *bufio.Writer</code></span>
<span class="codeline" id="line-286"><code></code></span>
<span class="codeline" id="line-287"><code>	// lastMethod is the method of the most recent request</code></span>
<span class="codeline" id="line-288"><code>	// on this connection, if any.</code></span>
<span class="codeline" id="line-289"><code>	lastMethod string</code></span>
<span class="codeline" id="line-290"><code></code></span>
<span class="codeline" id="line-291"><code>	curReq atomic.Value // of *response (which has a Request in it)</code></span>
<span class="codeline" id="line-292"><code></code></span>
<span class="codeline" id="line-293"><code>	curState struct{ atomic uint64 } // packed (unixtime&lt;&lt;8|uint8(ConnState))</code></span>
<span class="codeline" id="line-294"><code></code></span>
<span class="codeline" id="line-295"><code>	// mu guards hijackedv</code></span>
<span class="codeline" id="line-296"><code>	mu sync.Mutex</code></span>
<span class="codeline" id="line-297"><code></code></span>
<span class="codeline" id="line-298"><code>	// hijackedv is whether this connection has been hijacked</code></span>
<span class="codeline" id="line-299"><code>	// by a Handler with the Hijacker interface.</code></span>
<span class="codeline" id="line-300"><code>	// It is guarded by mu.</code></span>
<span class="codeline" id="line-301"><code>	hijackedv bool</code></span>
<span class="codeline" id="line-302"><code>}</code></span>
<span class="codeline" id="line-303"><code></code></span>
<span class="codeline" id="line-304"><code>func (c *conn) hijacked() bool {</code></span>
<span class="codeline" id="line-305"><code>	c.mu.Lock()</code></span>
<span class="codeline" id="line-306"><code>	defer c.mu.Unlock()</code></span>
<span class="codeline" id="line-307"><code>	return c.hijackedv</code></span>
<span class="codeline" id="line-308"><code>}</code></span>
<span class="codeline" id="line-309"><code></code></span>
<span class="codeline" id="line-310"><code>// c.mu must be held.</code></span>
<span class="codeline" id="line-311"><code>func (c *conn) hijackLocked() (rwc net.Conn, buf *bufio.ReadWriter, err error) {</code></span>
<span class="codeline" id="line-312"><code>	if c.hijackedv {</code></span>
<span class="codeline" id="line-313"><code>		return nil, nil, ErrHijacked</code></span>
<span class="codeline" id="line-314"><code>	}</code></span>
<span class="codeline" id="line-315"><code>	c.r.abortPendingRead()</code></span>
<span class="codeline" id="line-316"><code></code></span>
<span class="codeline" id="line-317"><code>	c.hijackedv = true</code></span>
<span class="codeline" id="line-318"><code>	rwc = c.rwc</code></span>
<span class="codeline" id="line-319"><code>	rwc.SetDeadline(time.Time{})</code></span>
<span class="codeline" id="line-320"><code></code></span>
<span class="codeline" id="line-321"><code>	buf = bufio.NewReadWriter(c.bufr, bufio.NewWriter(rwc))</code></span>
<span class="codeline" id="line-322"><code>	if c.r.hasByte {</code></span>
<span class="codeline" id="line-323"><code>		if _, err := c.bufr.Peek(c.bufr.Buffered() + 1); err != nil {</code></span>
<span class="codeline" id="line-324"><code>			return nil, nil, fmt.Errorf("unexpected Peek failure reading buffered byte: %v", err)</code></span>
<span class="codeline" id="line-325"><code>		}</code></span>
<span class="codeline" id="line-326"><code>	}</code></span>
<span class="codeline" id="line-327"><code>	c.setState(rwc, StateHijacked)</code></span>
<span class="codeline" id="line-328"><code>	return</code></span>
<span class="codeline" id="line-329"><code>}</code></span>
<span class="codeline" id="line-330"><code></code></span>
<span class="codeline" id="line-331"><code>// This should be &gt;= 512 bytes for DetectContentType,</code></span>
<span class="codeline" id="line-332"><code>// but otherwise it's somewhat arbitrary.</code></span>
<span class="codeline" id="line-333"><code>const bufferBeforeChunkingSize = 2048</code></span>
<span class="codeline" id="line-334"><code></code></span>
<span class="codeline" id="line-335"><code>// chunkWriter writes to a response's conn buffer, and is the writer</code></span>
<span class="codeline" id="line-336"><code>// wrapped by the response.bufw buffered writer.</code></span>
<span class="codeline" id="line-337"><code>//</code></span>
<span class="codeline" id="line-338"><code>// chunkWriter also is responsible for finalizing the Header, including</code></span>
<span class="codeline" id="line-339"><code>// conditionally setting the Content-Type and setting a Content-Length</code></span>
<span class="codeline" id="line-340"><code>// in cases where the handler's final output is smaller than the buffer</code></span>
<span class="codeline" id="line-341"><code>// size. It also conditionally adds chunk headers, when in chunking mode.</code></span>
<span class="codeline" id="line-342"><code>//</code></span>
<span class="codeline" id="line-343"><code>// See the comment above (*response).Write for the entire write flow.</code></span>
<span class="codeline" id="line-344"><code>type chunkWriter struct {</code></span>
<span class="codeline" id="line-345"><code>	res *response</code></span>
<span class="codeline" id="line-346"><code></code></span>
<span class="codeline" id="line-347"><code>	// header is either nil or a deep clone of res.handlerHeader</code></span>
<span class="codeline" id="line-348"><code>	// at the time of res.writeHeader, if res.writeHeader is</code></span>
<span class="codeline" id="line-349"><code>	// called and extra buffering is being done to calculate</code></span>
<span class="codeline" id="line-350"><code>	// Content-Type and/or Content-Length.</code></span>
<span class="codeline" id="line-351"><code>	header Header</code></span>
<span class="codeline" id="line-352"><code></code></span>
<span class="codeline" id="line-353"><code>	// wroteHeader tells whether the header's been written to "the</code></span>
<span class="codeline" id="line-354"><code>	// wire" (or rather: w.conn.buf). this is unlike</code></span>
<span class="codeline" id="line-355"><code>	// (*response).wroteHeader, which tells only whether it was</code></span>
<span class="codeline" id="line-356"><code>	// logically written.</code></span>
<span class="codeline" id="line-357"><code>	wroteHeader bool</code></span>
<span class="codeline" id="line-358"><code></code></span>
<span class="codeline" id="line-359"><code>	// set by the writeHeader method:</code></span>
<span class="codeline" id="line-360"><code>	chunking bool // using chunked transfer encoding for reply body</code></span>
<span class="codeline" id="line-361"><code>}</code></span>
<span class="codeline" id="line-362"><code></code></span>
<span class="codeline" id="line-363"><code>var (</code></span>
<span class="codeline" id="line-364"><code>	crlf       = []byte("\r\n")</code></span>
<span class="codeline" id="line-365"><code>	colonSpace = []byte(": ")</code></span>
<span class="codeline" id="line-366"><code>)</code></span>
<span class="codeline" id="line-367"><code></code></span>
<span class="codeline" id="line-368"><code>func (cw *chunkWriter) Write(p []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-369"><code>	if !cw.wroteHeader {</code></span>
<span class="codeline" id="line-370"><code>		cw.writeHeader(p)</code></span>
<span class="codeline" id="line-371"><code>	}</code></span>
<span class="codeline" id="line-372"><code>	if cw.res.req.Method == "HEAD" {</code></span>
<span class="codeline" id="line-373"><code>		// Eat writes.</code></span>
<span class="codeline" id="line-374"><code>		return len(p), nil</code></span>
<span class="codeline" id="line-375"><code>	}</code></span>
<span class="codeline" id="line-376"><code>	if cw.chunking {</code></span>
<span class="codeline" id="line-377"><code>		_, err = fmt.Fprintf(cw.res.conn.bufw, "%x\r\n", len(p))</code></span>
<span class="codeline" id="line-378"><code>		if err != nil {</code></span>
<span class="codeline" id="line-379"><code>			cw.res.conn.rwc.Close()</code></span>
<span class="codeline" id="line-380"><code>			return</code></span>
<span class="codeline" id="line-381"><code>		}</code></span>
<span class="codeline" id="line-382"><code>	}</code></span>
<span class="codeline" id="line-383"><code>	n, err = cw.res.conn.bufw.Write(p)</code></span>
<span class="codeline" id="line-384"><code>	if cw.chunking &amp;&amp; err == nil {</code></span>
<span class="codeline" id="line-385"><code>		_, err = cw.res.conn.bufw.Write(crlf)</code></span>
<span class="codeline" id="line-386"><code>	}</code></span>
<span class="codeline" id="line-387"><code>	if err != nil {</code></span>
<span class="codeline" id="line-388"><code>		cw.res.conn.rwc.Close()</code></span>
<span class="codeline" id="line-389"><code>	}</code></span>
<span class="codeline" id="line-390"><code>	return</code></span>
<span class="codeline" id="line-391"><code>}</code></span>
<span class="codeline" id="line-392"><code></code></span>
<span class="codeline" id="line-393"><code>func (cw *chunkWriter) flush() {</code></span>
<span class="codeline" id="line-394"><code>	if !cw.wroteHeader {</code></span>
<span class="codeline" id="line-395"><code>		cw.writeHeader(nil)</code></span>
<span class="codeline" id="line-396"><code>	}</code></span>
<span class="codeline" id="line-397"><code>	cw.res.conn.bufw.Flush()</code></span>
<span class="codeline" id="line-398"><code>}</code></span>
<span class="codeline" id="line-399"><code></code></span>
<span class="codeline" id="line-400"><code>func (cw *chunkWriter) close() {</code></span>
<span class="codeline" id="line-401"><code>	if !cw.wroteHeader {</code></span>
<span class="codeline" id="line-402"><code>		cw.writeHeader(nil)</code></span>
<span class="codeline" id="line-403"><code>	}</code></span>
<span class="codeline" id="line-404"><code>	if cw.chunking {</code></span>
<span class="codeline" id="line-405"><code>		bw := cw.res.conn.bufw // conn's bufio writer</code></span>
<span class="codeline" id="line-406"><code>		// zero chunk to mark EOF</code></span>
<span class="codeline" id="line-407"><code>		bw.WriteString("0\r\n")</code></span>
<span class="codeline" id="line-408"><code>		if trailers := cw.res.finalTrailers(); trailers != nil {</code></span>
<span class="codeline" id="line-409"><code>			trailers.Write(bw) // the writer handles noting errors</code></span>
<span class="codeline" id="line-410"><code>		}</code></span>
<span class="codeline" id="line-411"><code>		// final blank line after the trailers (whether</code></span>
<span class="codeline" id="line-412"><code>		// present or not)</code></span>
<span class="codeline" id="line-413"><code>		bw.WriteString("\r\n")</code></span>
<span class="codeline" id="line-414"><code>	}</code></span>
<span class="codeline" id="line-415"><code>}</code></span>
<span class="codeline" id="line-416"><code></code></span>
<span class="codeline" id="line-417"><code>// A response represents the server side of an HTTP response.</code></span>
<span class="codeline" id="line-418"><code>type response struct {</code></span>
<span class="codeline" id="line-419"><code>	conn             *conn</code></span>
<span class="codeline" id="line-420"><code>	req              *Request // request for this response</code></span>
<span class="codeline" id="line-421"><code>	reqBody          io.ReadCloser</code></span>
<span class="codeline" id="line-422"><code>	cancelCtx        context.CancelFunc // when ServeHTTP exits</code></span>
<span class="codeline" id="line-423"><code>	wroteHeader      bool               // reply header has been (logically) written</code></span>
<span class="codeline" id="line-424"><code>	wroteContinue    bool               // 100 Continue response was written</code></span>
<span class="codeline" id="line-425"><code>	wants10KeepAlive bool               // HTTP/1.0 w/ Connection "keep-alive"</code></span>
<span class="codeline" id="line-426"><code>	wantsClose       bool               // HTTP request has Connection "close"</code></span>
<span class="codeline" id="line-427"><code></code></span>
<span class="codeline" id="line-428"><code>	// canWriteContinue is a boolean value accessed as an atomic int32</code></span>
<span class="codeline" id="line-429"><code>	// that says whether or not a 100 Continue header can be written</code></span>
<span class="codeline" id="line-430"><code>	// to the connection.</code></span>
<span class="codeline" id="line-431"><code>	// writeContinueMu must be held while writing the header.</code></span>
<span class="codeline" id="line-432"><code>	// These two fields together synchronize the body reader</code></span>
<span class="codeline" id="line-433"><code>	// (the expectContinueReader, which wants to write 100 Continue)</code></span>
<span class="codeline" id="line-434"><code>	// against the main writer.</code></span>
<span class="codeline" id="line-435"><code>	canWriteContinue atomicBool</code></span>
<span class="codeline" id="line-436"><code>	writeContinueMu  sync.Mutex</code></span>
<span class="codeline" id="line-437"><code></code></span>
<span class="codeline" id="line-438"><code>	w  *bufio.Writer // buffers output in chunks to chunkWriter</code></span>
<span class="codeline" id="line-439"><code>	cw chunkWriter</code></span>
<span class="codeline" id="line-440"><code></code></span>
<span class="codeline" id="line-441"><code>	// handlerHeader is the Header that Handlers get access to,</code></span>
<span class="codeline" id="line-442"><code>	// which may be retained and mutated even after WriteHeader.</code></span>
<span class="codeline" id="line-443"><code>	// handlerHeader is copied into cw.header at WriteHeader</code></span>
<span class="codeline" id="line-444"><code>	// time, and privately mutated thereafter.</code></span>
<span class="codeline" id="line-445"><code>	handlerHeader Header</code></span>
<span class="codeline" id="line-446"><code>	calledHeader  bool // handler accessed handlerHeader via Header</code></span>
<span class="codeline" id="line-447"><code></code></span>
<span class="codeline" id="line-448"><code>	written       int64 // number of bytes written in body</code></span>
<span class="codeline" id="line-449"><code>	contentLength int64 // explicitly-declared Content-Length; or -1</code></span>
<span class="codeline" id="line-450"><code>	status        int   // status code passed to WriteHeader</code></span>
<span class="codeline" id="line-451"><code></code></span>
<span class="codeline" id="line-452"><code>	// close connection after this reply.  set on request and</code></span>
<span class="codeline" id="line-453"><code>	// updated after response from handler if there's a</code></span>
<span class="codeline" id="line-454"><code>	// "Connection: keep-alive" response header and a</code></span>
<span class="codeline" id="line-455"><code>	// Content-Length.</code></span>
<span class="codeline" id="line-456"><code>	closeAfterReply bool</code></span>
<span class="codeline" id="line-457"><code></code></span>
<span class="codeline" id="line-458"><code>	// requestBodyLimitHit is set by requestTooLarge when</code></span>
<span class="codeline" id="line-459"><code>	// maxBytesReader hits its max size. It is checked in</code></span>
<span class="codeline" id="line-460"><code>	// WriteHeader, to make sure we don't consume the</code></span>
<span class="codeline" id="line-461"><code>	// remaining request body to try to advance to the next HTTP</code></span>
<span class="codeline" id="line-462"><code>	// request. Instead, when this is set, we stop reading</code></span>
<span class="codeline" id="line-463"><code>	// subsequent requests on this connection and stop reading</code></span>
<span class="codeline" id="line-464"><code>	// input from it.</code></span>
<span class="codeline" id="line-465"><code>	requestBodyLimitHit bool</code></span>
<span class="codeline" id="line-466"><code></code></span>
<span class="codeline" id="line-467"><code>	// trailers are the headers to be sent after the handler</code></span>
<span class="codeline" id="line-468"><code>	// finishes writing the body. This field is initialized from</code></span>
<span class="codeline" id="line-469"><code>	// the Trailer response header when the response header is</code></span>
<span class="codeline" id="line-470"><code>	// written.</code></span>
<span class="codeline" id="line-471"><code>	trailers []string</code></span>
<span class="codeline" id="line-472"><code></code></span>
<span class="codeline" id="line-473"><code>	handlerDone atomicBool // set true when the handler exits</code></span>
<span class="codeline" id="line-474"><code></code></span>
<span class="codeline" id="line-475"><code>	// Buffers for Date, Content-Length, and status code</code></span>
<span class="codeline" id="line-476"><code>	dateBuf   [len(TimeFormat)]byte</code></span>
<span class="codeline" id="line-477"><code>	clenBuf   [10]byte</code></span>
<span class="codeline" id="line-478"><code>	statusBuf [3]byte</code></span>
<span class="codeline" id="line-479"><code></code></span>
<span class="codeline" id="line-480"><code>	// closeNotifyCh is the channel returned by CloseNotify.</code></span>
<span class="codeline" id="line-481"><code>	// TODO(bradfitz): this is currently (for Go 1.8) always</code></span>
<span class="codeline" id="line-482"><code>	// non-nil. Make this lazily-created again as it used to be?</code></span>
<span class="codeline" id="line-483"><code>	closeNotifyCh  chan bool</code></span>
<span class="codeline" id="line-484"><code>	didCloseNotify int32 // atomic (only 0-&gt;1 winner should send)</code></span>
<span class="codeline" id="line-485"><code>}</code></span>
<span class="codeline" id="line-486"><code></code></span>
<span class="codeline" id="line-487"><code>// TrailerPrefix is a magic prefix for ResponseWriter.Header map keys</code></span>
<span class="codeline" id="line-488"><code>// that, if present, signals that the map entry is actually for</code></span>
<span class="codeline" id="line-489"><code>// the response trailers, and not the response headers. The prefix</code></span>
<span class="codeline" id="line-490"><code>// is stripped after the ServeHTTP call finishes and the values are</code></span>
<span class="codeline" id="line-491"><code>// sent in the trailers.</code></span>
<span class="codeline" id="line-492"><code>//</code></span>
<span class="codeline" id="line-493"><code>// This mechanism is intended only for trailers that are not known</code></span>
<span class="codeline" id="line-494"><code>// prior to the headers being written. If the set of trailers is fixed</code></span>
<span class="codeline" id="line-495"><code>// or known before the header is written, the normal Go trailers mechanism</code></span>
<span class="codeline" id="line-496"><code>// is preferred:</code></span>
<span class="codeline" id="line-497"><code>//    https://golang.org/pkg/net/http/#ResponseWriter</code></span>
<span class="codeline" id="line-498"><code>//    https://golang.org/pkg/net/http/#example_ResponseWriter_trailers</code></span>
<span class="codeline" id="line-499"><code>const TrailerPrefix = "Trailer:"</code></span>
<span class="codeline" id="line-500"><code></code></span>
<span class="codeline" id="line-501"><code>// finalTrailers is called after the Handler exits and returns a non-nil</code></span>
<span class="codeline" id="line-502"><code>// value if the Handler set any trailers.</code></span>
<span class="codeline" id="line-503"><code>func (w *response) finalTrailers() Header {</code></span>
<span class="codeline" id="line-504"><code>	var t Header</code></span>
<span class="codeline" id="line-505"><code>	for k, vv := range w.handlerHeader {</code></span>
<span class="codeline" id="line-506"><code>		if strings.HasPrefix(k, TrailerPrefix) {</code></span>
<span class="codeline" id="line-507"><code>			if t == nil {</code></span>
<span class="codeline" id="line-508"><code>				t = make(Header)</code></span>
<span class="codeline" id="line-509"><code>			}</code></span>
<span class="codeline" id="line-510"><code>			t[strings.TrimPrefix(k, TrailerPrefix)] = vv</code></span>
<span class="codeline" id="line-511"><code>		}</code></span>
<span class="codeline" id="line-512"><code>	}</code></span>
<span class="codeline" id="line-513"><code>	for _, k := range w.trailers {</code></span>
<span class="codeline" id="line-514"><code>		if t == nil {</code></span>
<span class="codeline" id="line-515"><code>			t = make(Header)</code></span>
<span class="codeline" id="line-516"><code>		}</code></span>
<span class="codeline" id="line-517"><code>		for _, v := range w.handlerHeader[k] {</code></span>
<span class="codeline" id="line-518"><code>			t.Add(k, v)</code></span>
<span class="codeline" id="line-519"><code>		}</code></span>
<span class="codeline" id="line-520"><code>	}</code></span>
<span class="codeline" id="line-521"><code>	return t</code></span>
<span class="codeline" id="line-522"><code>}</code></span>
<span class="codeline" id="line-523"><code></code></span>
<span class="codeline" id="line-524"><code>type atomicBool int32</code></span>
<span class="codeline" id="line-525"><code></code></span>
<span class="codeline" id="line-526"><code>func (b *atomicBool) isSet() bool { return atomic.LoadInt32((*int32)(b)) != 0 }</code></span>
<span class="codeline" id="line-527"><code>func (b *atomicBool) setTrue()    { atomic.StoreInt32((*int32)(b), 1) }</code></span>
<span class="codeline" id="line-528"><code>func (b *atomicBool) setFalse()   { atomic.StoreInt32((*int32)(b), 0) }</code></span>
<span class="codeline" id="line-529"><code></code></span>
<span class="codeline" id="line-530"><code>// declareTrailer is called for each Trailer header when the</code></span>
<span class="codeline" id="line-531"><code>// response header is written. It notes that a header will need to be</code></span>
<span class="codeline" id="line-532"><code>// written in the trailers at the end of the response.</code></span>
<span class="codeline" id="line-533"><code>func (w *response) declareTrailer(k string) {</code></span>
<span class="codeline" id="line-534"><code>	k = CanonicalHeaderKey(k)</code></span>
<span class="codeline" id="line-535"><code>	if !httpguts.ValidTrailerHeader(k) {</code></span>
<span class="codeline" id="line-536"><code>		// Forbidden by RFC 7230, section 4.1.2</code></span>
<span class="codeline" id="line-537"><code>		return</code></span>
<span class="codeline" id="line-538"><code>	}</code></span>
<span class="codeline" id="line-539"><code>	w.trailers = append(w.trailers, k)</code></span>
<span class="codeline" id="line-540"><code>}</code></span>
<span class="codeline" id="line-541"><code></code></span>
<span class="codeline" id="line-542"><code>// requestTooLarge is called by maxBytesReader when too much input has</code></span>
<span class="codeline" id="line-543"><code>// been read from the client.</code></span>
<span class="codeline" id="line-544"><code>func (w *response) requestTooLarge() {</code></span>
<span class="codeline" id="line-545"><code>	w.closeAfterReply = true</code></span>
<span class="codeline" id="line-546"><code>	w.requestBodyLimitHit = true</code></span>
<span class="codeline" id="line-547"><code>	if !w.wroteHeader {</code></span>
<span class="codeline" id="line-548"><code>		w.Header().Set("Connection", "close")</code></span>
<span class="codeline" id="line-549"><code>	}</code></span>
<span class="codeline" id="line-550"><code>}</code></span>
<span class="codeline" id="line-551"><code></code></span>
<span class="codeline" id="line-552"><code>// needsSniff reports whether a Content-Type still needs to be sniffed.</code></span>
<span class="codeline" id="line-553"><code>func (w *response) needsSniff() bool {</code></span>
<span class="codeline" id="line-554"><code>	_, haveType := w.handlerHeader["Content-Type"]</code></span>
<span class="codeline" id="line-555"><code>	return !w.cw.wroteHeader &amp;&amp; !haveType &amp;&amp; w.written &lt; sniffLen</code></span>
<span class="codeline" id="line-556"><code>}</code></span>
<span class="codeline" id="line-557"><code></code></span>
<span class="codeline" id="line-558"><code>// writerOnly hides an io.Writer value's optional ReadFrom method</code></span>
<span class="codeline" id="line-559"><code>// from io.Copy.</code></span>
<span class="codeline" id="line-560"><code>type writerOnly struct {</code></span>
<span class="codeline" id="line-561"><code>	io.Writer</code></span>
<span class="codeline" id="line-562"><code>}</code></span>
<span class="codeline" id="line-563"><code></code></span>
<span class="codeline" id="line-564"><code>func srcIsRegularFile(src io.Reader) (isRegular bool, err error) {</code></span>
<span class="codeline" id="line-565"><code>	switch v := src.(type) {</code></span>
<span class="codeline" id="line-566"><code>	case *os.File:</code></span>
<span class="codeline" id="line-567"><code>		fi, err := v.Stat()</code></span>
<span class="codeline" id="line-568"><code>		if err != nil {</code></span>
<span class="codeline" id="line-569"><code>			return false, err</code></span>
<span class="codeline" id="line-570"><code>		}</code></span>
<span class="codeline" id="line-571"><code>		return fi.Mode().IsRegular(), nil</code></span>
<span class="codeline" id="line-572"><code>	case *io.LimitedReader:</code></span>
<span class="codeline" id="line-573"><code>		return srcIsRegularFile(v.R)</code></span>
<span class="codeline" id="line-574"><code>	default:</code></span>
<span class="codeline" id="line-575"><code>		return</code></span>
<span class="codeline" id="line-576"><code>	}</code></span>
<span class="codeline" id="line-577"><code>}</code></span>
<span class="codeline" id="line-578"><code></code></span>
<span class="codeline" id="line-579"><code>// ReadFrom is here to optimize copying from an *os.File regular file</code></span>
<span class="codeline" id="line-580"><code>// to a *net.TCPConn with sendfile.</code></span>
<span class="codeline" id="line-581"><code>func (w *response) ReadFrom(src io.Reader) (n int64, err error) {</code></span>
<span class="codeline" id="line-582"><code>	// Our underlying w.conn.rwc is usually a *TCPConn (with its</code></span>
<span class="codeline" id="line-583"><code>	// own ReadFrom method). If not, or if our src isn't a regular</code></span>
<span class="codeline" id="line-584"><code>	// file, just fall back to the normal copy method.</code></span>
<span class="codeline" id="line-585"><code>	rf, ok := w.conn.rwc.(io.ReaderFrom)</code></span>
<span class="codeline" id="line-586"><code>	regFile, err := srcIsRegularFile(src)</code></span>
<span class="codeline" id="line-587"><code>	if err != nil {</code></span>
<span class="codeline" id="line-588"><code>		return 0, err</code></span>
<span class="codeline" id="line-589"><code>	}</code></span>
<span class="codeline" id="line-590"><code>	if !ok || !regFile {</code></span>
<span class="codeline" id="line-591"><code>		bufp := copyBufPool.Get().(*[]byte)</code></span>
<span class="codeline" id="line-592"><code>		defer copyBufPool.Put(bufp)</code></span>
<span class="codeline" id="line-593"><code>		return io.CopyBuffer(writerOnly{w}, src, *bufp)</code></span>
<span class="codeline" id="line-594"><code>	}</code></span>
<span class="codeline" id="line-595"><code></code></span>
<span class="codeline" id="line-596"><code>	// sendfile path:</code></span>
<span class="codeline" id="line-597"><code></code></span>
<span class="codeline" id="line-598"><code>	if !w.wroteHeader {</code></span>
<span class="codeline" id="line-599"><code>		w.WriteHeader(StatusOK)</code></span>
<span class="codeline" id="line-600"><code>	}</code></span>
<span class="codeline" id="line-601"><code></code></span>
<span class="codeline" id="line-602"><code>	if w.needsSniff() {</code></span>
<span class="codeline" id="line-603"><code>		n0, err := io.Copy(writerOnly{w}, io.LimitReader(src, sniffLen))</code></span>
<span class="codeline" id="line-604"><code>		n += n0</code></span>
<span class="codeline" id="line-605"><code>		if err != nil {</code></span>
<span class="codeline" id="line-606"><code>			return n, err</code></span>
<span class="codeline" id="line-607"><code>		}</code></span>
<span class="codeline" id="line-608"><code>	}</code></span>
<span class="codeline" id="line-609"><code></code></span>
<span class="codeline" id="line-610"><code>	w.w.Flush()  // get rid of any previous writes</code></span>
<span class="codeline" id="line-611"><code>	w.cw.flush() // make sure Header is written; flush data to rwc</code></span>
<span class="codeline" id="line-612"><code></code></span>
<span class="codeline" id="line-613"><code>	// Now that cw has been flushed, its chunking field is guaranteed initialized.</code></span>
<span class="codeline" id="line-614"><code>	if !w.cw.chunking &amp;&amp; w.bodyAllowed() {</code></span>
<span class="codeline" id="line-615"><code>		n0, err := rf.ReadFrom(src)</code></span>
<span class="codeline" id="line-616"><code>		n += n0</code></span>
<span class="codeline" id="line-617"><code>		w.written += n0</code></span>
<span class="codeline" id="line-618"><code>		return n, err</code></span>
<span class="codeline" id="line-619"><code>	}</code></span>
<span class="codeline" id="line-620"><code></code></span>
<span class="codeline" id="line-621"><code>	n0, err := io.Copy(writerOnly{w}, src)</code></span>
<span class="codeline" id="line-622"><code>	n += n0</code></span>
<span class="codeline" id="line-623"><code>	return n, err</code></span>
<span class="codeline" id="line-624"><code>}</code></span>
<span class="codeline" id="line-625"><code></code></span>
<span class="codeline" id="line-626"><code>// debugServerConnections controls whether all server connections are wrapped</code></span>
<span class="codeline" id="line-627"><code>// with a verbose logging wrapper.</code></span>
<span class="codeline" id="line-628"><code>const debugServerConnections = false</code></span>
<span class="codeline" id="line-629"><code></code></span>
<span class="codeline" id="line-630"><code>// Create new connection from rwc.</code></span>
<span class="codeline" id="line-631"><code>func (srv *Server) newConn(rwc net.Conn) *conn {</code></span>
<span class="codeline" id="line-632"><code>	c := &amp;conn{</code></span>
<span class="codeline" id="line-633"><code>		server: srv,</code></span>
<span class="codeline" id="line-634"><code>		rwc:    rwc,</code></span>
<span class="codeline" id="line-635"><code>	}</code></span>
<span class="codeline" id="line-636"><code>	if debugServerConnections {</code></span>
<span class="codeline" id="line-637"><code>		c.rwc = newLoggingConn("server", c.rwc)</code></span>
<span class="codeline" id="line-638"><code>	}</code></span>
<span class="codeline" id="line-639"><code>	return c</code></span>
<span class="codeline" id="line-640"><code>}</code></span>
<span class="codeline" id="line-641"><code></code></span>
<span class="codeline" id="line-642"><code>type readResult struct {</code></span>
<span class="codeline" id="line-643"><code>	_   incomparable</code></span>
<span class="codeline" id="line-644"><code>	n   int</code></span>
<span class="codeline" id="line-645"><code>	err error</code></span>
<span class="codeline" id="line-646"><code>	b   byte // byte read, if n == 1</code></span>
<span class="codeline" id="line-647"><code>}</code></span>
<span class="codeline" id="line-648"><code></code></span>
<span class="codeline" id="line-649"><code>// connReader is the io.Reader wrapper used by *conn. It combines a</code></span>
<span class="codeline" id="line-650"><code>// selectively-activated io.LimitedReader (to bound request header</code></span>
<span class="codeline" id="line-651"><code>// read sizes) with support for selectively keeping an io.Reader.Read</code></span>
<span class="codeline" id="line-652"><code>// call blocked in a background goroutine to wait for activity and</code></span>
<span class="codeline" id="line-653"><code>// trigger a CloseNotifier channel.</code></span>
<span class="codeline" id="line-654"><code>type connReader struct {</code></span>
<span class="codeline" id="line-655"><code>	conn *conn</code></span>
<span class="codeline" id="line-656"><code></code></span>
<span class="codeline" id="line-657"><code>	mu      sync.Mutex // guards following</code></span>
<span class="codeline" id="line-658"><code>	hasByte bool</code></span>
<span class="codeline" id="line-659"><code>	byteBuf [1]byte</code></span>
<span class="codeline" id="line-660"><code>	cond    *sync.Cond</code></span>
<span class="codeline" id="line-661"><code>	inRead  bool</code></span>
<span class="codeline" id="line-662"><code>	aborted bool  // set true before conn.rwc deadline is set to past</code></span>
<span class="codeline" id="line-663"><code>	remain  int64 // bytes remaining</code></span>
<span class="codeline" id="line-664"><code>}</code></span>
<span class="codeline" id="line-665"><code></code></span>
<span class="codeline" id="line-666"><code>func (cr *connReader) lock() {</code></span>
<span class="codeline" id="line-667"><code>	cr.mu.Lock()</code></span>
<span class="codeline" id="line-668"><code>	if cr.cond == nil {</code></span>
<span class="codeline" id="line-669"><code>		cr.cond = sync.NewCond(&amp;cr.mu)</code></span>
<span class="codeline" id="line-670"><code>	}</code></span>
<span class="codeline" id="line-671"><code>}</code></span>
<span class="codeline" id="line-672"><code></code></span>
<span class="codeline" id="line-673"><code>func (cr *connReader) unlock() { cr.mu.Unlock() }</code></span>
<span class="codeline" id="line-674"><code></code></span>
<span class="codeline" id="line-675"><code>func (cr *connReader) startBackgroundRead() {</code></span>
<span class="codeline" id="line-676"><code>	cr.lock()</code></span>
<span class="codeline" id="line-677"><code>	defer cr.unlock()</code></span>
<span class="codeline" id="line-678"><code>	if cr.inRead {</code></span>
<span class="codeline" id="line-679"><code>		panic("invalid concurrent Body.Read call")</code></span>
<span class="codeline" id="line-680"><code>	}</code></span>
<span class="codeline" id="line-681"><code>	if cr.hasByte {</code></span>
<span class="codeline" id="line-682"><code>		return</code></span>
<span class="codeline" id="line-683"><code>	}</code></span>
<span class="codeline" id="line-684"><code>	cr.inRead = true</code></span>
<span class="codeline" id="line-685"><code>	cr.conn.rwc.SetReadDeadline(time.Time{})</code></span>
<span class="codeline" id="line-686"><code>	go cr.backgroundRead()</code></span>
<span class="codeline" id="line-687"><code>}</code></span>
<span class="codeline" id="line-688"><code></code></span>
<span class="codeline" id="line-689"><code>func (cr *connReader) backgroundRead() {</code></span>
<span class="codeline" id="line-690"><code>	n, err := cr.conn.rwc.Read(cr.byteBuf[:])</code></span>
<span class="codeline" id="line-691"><code>	cr.lock()</code></span>
<span class="codeline" id="line-692"><code>	if n == 1 {</code></span>
<span class="codeline" id="line-693"><code>		cr.hasByte = true</code></span>
<span class="codeline" id="line-694"><code>		// We were past the end of the previous request's body already</code></span>
<span class="codeline" id="line-695"><code>		// (since we wouldn't be in a background read otherwise), so</code></span>
<span class="codeline" id="line-696"><code>		// this is a pipelined HTTP request. Prior to Go 1.11 we used to</code></span>
<span class="codeline" id="line-697"><code>		// send on the CloseNotify channel and cancel the context here,</code></span>
<span class="codeline" id="line-698"><code>		// but the behavior was documented as only "may", and we only</code></span>
<span class="codeline" id="line-699"><code>		// did that because that's how CloseNotify accidentally behaved</code></span>
<span class="codeline" id="line-700"><code>		// in very early Go releases prior to context support. Once we</code></span>
<span class="codeline" id="line-701"><code>		// added context support, people used a Handler's</code></span>
<span class="codeline" id="line-702"><code>		// Request.Context() and passed it along. Having that context</code></span>
<span class="codeline" id="line-703"><code>		// cancel on pipelined HTTP requests caused problems.</code></span>
<span class="codeline" id="line-704"><code>		// Fortunately, almost nothing uses HTTP/1.x pipelining.</code></span>
<span class="codeline" id="line-705"><code>		// Unfortunately, apt-get does, or sometimes does.</code></span>
<span class="codeline" id="line-706"><code>		// New Go 1.11 behavior: don't fire CloseNotify or cancel</code></span>
<span class="codeline" id="line-707"><code>		// contexts on pipelined requests. Shouldn't affect people, but</code></span>
<span class="codeline" id="line-708"><code>		// fixes cases like Issue 23921. This does mean that a client</code></span>
<span class="codeline" id="line-709"><code>		// closing their TCP connection after sending a pipelined</code></span>
<span class="codeline" id="line-710"><code>		// request won't cancel the context, but we'll catch that on any</code></span>
<span class="codeline" id="line-711"><code>		// write failure (in checkConnErrorWriter.Write).</code></span>
<span class="codeline" id="line-712"><code>		// If the server never writes, yes, there are still contrived</code></span>
<span class="codeline" id="line-713"><code>		// server &amp; client behaviors where this fails to ever cancel the</code></span>
<span class="codeline" id="line-714"><code>		// context, but that's kinda why HTTP/1.x pipelining died</code></span>
<span class="codeline" id="line-715"><code>		// anyway.</code></span>
<span class="codeline" id="line-716"><code>	}</code></span>
<span class="codeline" id="line-717"><code>	if ne, ok := err.(net.Error); ok &amp;&amp; cr.aborted &amp;&amp; ne.Timeout() {</code></span>
<span class="codeline" id="line-718"><code>		// Ignore this error. It's the expected error from</code></span>
<span class="codeline" id="line-719"><code>		// another goroutine calling abortPendingRead.</code></span>
<span class="codeline" id="line-720"><code>	} else if err != nil {</code></span>
<span class="codeline" id="line-721"><code>		cr.handleReadError(err)</code></span>
<span class="codeline" id="line-722"><code>	}</code></span>
<span class="codeline" id="line-723"><code>	cr.aborted = false</code></span>
<span class="codeline" id="line-724"><code>	cr.inRead = false</code></span>
<span class="codeline" id="line-725"><code>	cr.unlock()</code></span>
<span class="codeline" id="line-726"><code>	cr.cond.Broadcast()</code></span>
<span class="codeline" id="line-727"><code>}</code></span>
<span class="codeline" id="line-728"><code></code></span>
<span class="codeline" id="line-729"><code>func (cr *connReader) abortPendingRead() {</code></span>
<span class="codeline" id="line-730"><code>	cr.lock()</code></span>
<span class="codeline" id="line-731"><code>	defer cr.unlock()</code></span>
<span class="codeline" id="line-732"><code>	if !cr.inRead {</code></span>
<span class="codeline" id="line-733"><code>		return</code></span>
<span class="codeline" id="line-734"><code>	}</code></span>
<span class="codeline" id="line-735"><code>	cr.aborted = true</code></span>
<span class="codeline" id="line-736"><code>	cr.conn.rwc.SetReadDeadline(aLongTimeAgo)</code></span>
<span class="codeline" id="line-737"><code>	for cr.inRead {</code></span>
<span class="codeline" id="line-738"><code>		cr.cond.Wait()</code></span>
<span class="codeline" id="line-739"><code>	}</code></span>
<span class="codeline" id="line-740"><code>	cr.conn.rwc.SetReadDeadline(time.Time{})</code></span>
<span class="codeline" id="line-741"><code>}</code></span>
<span class="codeline" id="line-742"><code></code></span>
<span class="codeline" id="line-743"><code>func (cr *connReader) setReadLimit(remain int64) { cr.remain = remain }</code></span>
<span class="codeline" id="line-744"><code>func (cr *connReader) setInfiniteReadLimit()     { cr.remain = maxInt64 }</code></span>
<span class="codeline" id="line-745"><code>func (cr *connReader) hitReadLimit() bool        { return cr.remain &lt;= 0 }</code></span>
<span class="codeline" id="line-746"><code></code></span>
<span class="codeline" id="line-747"><code>// handleReadError is called whenever a Read from the client returns a</code></span>
<span class="codeline" id="line-748"><code>// non-nil error.</code></span>
<span class="codeline" id="line-749"><code>//</code></span>
<span class="codeline" id="line-750"><code>// The provided non-nil err is almost always io.EOF or a "use of</code></span>
<span class="codeline" id="line-751"><code>// closed network connection". In any case, the error is not</code></span>
<span class="codeline" id="line-752"><code>// particularly interesting, except perhaps for debugging during</code></span>
<span class="codeline" id="line-753"><code>// development. Any error means the connection is dead and we should</code></span>
<span class="codeline" id="line-754"><code>// down its context.</code></span>
<span class="codeline" id="line-755"><code>//</code></span>
<span class="codeline" id="line-756"><code>// It may be called from multiple goroutines.</code></span>
<span class="codeline" id="line-757"><code>func (cr *connReader) handleReadError(_ error) {</code></span>
<span class="codeline" id="line-758"><code>	cr.conn.cancelCtx()</code></span>
<span class="codeline" id="line-759"><code>	cr.closeNotify()</code></span>
<span class="codeline" id="line-760"><code>}</code></span>
<span class="codeline" id="line-761"><code></code></span>
<span class="codeline" id="line-762"><code>// may be called from multiple goroutines.</code></span>
<span class="codeline" id="line-763"><code>func (cr *connReader) closeNotify() {</code></span>
<span class="codeline" id="line-764"><code>	res, _ := cr.conn.curReq.Load().(*response)</code></span>
<span class="codeline" id="line-765"><code>	if res != nil &amp;&amp; atomic.CompareAndSwapInt32(&amp;res.didCloseNotify, 0, 1) {</code></span>
<span class="codeline" id="line-766"><code>		res.closeNotifyCh &lt;- true</code></span>
<span class="codeline" id="line-767"><code>	}</code></span>
<span class="codeline" id="line-768"><code>}</code></span>
<span class="codeline" id="line-769"><code></code></span>
<span class="codeline" id="line-770"><code>func (cr *connReader) Read(p []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-771"><code>	cr.lock()</code></span>
<span class="codeline" id="line-772"><code>	if cr.inRead {</code></span>
<span class="codeline" id="line-773"><code>		cr.unlock()</code></span>
<span class="codeline" id="line-774"><code>		if cr.conn.hijacked() {</code></span>
<span class="codeline" id="line-775"><code>			panic("invalid Body.Read call. After hijacked, the original Request must not be used")</code></span>
<span class="codeline" id="line-776"><code>		}</code></span>
<span class="codeline" id="line-777"><code>		panic("invalid concurrent Body.Read call")</code></span>
<span class="codeline" id="line-778"><code>	}</code></span>
<span class="codeline" id="line-779"><code>	if cr.hitReadLimit() {</code></span>
<span class="codeline" id="line-780"><code>		cr.unlock()</code></span>
<span class="codeline" id="line-781"><code>		return 0, io.EOF</code></span>
<span class="codeline" id="line-782"><code>	}</code></span>
<span class="codeline" id="line-783"><code>	if len(p) == 0 {</code></span>
<span class="codeline" id="line-784"><code>		cr.unlock()</code></span>
<span class="codeline" id="line-785"><code>		return 0, nil</code></span>
<span class="codeline" id="line-786"><code>	}</code></span>
<span class="codeline" id="line-787"><code>	if int64(len(p)) &gt; cr.remain {</code></span>
<span class="codeline" id="line-788"><code>		p = p[:cr.remain]</code></span>
<span class="codeline" id="line-789"><code>	}</code></span>
<span class="codeline" id="line-790"><code>	if cr.hasByte {</code></span>
<span class="codeline" id="line-791"><code>		p[0] = cr.byteBuf[0]</code></span>
<span class="codeline" id="line-792"><code>		cr.hasByte = false</code></span>
<span class="codeline" id="line-793"><code>		cr.unlock()</code></span>
<span class="codeline" id="line-794"><code>		return 1, nil</code></span>
<span class="codeline" id="line-795"><code>	}</code></span>
<span class="codeline" id="line-796"><code>	cr.inRead = true</code></span>
<span class="codeline" id="line-797"><code>	cr.unlock()</code></span>
<span class="codeline" id="line-798"><code>	n, err = cr.conn.rwc.Read(p)</code></span>
<span class="codeline" id="line-799"><code></code></span>
<span class="codeline" id="line-800"><code>	cr.lock()</code></span>
<span class="codeline" id="line-801"><code>	cr.inRead = false</code></span>
<span class="codeline" id="line-802"><code>	if err != nil {</code></span>
<span class="codeline" id="line-803"><code>		cr.handleReadError(err)</code></span>
<span class="codeline" id="line-804"><code>	}</code></span>
<span class="codeline" id="line-805"><code>	cr.remain -= int64(n)</code></span>
<span class="codeline" id="line-806"><code>	cr.unlock()</code></span>
<span class="codeline" id="line-807"><code></code></span>
<span class="codeline" id="line-808"><code>	cr.cond.Broadcast()</code></span>
<span class="codeline" id="line-809"><code>	return n, err</code></span>
<span class="codeline" id="line-810"><code>}</code></span>
<span class="codeline" id="line-811"><code></code></span>
<span class="codeline" id="line-812"><code>var (</code></span>
<span class="codeline" id="line-813"><code>	bufioReaderPool   sync.Pool</code></span>
<span class="codeline" id="line-814"><code>	bufioWriter2kPool sync.Pool</code></span>
<span class="codeline" id="line-815"><code>	bufioWriter4kPool sync.Pool</code></span>
<span class="codeline" id="line-816"><code>)</code></span>
<span class="codeline" id="line-817"><code></code></span>
<span class="codeline" id="line-818"><code>var copyBufPool = sync.Pool{</code></span>
<span class="codeline" id="line-819"><code>	New: func() interface{} {</code></span>
<span class="codeline" id="line-820"><code>		b := make([]byte, 32*1024)</code></span>
<span class="codeline" id="line-821"><code>		return &amp;b</code></span>
<span class="codeline" id="line-822"><code>	},</code></span>
<span class="codeline" id="line-823"><code>}</code></span>
<span class="codeline" id="line-824"><code></code></span>
<span class="codeline" id="line-825"><code>func bufioWriterPool(size int) *sync.Pool {</code></span>
<span class="codeline" id="line-826"><code>	switch size {</code></span>
<span class="codeline" id="line-827"><code>	case 2 &lt;&lt; 10:</code></span>
<span class="codeline" id="line-828"><code>		return &amp;bufioWriter2kPool</code></span>
<span class="codeline" id="line-829"><code>	case 4 &lt;&lt; 10:</code></span>
<span class="codeline" id="line-830"><code>		return &amp;bufioWriter4kPool</code></span>
<span class="codeline" id="line-831"><code>	}</code></span>
<span class="codeline" id="line-832"><code>	return nil</code></span>
<span class="codeline" id="line-833"><code>}</code></span>
<span class="codeline" id="line-834"><code></code></span>
<span class="codeline" id="line-835"><code>func newBufioReader(r io.Reader) *bufio.Reader {</code></span>
<span class="codeline" id="line-836"><code>	if v := bufioReaderPool.Get(); v != nil {</code></span>
<span class="codeline" id="line-837"><code>		br := v.(*bufio.Reader)</code></span>
<span class="codeline" id="line-838"><code>		br.Reset(r)</code></span>
<span class="codeline" id="line-839"><code>		return br</code></span>
<span class="codeline" id="line-840"><code>	}</code></span>
<span class="codeline" id="line-841"><code>	// Note: if this reader size is ever changed, update</code></span>
<span class="codeline" id="line-842"><code>	// TestHandlerBodyClose's assumptions.</code></span>
<span class="codeline" id="line-843"><code>	return bufio.NewReader(r)</code></span>
<span class="codeline" id="line-844"><code>}</code></span>
<span class="codeline" id="line-845"><code></code></span>
<span class="codeline" id="line-846"><code>func putBufioReader(br *bufio.Reader) {</code></span>
<span class="codeline" id="line-847"><code>	br.Reset(nil)</code></span>
<span class="codeline" id="line-848"><code>	bufioReaderPool.Put(br)</code></span>
<span class="codeline" id="line-849"><code>}</code></span>
<span class="codeline" id="line-850"><code></code></span>
<span class="codeline" id="line-851"><code>func newBufioWriterSize(w io.Writer, size int) *bufio.Writer {</code></span>
<span class="codeline" id="line-852"><code>	pool := bufioWriterPool(size)</code></span>
<span class="codeline" id="line-853"><code>	if pool != nil {</code></span>
<span class="codeline" id="line-854"><code>		if v := pool.Get(); v != nil {</code></span>
<span class="codeline" id="line-855"><code>			bw := v.(*bufio.Writer)</code></span>
<span class="codeline" id="line-856"><code>			bw.Reset(w)</code></span>
<span class="codeline" id="line-857"><code>			return bw</code></span>
<span class="codeline" id="line-858"><code>		}</code></span>
<span class="codeline" id="line-859"><code>	}</code></span>
<span class="codeline" id="line-860"><code>	return bufio.NewWriterSize(w, size)</code></span>
<span class="codeline" id="line-861"><code>}</code></span>
<span class="codeline" id="line-862"><code></code></span>
<span class="codeline" id="line-863"><code>func putBufioWriter(bw *bufio.Writer) {</code></span>
<span class="codeline" id="line-864"><code>	bw.Reset(nil)</code></span>
<span class="codeline" id="line-865"><code>	if pool := bufioWriterPool(bw.Available()); pool != nil {</code></span>
<span class="codeline" id="line-866"><code>		pool.Put(bw)</code></span>
<span class="codeline" id="line-867"><code>	}</code></span>
<span class="codeline" id="line-868"><code>}</code></span>
<span class="codeline" id="line-869"><code></code></span>
<span class="codeline" id="line-870"><code>// DefaultMaxHeaderBytes is the maximum permitted size of the headers</code></span>
<span class="codeline" id="line-871"><code>// in an HTTP request.</code></span>
<span class="codeline" id="line-872"><code>// This can be overridden by setting Server.MaxHeaderBytes.</code></span>
<span class="codeline" id="line-873"><code>const DefaultMaxHeaderBytes = 1 &lt;&lt; 20 // 1 MB</code></span>
<span class="codeline" id="line-874"><code></code></span>
<span class="codeline" id="line-875"><code>func (srv *Server) maxHeaderBytes() int {</code></span>
<span class="codeline" id="line-876"><code>	if srv.MaxHeaderBytes &gt; 0 {</code></span>
<span class="codeline" id="line-877"><code>		return srv.MaxHeaderBytes</code></span>
<span class="codeline" id="line-878"><code>	}</code></span>
<span class="codeline" id="line-879"><code>	return DefaultMaxHeaderBytes</code></span>
<span class="codeline" id="line-880"><code>}</code></span>
<span class="codeline" id="line-881"><code></code></span>
<span class="codeline" id="line-882"><code>func (srv *Server) initialReadLimitSize() int64 {</code></span>
<span class="codeline" id="line-883"><code>	return int64(srv.maxHeaderBytes()) + 4096 // bufio slop</code></span>
<span class="codeline" id="line-884"><code>}</code></span>
<span class="codeline" id="line-885"><code></code></span>
<span class="codeline" id="line-886"><code>// wrapper around io.ReadCloser which on first read, sends an</code></span>
<span class="codeline" id="line-887"><code>// HTTP/1.1 100 Continue header</code></span>
<span class="codeline" id="line-888"><code>type expectContinueReader struct {</code></span>
<span class="codeline" id="line-889"><code>	resp       *response</code></span>
<span class="codeline" id="line-890"><code>	readCloser io.ReadCloser</code></span>
<span class="codeline" id="line-891"><code>	closed     bool</code></span>
<span class="codeline" id="line-892"><code>	sawEOF     atomicBool</code></span>
<span class="codeline" id="line-893"><code>}</code></span>
<span class="codeline" id="line-894"><code></code></span>
<span class="codeline" id="line-895"><code>func (ecr *expectContinueReader) Read(p []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-896"><code>	if ecr.closed {</code></span>
<span class="codeline" id="line-897"><code>		return 0, ErrBodyReadAfterClose</code></span>
<span class="codeline" id="line-898"><code>	}</code></span>
<span class="codeline" id="line-899"><code>	w := ecr.resp</code></span>
<span class="codeline" id="line-900"><code>	if !w.wroteContinue &amp;&amp; w.canWriteContinue.isSet() &amp;&amp; !w.conn.hijacked() {</code></span>
<span class="codeline" id="line-901"><code>		w.wroteContinue = true</code></span>
<span class="codeline" id="line-902"><code>		w.writeContinueMu.Lock()</code></span>
<span class="codeline" id="line-903"><code>		if w.canWriteContinue.isSet() {</code></span>
<span class="codeline" id="line-904"><code>			w.conn.bufw.WriteString("HTTP/1.1 100 Continue\r\n\r\n")</code></span>
<span class="codeline" id="line-905"><code>			w.conn.bufw.Flush()</code></span>
<span class="codeline" id="line-906"><code>			w.canWriteContinue.setFalse()</code></span>
<span class="codeline" id="line-907"><code>		}</code></span>
<span class="codeline" id="line-908"><code>		w.writeContinueMu.Unlock()</code></span>
<span class="codeline" id="line-909"><code>	}</code></span>
<span class="codeline" id="line-910"><code>	n, err = ecr.readCloser.Read(p)</code></span>
<span class="codeline" id="line-911"><code>	if err == io.EOF {</code></span>
<span class="codeline" id="line-912"><code>		ecr.sawEOF.setTrue()</code></span>
<span class="codeline" id="line-913"><code>	}</code></span>
<span class="codeline" id="line-914"><code>	return</code></span>
<span class="codeline" id="line-915"><code>}</code></span>
<span class="codeline" id="line-916"><code></code></span>
<span class="codeline" id="line-917"><code>func (ecr *expectContinueReader) Close() error {</code></span>
<span class="codeline" id="line-918"><code>	ecr.closed = true</code></span>
<span class="codeline" id="line-919"><code>	return ecr.readCloser.Close()</code></span>
<span class="codeline" id="line-920"><code>}</code></span>
<span class="codeline" id="line-921"><code></code></span>
<span class="codeline" id="line-922"><code>// TimeFormat is the time format to use when generating times in HTTP</code></span>
<span class="codeline" id="line-923"><code>// headers. It is like time.RFC1123 but hard-codes GMT as the time</code></span>
<span class="codeline" id="line-924"><code>// zone. The time being formatted must be in UTC for Format to</code></span>
<span class="codeline" id="line-925"><code>// generate the correct format.</code></span>
<span class="codeline" id="line-926"><code>//</code></span>
<span class="codeline" id="line-927"><code>// For parsing this time format, see ParseTime.</code></span>
<span class="codeline" id="line-928"><code>const TimeFormat = "Mon, 02 Jan 2006 15:04:05 GMT"</code></span>
<span class="codeline" id="line-929"><code></code></span>
<span class="codeline" id="line-930"><code>// appendTime is a non-allocating version of []byte(t.UTC().Format(TimeFormat))</code></span>
<span class="codeline" id="line-931"><code>func appendTime(b []byte, t time.Time) []byte {</code></span>
<span class="codeline" id="line-932"><code>	const days = "SunMonTueWedThuFriSat"</code></span>
<span class="codeline" id="line-933"><code>	const months = "JanFebMarAprMayJunJulAugSepOctNovDec"</code></span>
<span class="codeline" id="line-934"><code></code></span>
<span class="codeline" id="line-935"><code>	t = t.UTC()</code></span>
<span class="codeline" id="line-936"><code>	yy, mm, dd := t.Date()</code></span>
<span class="codeline" id="line-937"><code>	hh, mn, ss := t.Clock()</code></span>
<span class="codeline" id="line-938"><code>	day := days[3*t.Weekday():]</code></span>
<span class="codeline" id="line-939"><code>	mon := months[3*(mm-1):]</code></span>
<span class="codeline" id="line-940"><code></code></span>
<span class="codeline" id="line-941"><code>	return append(b,</code></span>
<span class="codeline" id="line-942"><code>		day[0], day[1], day[2], ',', ' ',</code></span>
<span class="codeline" id="line-943"><code>		byte('0'+dd/10), byte('0'+dd%10), ' ',</code></span>
<span class="codeline" id="line-944"><code>		mon[0], mon[1], mon[2], ' ',</code></span>
<span class="codeline" id="line-945"><code>		byte('0'+yy/1000), byte('0'+(yy/100)%10), byte('0'+(yy/10)%10), byte('0'+yy%10), ' ',</code></span>
<span class="codeline" id="line-946"><code>		byte('0'+hh/10), byte('0'+hh%10), ':',</code></span>
<span class="codeline" id="line-947"><code>		byte('0'+mn/10), byte('0'+mn%10), ':',</code></span>
<span class="codeline" id="line-948"><code>		byte('0'+ss/10), byte('0'+ss%10), ' ',</code></span>
<span class="codeline" id="line-949"><code>		'G', 'M', 'T')</code></span>
<span class="codeline" id="line-950"><code>}</code></span>
<span class="codeline" id="line-951"><code></code></span>
<span class="codeline" id="line-952"><code>var errTooLarge = errors.New("http: request too large")</code></span>
<span class="codeline" id="line-953"><code></code></span>
<span class="codeline" id="line-954"><code>// Read next request from connection.</code></span>
<span class="codeline" id="line-955"><code>func (c *conn) readRequest(ctx context.Context) (w *response, err error) {</code></span>
<span class="codeline" id="line-956"><code>	if c.hijacked() {</code></span>
<span class="codeline" id="line-957"><code>		return nil, ErrHijacked</code></span>
<span class="codeline" id="line-958"><code>	}</code></span>
<span class="codeline" id="line-959"><code></code></span>
<span class="codeline" id="line-960"><code>	var (</code></span>
<span class="codeline" id="line-961"><code>		wholeReqDeadline time.Time // or zero if none</code></span>
<span class="codeline" id="line-962"><code>		hdrDeadline      time.Time // or zero if none</code></span>
<span class="codeline" id="line-963"><code>	)</code></span>
<span class="codeline" id="line-964"><code>	t0 := time.Now()</code></span>
<span class="codeline" id="line-965"><code>	if d := c.server.readHeaderTimeout(); d != 0 {</code></span>
<span class="codeline" id="line-966"><code>		hdrDeadline = t0.Add(d)</code></span>
<span class="codeline" id="line-967"><code>	}</code></span>
<span class="codeline" id="line-968"><code>	if d := c.server.ReadTimeout; d != 0 {</code></span>
<span class="codeline" id="line-969"><code>		wholeReqDeadline = t0.Add(d)</code></span>
<span class="codeline" id="line-970"><code>	}</code></span>
<span class="codeline" id="line-971"><code>	c.rwc.SetReadDeadline(hdrDeadline)</code></span>
<span class="codeline" id="line-972"><code>	if d := c.server.WriteTimeout; d != 0 {</code></span>
<span class="codeline" id="line-973"><code>		defer func() {</code></span>
<span class="codeline" id="line-974"><code>			c.rwc.SetWriteDeadline(time.Now().Add(d))</code></span>
<span class="codeline" id="line-975"><code>		}()</code></span>
<span class="codeline" id="line-976"><code>	}</code></span>
<span class="codeline" id="line-977"><code></code></span>
<span class="codeline" id="line-978"><code>	c.r.setReadLimit(c.server.initialReadLimitSize())</code></span>
<span class="codeline" id="line-979"><code>	if c.lastMethod == "POST" {</code></span>
<span class="codeline" id="line-980"><code>		// RFC 7230 section 3 tolerance for old buggy clients.</code></span>
<span class="codeline" id="line-981"><code>		peek, _ := c.bufr.Peek(4) // ReadRequest will get err below</code></span>
<span class="codeline" id="line-982"><code>		c.bufr.Discard(numLeadingCRorLF(peek))</code></span>
<span class="codeline" id="line-983"><code>	}</code></span>
<span class="codeline" id="line-984"><code>	req, err := readRequest(c.bufr, keepHostHeader)</code></span>
<span class="codeline" id="line-985"><code>	if err != nil {</code></span>
<span class="codeline" id="line-986"><code>		if c.r.hitReadLimit() {</code></span>
<span class="codeline" id="line-987"><code>			return nil, errTooLarge</code></span>
<span class="codeline" id="line-988"><code>		}</code></span>
<span class="codeline" id="line-989"><code>		return nil, err</code></span>
<span class="codeline" id="line-990"><code>	}</code></span>
<span class="codeline" id="line-991"><code></code></span>
<span class="codeline" id="line-992"><code>	if !http1ServerSupportsRequest(req) {</code></span>
<span class="codeline" id="line-993"><code>		return nil, badRequestError("unsupported protocol version")</code></span>
<span class="codeline" id="line-994"><code>	}</code></span>
<span class="codeline" id="line-995"><code></code></span>
<span class="codeline" id="line-996"><code>	c.lastMethod = req.Method</code></span>
<span class="codeline" id="line-997"><code>	c.r.setInfiniteReadLimit()</code></span>
<span class="codeline" id="line-998"><code></code></span>
<span class="codeline" id="line-999"><code>	hosts, haveHost := req.Header["Host"]</code></span>
<span class="codeline" id="line-1000"><code>	isH2Upgrade := req.isH2Upgrade()</code></span>
<span class="codeline" id="line-1001"><code>	if req.ProtoAtLeast(1, 1) &amp;&amp; (!haveHost || len(hosts) == 0) &amp;&amp; !isH2Upgrade &amp;&amp; req.Method != "CONNECT" {</code></span>
<span class="codeline" id="line-1002"><code>		return nil, badRequestError("missing required Host header")</code></span>
<span class="codeline" id="line-1003"><code>	}</code></span>
<span class="codeline" id="line-1004"><code>	if len(hosts) &gt; 1 {</code></span>
<span class="codeline" id="line-1005"><code>		return nil, badRequestError("too many Host headers")</code></span>
<span class="codeline" id="line-1006"><code>	}</code></span>
<span class="codeline" id="line-1007"><code>	if len(hosts) == 1 &amp;&amp; !httpguts.ValidHostHeader(hosts[0]) {</code></span>
<span class="codeline" id="line-1008"><code>		return nil, badRequestError("malformed Host header")</code></span>
<span class="codeline" id="line-1009"><code>	}</code></span>
<span class="codeline" id="line-1010"><code>	for k, vv := range req.Header {</code></span>
<span class="codeline" id="line-1011"><code>		if !httpguts.ValidHeaderFieldName(k) {</code></span>
<span class="codeline" id="line-1012"><code>			return nil, badRequestError("invalid header name")</code></span>
<span class="codeline" id="line-1013"><code>		}</code></span>
<span class="codeline" id="line-1014"><code>		for _, v := range vv {</code></span>
<span class="codeline" id="line-1015"><code>			if !httpguts.ValidHeaderFieldValue(v) {</code></span>
<span class="codeline" id="line-1016"><code>				return nil, badRequestError("invalid header value")</code></span>
<span class="codeline" id="line-1017"><code>			}</code></span>
<span class="codeline" id="line-1018"><code>		}</code></span>
<span class="codeline" id="line-1019"><code>	}</code></span>
<span class="codeline" id="line-1020"><code>	delete(req.Header, "Host")</code></span>
<span class="codeline" id="line-1021"><code></code></span>
<span class="codeline" id="line-1022"><code>	ctx, cancelCtx := context.WithCancel(ctx)</code></span>
<span class="codeline" id="line-1023"><code>	req.ctx = ctx</code></span>
<span class="codeline" id="line-1024"><code>	req.RemoteAddr = c.remoteAddr</code></span>
<span class="codeline" id="line-1025"><code>	req.TLS = c.tlsState</code></span>
<span class="codeline" id="line-1026"><code>	if body, ok := req.Body.(*body); ok {</code></span>
<span class="codeline" id="line-1027"><code>		body.doEarlyClose = true</code></span>
<span class="codeline" id="line-1028"><code>	}</code></span>
<span class="codeline" id="line-1029"><code></code></span>
<span class="codeline" id="line-1030"><code>	// Adjust the read deadline if necessary.</code></span>
<span class="codeline" id="line-1031"><code>	if !hdrDeadline.Equal(wholeReqDeadline) {</code></span>
<span class="codeline" id="line-1032"><code>		c.rwc.SetReadDeadline(wholeReqDeadline)</code></span>
<span class="codeline" id="line-1033"><code>	}</code></span>
<span class="codeline" id="line-1034"><code></code></span>
<span class="codeline" id="line-1035"><code>	w = &amp;response{</code></span>
<span class="codeline" id="line-1036"><code>		conn:          c,</code></span>
<span class="codeline" id="line-1037"><code>		cancelCtx:     cancelCtx,</code></span>
<span class="codeline" id="line-1038"><code>		req:           req,</code></span>
<span class="codeline" id="line-1039"><code>		reqBody:       req.Body,</code></span>
<span class="codeline" id="line-1040"><code>		handlerHeader: make(Header),</code></span>
<span class="codeline" id="line-1041"><code>		contentLength: -1,</code></span>
<span class="codeline" id="line-1042"><code>		closeNotifyCh: make(chan bool, 1),</code></span>
<span class="codeline" id="line-1043"><code></code></span>
<span class="codeline" id="line-1044"><code>		// We populate these ahead of time so we're not</code></span>
<span class="codeline" id="line-1045"><code>		// reading from req.Header after their Handler starts</code></span>
<span class="codeline" id="line-1046"><code>		// and maybe mutates it (Issue 14940)</code></span>
<span class="codeline" id="line-1047"><code>		wants10KeepAlive: req.wantsHttp10KeepAlive(),</code></span>
<span class="codeline" id="line-1048"><code>		wantsClose:       req.wantsClose(),</code></span>
<span class="codeline" id="line-1049"><code>	}</code></span>
<span class="codeline" id="line-1050"><code>	if isH2Upgrade {</code></span>
<span class="codeline" id="line-1051"><code>		w.closeAfterReply = true</code></span>
<span class="codeline" id="line-1052"><code>	}</code></span>
<span class="codeline" id="line-1053"><code>	w.cw.res = w</code></span>
<span class="codeline" id="line-1054"><code>	w.w = newBufioWriterSize(&amp;w.cw, bufferBeforeChunkingSize)</code></span>
<span class="codeline" id="line-1055"><code>	return w, nil</code></span>
<span class="codeline" id="line-1056"><code>}</code></span>
<span class="codeline" id="line-1057"><code></code></span>
<span class="codeline" id="line-1058"><code>// http1ServerSupportsRequest reports whether Go's HTTP/1.x server</code></span>
<span class="codeline" id="line-1059"><code>// supports the given request.</code></span>
<span class="codeline" id="line-1060"><code>func http1ServerSupportsRequest(req *Request) bool {</code></span>
<span class="codeline" id="line-1061"><code>	if req.ProtoMajor == 1 {</code></span>
<span class="codeline" id="line-1062"><code>		return true</code></span>
<span class="codeline" id="line-1063"><code>	}</code></span>
<span class="codeline" id="line-1064"><code>	// Accept "PRI * HTTP/2.0" upgrade requests, so Handlers can</code></span>
<span class="codeline" id="line-1065"><code>	// wire up their own HTTP/2 upgrades.</code></span>
<span class="codeline" id="line-1066"><code>	if req.ProtoMajor == 2 &amp;&amp; req.ProtoMinor == 0 &amp;&amp;</code></span>
<span class="codeline" id="line-1067"><code>		req.Method == "PRI" &amp;&amp; req.RequestURI == "*" {</code></span>
<span class="codeline" id="line-1068"><code>		return true</code></span>
<span class="codeline" id="line-1069"><code>	}</code></span>
<span class="codeline" id="line-1070"><code>	// Reject HTTP/0.x, and all other HTTP/2+ requests (which</code></span>
<span class="codeline" id="line-1071"><code>	// aren't encoded in ASCII anyway).</code></span>
<span class="codeline" id="line-1072"><code>	return false</code></span>
<span class="codeline" id="line-1073"><code>}</code></span>
<span class="codeline" id="line-1074"><code></code></span>
<span class="codeline" id="line-1075"><code>func (w *response) Header() Header {</code></span>
<span class="codeline" id="line-1076"><code>	if w.cw.header == nil &amp;&amp; w.wroteHeader &amp;&amp; !w.cw.wroteHeader {</code></span>
<span class="codeline" id="line-1077"><code>		// Accessing the header between logically writing it</code></span>
<span class="codeline" id="line-1078"><code>		// and physically writing it means we need to allocate</code></span>
<span class="codeline" id="line-1079"><code>		// a clone to snapshot the logically written state.</code></span>
<span class="codeline" id="line-1080"><code>		w.cw.header = w.handlerHeader.Clone()</code></span>
<span class="codeline" id="line-1081"><code>	}</code></span>
<span class="codeline" id="line-1082"><code>	w.calledHeader = true</code></span>
<span class="codeline" id="line-1083"><code>	return w.handlerHeader</code></span>
<span class="codeline" id="line-1084"><code>}</code></span>
<span class="codeline" id="line-1085"><code></code></span>
<span class="codeline" id="line-1086"><code>// maxPostHandlerReadBytes is the max number of Request.Body bytes not</code></span>
<span class="codeline" id="line-1087"><code>// consumed by a handler that the server will read from the client</code></span>
<span class="codeline" id="line-1088"><code>// in order to keep a connection alive. If there are more bytes than</code></span>
<span class="codeline" id="line-1089"><code>// this then the server to be paranoid instead sends a "Connection:</code></span>
<span class="codeline" id="line-1090"><code>// close" response.</code></span>
<span class="codeline" id="line-1091"><code>//</code></span>
<span class="codeline" id="line-1092"><code>// This number is approximately what a typical machine's TCP buffer</code></span>
<span class="codeline" id="line-1093"><code>// size is anyway.  (if we have the bytes on the machine, we might as</code></span>
<span class="codeline" id="line-1094"><code>// well read them)</code></span>
<span class="codeline" id="line-1095"><code>const maxPostHandlerReadBytes = 256 &lt;&lt; 10</code></span>
<span class="codeline" id="line-1096"><code></code></span>
<span class="codeline" id="line-1097"><code>func checkWriteHeaderCode(code int) {</code></span>
<span class="codeline" id="line-1098"><code>	// Issue 22880: require valid WriteHeader status codes.</code></span>
<span class="codeline" id="line-1099"><code>	// For now we only enforce that it's three digits.</code></span>
<span class="codeline" id="line-1100"><code>	// In the future we might block things over 599 (600 and above aren't defined</code></span>
<span class="codeline" id="line-1101"><code>	// at https://httpwg.org/specs/rfc7231.html#status.codes)</code></span>
<span class="codeline" id="line-1102"><code>	// and we might block under 200 (once we have more mature 1xx support).</code></span>
<span class="codeline" id="line-1103"><code>	// But for now any three digits.</code></span>
<span class="codeline" id="line-1104"><code>	//</code></span>
<span class="codeline" id="line-1105"><code>	// We used to send "HTTP/1.1 000 0" on the wire in responses but there's</code></span>
<span class="codeline" id="line-1106"><code>	// no equivalent bogus thing we can realistically send in HTTP/2,</code></span>
<span class="codeline" id="line-1107"><code>	// so we'll consistently panic instead and help people find their bugs</code></span>
<span class="codeline" id="line-1108"><code>	// early. (We can't return an error from WriteHeader even if we wanted to.)</code></span>
<span class="codeline" id="line-1109"><code>	if code &lt; 100 || code &gt; 999 {</code></span>
<span class="codeline" id="line-1110"><code>		panic(fmt.Sprintf("invalid WriteHeader code %v", code))</code></span>
<span class="codeline" id="line-1111"><code>	}</code></span>
<span class="codeline" id="line-1112"><code>}</code></span>
<span class="codeline" id="line-1113"><code></code></span>
<span class="codeline" id="line-1114"><code>// relevantCaller searches the call stack for the first function outside of net/http.</code></span>
<span class="codeline" id="line-1115"><code>// The purpose of this function is to provide more helpful error messages.</code></span>
<span class="codeline" id="line-1116"><code>func relevantCaller() runtime.Frame {</code></span>
<span class="codeline" id="line-1117"><code>	pc := make([]uintptr, 16)</code></span>
<span class="codeline" id="line-1118"><code>	n := runtime.Callers(1, pc)</code></span>
<span class="codeline" id="line-1119"><code>	frames := runtime.CallersFrames(pc[:n])</code></span>
<span class="codeline" id="line-1120"><code>	var frame runtime.Frame</code></span>
<span class="codeline" id="line-1121"><code>	for {</code></span>
<span class="codeline" id="line-1122"><code>		frame, more := frames.Next()</code></span>
<span class="codeline" id="line-1123"><code>		if !strings.HasPrefix(frame.Function, "net/http.") {</code></span>
<span class="codeline" id="line-1124"><code>			return frame</code></span>
<span class="codeline" id="line-1125"><code>		}</code></span>
<span class="codeline" id="line-1126"><code>		if !more {</code></span>
<span class="codeline" id="line-1127"><code>			break</code></span>
<span class="codeline" id="line-1128"><code>		}</code></span>
<span class="codeline" id="line-1129"><code>	}</code></span>
<span class="codeline" id="line-1130"><code>	return frame</code></span>
<span class="codeline" id="line-1131"><code>}</code></span>
<span class="codeline" id="line-1132"><code></code></span>
<span class="codeline" id="line-1133"><code>func (w *response) WriteHeader(code int) {</code></span>
<span class="codeline" id="line-1134"><code>	if w.conn.hijacked() {</code></span>
<span class="codeline" id="line-1135"><code>		caller := relevantCaller()</code></span>
<span class="codeline" id="line-1136"><code>		w.conn.server.logf("http: response.WriteHeader on hijacked connection from %s (%s:%d)", caller.Function, path.Base(caller.File), caller.Line)</code></span>
<span class="codeline" id="line-1137"><code>		return</code></span>
<span class="codeline" id="line-1138"><code>	}</code></span>
<span class="codeline" id="line-1139"><code>	if w.wroteHeader {</code></span>
<span class="codeline" id="line-1140"><code>		caller := relevantCaller()</code></span>
<span class="codeline" id="line-1141"><code>		w.conn.server.logf("http: superfluous response.WriteHeader call from %s (%s:%d)", caller.Function, path.Base(caller.File), caller.Line)</code></span>
<span class="codeline" id="line-1142"><code>		return</code></span>
<span class="codeline" id="line-1143"><code>	}</code></span>
<span class="codeline" id="line-1144"><code>	checkWriteHeaderCode(code)</code></span>
<span class="codeline" id="line-1145"><code>	w.wroteHeader = true</code></span>
<span class="codeline" id="line-1146"><code>	w.status = code</code></span>
<span class="codeline" id="line-1147"><code></code></span>
<span class="codeline" id="line-1148"><code>	if w.calledHeader &amp;&amp; w.cw.header == nil {</code></span>
<span class="codeline" id="line-1149"><code>		w.cw.header = w.handlerHeader.Clone()</code></span>
<span class="codeline" id="line-1150"><code>	}</code></span>
<span class="codeline" id="line-1151"><code></code></span>
<span class="codeline" id="line-1152"><code>	if cl := w.handlerHeader.get("Content-Length"); cl != "" {</code></span>
<span class="codeline" id="line-1153"><code>		v, err := strconv.ParseInt(cl, 10, 64)</code></span>
<span class="codeline" id="line-1154"><code>		if err == nil &amp;&amp; v &gt;= 0 {</code></span>
<span class="codeline" id="line-1155"><code>			w.contentLength = v</code></span>
<span class="codeline" id="line-1156"><code>		} else {</code></span>
<span class="codeline" id="line-1157"><code>			w.conn.server.logf("http: invalid Content-Length of %q", cl)</code></span>
<span class="codeline" id="line-1158"><code>			w.handlerHeader.Del("Content-Length")</code></span>
<span class="codeline" id="line-1159"><code>		}</code></span>
<span class="codeline" id="line-1160"><code>	}</code></span>
<span class="codeline" id="line-1161"><code>}</code></span>
<span class="codeline" id="line-1162"><code></code></span>
<span class="codeline" id="line-1163"><code>// extraHeader is the set of headers sometimes added by chunkWriter.writeHeader.</code></span>
<span class="codeline" id="line-1164"><code>// This type is used to avoid extra allocations from cloning and/or populating</code></span>
<span class="codeline" id="line-1165"><code>// the response Header map and all its 1-element slices.</code></span>
<span class="codeline" id="line-1166"><code>type extraHeader struct {</code></span>
<span class="codeline" id="line-1167"><code>	contentType      string</code></span>
<span class="codeline" id="line-1168"><code>	connection       string</code></span>
<span class="codeline" id="line-1169"><code>	transferEncoding string</code></span>
<span class="codeline" id="line-1170"><code>	date             []byte // written if not nil</code></span>
<span class="codeline" id="line-1171"><code>	contentLength    []byte // written if not nil</code></span>
<span class="codeline" id="line-1172"><code>}</code></span>
<span class="codeline" id="line-1173"><code></code></span>
<span class="codeline" id="line-1174"><code>// Sorted the same as extraHeader.Write's loop.</code></span>
<span class="codeline" id="line-1175"><code>var extraHeaderKeys = [][]byte{</code></span>
<span class="codeline" id="line-1176"><code>	[]byte("Content-Type"),</code></span>
<span class="codeline" id="line-1177"><code>	[]byte("Connection"),</code></span>
<span class="codeline" id="line-1178"><code>	[]byte("Transfer-Encoding"),</code></span>
<span class="codeline" id="line-1179"><code>}</code></span>
<span class="codeline" id="line-1180"><code></code></span>
<span class="codeline" id="line-1181"><code>var (</code></span>
<span class="codeline" id="line-1182"><code>	headerContentLength = []byte("Content-Length: ")</code></span>
<span class="codeline" id="line-1183"><code>	headerDate          = []byte("Date: ")</code></span>
<span class="codeline" id="line-1184"><code>)</code></span>
<span class="codeline" id="line-1185"><code></code></span>
<span class="codeline" id="line-1186"><code>// Write writes the headers described in h to w.</code></span>
<span class="codeline" id="line-1187"><code>//</code></span>
<span class="codeline" id="line-1188"><code>// This method has a value receiver, despite the somewhat large size</code></span>
<span class="codeline" id="line-1189"><code>// of h, because it prevents an allocation. The escape analysis isn't</code></span>
<span class="codeline" id="line-1190"><code>// smart enough to realize this function doesn't mutate h.</code></span>
<span class="codeline" id="line-1191"><code>func (h extraHeader) Write(w *bufio.Writer) {</code></span>
<span class="codeline" id="line-1192"><code>	if h.date != nil {</code></span>
<span class="codeline" id="line-1193"><code>		w.Write(headerDate)</code></span>
<span class="codeline" id="line-1194"><code>		w.Write(h.date)</code></span>
<span class="codeline" id="line-1195"><code>		w.Write(crlf)</code></span>
<span class="codeline" id="line-1196"><code>	}</code></span>
<span class="codeline" id="line-1197"><code>	if h.contentLength != nil {</code></span>
<span class="codeline" id="line-1198"><code>		w.Write(headerContentLength)</code></span>
<span class="codeline" id="line-1199"><code>		w.Write(h.contentLength)</code></span>
<span class="codeline" id="line-1200"><code>		w.Write(crlf)</code></span>
<span class="codeline" id="line-1201"><code>	}</code></span>
<span class="codeline" id="line-1202"><code>	for i, v := range []string{h.contentType, h.connection, h.transferEncoding} {</code></span>
<span class="codeline" id="line-1203"><code>		if v != "" {</code></span>
<span class="codeline" id="line-1204"><code>			w.Write(extraHeaderKeys[i])</code></span>
<span class="codeline" id="line-1205"><code>			w.Write(colonSpace)</code></span>
<span class="codeline" id="line-1206"><code>			w.WriteString(v)</code></span>
<span class="codeline" id="line-1207"><code>			w.Write(crlf)</code></span>
<span class="codeline" id="line-1208"><code>		}</code></span>
<span class="codeline" id="line-1209"><code>	}</code></span>
<span class="codeline" id="line-1210"><code>}</code></span>
<span class="codeline" id="line-1211"><code></code></span>
<span class="codeline" id="line-1212"><code>// writeHeader finalizes the header sent to the client and writes it</code></span>
<span class="codeline" id="line-1213"><code>// to cw.res.conn.bufw.</code></span>
<span class="codeline" id="line-1214"><code>//</code></span>
<span class="codeline" id="line-1215"><code>// p is not written by writeHeader, but is the first chunk of the body</code></span>
<span class="codeline" id="line-1216"><code>// that will be written. It is sniffed for a Content-Type if none is</code></span>
<span class="codeline" id="line-1217"><code>// set explicitly. It's also used to set the Content-Length, if the</code></span>
<span class="codeline" id="line-1218"><code>// total body size was small and the handler has already finished</code></span>
<span class="codeline" id="line-1219"><code>// running.</code></span>
<span class="codeline" id="line-1220"><code>func (cw *chunkWriter) writeHeader(p []byte) {</code></span>
<span class="codeline" id="line-1221"><code>	if cw.wroteHeader {</code></span>
<span class="codeline" id="line-1222"><code>		return</code></span>
<span class="codeline" id="line-1223"><code>	}</code></span>
<span class="codeline" id="line-1224"><code>	cw.wroteHeader = true</code></span>
<span class="codeline" id="line-1225"><code></code></span>
<span class="codeline" id="line-1226"><code>	w := cw.res</code></span>
<span class="codeline" id="line-1227"><code>	keepAlivesEnabled := w.conn.server.doKeepAlives()</code></span>
<span class="codeline" id="line-1228"><code>	isHEAD := w.req.Method == "HEAD"</code></span>
<span class="codeline" id="line-1229"><code></code></span>
<span class="codeline" id="line-1230"><code>	// header is written out to w.conn.buf below. Depending on the</code></span>
<span class="codeline" id="line-1231"><code>	// state of the handler, we either own the map or not. If we</code></span>
<span class="codeline" id="line-1232"><code>	// don't own it, the exclude map is created lazily for</code></span>
<span class="codeline" id="line-1233"><code>	// WriteSubset to remove headers. The setHeader struct holds</code></span>
<span class="codeline" id="line-1234"><code>	// headers we need to add.</code></span>
<span class="codeline" id="line-1235"><code>	header := cw.header</code></span>
<span class="codeline" id="line-1236"><code>	owned := header != nil</code></span>
<span class="codeline" id="line-1237"><code>	if !owned {</code></span>
<span class="codeline" id="line-1238"><code>		header = w.handlerHeader</code></span>
<span class="codeline" id="line-1239"><code>	}</code></span>
<span class="codeline" id="line-1240"><code>	var excludeHeader map[string]bool</code></span>
<span class="codeline" id="line-1241"><code>	delHeader := func(key string) {</code></span>
<span class="codeline" id="line-1242"><code>		if owned {</code></span>
<span class="codeline" id="line-1243"><code>			header.Del(key)</code></span>
<span class="codeline" id="line-1244"><code>			return</code></span>
<span class="codeline" id="line-1245"><code>		}</code></span>
<span class="codeline" id="line-1246"><code>		if _, ok := header[key]; !ok {</code></span>
<span class="codeline" id="line-1247"><code>			return</code></span>
<span class="codeline" id="line-1248"><code>		}</code></span>
<span class="codeline" id="line-1249"><code>		if excludeHeader == nil {</code></span>
<span class="codeline" id="line-1250"><code>			excludeHeader = make(map[string]bool)</code></span>
<span class="codeline" id="line-1251"><code>		}</code></span>
<span class="codeline" id="line-1252"><code>		excludeHeader[key] = true</code></span>
<span class="codeline" id="line-1253"><code>	}</code></span>
<span class="codeline" id="line-1254"><code>	var setHeader extraHeader</code></span>
<span class="codeline" id="line-1255"><code></code></span>
<span class="codeline" id="line-1256"><code>	// Don't write out the fake "Trailer:foo" keys. See TrailerPrefix.</code></span>
<span class="codeline" id="line-1257"><code>	trailers := false</code></span>
<span class="codeline" id="line-1258"><code>	for k := range cw.header {</code></span>
<span class="codeline" id="line-1259"><code>		if strings.HasPrefix(k, TrailerPrefix) {</code></span>
<span class="codeline" id="line-1260"><code>			if excludeHeader == nil {</code></span>
<span class="codeline" id="line-1261"><code>				excludeHeader = make(map[string]bool)</code></span>
<span class="codeline" id="line-1262"><code>			}</code></span>
<span class="codeline" id="line-1263"><code>			excludeHeader[k] = true</code></span>
<span class="codeline" id="line-1264"><code>			trailers = true</code></span>
<span class="codeline" id="line-1265"><code>		}</code></span>
<span class="codeline" id="line-1266"><code>	}</code></span>
<span class="codeline" id="line-1267"><code>	for _, v := range cw.header["Trailer"] {</code></span>
<span class="codeline" id="line-1268"><code>		trailers = true</code></span>
<span class="codeline" id="line-1269"><code>		foreachHeaderElement(v, cw.res.declareTrailer)</code></span>
<span class="codeline" id="line-1270"><code>	}</code></span>
<span class="codeline" id="line-1271"><code></code></span>
<span class="codeline" id="line-1272"><code>	te := header.get("Transfer-Encoding")</code></span>
<span class="codeline" id="line-1273"><code>	hasTE := te != ""</code></span>
<span class="codeline" id="line-1274"><code></code></span>
<span class="codeline" id="line-1275"><code>	// If the handler is done but never sent a Content-Length</code></span>
<span class="codeline" id="line-1276"><code>	// response header and this is our first (and last) write, set</code></span>
<span class="codeline" id="line-1277"><code>	// it, even to zero. This helps HTTP/1.0 clients keep their</code></span>
<span class="codeline" id="line-1278"><code>	// "keep-alive" connections alive.</code></span>
<span class="codeline" id="line-1279"><code>	// Exceptions: 304/204/1xx responses never get Content-Length, and if</code></span>
<span class="codeline" id="line-1280"><code>	// it was a HEAD request, we don't know the difference between</code></span>
<span class="codeline" id="line-1281"><code>	// 0 actual bytes and 0 bytes because the handler noticed it</code></span>
<span class="codeline" id="line-1282"><code>	// was a HEAD request and chose not to write anything. So for</code></span>
<span class="codeline" id="line-1283"><code>	// HEAD, the handler should either write the Content-Length or</code></span>
<span class="codeline" id="line-1284"><code>	// write non-zero bytes. If it's actually 0 bytes and the</code></span>
<span class="codeline" id="line-1285"><code>	// handler never looked at the Request.Method, we just don't</code></span>
<span class="codeline" id="line-1286"><code>	// send a Content-Length header.</code></span>
<span class="codeline" id="line-1287"><code>	// Further, we don't send an automatic Content-Length if they</code></span>
<span class="codeline" id="line-1288"><code>	// set a Transfer-Encoding, because they're generally incompatible.</code></span>
<span class="codeline" id="line-1289"><code>	if w.handlerDone.isSet() &amp;&amp; !trailers &amp;&amp; !hasTE &amp;&amp; bodyAllowedForStatus(w.status) &amp;&amp; header.get("Content-Length") == "" &amp;&amp; (!isHEAD || len(p) &gt; 0) {</code></span>
<span class="codeline" id="line-1290"><code>		w.contentLength = int64(len(p))</code></span>
<span class="codeline" id="line-1291"><code>		setHeader.contentLength = strconv.AppendInt(cw.res.clenBuf[:0], int64(len(p)), 10)</code></span>
<span class="codeline" id="line-1292"><code>	}</code></span>
<span class="codeline" id="line-1293"><code></code></span>
<span class="codeline" id="line-1294"><code>	// If this was an HTTP/1.0 request with keep-alive and we sent a</code></span>
<span class="codeline" id="line-1295"><code>	// Content-Length back, we can make this a keep-alive response ...</code></span>
<span class="codeline" id="line-1296"><code>	if w.wants10KeepAlive &amp;&amp; keepAlivesEnabled {</code></span>
<span class="codeline" id="line-1297"><code>		sentLength := header.get("Content-Length") != ""</code></span>
<span class="codeline" id="line-1298"><code>		if sentLength &amp;&amp; header.get("Connection") == "keep-alive" {</code></span>
<span class="codeline" id="line-1299"><code>			w.closeAfterReply = false</code></span>
<span class="codeline" id="line-1300"><code>		}</code></span>
<span class="codeline" id="line-1301"><code>	}</code></span>
<span class="codeline" id="line-1302"><code></code></span>
<span class="codeline" id="line-1303"><code>	// Check for an explicit (and valid) Content-Length header.</code></span>
<span class="codeline" id="line-1304"><code>	hasCL := w.contentLength != -1</code></span>
<span class="codeline" id="line-1305"><code></code></span>
<span class="codeline" id="line-1306"><code>	if w.wants10KeepAlive &amp;&amp; (isHEAD || hasCL || !bodyAllowedForStatus(w.status)) {</code></span>
<span class="codeline" id="line-1307"><code>		_, connectionHeaderSet := header["Connection"]</code></span>
<span class="codeline" id="line-1308"><code>		if !connectionHeaderSet {</code></span>
<span class="codeline" id="line-1309"><code>			setHeader.connection = "keep-alive"</code></span>
<span class="codeline" id="line-1310"><code>		}</code></span>
<span class="codeline" id="line-1311"><code>	} else if !w.req.ProtoAtLeast(1, 1) || w.wantsClose {</code></span>
<span class="codeline" id="line-1312"><code>		w.closeAfterReply = true</code></span>
<span class="codeline" id="line-1313"><code>	}</code></span>
<span class="codeline" id="line-1314"><code></code></span>
<span class="codeline" id="line-1315"><code>	if header.get("Connection") == "close" || !keepAlivesEnabled {</code></span>
<span class="codeline" id="line-1316"><code>		w.closeAfterReply = true</code></span>
<span class="codeline" id="line-1317"><code>	}</code></span>
<span class="codeline" id="line-1318"><code></code></span>
<span class="codeline" id="line-1319"><code>	// If the client wanted a 100-continue but we never sent it to</code></span>
<span class="codeline" id="line-1320"><code>	// them (or, more strictly: we never finished reading their</code></span>
<span class="codeline" id="line-1321"><code>	// request body), don't reuse this connection because it's now</code></span>
<span class="codeline" id="line-1322"><code>	// in an unknown state: we might be sending this response at</code></span>
<span class="codeline" id="line-1323"><code>	// the same time the client is now sending its request body</code></span>
<span class="codeline" id="line-1324"><code>	// after a timeout.  (Some HTTP clients send Expect:</code></span>
<span class="codeline" id="line-1325"><code>	// 100-continue but knowing that some servers don't support</code></span>
<span class="codeline" id="line-1326"><code>	// it, the clients set a timer and send the body later anyway)</code></span>
<span class="codeline" id="line-1327"><code>	// If we haven't seen EOF, we can't skip over the unread body</code></span>
<span class="codeline" id="line-1328"><code>	// because we don't know if the next bytes on the wire will be</code></span>
<span class="codeline" id="line-1329"><code>	// the body-following-the-timer or the subsequent request.</code></span>
<span class="codeline" id="line-1330"><code>	// See Issue 11549.</code></span>
<span class="codeline" id="line-1331"><code>	if ecr, ok := w.req.Body.(*expectContinueReader); ok &amp;&amp; !ecr.sawEOF.isSet() {</code></span>
<span class="codeline" id="line-1332"><code>		w.closeAfterReply = true</code></span>
<span class="codeline" id="line-1333"><code>	}</code></span>
<span class="codeline" id="line-1334"><code></code></span>
<span class="codeline" id="line-1335"><code>	// Per RFC 2616, we should consume the request body before</code></span>
<span class="codeline" id="line-1336"><code>	// replying, if the handler hasn't already done so. But we</code></span>
<span class="codeline" id="line-1337"><code>	// don't want to do an unbounded amount of reading here for</code></span>
<span class="codeline" id="line-1338"><code>	// DoS reasons, so we only try up to a threshold.</code></span>
<span class="codeline" id="line-1339"><code>	// TODO(bradfitz): where does RFC 2616 say that? See Issue 15527</code></span>
<span class="codeline" id="line-1340"><code>	// about HTTP/1.x Handlers concurrently reading and writing, like</code></span>
<span class="codeline" id="line-1341"><code>	// HTTP/2 handlers can do. Maybe this code should be relaxed?</code></span>
<span class="codeline" id="line-1342"><code>	if w.req.ContentLength != 0 &amp;&amp; !w.closeAfterReply {</code></span>
<span class="codeline" id="line-1343"><code>		var discard, tooBig bool</code></span>
<span class="codeline" id="line-1344"><code></code></span>
<span class="codeline" id="line-1345"><code>		switch bdy := w.req.Body.(type) {</code></span>
<span class="codeline" id="line-1346"><code>		case *expectContinueReader:</code></span>
<span class="codeline" id="line-1347"><code>			if bdy.resp.wroteContinue {</code></span>
<span class="codeline" id="line-1348"><code>				discard = true</code></span>
<span class="codeline" id="line-1349"><code>			}</code></span>
<span class="codeline" id="line-1350"><code>		case *body:</code></span>
<span class="codeline" id="line-1351"><code>			bdy.mu.Lock()</code></span>
<span class="codeline" id="line-1352"><code>			switch {</code></span>
<span class="codeline" id="line-1353"><code>			case bdy.closed:</code></span>
<span class="codeline" id="line-1354"><code>				if !bdy.sawEOF {</code></span>
<span class="codeline" id="line-1355"><code>					// Body was closed in handler with non-EOF error.</code></span>
<span class="codeline" id="line-1356"><code>					w.closeAfterReply = true</code></span>
<span class="codeline" id="line-1357"><code>				}</code></span>
<span class="codeline" id="line-1358"><code>			case bdy.unreadDataSizeLocked() &gt;= maxPostHandlerReadBytes:</code></span>
<span class="codeline" id="line-1359"><code>				tooBig = true</code></span>
<span class="codeline" id="line-1360"><code>			default:</code></span>
<span class="codeline" id="line-1361"><code>				discard = true</code></span>
<span class="codeline" id="line-1362"><code>			}</code></span>
<span class="codeline" id="line-1363"><code>			bdy.mu.Unlock()</code></span>
<span class="codeline" id="line-1364"><code>		default:</code></span>
<span class="codeline" id="line-1365"><code>			discard = true</code></span>
<span class="codeline" id="line-1366"><code>		}</code></span>
<span class="codeline" id="line-1367"><code></code></span>
<span class="codeline" id="line-1368"><code>		if discard {</code></span>
<span class="codeline" id="line-1369"><code>			_, err := io.CopyN(ioutil.Discard, w.reqBody, maxPostHandlerReadBytes+1)</code></span>
<span class="codeline" id="line-1370"><code>			switch err {</code></span>
<span class="codeline" id="line-1371"><code>			case nil:</code></span>
<span class="codeline" id="line-1372"><code>				// There must be even more data left over.</code></span>
<span class="codeline" id="line-1373"><code>				tooBig = true</code></span>
<span class="codeline" id="line-1374"><code>			case ErrBodyReadAfterClose:</code></span>
<span class="codeline" id="line-1375"><code>				// Body was already consumed and closed.</code></span>
<span class="codeline" id="line-1376"><code>			case io.EOF:</code></span>
<span class="codeline" id="line-1377"><code>				// The remaining body was just consumed, close it.</code></span>
<span class="codeline" id="line-1378"><code>				err = w.reqBody.Close()</code></span>
<span class="codeline" id="line-1379"><code>				if err != nil {</code></span>
<span class="codeline" id="line-1380"><code>					w.closeAfterReply = true</code></span>
<span class="codeline" id="line-1381"><code>				}</code></span>
<span class="codeline" id="line-1382"><code>			default:</code></span>
<span class="codeline" id="line-1383"><code>				// Some other kind of error occurred, like a read timeout, or</code></span>
<span class="codeline" id="line-1384"><code>				// corrupt chunked encoding. In any case, whatever remains</code></span>
<span class="codeline" id="line-1385"><code>				// on the wire must not be parsed as another HTTP request.</code></span>
<span class="codeline" id="line-1386"><code>				w.closeAfterReply = true</code></span>
<span class="codeline" id="line-1387"><code>			}</code></span>
<span class="codeline" id="line-1388"><code>		}</code></span>
<span class="codeline" id="line-1389"><code></code></span>
<span class="codeline" id="line-1390"><code>		if tooBig {</code></span>
<span class="codeline" id="line-1391"><code>			w.requestTooLarge()</code></span>
<span class="codeline" id="line-1392"><code>			delHeader("Connection")</code></span>
<span class="codeline" id="line-1393"><code>			setHeader.connection = "close"</code></span>
<span class="codeline" id="line-1394"><code>		}</code></span>
<span class="codeline" id="line-1395"><code>	}</code></span>
<span class="codeline" id="line-1396"><code></code></span>
<span class="codeline" id="line-1397"><code>	code := w.status</code></span>
<span class="codeline" id="line-1398"><code>	if bodyAllowedForStatus(code) {</code></span>
<span class="codeline" id="line-1399"><code>		// If no content type, apply sniffing algorithm to body.</code></span>
<span class="codeline" id="line-1400"><code>		_, haveType := header["Content-Type"]</code></span>
<span class="codeline" id="line-1401"><code></code></span>
<span class="codeline" id="line-1402"><code>		// If the Content-Encoding was set and is non-blank,</code></span>
<span class="codeline" id="line-1403"><code>		// we shouldn't sniff the body. See Issue 31753.</code></span>
<span class="codeline" id="line-1404"><code>		ce := header.Get("Content-Encoding")</code></span>
<span class="codeline" id="line-1405"><code>		hasCE := len(ce) &gt; 0</code></span>
<span class="codeline" id="line-1406"><code>		if !hasCE &amp;&amp; !haveType &amp;&amp; !hasTE &amp;&amp; len(p) &gt; 0 {</code></span>
<span class="codeline" id="line-1407"><code>			setHeader.contentType = DetectContentType(p)</code></span>
<span class="codeline" id="line-1408"><code>		}</code></span>
<span class="codeline" id="line-1409"><code>	} else {</code></span>
<span class="codeline" id="line-1410"><code>		for _, k := range suppressedHeaders(code) {</code></span>
<span class="codeline" id="line-1411"><code>			delHeader(k)</code></span>
<span class="codeline" id="line-1412"><code>		}</code></span>
<span class="codeline" id="line-1413"><code>	}</code></span>
<span class="codeline" id="line-1414"><code></code></span>
<span class="codeline" id="line-1415"><code>	if !header.has("Date") {</code></span>
<span class="codeline" id="line-1416"><code>		setHeader.date = appendTime(cw.res.dateBuf[:0], time.Now())</code></span>
<span class="codeline" id="line-1417"><code>	}</code></span>
<span class="codeline" id="line-1418"><code></code></span>
<span class="codeline" id="line-1419"><code>	if hasCL &amp;&amp; hasTE &amp;&amp; te != "identity" {</code></span>
<span class="codeline" id="line-1420"><code>		// TODO: return an error if WriteHeader gets a return parameter</code></span>
<span class="codeline" id="line-1421"><code>		// For now just ignore the Content-Length.</code></span>
<span class="codeline" id="line-1422"><code>		w.conn.server.logf("http: WriteHeader called with both Transfer-Encoding of %q and a Content-Length of %d",</code></span>
<span class="codeline" id="line-1423"><code>			te, w.contentLength)</code></span>
<span class="codeline" id="line-1424"><code>		delHeader("Content-Length")</code></span>
<span class="codeline" id="line-1425"><code>		hasCL = false</code></span>
<span class="codeline" id="line-1426"><code>	}</code></span>
<span class="codeline" id="line-1427"><code></code></span>
<span class="codeline" id="line-1428"><code>	if w.req.Method == "HEAD" || !bodyAllowedForStatus(code) {</code></span>
<span class="codeline" id="line-1429"><code>		// do nothing</code></span>
<span class="codeline" id="line-1430"><code>	} else if code == StatusNoContent {</code></span>
<span class="codeline" id="line-1431"><code>		delHeader("Transfer-Encoding")</code></span>
<span class="codeline" id="line-1432"><code>	} else if hasCL {</code></span>
<span class="codeline" id="line-1433"><code>		delHeader("Transfer-Encoding")</code></span>
<span class="codeline" id="line-1434"><code>	} else if w.req.ProtoAtLeast(1, 1) {</code></span>
<span class="codeline" id="line-1435"><code>		// HTTP/1.1 or greater: Transfer-Encoding has been set to identity, and no</code></span>
<span class="codeline" id="line-1436"><code>		// content-length has been provided. The connection must be closed after the</code></span>
<span class="codeline" id="line-1437"><code>		// reply is written, and no chunking is to be done. This is the setup</code></span>
<span class="codeline" id="line-1438"><code>		// recommended in the Server-Sent Events candidate recommendation 11,</code></span>
<span class="codeline" id="line-1439"><code>		// section 8.</code></span>
<span class="codeline" id="line-1440"><code>		if hasTE &amp;&amp; te == "identity" {</code></span>
<span class="codeline" id="line-1441"><code>			cw.chunking = false</code></span>
<span class="codeline" id="line-1442"><code>			w.closeAfterReply = true</code></span>
<span class="codeline" id="line-1443"><code>		} else {</code></span>
<span class="codeline" id="line-1444"><code>			// HTTP/1.1 or greater: use chunked transfer encoding</code></span>
<span class="codeline" id="line-1445"><code>			// to avoid closing the connection at EOF.</code></span>
<span class="codeline" id="line-1446"><code>			cw.chunking = true</code></span>
<span class="codeline" id="line-1447"><code>			setHeader.transferEncoding = "chunked"</code></span>
<span class="codeline" id="line-1448"><code>			if hasTE &amp;&amp; te == "chunked" {</code></span>
<span class="codeline" id="line-1449"><code>				// We will send the chunked Transfer-Encoding header later.</code></span>
<span class="codeline" id="line-1450"><code>				delHeader("Transfer-Encoding")</code></span>
<span class="codeline" id="line-1451"><code>			}</code></span>
<span class="codeline" id="line-1452"><code>		}</code></span>
<span class="codeline" id="line-1453"><code>	} else {</code></span>
<span class="codeline" id="line-1454"><code>		// HTTP version &lt; 1.1: cannot do chunked transfer</code></span>
<span class="codeline" id="line-1455"><code>		// encoding and we don't know the Content-Length so</code></span>
<span class="codeline" id="line-1456"><code>		// signal EOF by closing connection.</code></span>
<span class="codeline" id="line-1457"><code>		w.closeAfterReply = true</code></span>
<span class="codeline" id="line-1458"><code>		delHeader("Transfer-Encoding") // in case already set</code></span>
<span class="codeline" id="line-1459"><code>	}</code></span>
<span class="codeline" id="line-1460"><code></code></span>
<span class="codeline" id="line-1461"><code>	// Cannot use Content-Length with non-identity Transfer-Encoding.</code></span>
<span class="codeline" id="line-1462"><code>	if cw.chunking {</code></span>
<span class="codeline" id="line-1463"><code>		delHeader("Content-Length")</code></span>
<span class="codeline" id="line-1464"><code>	}</code></span>
<span class="codeline" id="line-1465"><code>	if !w.req.ProtoAtLeast(1, 0) {</code></span>
<span class="codeline" id="line-1466"><code>		return</code></span>
<span class="codeline" id="line-1467"><code>	}</code></span>
<span class="codeline" id="line-1468"><code></code></span>
<span class="codeline" id="line-1469"><code>	if w.closeAfterReply &amp;&amp; (!keepAlivesEnabled || !hasToken(cw.header.get("Connection"), "close")) {</code></span>
<span class="codeline" id="line-1470"><code>		delHeader("Connection")</code></span>
<span class="codeline" id="line-1471"><code>		if w.req.ProtoAtLeast(1, 1) {</code></span>
<span class="codeline" id="line-1472"><code>			setHeader.connection = "close"</code></span>
<span class="codeline" id="line-1473"><code>		}</code></span>
<span class="codeline" id="line-1474"><code>	}</code></span>
<span class="codeline" id="line-1475"><code></code></span>
<span class="codeline" id="line-1476"><code>	writeStatusLine(w.conn.bufw, w.req.ProtoAtLeast(1, 1), code, w.statusBuf[:])</code></span>
<span class="codeline" id="line-1477"><code>	cw.header.WriteSubset(w.conn.bufw, excludeHeader)</code></span>
<span class="codeline" id="line-1478"><code>	setHeader.Write(w.conn.bufw)</code></span>
<span class="codeline" id="line-1479"><code>	w.conn.bufw.Write(crlf)</code></span>
<span class="codeline" id="line-1480"><code>}</code></span>
<span class="codeline" id="line-1481"><code></code></span>
<span class="codeline" id="line-1482"><code>// foreachHeaderElement splits v according to the "#rule" construction</code></span>
<span class="codeline" id="line-1483"><code>// in RFC 7230 section 7 and calls fn for each non-empty element.</code></span>
<span class="codeline" id="line-1484"><code>func foreachHeaderElement(v string, fn func(string)) {</code></span>
<span class="codeline" id="line-1485"><code>	v = textproto.TrimString(v)</code></span>
<span class="codeline" id="line-1486"><code>	if v == "" {</code></span>
<span class="codeline" id="line-1487"><code>		return</code></span>
<span class="codeline" id="line-1488"><code>	}</code></span>
<span class="codeline" id="line-1489"><code>	if !strings.Contains(v, ",") {</code></span>
<span class="codeline" id="line-1490"><code>		fn(v)</code></span>
<span class="codeline" id="line-1491"><code>		return</code></span>
<span class="codeline" id="line-1492"><code>	}</code></span>
<span class="codeline" id="line-1493"><code>	for _, f := range strings.Split(v, ",") {</code></span>
<span class="codeline" id="line-1494"><code>		if f = textproto.TrimString(f); f != "" {</code></span>
<span class="codeline" id="line-1495"><code>			fn(f)</code></span>
<span class="codeline" id="line-1496"><code>		}</code></span>
<span class="codeline" id="line-1497"><code>	}</code></span>
<span class="codeline" id="line-1498"><code>}</code></span>
<span class="codeline" id="line-1499"><code></code></span>
<span class="codeline" id="line-1500"><code>// writeStatusLine writes an HTTP/1.x Status-Line (RFC 7230 Section 3.1.2)</code></span>
<span class="codeline" id="line-1501"><code>// to bw. is11 is whether the HTTP request is HTTP/1.1. false means HTTP/1.0.</code></span>
<span class="codeline" id="line-1502"><code>// code is the response status code.</code></span>
<span class="codeline" id="line-1503"><code>// scratch is an optional scratch buffer. If it has at least capacity 3, it's used.</code></span>
<span class="codeline" id="line-1504"><code>func writeStatusLine(bw *bufio.Writer, is11 bool, code int, scratch []byte) {</code></span>
<span class="codeline" id="line-1505"><code>	if is11 {</code></span>
<span class="codeline" id="line-1506"><code>		bw.WriteString("HTTP/1.1 ")</code></span>
<span class="codeline" id="line-1507"><code>	} else {</code></span>
<span class="codeline" id="line-1508"><code>		bw.WriteString("HTTP/1.0 ")</code></span>
<span class="codeline" id="line-1509"><code>	}</code></span>
<span class="codeline" id="line-1510"><code>	if text, ok := statusText[code]; ok {</code></span>
<span class="codeline" id="line-1511"><code>		bw.Write(strconv.AppendInt(scratch[:0], int64(code), 10))</code></span>
<span class="codeline" id="line-1512"><code>		bw.WriteByte(' ')</code></span>
<span class="codeline" id="line-1513"><code>		bw.WriteString(text)</code></span>
<span class="codeline" id="line-1514"><code>		bw.WriteString("\r\n")</code></span>
<span class="codeline" id="line-1515"><code>	} else {</code></span>
<span class="codeline" id="line-1516"><code>		// don't worry about performance</code></span>
<span class="codeline" id="line-1517"><code>		fmt.Fprintf(bw, "%03d status code %d\r\n", code, code)</code></span>
<span class="codeline" id="line-1518"><code>	}</code></span>
<span class="codeline" id="line-1519"><code>}</code></span>
<span class="codeline" id="line-1520"><code></code></span>
<span class="codeline" id="line-1521"><code>// bodyAllowed reports whether a Write is allowed for this response type.</code></span>
<span class="codeline" id="line-1522"><code>// It's illegal to call this before the header has been flushed.</code></span>
<span class="codeline" id="line-1523"><code>func (w *response) bodyAllowed() bool {</code></span>
<span class="codeline" id="line-1524"><code>	if !w.wroteHeader {</code></span>
<span class="codeline" id="line-1525"><code>		panic("")</code></span>
<span class="codeline" id="line-1526"><code>	}</code></span>
<span class="codeline" id="line-1527"><code>	return bodyAllowedForStatus(w.status)</code></span>
<span class="codeline" id="line-1528"><code>}</code></span>
<span class="codeline" id="line-1529"><code></code></span>
<span class="codeline" id="line-1530"><code>// The Life Of A Write is like this:</code></span>
<span class="codeline" id="line-1531"><code>//</code></span>
<span class="codeline" id="line-1532"><code>// Handler starts. No header has been sent. The handler can either</code></span>
<span class="codeline" id="line-1533"><code>// write a header, or just start writing. Writing before sending a header</code></span>
<span class="codeline" id="line-1534"><code>// sends an implicitly empty 200 OK header.</code></span>
<span class="codeline" id="line-1535"><code>//</code></span>
<span class="codeline" id="line-1536"><code>// If the handler didn't declare a Content-Length up front, we either</code></span>
<span class="codeline" id="line-1537"><code>// go into chunking mode or, if the handler finishes running before</code></span>
<span class="codeline" id="line-1538"><code>// the chunking buffer size, we compute a Content-Length and send that</code></span>
<span class="codeline" id="line-1539"><code>// in the header instead.</code></span>
<span class="codeline" id="line-1540"><code>//</code></span>
<span class="codeline" id="line-1541"><code>// Likewise, if the handler didn't set a Content-Type, we sniff that</code></span>
<span class="codeline" id="line-1542"><code>// from the initial chunk of output.</code></span>
<span class="codeline" id="line-1543"><code>//</code></span>
<span class="codeline" id="line-1544"><code>// The Writers are wired together like:</code></span>
<span class="codeline" id="line-1545"><code>//</code></span>
<span class="codeline" id="line-1546"><code>// 1. *response (the ResponseWriter) -&gt;</code></span>
<span class="codeline" id="line-1547"><code>// 2. (*response).w, a *bufio.Writer of bufferBeforeChunkingSize bytes</code></span>
<span class="codeline" id="line-1548"><code>// 3. chunkWriter.Writer (whose writeHeader finalizes Content-Length/Type)</code></span>
<span class="codeline" id="line-1549"><code>//    and which writes the chunk headers, if needed.</code></span>
<span class="codeline" id="line-1550"><code>// 4. conn.buf, a bufio.Writer of default (4kB) bytes, writing to -&gt;</code></span>
<span class="codeline" id="line-1551"><code>// 5. checkConnErrorWriter{c}, which notes any non-nil error on Write</code></span>
<span class="codeline" id="line-1552"><code>//    and populates c.werr with it if so. but otherwise writes to:</code></span>
<span class="codeline" id="line-1553"><code>// 6. the rwc, the net.Conn.</code></span>
<span class="codeline" id="line-1554"><code>//</code></span>
<span class="codeline" id="line-1555"><code>// TODO(bradfitz): short-circuit some of the buffering when the</code></span>
<span class="codeline" id="line-1556"><code>// initial header contains both a Content-Type and Content-Length.</code></span>
<span class="codeline" id="line-1557"><code>// Also short-circuit in (1) when the header's been sent and not in</code></span>
<span class="codeline" id="line-1558"><code>// chunking mode, writing directly to (4) instead, if (2) has no</code></span>
<span class="codeline" id="line-1559"><code>// buffered data. More generally, we could short-circuit from (1) to</code></span>
<span class="codeline" id="line-1560"><code>// (3) even in chunking mode if the write size from (1) is over some</code></span>
<span class="codeline" id="line-1561"><code>// threshold and nothing is in (2).  The answer might be mostly making</code></span>
<span class="codeline" id="line-1562"><code>// bufferBeforeChunkingSize smaller and having bufio's fast-paths deal</code></span>
<span class="codeline" id="line-1563"><code>// with this instead.</code></span>
<span class="codeline" id="line-1564"><code>func (w *response) Write(data []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-1565"><code>	return w.write(len(data), data, "")</code></span>
<span class="codeline" id="line-1566"><code>}</code></span>
<span class="codeline" id="line-1567"><code></code></span>
<span class="codeline" id="line-1568"><code>func (w *response) WriteString(data string) (n int, err error) {</code></span>
<span class="codeline" id="line-1569"><code>	return w.write(len(data), nil, data)</code></span>
<span class="codeline" id="line-1570"><code>}</code></span>
<span class="codeline" id="line-1571"><code></code></span>
<span class="codeline" id="line-1572"><code>// either dataB or dataS is non-zero.</code></span>
<span class="codeline" id="line-1573"><code>func (w *response) write(lenData int, dataB []byte, dataS string) (n int, err error) {</code></span>
<span class="codeline" id="line-1574"><code>	if w.conn.hijacked() {</code></span>
<span class="codeline" id="line-1575"><code>		if lenData &gt; 0 {</code></span>
<span class="codeline" id="line-1576"><code>			caller := relevantCaller()</code></span>
<span class="codeline" id="line-1577"><code>			w.conn.server.logf("http: response.Write on hijacked connection from %s (%s:%d)", caller.Function, path.Base(caller.File), caller.Line)</code></span>
<span class="codeline" id="line-1578"><code>		}</code></span>
<span class="codeline" id="line-1579"><code>		return 0, ErrHijacked</code></span>
<span class="codeline" id="line-1580"><code>	}</code></span>
<span class="codeline" id="line-1581"><code></code></span>
<span class="codeline" id="line-1582"><code>	if w.canWriteContinue.isSet() {</code></span>
<span class="codeline" id="line-1583"><code>		// Body reader wants to write 100 Continue but hasn't yet.</code></span>
<span class="codeline" id="line-1584"><code>		// Tell it not to. The store must be done while holding the lock</code></span>
<span class="codeline" id="line-1585"><code>		// because the lock makes sure that there is not an active write</code></span>
<span class="codeline" id="line-1586"><code>		// this very moment.</code></span>
<span class="codeline" id="line-1587"><code>		w.writeContinueMu.Lock()</code></span>
<span class="codeline" id="line-1588"><code>		w.canWriteContinue.setFalse()</code></span>
<span class="codeline" id="line-1589"><code>		w.writeContinueMu.Unlock()</code></span>
<span class="codeline" id="line-1590"><code>	}</code></span>
<span class="codeline" id="line-1591"><code></code></span>
<span class="codeline" id="line-1592"><code>	if !w.wroteHeader {</code></span>
<span class="codeline" id="line-1593"><code>		w.WriteHeader(StatusOK)</code></span>
<span class="codeline" id="line-1594"><code>	}</code></span>
<span class="codeline" id="line-1595"><code>	if lenData == 0 {</code></span>
<span class="codeline" id="line-1596"><code>		return 0, nil</code></span>
<span class="codeline" id="line-1597"><code>	}</code></span>
<span class="codeline" id="line-1598"><code>	if !w.bodyAllowed() {</code></span>
<span class="codeline" id="line-1599"><code>		return 0, ErrBodyNotAllowed</code></span>
<span class="codeline" id="line-1600"><code>	}</code></span>
<span class="codeline" id="line-1601"><code></code></span>
<span class="codeline" id="line-1602"><code>	w.written += int64(lenData) // ignoring errors, for errorKludge</code></span>
<span class="codeline" id="line-1603"><code>	if w.contentLength != -1 &amp;&amp; w.written &gt; w.contentLength {</code></span>
<span class="codeline" id="line-1604"><code>		return 0, ErrContentLength</code></span>
<span class="codeline" id="line-1605"><code>	}</code></span>
<span class="codeline" id="line-1606"><code>	if dataB != nil {</code></span>
<span class="codeline" id="line-1607"><code>		return w.w.Write(dataB)</code></span>
<span class="codeline" id="line-1608"><code>	} else {</code></span>
<span class="codeline" id="line-1609"><code>		return w.w.WriteString(dataS)</code></span>
<span class="codeline" id="line-1610"><code>	}</code></span>
<span class="codeline" id="line-1611"><code>}</code></span>
<span class="codeline" id="line-1612"><code></code></span>
<span class="codeline" id="line-1613"><code>func (w *response) finishRequest() {</code></span>
<span class="codeline" id="line-1614"><code>	w.handlerDone.setTrue()</code></span>
<span class="codeline" id="line-1615"><code></code></span>
<span class="codeline" id="line-1616"><code>	if !w.wroteHeader {</code></span>
<span class="codeline" id="line-1617"><code>		w.WriteHeader(StatusOK)</code></span>
<span class="codeline" id="line-1618"><code>	}</code></span>
<span class="codeline" id="line-1619"><code></code></span>
<span class="codeline" id="line-1620"><code>	w.w.Flush()</code></span>
<span class="codeline" id="line-1621"><code>	putBufioWriter(w.w)</code></span>
<span class="codeline" id="line-1622"><code>	w.cw.close()</code></span>
<span class="codeline" id="line-1623"><code>	w.conn.bufw.Flush()</code></span>
<span class="codeline" id="line-1624"><code></code></span>
<span class="codeline" id="line-1625"><code>	w.conn.r.abortPendingRead()</code></span>
<span class="codeline" id="line-1626"><code></code></span>
<span class="codeline" id="line-1627"><code>	// Close the body (regardless of w.closeAfterReply) so we can</code></span>
<span class="codeline" id="line-1628"><code>	// re-use its bufio.Reader later safely.</code></span>
<span class="codeline" id="line-1629"><code>	w.reqBody.Close()</code></span>
<span class="codeline" id="line-1630"><code></code></span>
<span class="codeline" id="line-1631"><code>	if w.req.MultipartForm != nil {</code></span>
<span class="codeline" id="line-1632"><code>		w.req.MultipartForm.RemoveAll()</code></span>
<span class="codeline" id="line-1633"><code>	}</code></span>
<span class="codeline" id="line-1634"><code>}</code></span>
<span class="codeline" id="line-1635"><code></code></span>
<span class="codeline" id="line-1636"><code>// shouldReuseConnection reports whether the underlying TCP connection can be reused.</code></span>
<span class="codeline" id="line-1637"><code>// It must only be called after the handler is done executing.</code></span>
<span class="codeline" id="line-1638"><code>func (w *response) shouldReuseConnection() bool {</code></span>
<span class="codeline" id="line-1639"><code>	if w.closeAfterReply {</code></span>
<span class="codeline" id="line-1640"><code>		// The request or something set while executing the</code></span>
<span class="codeline" id="line-1641"><code>		// handler indicated we shouldn't reuse this</code></span>
<span class="codeline" id="line-1642"><code>		// connection.</code></span>
<span class="codeline" id="line-1643"><code>		return false</code></span>
<span class="codeline" id="line-1644"><code>	}</code></span>
<span class="codeline" id="line-1645"><code></code></span>
<span class="codeline" id="line-1646"><code>	if w.req.Method != "HEAD" &amp;&amp; w.contentLength != -1 &amp;&amp; w.bodyAllowed() &amp;&amp; w.contentLength != w.written {</code></span>
<span class="codeline" id="line-1647"><code>		// Did not write enough. Avoid getting out of sync.</code></span>
<span class="codeline" id="line-1648"><code>		return false</code></span>
<span class="codeline" id="line-1649"><code>	}</code></span>
<span class="codeline" id="line-1650"><code></code></span>
<span class="codeline" id="line-1651"><code>	// There was some error writing to the underlying connection</code></span>
<span class="codeline" id="line-1652"><code>	// during the request, so don't re-use this conn.</code></span>
<span class="codeline" id="line-1653"><code>	if w.conn.werr != nil {</code></span>
<span class="codeline" id="line-1654"><code>		return false</code></span>
<span class="codeline" id="line-1655"><code>	}</code></span>
<span class="codeline" id="line-1656"><code></code></span>
<span class="codeline" id="line-1657"><code>	if w.closedRequestBodyEarly() {</code></span>
<span class="codeline" id="line-1658"><code>		return false</code></span>
<span class="codeline" id="line-1659"><code>	}</code></span>
<span class="codeline" id="line-1660"><code></code></span>
<span class="codeline" id="line-1661"><code>	return true</code></span>
<span class="codeline" id="line-1662"><code>}</code></span>
<span class="codeline" id="line-1663"><code></code></span>
<span class="codeline" id="line-1664"><code>func (w *response) closedRequestBodyEarly() bool {</code></span>
<span class="codeline" id="line-1665"><code>	body, ok := w.req.Body.(*body)</code></span>
<span class="codeline" id="line-1666"><code>	return ok &amp;&amp; body.didEarlyClose()</code></span>
<span class="codeline" id="line-1667"><code>}</code></span>
<span class="codeline" id="line-1668"><code></code></span>
<span class="codeline" id="line-1669"><code>func (w *response) Flush() {</code></span>
<span class="codeline" id="line-1670"><code>	if !w.wroteHeader {</code></span>
<span class="codeline" id="line-1671"><code>		w.WriteHeader(StatusOK)</code></span>
<span class="codeline" id="line-1672"><code>	}</code></span>
<span class="codeline" id="line-1673"><code>	w.w.Flush()</code></span>
<span class="codeline" id="line-1674"><code>	w.cw.flush()</code></span>
<span class="codeline" id="line-1675"><code>}</code></span>
<span class="codeline" id="line-1676"><code></code></span>
<span class="codeline" id="line-1677"><code>func (c *conn) finalFlush() {</code></span>
<span class="codeline" id="line-1678"><code>	if c.bufr != nil {</code></span>
<span class="codeline" id="line-1679"><code>		// Steal the bufio.Reader (~4KB worth of memory) and its associated</code></span>
<span class="codeline" id="line-1680"><code>		// reader for a future connection.</code></span>
<span class="codeline" id="line-1681"><code>		putBufioReader(c.bufr)</code></span>
<span class="codeline" id="line-1682"><code>		c.bufr = nil</code></span>
<span class="codeline" id="line-1683"><code>	}</code></span>
<span class="codeline" id="line-1684"><code></code></span>
<span class="codeline" id="line-1685"><code>	if c.bufw != nil {</code></span>
<span class="codeline" id="line-1686"><code>		c.bufw.Flush()</code></span>
<span class="codeline" id="line-1687"><code>		// Steal the bufio.Writer (~4KB worth of memory) and its associated</code></span>
<span class="codeline" id="line-1688"><code>		// writer for a future connection.</code></span>
<span class="codeline" id="line-1689"><code>		putBufioWriter(c.bufw)</code></span>
<span class="codeline" id="line-1690"><code>		c.bufw = nil</code></span>
<span class="codeline" id="line-1691"><code>	}</code></span>
<span class="codeline" id="line-1692"><code>}</code></span>
<span class="codeline" id="line-1693"><code></code></span>
<span class="codeline" id="line-1694"><code>// Close the connection.</code></span>
<span class="codeline" id="line-1695"><code>func (c *conn) close() {</code></span>
<span class="codeline" id="line-1696"><code>	c.finalFlush()</code></span>
<span class="codeline" id="line-1697"><code>	c.rwc.Close()</code></span>
<span class="codeline" id="line-1698"><code>}</code></span>
<span class="codeline" id="line-1699"><code></code></span>
<span class="codeline" id="line-1700"><code>// rstAvoidanceDelay is the amount of time we sleep after closing the</code></span>
<span class="codeline" id="line-1701"><code>// write side of a TCP connection before closing the entire socket.</code></span>
<span class="codeline" id="line-1702"><code>// By sleeping, we increase the chances that the client sees our FIN</code></span>
<span class="codeline" id="line-1703"><code>// and processes its final data before they process the subsequent RST</code></span>
<span class="codeline" id="line-1704"><code>// from closing a connection with known unread data.</code></span>
<span class="codeline" id="line-1705"><code>// This RST seems to occur mostly on BSD systems. (And Windows?)</code></span>
<span class="codeline" id="line-1706"><code>// This timeout is somewhat arbitrary (~latency around the planet).</code></span>
<span class="codeline" id="line-1707"><code>const rstAvoidanceDelay = 500 * time.Millisecond</code></span>
<span class="codeline" id="line-1708"><code></code></span>
<span class="codeline" id="line-1709"><code>type closeWriter interface {</code></span>
<span class="codeline" id="line-1710"><code>	CloseWrite() error</code></span>
<span class="codeline" id="line-1711"><code>}</code></span>
<span class="codeline" id="line-1712"><code></code></span>
<span class="codeline" id="line-1713"><code>var _ closeWriter = (*net.TCPConn)(nil)</code></span>
<span class="codeline" id="line-1714"><code></code></span>
<span class="codeline" id="line-1715"><code>// closeWrite flushes any outstanding data and sends a FIN packet (if</code></span>
<span class="codeline" id="line-1716"><code>// client is connected via TCP), signalling that we're done. We then</code></span>
<span class="codeline" id="line-1717"><code>// pause for a bit, hoping the client processes it before any</code></span>
<span class="codeline" id="line-1718"><code>// subsequent RST.</code></span>
<span class="codeline" id="line-1719"><code>//</code></span>
<span class="codeline" id="line-1720"><code>// See https://golang.org/issue/3595</code></span>
<span class="codeline" id="line-1721"><code>func (c *conn) closeWriteAndWait() {</code></span>
<span class="codeline" id="line-1722"><code>	c.finalFlush()</code></span>
<span class="codeline" id="line-1723"><code>	if tcp, ok := c.rwc.(closeWriter); ok {</code></span>
<span class="codeline" id="line-1724"><code>		tcp.CloseWrite()</code></span>
<span class="codeline" id="line-1725"><code>	}</code></span>
<span class="codeline" id="line-1726"><code>	time.Sleep(rstAvoidanceDelay)</code></span>
<span class="codeline" id="line-1727"><code>}</code></span>
<span class="codeline" id="line-1728"><code></code></span>
<span class="codeline" id="line-1729"><code>// validNextProto reports whether the proto is a valid ALPN protocol name.</code></span>
<span class="codeline" id="line-1730"><code>// Everything is valid except the empty string and built-in protocol types,</code></span>
<span class="codeline" id="line-1731"><code>// so that those can't be overridden with alternate implementations.</code></span>
<span class="codeline" id="line-1732"><code>func validNextProto(proto string) bool {</code></span>
<span class="codeline" id="line-1733"><code>	switch proto {</code></span>
<span class="codeline" id="line-1734"><code>	case "", "http/1.1", "http/1.0":</code></span>
<span class="codeline" id="line-1735"><code>		return false</code></span>
<span class="codeline" id="line-1736"><code>	}</code></span>
<span class="codeline" id="line-1737"><code>	return true</code></span>
<span class="codeline" id="line-1738"><code>}</code></span>
<span class="codeline" id="line-1739"><code></code></span>
<span class="codeline" id="line-1740"><code>func (c *conn) setState(nc net.Conn, state ConnState) {</code></span>
<span class="codeline" id="line-1741"><code>	srv := c.server</code></span>
<span class="codeline" id="line-1742"><code>	switch state {</code></span>
<span class="codeline" id="line-1743"><code>	case StateNew:</code></span>
<span class="codeline" id="line-1744"><code>		srv.trackConn(c, true)</code></span>
<span class="codeline" id="line-1745"><code>	case StateHijacked, StateClosed:</code></span>
<span class="codeline" id="line-1746"><code>		srv.trackConn(c, false)</code></span>
<span class="codeline" id="line-1747"><code>	}</code></span>
<span class="codeline" id="line-1748"><code>	if state &gt; 0xff || state &lt; 0 {</code></span>
<span class="codeline" id="line-1749"><code>		panic("internal error")</code></span>
<span class="codeline" id="line-1750"><code>	}</code></span>
<span class="codeline" id="line-1751"><code>	packedState := uint64(time.Now().Unix()&lt;&lt;8) | uint64(state)</code></span>
<span class="codeline" id="line-1752"><code>	atomic.StoreUint64(&amp;c.curState.atomic, packedState)</code></span>
<span class="codeline" id="line-1753"><code>	if hook := srv.ConnState; hook != nil {</code></span>
<span class="codeline" id="line-1754"><code>		hook(nc, state)</code></span>
<span class="codeline" id="line-1755"><code>	}</code></span>
<span class="codeline" id="line-1756"><code>}</code></span>
<span class="codeline" id="line-1757"><code></code></span>
<span class="codeline" id="line-1758"><code>func (c *conn) getState() (state ConnState, unixSec int64) {</code></span>
<span class="codeline" id="line-1759"><code>	packedState := atomic.LoadUint64(&amp;c.curState.atomic)</code></span>
<span class="codeline" id="line-1760"><code>	return ConnState(packedState &amp; 0xff), int64(packedState &gt;&gt; 8)</code></span>
<span class="codeline" id="line-1761"><code>}</code></span>
<span class="codeline" id="line-1762"><code></code></span>
<span class="codeline" id="line-1763"><code>// badRequestError is a literal string (used by in the server in HTML,</code></span>
<span class="codeline" id="line-1764"><code>// unescaped) to tell the user why their request was bad. It should</code></span>
<span class="codeline" id="line-1765"><code>// be plain text without user info or other embedded errors.</code></span>
<span class="codeline" id="line-1766"><code>type badRequestError string</code></span>
<span class="codeline" id="line-1767"><code></code></span>
<span class="codeline" id="line-1768"><code>func (e badRequestError) Error() string { return "Bad Request: " + string(e) }</code></span>
<span class="codeline" id="line-1769"><code></code></span>
<span class="codeline" id="line-1770"><code>// ErrAbortHandler is a sentinel panic value to abort a handler.</code></span>
<span class="codeline" id="line-1771"><code>// While any panic from ServeHTTP aborts the response to the client,</code></span>
<span class="codeline" id="line-1772"><code>// panicking with ErrAbortHandler also suppresses logging of a stack</code></span>
<span class="codeline" id="line-1773"><code>// trace to the server's error log.</code></span>
<span class="codeline" id="line-1774"><code>var ErrAbortHandler = errors.New("net/http: abort Handler")</code></span>
<span class="codeline" id="line-1775"><code></code></span>
<span class="codeline" id="line-1776"><code>// isCommonNetReadError reports whether err is a common error</code></span>
<span class="codeline" id="line-1777"><code>// encountered during reading a request off the network when the</code></span>
<span class="codeline" id="line-1778"><code>// client has gone away or had its read fail somehow. This is used to</code></span>
<span class="codeline" id="line-1779"><code>// determine which logs are interesting enough to log about.</code></span>
<span class="codeline" id="line-1780"><code>func isCommonNetReadError(err error) bool {</code></span>
<span class="codeline" id="line-1781"><code>	if err == io.EOF {</code></span>
<span class="codeline" id="line-1782"><code>		return true</code></span>
<span class="codeline" id="line-1783"><code>	}</code></span>
<span class="codeline" id="line-1784"><code>	if neterr, ok := err.(net.Error); ok &amp;&amp; neterr.Timeout() {</code></span>
<span class="codeline" id="line-1785"><code>		return true</code></span>
<span class="codeline" id="line-1786"><code>	}</code></span>
<span class="codeline" id="line-1787"><code>	if oe, ok := err.(*net.OpError); ok &amp;&amp; oe.Op == "read" {</code></span>
<span class="codeline" id="line-1788"><code>		return true</code></span>
<span class="codeline" id="line-1789"><code>	}</code></span>
<span class="codeline" id="line-1790"><code>	return false</code></span>
<span class="codeline" id="line-1791"><code>}</code></span>
<span class="codeline" id="line-1792"><code></code></span>
<span class="codeline" id="line-1793"><code>// Serve a new connection.</code></span>
<span class="codeline" id="line-1794"><code>func (c *conn) serve(ctx context.Context) {</code></span>
<span class="codeline" id="line-1795"><code>	c.remoteAddr = c.rwc.RemoteAddr().String()</code></span>
<span class="codeline" id="line-1796"><code>	ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr())</code></span>
<span class="codeline" id="line-1797"><code>	defer func() {</code></span>
<span class="codeline" id="line-1798"><code>		if err := recover(); err != nil &amp;&amp; err != ErrAbortHandler {</code></span>
<span class="codeline" id="line-1799"><code>			const size = 64 &lt;&lt; 10</code></span>
<span class="codeline" id="line-1800"><code>			buf := make([]byte, size)</code></span>
<span class="codeline" id="line-1801"><code>			buf = buf[:runtime.Stack(buf, false)]</code></span>
<span class="codeline" id="line-1802"><code>			c.server.logf("http: panic serving %v: %v\n%s", c.remoteAddr, err, buf)</code></span>
<span class="codeline" id="line-1803"><code>		}</code></span>
<span class="codeline" id="line-1804"><code>		if !c.hijacked() {</code></span>
<span class="codeline" id="line-1805"><code>			c.close()</code></span>
<span class="codeline" id="line-1806"><code>			c.setState(c.rwc, StateClosed)</code></span>
<span class="codeline" id="line-1807"><code>		}</code></span>
<span class="codeline" id="line-1808"><code>	}()</code></span>
<span class="codeline" id="line-1809"><code></code></span>
<span class="codeline" id="line-1810"><code>	if tlsConn, ok := c.rwc.(*tls.Conn); ok {</code></span>
<span class="codeline" id="line-1811"><code>		if d := c.server.ReadTimeout; d != 0 {</code></span>
<span class="codeline" id="line-1812"><code>			c.rwc.SetReadDeadline(time.Now().Add(d))</code></span>
<span class="codeline" id="line-1813"><code>		}</code></span>
<span class="codeline" id="line-1814"><code>		if d := c.server.WriteTimeout; d != 0 {</code></span>
<span class="codeline" id="line-1815"><code>			c.rwc.SetWriteDeadline(time.Now().Add(d))</code></span>
<span class="codeline" id="line-1816"><code>		}</code></span>
<span class="codeline" id="line-1817"><code>		if err := tlsConn.Handshake(); err != nil {</code></span>
<span class="codeline" id="line-1818"><code>			// If the handshake failed due to the client not speaking</code></span>
<span class="codeline" id="line-1819"><code>			// TLS, assume they're speaking plaintext HTTP and write a</code></span>
<span class="codeline" id="line-1820"><code>			// 400 response on the TLS conn's underlying net.Conn.</code></span>
<span class="codeline" id="line-1821"><code>			if re, ok := err.(tls.RecordHeaderError); ok &amp;&amp; re.Conn != nil &amp;&amp; tlsRecordHeaderLooksLikeHTTP(re.RecordHeader) {</code></span>
<span class="codeline" id="line-1822"><code>				io.WriteString(re.Conn, "HTTP/1.0 400 Bad Request\r\n\r\nClient sent an HTTP request to an HTTPS server.\n")</code></span>
<span class="codeline" id="line-1823"><code>				re.Conn.Close()</code></span>
<span class="codeline" id="line-1824"><code>				return</code></span>
<span class="codeline" id="line-1825"><code>			}</code></span>
<span class="codeline" id="line-1826"><code>			c.server.logf("http: TLS handshake error from %s: %v", c.rwc.RemoteAddr(), err)</code></span>
<span class="codeline" id="line-1827"><code>			return</code></span>
<span class="codeline" id="line-1828"><code>		}</code></span>
<span class="codeline" id="line-1829"><code>		c.tlsState = new(tls.ConnectionState)</code></span>
<span class="codeline" id="line-1830"><code>		*c.tlsState = tlsConn.ConnectionState()</code></span>
<span class="codeline" id="line-1831"><code>		if proto := c.tlsState.NegotiatedProtocol; validNextProto(proto) {</code></span>
<span class="codeline" id="line-1832"><code>			if fn := c.server.TLSNextProto[proto]; fn != nil {</code></span>
<span class="codeline" id="line-1833"><code>				h := initALPNRequest{ctx, tlsConn, serverHandler{c.server}}</code></span>
<span class="codeline" id="line-1834"><code>				fn(c.server, tlsConn, h)</code></span>
<span class="codeline" id="line-1835"><code>			}</code></span>
<span class="codeline" id="line-1836"><code>			return</code></span>
<span class="codeline" id="line-1837"><code>		}</code></span>
<span class="codeline" id="line-1838"><code>	}</code></span>
<span class="codeline" id="line-1839"><code></code></span>
<span class="codeline" id="line-1840"><code>	// HTTP/1.x from here on.</code></span>
<span class="codeline" id="line-1841"><code></code></span>
<span class="codeline" id="line-1842"><code>	ctx, cancelCtx := context.WithCancel(ctx)</code></span>
<span class="codeline" id="line-1843"><code>	c.cancelCtx = cancelCtx</code></span>
<span class="codeline" id="line-1844"><code>	defer cancelCtx()</code></span>
<span class="codeline" id="line-1845"><code></code></span>
<span class="codeline" id="line-1846"><code>	c.r = &amp;connReader{conn: c}</code></span>
<span class="codeline" id="line-1847"><code>	c.bufr = newBufioReader(c.r)</code></span>
<span class="codeline" id="line-1848"><code>	c.bufw = newBufioWriterSize(checkConnErrorWriter{c}, 4&lt;&lt;10)</code></span>
<span class="codeline" id="line-1849"><code></code></span>
<span class="codeline" id="line-1850"><code>	for {</code></span>
<span class="codeline" id="line-1851"><code>		w, err := c.readRequest(ctx)</code></span>
<span class="codeline" id="line-1852"><code>		if c.r.remain != c.server.initialReadLimitSize() {</code></span>
<span class="codeline" id="line-1853"><code>			// If we read any bytes off the wire, we're active.</code></span>
<span class="codeline" id="line-1854"><code>			c.setState(c.rwc, StateActive)</code></span>
<span class="codeline" id="line-1855"><code>		}</code></span>
<span class="codeline" id="line-1856"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1857"><code>			const errorHeaders = "\r\nContent-Type: text/plain; charset=utf-8\r\nConnection: close\r\n\r\n"</code></span>
<span class="codeline" id="line-1858"><code></code></span>
<span class="codeline" id="line-1859"><code>			switch {</code></span>
<span class="codeline" id="line-1860"><code>			case err == errTooLarge:</code></span>
<span class="codeline" id="line-1861"><code>				// Their HTTP client may or may not be</code></span>
<span class="codeline" id="line-1862"><code>				// able to read this if we're</code></span>
<span class="codeline" id="line-1863"><code>				// responding to them and hanging up</code></span>
<span class="codeline" id="line-1864"><code>				// while they're still writing their</code></span>
<span class="codeline" id="line-1865"><code>				// request. Undefined behavior.</code></span>
<span class="codeline" id="line-1866"><code>				const publicErr = "431 Request Header Fields Too Large"</code></span>
<span class="codeline" id="line-1867"><code>				fmt.Fprintf(c.rwc, "HTTP/1.1 "+publicErr+errorHeaders+publicErr)</code></span>
<span class="codeline" id="line-1868"><code>				c.closeWriteAndWait()</code></span>
<span class="codeline" id="line-1869"><code>				return</code></span>
<span class="codeline" id="line-1870"><code></code></span>
<span class="codeline" id="line-1871"><code>			case isUnsupportedTEError(err):</code></span>
<span class="codeline" id="line-1872"><code>				// Respond as per RFC 7230 Section 3.3.1 which says,</code></span>
<span class="codeline" id="line-1873"><code>				//      A server that receives a request message with a</code></span>
<span class="codeline" id="line-1874"><code>				//      transfer coding it does not understand SHOULD</code></span>
<span class="codeline" id="line-1875"><code>				//      respond with 501 (Unimplemented).</code></span>
<span class="codeline" id="line-1876"><code>				code := StatusNotImplemented</code></span>
<span class="codeline" id="line-1877"><code></code></span>
<span class="codeline" id="line-1878"><code>				// We purposefully aren't echoing back the transfer-encoding's value,</code></span>
<span class="codeline" id="line-1879"><code>				// so as to mitigate the risk of cross side scripting by an attacker.</code></span>
<span class="codeline" id="line-1880"><code>				fmt.Fprintf(c.rwc, "HTTP/1.1 %d %s%sUnsupported transfer encoding", code, StatusText(code), errorHeaders)</code></span>
<span class="codeline" id="line-1881"><code>				return</code></span>
<span class="codeline" id="line-1882"><code></code></span>
<span class="codeline" id="line-1883"><code>			case isCommonNetReadError(err):</code></span>
<span class="codeline" id="line-1884"><code>				return // don't reply</code></span>
<span class="codeline" id="line-1885"><code></code></span>
<span class="codeline" id="line-1886"><code>			default:</code></span>
<span class="codeline" id="line-1887"><code>				publicErr := "400 Bad Request"</code></span>
<span class="codeline" id="line-1888"><code>				if v, ok := err.(badRequestError); ok {</code></span>
<span class="codeline" id="line-1889"><code>					publicErr = publicErr + ": " + string(v)</code></span>
<span class="codeline" id="line-1890"><code>				}</code></span>
<span class="codeline" id="line-1891"><code></code></span>
<span class="codeline" id="line-1892"><code>				fmt.Fprintf(c.rwc, "HTTP/1.1 "+publicErr+errorHeaders+publicErr)</code></span>
<span class="codeline" id="line-1893"><code>				return</code></span>
<span class="codeline" id="line-1894"><code>			}</code></span>
<span class="codeline" id="line-1895"><code>		}</code></span>
<span class="codeline" id="line-1896"><code></code></span>
<span class="codeline" id="line-1897"><code>		// Expect 100 Continue support</code></span>
<span class="codeline" id="line-1898"><code>		req := w.req</code></span>
<span class="codeline" id="line-1899"><code>		if req.expectsContinue() {</code></span>
<span class="codeline" id="line-1900"><code>			if req.ProtoAtLeast(1, 1) &amp;&amp; req.ContentLength != 0 {</code></span>
<span class="codeline" id="line-1901"><code>				// Wrap the Body reader with one that replies on the connection</code></span>
<span class="codeline" id="line-1902"><code>				req.Body = &amp;expectContinueReader{readCloser: req.Body, resp: w}</code></span>
<span class="codeline" id="line-1903"><code>				w.canWriteContinue.setTrue()</code></span>
<span class="codeline" id="line-1904"><code>			}</code></span>
<span class="codeline" id="line-1905"><code>		} else if req.Header.get("Expect") != "" {</code></span>
<span class="codeline" id="line-1906"><code>			w.sendExpectationFailed()</code></span>
<span class="codeline" id="line-1907"><code>			return</code></span>
<span class="codeline" id="line-1908"><code>		}</code></span>
<span class="codeline" id="line-1909"><code></code></span>
<span class="codeline" id="line-1910"><code>		c.curReq.Store(w)</code></span>
<span class="codeline" id="line-1911"><code></code></span>
<span class="codeline" id="line-1912"><code>		if requestBodyRemains(req.Body) {</code></span>
<span class="codeline" id="line-1913"><code>			registerOnHitEOF(req.Body, w.conn.r.startBackgroundRead)</code></span>
<span class="codeline" id="line-1914"><code>		} else {</code></span>
<span class="codeline" id="line-1915"><code>			w.conn.r.startBackgroundRead()</code></span>
<span class="codeline" id="line-1916"><code>		}</code></span>
<span class="codeline" id="line-1917"><code></code></span>
<span class="codeline" id="line-1918"><code>		// HTTP cannot have multiple simultaneous active requests.[*]</code></span>
<span class="codeline" id="line-1919"><code>		// Until the server replies to this request, it can't read another,</code></span>
<span class="codeline" id="line-1920"><code>		// so we might as well run the handler in this goroutine.</code></span>
<span class="codeline" id="line-1921"><code>		// [*] Not strictly true: HTTP pipelining. We could let them all process</code></span>
<span class="codeline" id="line-1922"><code>		// in parallel even if their responses need to be serialized.</code></span>
<span class="codeline" id="line-1923"><code>		// But we're not going to implement HTTP pipelining because it</code></span>
<span class="codeline" id="line-1924"><code>		// was never deployed in the wild and the answer is HTTP/2.</code></span>
<span class="codeline" id="line-1925"><code>		serverHandler{c.server}.ServeHTTP(w, w.req)</code></span>
<span class="codeline" id="line-1926"><code>		w.cancelCtx()</code></span>
<span class="codeline" id="line-1927"><code>		if c.hijacked() {</code></span>
<span class="codeline" id="line-1928"><code>			return</code></span>
<span class="codeline" id="line-1929"><code>		}</code></span>
<span class="codeline" id="line-1930"><code>		w.finishRequest()</code></span>
<span class="codeline" id="line-1931"><code>		if !w.shouldReuseConnection() {</code></span>
<span class="codeline" id="line-1932"><code>			if w.requestBodyLimitHit || w.closedRequestBodyEarly() {</code></span>
<span class="codeline" id="line-1933"><code>				c.closeWriteAndWait()</code></span>
<span class="codeline" id="line-1934"><code>			}</code></span>
<span class="codeline" id="line-1935"><code>			return</code></span>
<span class="codeline" id="line-1936"><code>		}</code></span>
<span class="codeline" id="line-1937"><code>		c.setState(c.rwc, StateIdle)</code></span>
<span class="codeline" id="line-1938"><code>		c.curReq.Store((*response)(nil))</code></span>
<span class="codeline" id="line-1939"><code></code></span>
<span class="codeline" id="line-1940"><code>		if !w.conn.server.doKeepAlives() {</code></span>
<span class="codeline" id="line-1941"><code>			// We're in shutdown mode. We might've replied</code></span>
<span class="codeline" id="line-1942"><code>			// to the user without "Connection: close" and</code></span>
<span class="codeline" id="line-1943"><code>			// they might think they can send another</code></span>
<span class="codeline" id="line-1944"><code>			// request, but such is life with HTTP/1.1.</code></span>
<span class="codeline" id="line-1945"><code>			return</code></span>
<span class="codeline" id="line-1946"><code>		}</code></span>
<span class="codeline" id="line-1947"><code></code></span>
<span class="codeline" id="line-1948"><code>		if d := c.server.idleTimeout(); d != 0 {</code></span>
<span class="codeline" id="line-1949"><code>			c.rwc.SetReadDeadline(time.Now().Add(d))</code></span>
<span class="codeline" id="line-1950"><code>			if _, err := c.bufr.Peek(4); err != nil {</code></span>
<span class="codeline" id="line-1951"><code>				return</code></span>
<span class="codeline" id="line-1952"><code>			}</code></span>
<span class="codeline" id="line-1953"><code>		}</code></span>
<span class="codeline" id="line-1954"><code>		c.rwc.SetReadDeadline(time.Time{})</code></span>
<span class="codeline" id="line-1955"><code>	}</code></span>
<span class="codeline" id="line-1956"><code>}</code></span>
<span class="codeline" id="line-1957"><code></code></span>
<span class="codeline" id="line-1958"><code>func (w *response) sendExpectationFailed() {</code></span>
<span class="codeline" id="line-1959"><code>	// TODO(bradfitz): let ServeHTTP handlers handle</code></span>
<span class="codeline" id="line-1960"><code>	// requests with non-standard expectation[s]? Seems</code></span>
<span class="codeline" id="line-1961"><code>	// theoretical at best, and doesn't fit into the</code></span>
<span class="codeline" id="line-1962"><code>	// current ServeHTTP model anyway. We'd need to</code></span>
<span class="codeline" id="line-1963"><code>	// make the ResponseWriter an optional</code></span>
<span class="codeline" id="line-1964"><code>	// "ExpectReplier" interface or something.</code></span>
<span class="codeline" id="line-1965"><code>	//</code></span>
<span class="codeline" id="line-1966"><code>	// For now we'll just obey RFC 7231 5.1.1 which says</code></span>
<span class="codeline" id="line-1967"><code>	// "A server that receives an Expect field-value other</code></span>
<span class="codeline" id="line-1968"><code>	// than 100-continue MAY respond with a 417 (Expectation</code></span>
<span class="codeline" id="line-1969"><code>	// Failed) status code to indicate that the unexpected</code></span>
<span class="codeline" id="line-1970"><code>	// expectation cannot be met."</code></span>
<span class="codeline" id="line-1971"><code>	w.Header().Set("Connection", "close")</code></span>
<span class="codeline" id="line-1972"><code>	w.WriteHeader(StatusExpectationFailed)</code></span>
<span class="codeline" id="line-1973"><code>	w.finishRequest()</code></span>
<span class="codeline" id="line-1974"><code>}</code></span>
<span class="codeline" id="line-1975"><code></code></span>
<span class="codeline" id="line-1976"><code>// Hijack implements the Hijacker.Hijack method. Our response is both a ResponseWriter</code></span>
<span class="codeline" id="line-1977"><code>// and a Hijacker.</code></span>
<span class="codeline" id="line-1978"><code>func (w *response) Hijack() (rwc net.Conn, buf *bufio.ReadWriter, err error) {</code></span>
<span class="codeline" id="line-1979"><code>	if w.handlerDone.isSet() {</code></span>
<span class="codeline" id="line-1980"><code>		panic("net/http: Hijack called after ServeHTTP finished")</code></span>
<span class="codeline" id="line-1981"><code>	}</code></span>
<span class="codeline" id="line-1982"><code>	if w.wroteHeader {</code></span>
<span class="codeline" id="line-1983"><code>		w.cw.flush()</code></span>
<span class="codeline" id="line-1984"><code>	}</code></span>
<span class="codeline" id="line-1985"><code></code></span>
<span class="codeline" id="line-1986"><code>	c := w.conn</code></span>
<span class="codeline" id="line-1987"><code>	c.mu.Lock()</code></span>
<span class="codeline" id="line-1988"><code>	defer c.mu.Unlock()</code></span>
<span class="codeline" id="line-1989"><code></code></span>
<span class="codeline" id="line-1990"><code>	// Release the bufioWriter that writes to the chunk writer, it is not</code></span>
<span class="codeline" id="line-1991"><code>	// used after a connection has been hijacked.</code></span>
<span class="codeline" id="line-1992"><code>	rwc, buf, err = c.hijackLocked()</code></span>
<span class="codeline" id="line-1993"><code>	if err == nil {</code></span>
<span class="codeline" id="line-1994"><code>		putBufioWriter(w.w)</code></span>
<span class="codeline" id="line-1995"><code>		w.w = nil</code></span>
<span class="codeline" id="line-1996"><code>	}</code></span>
<span class="codeline" id="line-1997"><code>	return rwc, buf, err</code></span>
<span class="codeline" id="line-1998"><code>}</code></span>
<span class="codeline" id="line-1999"><code></code></span>
<span class="codeline" id="line-2000"><code>func (w *response) CloseNotify() &lt;-chan bool {</code></span>
<span class="codeline" id="line-2001"><code>	if w.handlerDone.isSet() {</code></span>
<span class="codeline" id="line-2002"><code>		panic("net/http: CloseNotify called after ServeHTTP finished")</code></span>
<span class="codeline" id="line-2003"><code>	}</code></span>
<span class="codeline" id="line-2004"><code>	return w.closeNotifyCh</code></span>
<span class="codeline" id="line-2005"><code>}</code></span>
<span class="codeline" id="line-2006"><code></code></span>
<span class="codeline" id="line-2007"><code>func registerOnHitEOF(rc io.ReadCloser, fn func()) {</code></span>
<span class="codeline" id="line-2008"><code>	switch v := rc.(type) {</code></span>
<span class="codeline" id="line-2009"><code>	case *expectContinueReader:</code></span>
<span class="codeline" id="line-2010"><code>		registerOnHitEOF(v.readCloser, fn)</code></span>
<span class="codeline" id="line-2011"><code>	case *body:</code></span>
<span class="codeline" id="line-2012"><code>		v.registerOnHitEOF(fn)</code></span>
<span class="codeline" id="line-2013"><code>	default:</code></span>
<span class="codeline" id="line-2014"><code>		panic("unexpected type " + fmt.Sprintf("%T", rc))</code></span>
<span class="codeline" id="line-2015"><code>	}</code></span>
<span class="codeline" id="line-2016"><code>}</code></span>
<span class="codeline" id="line-2017"><code></code></span>
<span class="codeline" id="line-2018"><code>// requestBodyRemains reports whether future calls to Read</code></span>
<span class="codeline" id="line-2019"><code>// on rc might yield more data.</code></span>
<span class="codeline" id="line-2020"><code>func requestBodyRemains(rc io.ReadCloser) bool {</code></span>
<span class="codeline" id="line-2021"><code>	if rc == NoBody {</code></span>
<span class="codeline" id="line-2022"><code>		return false</code></span>
<span class="codeline" id="line-2023"><code>	}</code></span>
<span class="codeline" id="line-2024"><code>	switch v := rc.(type) {</code></span>
<span class="codeline" id="line-2025"><code>	case *expectContinueReader:</code></span>
<span class="codeline" id="line-2026"><code>		return requestBodyRemains(v.readCloser)</code></span>
<span class="codeline" id="line-2027"><code>	case *body:</code></span>
<span class="codeline" id="line-2028"><code>		return v.bodyRemains()</code></span>
<span class="codeline" id="line-2029"><code>	default:</code></span>
<span class="codeline" id="line-2030"><code>		panic("unexpected type " + fmt.Sprintf("%T", rc))</code></span>
<span class="codeline" id="line-2031"><code>	}</code></span>
<span class="codeline" id="line-2032"><code>}</code></span>
<span class="codeline" id="line-2033"><code></code></span>
<span class="codeline" id="line-2034"><code>// The HandlerFunc type is an adapter to allow the use of</code></span>
<span class="codeline" id="line-2035"><code>// ordinary functions as HTTP handlers. If f is a function</code></span>
<span class="codeline" id="line-2036"><code>// with the appropriate signature, HandlerFunc(f) is a</code></span>
<span class="codeline" id="line-2037"><code>// Handler that calls f.</code></span>
<span class="codeline" id="line-2038"><code>type HandlerFunc func(ResponseWriter, *Request)</code></span>
<span class="codeline" id="line-2039"><code></code></span>
<span class="codeline" id="line-2040"><code>// ServeHTTP calls f(w, r).</code></span>
<span class="codeline" id="line-2041"><code>func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {</code></span>
<span class="codeline" id="line-2042"><code>	f(w, r)</code></span>
<span class="codeline" id="line-2043"><code>}</code></span>
<span class="codeline" id="line-2044"><code></code></span>
<span class="codeline" id="line-2045"><code>// Helper handlers</code></span>
<span class="codeline" id="line-2046"><code></code></span>
<span class="codeline" id="line-2047"><code>// Error replies to the request with the specified error message and HTTP code.</code></span>
<span class="codeline" id="line-2048"><code>// It does not otherwise end the request; the caller should ensure no further</code></span>
<span class="codeline" id="line-2049"><code>// writes are done to w.</code></span>
<span class="codeline" id="line-2050"><code>// The error message should be plain text.</code></span>
<span class="codeline" id="line-2051"><code>func Error(w ResponseWriter, error string, code int) {</code></span>
<span class="codeline" id="line-2052"><code>	w.Header().Set("Content-Type", "text/plain; charset=utf-8")</code></span>
<span class="codeline" id="line-2053"><code>	w.Header().Set("X-Content-Type-Options", "nosniff")</code></span>
<span class="codeline" id="line-2054"><code>	w.WriteHeader(code)</code></span>
<span class="codeline" id="line-2055"><code>	fmt.Fprintln(w, error)</code></span>
<span class="codeline" id="line-2056"><code>}</code></span>
<span class="codeline" id="line-2057"><code></code></span>
<span class="codeline" id="line-2058"><code>// NotFound replies to the request with an HTTP 404 not found error.</code></span>
<span class="codeline" id="line-2059"><code>func NotFound(w ResponseWriter, r *Request) { Error(w, "404 page not found", StatusNotFound) }</code></span>
<span class="codeline" id="line-2060"><code></code></span>
<span class="codeline" id="line-2061"><code>// NotFoundHandler returns a simple request handler</code></span>
<span class="codeline" id="line-2062"><code>// that replies to each request with a ``404 page not found'' reply.</code></span>
<span class="codeline" id="line-2063"><code>func NotFoundHandler() Handler { return HandlerFunc(NotFound) }</code></span>
<span class="codeline" id="line-2064"><code></code></span>
<span class="codeline" id="line-2065"><code>// StripPrefix returns a handler that serves HTTP requests</code></span>
<span class="codeline" id="line-2066"><code>// by removing the given prefix from the request URL's Path</code></span>
<span class="codeline" id="line-2067"><code>// and invoking the handler h. StripPrefix handles a</code></span>
<span class="codeline" id="line-2068"><code>// request for a path that doesn't begin with prefix by</code></span>
<span class="codeline" id="line-2069"><code>// replying with an HTTP 404 not found error.</code></span>
<span class="codeline" id="line-2070"><code>func StripPrefix(prefix string, h Handler) Handler {</code></span>
<span class="codeline" id="line-2071"><code>	if prefix == "" {</code></span>
<span class="codeline" id="line-2072"><code>		return h</code></span>
<span class="codeline" id="line-2073"><code>	}</code></span>
<span class="codeline" id="line-2074"><code>	return HandlerFunc(func(w ResponseWriter, r *Request) {</code></span>
<span class="codeline" id="line-2075"><code>		if p := strings.TrimPrefix(r.URL.Path, prefix); len(p) &lt; len(r.URL.Path) {</code></span>
<span class="codeline" id="line-2076"><code>			r2 := new(Request)</code></span>
<span class="codeline" id="line-2077"><code>			*r2 = *r</code></span>
<span class="codeline" id="line-2078"><code>			r2.URL = new(url.URL)</code></span>
<span class="codeline" id="line-2079"><code>			*r2.URL = *r.URL</code></span>
<span class="codeline" id="line-2080"><code>			r2.URL.Path = p</code></span>
<span class="codeline" id="line-2081"><code>			h.ServeHTTP(w, r2)</code></span>
<span class="codeline" id="line-2082"><code>		} else {</code></span>
<span class="codeline" id="line-2083"><code>			NotFound(w, r)</code></span>
<span class="codeline" id="line-2084"><code>		}</code></span>
<span class="codeline" id="line-2085"><code>	})</code></span>
<span class="codeline" id="line-2086"><code>}</code></span>
<span class="codeline" id="line-2087"><code></code></span>
<span class="codeline" id="line-2088"><code>// Redirect replies to the request with a redirect to url,</code></span>
<span class="codeline" id="line-2089"><code>// which may be a path relative to the request path.</code></span>
<span class="codeline" id="line-2090"><code>//</code></span>
<span class="codeline" id="line-2091"><code>// The provided code should be in the 3xx range and is usually</code></span>
<span class="codeline" id="line-2092"><code>// StatusMovedPermanently, StatusFound or StatusSeeOther.</code></span>
<span class="codeline" id="line-2093"><code>//</code></span>
<span class="codeline" id="line-2094"><code>// If the Content-Type header has not been set, Redirect sets it</code></span>
<span class="codeline" id="line-2095"><code>// to "text/html; charset=utf-8" and writes a small HTML body.</code></span>
<span class="codeline" id="line-2096"><code>// Setting the Content-Type header to any value, including nil,</code></span>
<span class="codeline" id="line-2097"><code>// disables that behavior.</code></span>
<span class="codeline" id="line-2098"><code>func Redirect(w ResponseWriter, r *Request, url string, code int) {</code></span>
<span class="codeline" id="line-2099"><code>	if u, err := urlpkg.Parse(url); err == nil {</code></span>
<span class="codeline" id="line-2100"><code>		// If url was relative, make its path absolute by</code></span>
<span class="codeline" id="line-2101"><code>		// combining with request path.</code></span>
<span class="codeline" id="line-2102"><code>		// The client would probably do this for us,</code></span>
<span class="codeline" id="line-2103"><code>		// but doing it ourselves is more reliable.</code></span>
<span class="codeline" id="line-2104"><code>		// See RFC 7231, section 7.1.2</code></span>
<span class="codeline" id="line-2105"><code>		if u.Scheme == "" &amp;&amp; u.Host == "" {</code></span>
<span class="codeline" id="line-2106"><code>			oldpath := r.URL.Path</code></span>
<span class="codeline" id="line-2107"><code>			if oldpath == "" { // should not happen, but avoid a crash if it does</code></span>
<span class="codeline" id="line-2108"><code>				oldpath = "/"</code></span>
<span class="codeline" id="line-2109"><code>			}</code></span>
<span class="codeline" id="line-2110"><code></code></span>
<span class="codeline" id="line-2111"><code>			// no leading http://server</code></span>
<span class="codeline" id="line-2112"><code>			if url == "" || url[0] != '/' {</code></span>
<span class="codeline" id="line-2113"><code>				// make relative path absolute</code></span>
<span class="codeline" id="line-2114"><code>				olddir, _ := path.Split(oldpath)</code></span>
<span class="codeline" id="line-2115"><code>				url = olddir + url</code></span>
<span class="codeline" id="line-2116"><code>			}</code></span>
<span class="codeline" id="line-2117"><code></code></span>
<span class="codeline" id="line-2118"><code>			var query string</code></span>
<span class="codeline" id="line-2119"><code>			if i := strings.Index(url, "?"); i != -1 {</code></span>
<span class="codeline" id="line-2120"><code>				url, query = url[:i], url[i:]</code></span>
<span class="codeline" id="line-2121"><code>			}</code></span>
<span class="codeline" id="line-2122"><code></code></span>
<span class="codeline" id="line-2123"><code>			// clean up but preserve trailing slash</code></span>
<span class="codeline" id="line-2124"><code>			trailing := strings.HasSuffix(url, "/")</code></span>
<span class="codeline" id="line-2125"><code>			url = path.Clean(url)</code></span>
<span class="codeline" id="line-2126"><code>			if trailing &amp;&amp; !strings.HasSuffix(url, "/") {</code></span>
<span class="codeline" id="line-2127"><code>				url += "/"</code></span>
<span class="codeline" id="line-2128"><code>			}</code></span>
<span class="codeline" id="line-2129"><code>			url += query</code></span>
<span class="codeline" id="line-2130"><code>		}</code></span>
<span class="codeline" id="line-2131"><code>	}</code></span>
<span class="codeline" id="line-2132"><code></code></span>
<span class="codeline" id="line-2133"><code>	h := w.Header()</code></span>
<span class="codeline" id="line-2134"><code></code></span>
<span class="codeline" id="line-2135"><code>	// RFC 7231 notes that a short HTML body is usually included in</code></span>
<span class="codeline" id="line-2136"><code>	// the response because older user agents may not understand 301/307.</code></span>
<span class="codeline" id="line-2137"><code>	// Do it only if the request didn't already have a Content-Type header.</code></span>
<span class="codeline" id="line-2138"><code>	_, hadCT := h["Content-Type"]</code></span>
<span class="codeline" id="line-2139"><code></code></span>
<span class="codeline" id="line-2140"><code>	h.Set("Location", hexEscapeNonASCII(url))</code></span>
<span class="codeline" id="line-2141"><code>	if !hadCT &amp;&amp; (r.Method == "GET" || r.Method == "HEAD") {</code></span>
<span class="codeline" id="line-2142"><code>		h.Set("Content-Type", "text/html; charset=utf-8")</code></span>
<span class="codeline" id="line-2143"><code>	}</code></span>
<span class="codeline" id="line-2144"><code>	w.WriteHeader(code)</code></span>
<span class="codeline" id="line-2145"><code></code></span>
<span class="codeline" id="line-2146"><code>	// Shouldn't send the body for POST or HEAD; that leaves GET.</code></span>
<span class="codeline" id="line-2147"><code>	if !hadCT &amp;&amp; r.Method == "GET" {</code></span>
<span class="codeline" id="line-2148"><code>		body := "&lt;a href=\"" + htmlEscape(url) + "\"&gt;" + statusText[code] + "&lt;/a&gt;.\n"</code></span>
<span class="codeline" id="line-2149"><code>		fmt.Fprintln(w, body)</code></span>
<span class="codeline" id="line-2150"><code>	}</code></span>
<span class="codeline" id="line-2151"><code>}</code></span>
<span class="codeline" id="line-2152"><code></code></span>
<span class="codeline" id="line-2153"><code>var htmlReplacer = strings.NewReplacer(</code></span>
<span class="codeline" id="line-2154"><code>	"&amp;", "&amp;amp;",</code></span>
<span class="codeline" id="line-2155"><code>	"&lt;", "&amp;lt;",</code></span>
<span class="codeline" id="line-2156"><code>	"&gt;", "&amp;gt;",</code></span>
<span class="codeline" id="line-2157"><code>	// "&amp;#34;" is shorter than "&amp;quot;".</code></span>
<span class="codeline" id="line-2158"><code>	`"`, "&amp;#34;",</code></span>
<span class="codeline" id="line-2159"><code>	// "&amp;#39;" is shorter than "&amp;apos;" and apos was not in HTML until HTML5.</code></span>
<span class="codeline" id="line-2160"><code>	"'", "&amp;#39;",</code></span>
<span class="codeline" id="line-2161"><code>)</code></span>
<span class="codeline" id="line-2162"><code></code></span>
<span class="codeline" id="line-2163"><code>func htmlEscape(s string) string {</code></span>
<span class="codeline" id="line-2164"><code>	return htmlReplacer.Replace(s)</code></span>
<span class="codeline" id="line-2165"><code>}</code></span>
<span class="codeline" id="line-2166"><code></code></span>
<span class="codeline" id="line-2167"><code>// Redirect to a fixed URL</code></span>
<span class="codeline" id="line-2168"><code>type redirectHandler struct {</code></span>
<span class="codeline" id="line-2169"><code>	url  string</code></span>
<span class="codeline" id="line-2170"><code>	code int</code></span>
<span class="codeline" id="line-2171"><code>}</code></span>
<span class="codeline" id="line-2172"><code></code></span>
<span class="codeline" id="line-2173"><code>func (rh *redirectHandler) ServeHTTP(w ResponseWriter, r *Request) {</code></span>
<span class="codeline" id="line-2174"><code>	Redirect(w, r, rh.url, rh.code)</code></span>
<span class="codeline" id="line-2175"><code>}</code></span>
<span class="codeline" id="line-2176"><code></code></span>
<span class="codeline" id="line-2177"><code>// RedirectHandler returns a request handler that redirects</code></span>
<span class="codeline" id="line-2178"><code>// each request it receives to the given url using the given</code></span>
<span class="codeline" id="line-2179"><code>// status code.</code></span>
<span class="codeline" id="line-2180"><code>//</code></span>
<span class="codeline" id="line-2181"><code>// The provided code should be in the 3xx range and is usually</code></span>
<span class="codeline" id="line-2182"><code>// StatusMovedPermanently, StatusFound or StatusSeeOther.</code></span>
<span class="codeline" id="line-2183"><code>func RedirectHandler(url string, code int) Handler {</code></span>
<span class="codeline" id="line-2184"><code>	return &amp;redirectHandler{url, code}</code></span>
<span class="codeline" id="line-2185"><code>}</code></span>
<span class="codeline" id="line-2186"><code></code></span>
<span class="codeline" id="line-2187"><code>// ServeMux is an HTTP request multiplexer.</code></span>
<span class="codeline" id="line-2188"><code>// It matches the URL of each incoming request against a list of registered</code></span>
<span class="codeline" id="line-2189"><code>// patterns and calls the handler for the pattern that</code></span>
<span class="codeline" id="line-2190"><code>// most closely matches the URL.</code></span>
<span class="codeline" id="line-2191"><code>//</code></span>
<span class="codeline" id="line-2192"><code>// Patterns name fixed, rooted paths, like "/favicon.ico",</code></span>
<span class="codeline" id="line-2193"><code>// or rooted subtrees, like "/images/" (note the trailing slash).</code></span>
<span class="codeline" id="line-2194"><code>// Longer patterns take precedence over shorter ones, so that</code></span>
<span class="codeline" id="line-2195"><code>// if there are handlers registered for both "/images/"</code></span>
<span class="codeline" id="line-2196"><code>// and "/images/thumbnails/", the latter handler will be</code></span>
<span class="codeline" id="line-2197"><code>// called for paths beginning "/images/thumbnails/" and the</code></span>
<span class="codeline" id="line-2198"><code>// former will receive requests for any other paths in the</code></span>
<span class="codeline" id="line-2199"><code>// "/images/" subtree.</code></span>
<span class="codeline" id="line-2200"><code>//</code></span>
<span class="codeline" id="line-2201"><code>// Note that since a pattern ending in a slash names a rooted subtree,</code></span>
<span class="codeline" id="line-2202"><code>// the pattern "/" matches all paths not matched by other registered</code></span>
<span class="codeline" id="line-2203"><code>// patterns, not just the URL with Path == "/".</code></span>
<span class="codeline" id="line-2204"><code>//</code></span>
<span class="codeline" id="line-2205"><code>// If a subtree has been registered and a request is received naming the</code></span>
<span class="codeline" id="line-2206"><code>// subtree root without its trailing slash, ServeMux redirects that</code></span>
<span class="codeline" id="line-2207"><code>// request to the subtree root (adding the trailing slash). This behavior can</code></span>
<span class="codeline" id="line-2208"><code>// be overridden with a separate registration for the path without</code></span>
<span class="codeline" id="line-2209"><code>// the trailing slash. For example, registering "/images/" causes ServeMux</code></span>
<span class="codeline" id="line-2210"><code>// to redirect a request for "/images" to "/images/", unless "/images" has</code></span>
<span class="codeline" id="line-2211"><code>// been registered separately.</code></span>
<span class="codeline" id="line-2212"><code>//</code></span>
<span class="codeline" id="line-2213"><code>// Patterns may optionally begin with a host name, restricting matches to</code></span>
<span class="codeline" id="line-2214"><code>// URLs on that host only. Host-specific patterns take precedence over</code></span>
<span class="codeline" id="line-2215"><code>// general patterns, so that a handler might register for the two patterns</code></span>
<span class="codeline" id="line-2216"><code>// "/codesearch" and "codesearch.google.com/" without also taking over</code></span>
<span class="codeline" id="line-2217"><code>// requests for "http://www.google.com/".</code></span>
<span class="codeline" id="line-2218"><code>//</code></span>
<span class="codeline" id="line-2219"><code>// ServeMux also takes care of sanitizing the URL request path and the Host</code></span>
<span class="codeline" id="line-2220"><code>// header, stripping the port number and redirecting any request containing . or</code></span>
<span class="codeline" id="line-2221"><code>// .. elements or repeated slashes to an equivalent, cleaner URL.</code></span>
<span class="codeline" id="line-2222"><code>type ServeMux struct {</code></span>
<span class="codeline" id="line-2223"><code>	mu    sync.RWMutex</code></span>
<span class="codeline" id="line-2224"><code>	m     map[string]muxEntry</code></span>
<span class="codeline" id="line-2225"><code>	es    []muxEntry // slice of entries sorted from longest to shortest.</code></span>
<span class="codeline" id="line-2226"><code>	hosts bool       // whether any patterns contain hostnames</code></span>
<span class="codeline" id="line-2227"><code>}</code></span>
<span class="codeline" id="line-2228"><code></code></span>
<span class="codeline" id="line-2229"><code>type muxEntry struct {</code></span>
<span class="codeline" id="line-2230"><code>	h       Handler</code></span>
<span class="codeline" id="line-2231"><code>	pattern string</code></span>
<span class="codeline" id="line-2232"><code>}</code></span>
<span class="codeline" id="line-2233"><code></code></span>
<span class="codeline" id="line-2234"><code>// NewServeMux allocates and returns a new ServeMux.</code></span>
<span class="codeline" id="line-2235"><code>func NewServeMux() *ServeMux { return new(ServeMux) }</code></span>
<span class="codeline" id="line-2236"><code></code></span>
<span class="codeline" id="line-2237"><code>// DefaultServeMux is the default ServeMux used by Serve.</code></span>
<span class="codeline" id="line-2238"><code>var DefaultServeMux = &amp;defaultServeMux</code></span>
<span class="codeline" id="line-2239"><code></code></span>
<span class="codeline" id="line-2240"><code>var defaultServeMux ServeMux</code></span>
<span class="codeline" id="line-2241"><code></code></span>
<span class="codeline" id="line-2242"><code>// cleanPath returns the canonical path for p, eliminating . and .. elements.</code></span>
<span class="codeline" id="line-2243"><code>func cleanPath(p string) string {</code></span>
<span class="codeline" id="line-2244"><code>	if p == "" {</code></span>
<span class="codeline" id="line-2245"><code>		return "/"</code></span>
<span class="codeline" id="line-2246"><code>	}</code></span>
<span class="codeline" id="line-2247"><code>	if p[0] != '/' {</code></span>
<span class="codeline" id="line-2248"><code>		p = "/" + p</code></span>
<span class="codeline" id="line-2249"><code>	}</code></span>
<span class="codeline" id="line-2250"><code>	np := path.Clean(p)</code></span>
<span class="codeline" id="line-2251"><code>	// path.Clean removes trailing slash except for root;</code></span>
<span class="codeline" id="line-2252"><code>	// put the trailing slash back if necessary.</code></span>
<span class="codeline" id="line-2253"><code>	if p[len(p)-1] == '/' &amp;&amp; np != "/" {</code></span>
<span class="codeline" id="line-2254"><code>		// Fast path for common case of p being the string we want:</code></span>
<span class="codeline" id="line-2255"><code>		if len(p) == len(np)+1 &amp;&amp; strings.HasPrefix(p, np) {</code></span>
<span class="codeline" id="line-2256"><code>			np = p</code></span>
<span class="codeline" id="line-2257"><code>		} else {</code></span>
<span class="codeline" id="line-2258"><code>			np += "/"</code></span>
<span class="codeline" id="line-2259"><code>		}</code></span>
<span class="codeline" id="line-2260"><code>	}</code></span>
<span class="codeline" id="line-2261"><code>	return np</code></span>
<span class="codeline" id="line-2262"><code>}</code></span>
<span class="codeline" id="line-2263"><code></code></span>
<span class="codeline" id="line-2264"><code>// stripHostPort returns h without any trailing ":&lt;port&gt;".</code></span>
<span class="codeline" id="line-2265"><code>func stripHostPort(h string) string {</code></span>
<span class="codeline" id="line-2266"><code>	// If no port on host, return unchanged</code></span>
<span class="codeline" id="line-2267"><code>	if strings.IndexByte(h, ':') == -1 {</code></span>
<span class="codeline" id="line-2268"><code>		return h</code></span>
<span class="codeline" id="line-2269"><code>	}</code></span>
<span class="codeline" id="line-2270"><code>	host, _, err := net.SplitHostPort(h)</code></span>
<span class="codeline" id="line-2271"><code>	if err != nil {</code></span>
<span class="codeline" id="line-2272"><code>		return h // on error, return unchanged</code></span>
<span class="codeline" id="line-2273"><code>	}</code></span>
<span class="codeline" id="line-2274"><code>	return host</code></span>
<span class="codeline" id="line-2275"><code>}</code></span>
<span class="codeline" id="line-2276"><code></code></span>
<span class="codeline" id="line-2277"><code>// Find a handler on a handler map given a path string.</code></span>
<span class="codeline" id="line-2278"><code>// Most-specific (longest) pattern wins.</code></span>
<span class="codeline" id="line-2279"><code>func (mux *ServeMux) match(path string) (h Handler, pattern string) {</code></span>
<span class="codeline" id="line-2280"><code>	// Check for exact match first.</code></span>
<span class="codeline" id="line-2281"><code>	v, ok := mux.m[path]</code></span>
<span class="codeline" id="line-2282"><code>	if ok {</code></span>
<span class="codeline" id="line-2283"><code>		return v.h, v.pattern</code></span>
<span class="codeline" id="line-2284"><code>	}</code></span>
<span class="codeline" id="line-2285"><code></code></span>
<span class="codeline" id="line-2286"><code>	// Check for longest valid match.  mux.es contains all patterns</code></span>
<span class="codeline" id="line-2287"><code>	// that end in / sorted from longest to shortest.</code></span>
<span class="codeline" id="line-2288"><code>	for _, e := range mux.es {</code></span>
<span class="codeline" id="line-2289"><code>		if strings.HasPrefix(path, e.pattern) {</code></span>
<span class="codeline" id="line-2290"><code>			return e.h, e.pattern</code></span>
<span class="codeline" id="line-2291"><code>		}</code></span>
<span class="codeline" id="line-2292"><code>	}</code></span>
<span class="codeline" id="line-2293"><code>	return nil, ""</code></span>
<span class="codeline" id="line-2294"><code>}</code></span>
<span class="codeline" id="line-2295"><code></code></span>
<span class="codeline" id="line-2296"><code>// redirectToPathSlash determines if the given path needs appending "/" to it.</code></span>
<span class="codeline" id="line-2297"><code>// This occurs when a handler for path + "/" was already registered, but</code></span>
<span class="codeline" id="line-2298"><code>// not for path itself. If the path needs appending to, it creates a new</code></span>
<span class="codeline" id="line-2299"><code>// URL, setting the path to u.Path + "/" and returning true to indicate so.</code></span>
<span class="codeline" id="line-2300"><code>func (mux *ServeMux) redirectToPathSlash(host, path string, u *url.URL) (*url.URL, bool) {</code></span>
<span class="codeline" id="line-2301"><code>	mux.mu.RLock()</code></span>
<span class="codeline" id="line-2302"><code>	shouldRedirect := mux.shouldRedirectRLocked(host, path)</code></span>
<span class="codeline" id="line-2303"><code>	mux.mu.RUnlock()</code></span>
<span class="codeline" id="line-2304"><code>	if !shouldRedirect {</code></span>
<span class="codeline" id="line-2305"><code>		return u, false</code></span>
<span class="codeline" id="line-2306"><code>	}</code></span>
<span class="codeline" id="line-2307"><code>	path = path + "/"</code></span>
<span class="codeline" id="line-2308"><code>	u = &amp;url.URL{Path: path, RawQuery: u.RawQuery}</code></span>
<span class="codeline" id="line-2309"><code>	return u, true</code></span>
<span class="codeline" id="line-2310"><code>}</code></span>
<span class="codeline" id="line-2311"><code></code></span>
<span class="codeline" id="line-2312"><code>// shouldRedirectRLocked reports whether the given path and host should be redirected to</code></span>
<span class="codeline" id="line-2313"><code>// path+"/". This should happen if a handler is registered for path+"/" but</code></span>
<span class="codeline" id="line-2314"><code>// not path -- see comments at ServeMux.</code></span>
<span class="codeline" id="line-2315"><code>func (mux *ServeMux) shouldRedirectRLocked(host, path string) bool {</code></span>
<span class="codeline" id="line-2316"><code>	p := []string{path, host + path}</code></span>
<span class="codeline" id="line-2317"><code></code></span>
<span class="codeline" id="line-2318"><code>	for _, c := range p {</code></span>
<span class="codeline" id="line-2319"><code>		if _, exist := mux.m[c]; exist {</code></span>
<span class="codeline" id="line-2320"><code>			return false</code></span>
<span class="codeline" id="line-2321"><code>		}</code></span>
<span class="codeline" id="line-2322"><code>	}</code></span>
<span class="codeline" id="line-2323"><code></code></span>
<span class="codeline" id="line-2324"><code>	n := len(path)</code></span>
<span class="codeline" id="line-2325"><code>	if n == 0 {</code></span>
<span class="codeline" id="line-2326"><code>		return false</code></span>
<span class="codeline" id="line-2327"><code>	}</code></span>
<span class="codeline" id="line-2328"><code>	for _, c := range p {</code></span>
<span class="codeline" id="line-2329"><code>		if _, exist := mux.m[c+"/"]; exist {</code></span>
<span class="codeline" id="line-2330"><code>			return path[n-1] != '/'</code></span>
<span class="codeline" id="line-2331"><code>		}</code></span>
<span class="codeline" id="line-2332"><code>	}</code></span>
<span class="codeline" id="line-2333"><code></code></span>
<span class="codeline" id="line-2334"><code>	return false</code></span>
<span class="codeline" id="line-2335"><code>}</code></span>
<span class="codeline" id="line-2336"><code></code></span>
<span class="codeline" id="line-2337"><code>// Handler returns the handler to use for the given request,</code></span>
<span class="codeline" id="line-2338"><code>// consulting r.Method, r.Host, and r.URL.Path. It always returns</code></span>
<span class="codeline" id="line-2339"><code>// a non-nil handler. If the path is not in its canonical form, the</code></span>
<span class="codeline" id="line-2340"><code>// handler will be an internally-generated handler that redirects</code></span>
<span class="codeline" id="line-2341"><code>// to the canonical path. If the host contains a port, it is ignored</code></span>
<span class="codeline" id="line-2342"><code>// when matching handlers.</code></span>
<span class="codeline" id="line-2343"><code>//</code></span>
<span class="codeline" id="line-2344"><code>// The path and host are used unchanged for CONNECT requests.</code></span>
<span class="codeline" id="line-2345"><code>//</code></span>
<span class="codeline" id="line-2346"><code>// Handler also returns the registered pattern that matches the</code></span>
<span class="codeline" id="line-2347"><code>// request or, in the case of internally-generated redirects,</code></span>
<span class="codeline" id="line-2348"><code>// the pattern that will match after following the redirect.</code></span>
<span class="codeline" id="line-2349"><code>//</code></span>
<span class="codeline" id="line-2350"><code>// If there is no registered handler that applies to the request,</code></span>
<span class="codeline" id="line-2351"><code>// Handler returns a ``page not found'' handler and an empty pattern.</code></span>
<span class="codeline" id="line-2352"><code>func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) {</code></span>
<span class="codeline" id="line-2353"><code></code></span>
<span class="codeline" id="line-2354"><code>	// CONNECT requests are not canonicalized.</code></span>
<span class="codeline" id="line-2355"><code>	if r.Method == "CONNECT" {</code></span>
<span class="codeline" id="line-2356"><code>		// If r.URL.Path is /tree and its handler is not registered,</code></span>
<span class="codeline" id="line-2357"><code>		// the /tree -&gt; /tree/ redirect applies to CONNECT requests</code></span>
<span class="codeline" id="line-2358"><code>		// but the path canonicalization does not.</code></span>
<span class="codeline" id="line-2359"><code>		if u, ok := mux.redirectToPathSlash(r.URL.Host, r.URL.Path, r.URL); ok {</code></span>
<span class="codeline" id="line-2360"><code>			return RedirectHandler(u.String(), StatusMovedPermanently), u.Path</code></span>
<span class="codeline" id="line-2361"><code>		}</code></span>
<span class="codeline" id="line-2362"><code></code></span>
<span class="codeline" id="line-2363"><code>		return mux.handler(r.Host, r.URL.Path)</code></span>
<span class="codeline" id="line-2364"><code>	}</code></span>
<span class="codeline" id="line-2365"><code></code></span>
<span class="codeline" id="line-2366"><code>	// All other requests have any port stripped and path cleaned</code></span>
<span class="codeline" id="line-2367"><code>	// before passing to mux.handler.</code></span>
<span class="codeline" id="line-2368"><code>	host := stripHostPort(r.Host)</code></span>
<span class="codeline" id="line-2369"><code>	path := cleanPath(r.URL.Path)</code></span>
<span class="codeline" id="line-2370"><code></code></span>
<span class="codeline" id="line-2371"><code>	// If the given path is /tree and its handler is not registered,</code></span>
<span class="codeline" id="line-2372"><code>	// redirect for /tree/.</code></span>
<span class="codeline" id="line-2373"><code>	if u, ok := mux.redirectToPathSlash(host, path, r.URL); ok {</code></span>
<span class="codeline" id="line-2374"><code>		return RedirectHandler(u.String(), StatusMovedPermanently), u.Path</code></span>
<span class="codeline" id="line-2375"><code>	}</code></span>
<span class="codeline" id="line-2376"><code></code></span>
<span class="codeline" id="line-2377"><code>	if path != r.URL.Path {</code></span>
<span class="codeline" id="line-2378"><code>		_, pattern = mux.handler(host, path)</code></span>
<span class="codeline" id="line-2379"><code>		url := *r.URL</code></span>
<span class="codeline" id="line-2380"><code>		url.Path = path</code></span>
<span class="codeline" id="line-2381"><code>		return RedirectHandler(url.String(), StatusMovedPermanently), pattern</code></span>
<span class="codeline" id="line-2382"><code>	}</code></span>
<span class="codeline" id="line-2383"><code></code></span>
<span class="codeline" id="line-2384"><code>	return mux.handler(host, r.URL.Path)</code></span>
<span class="codeline" id="line-2385"><code>}</code></span>
<span class="codeline" id="line-2386"><code></code></span>
<span class="codeline" id="line-2387"><code>// handler is the main implementation of Handler.</code></span>
<span class="codeline" id="line-2388"><code>// The path is known to be in canonical form, except for CONNECT methods.</code></span>
<span class="codeline" id="line-2389"><code>func (mux *ServeMux) handler(host, path string) (h Handler, pattern string) {</code></span>
<span class="codeline" id="line-2390"><code>	mux.mu.RLock()</code></span>
<span class="codeline" id="line-2391"><code>	defer mux.mu.RUnlock()</code></span>
<span class="codeline" id="line-2392"><code></code></span>
<span class="codeline" id="line-2393"><code>	// Host-specific pattern takes precedence over generic ones</code></span>
<span class="codeline" id="line-2394"><code>	if mux.hosts {</code></span>
<span class="codeline" id="line-2395"><code>		h, pattern = mux.match(host + path)</code></span>
<span class="codeline" id="line-2396"><code>	}</code></span>
<span class="codeline" id="line-2397"><code>	if h == nil {</code></span>
<span class="codeline" id="line-2398"><code>		h, pattern = mux.match(path)</code></span>
<span class="codeline" id="line-2399"><code>	}</code></span>
<span class="codeline" id="line-2400"><code>	if h == nil {</code></span>
<span class="codeline" id="line-2401"><code>		h, pattern = NotFoundHandler(), ""</code></span>
<span class="codeline" id="line-2402"><code>	}</code></span>
<span class="codeline" id="line-2403"><code>	return</code></span>
<span class="codeline" id="line-2404"><code>}</code></span>
<span class="codeline" id="line-2405"><code></code></span>
<span class="codeline" id="line-2406"><code>// ServeHTTP dispatches the request to the handler whose</code></span>
<span class="codeline" id="line-2407"><code>// pattern most closely matches the request URL.</code></span>
<span class="codeline" id="line-2408"><code>func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {</code></span>
<span class="codeline" id="line-2409"><code>	if r.RequestURI == "*" {</code></span>
<span class="codeline" id="line-2410"><code>		if r.ProtoAtLeast(1, 1) {</code></span>
<span class="codeline" id="line-2411"><code>			w.Header().Set("Connection", "close")</code></span>
<span class="codeline" id="line-2412"><code>		}</code></span>
<span class="codeline" id="line-2413"><code>		w.WriteHeader(StatusBadRequest)</code></span>
<span class="codeline" id="line-2414"><code>		return</code></span>
<span class="codeline" id="line-2415"><code>	}</code></span>
<span class="codeline" id="line-2416"><code>	h, _ := mux.Handler(r)</code></span>
<span class="codeline" id="line-2417"><code>	h.ServeHTTP(w, r)</code></span>
<span class="codeline" id="line-2418"><code>}</code></span>
<span class="codeline" id="line-2419"><code></code></span>
<span class="codeline" id="line-2420"><code>// Handle registers the handler for the given pattern.</code></span>
<span class="codeline" id="line-2421"><code>// If a handler already exists for pattern, Handle panics.</code></span>
<span class="codeline" id="line-2422"><code>func (mux *ServeMux) Handle(pattern string, handler Handler) {</code></span>
<span class="codeline" id="line-2423"><code>	mux.mu.Lock()</code></span>
<span class="codeline" id="line-2424"><code>	defer mux.mu.Unlock()</code></span>
<span class="codeline" id="line-2425"><code></code></span>
<span class="codeline" id="line-2426"><code>	if pattern == "" {</code></span>
<span class="codeline" id="line-2427"><code>		panic("http: invalid pattern")</code></span>
<span class="codeline" id="line-2428"><code>	}</code></span>
<span class="codeline" id="line-2429"><code>	if handler == nil {</code></span>
<span class="codeline" id="line-2430"><code>		panic("http: nil handler")</code></span>
<span class="codeline" id="line-2431"><code>	}</code></span>
<span class="codeline" id="line-2432"><code>	if _, exist := mux.m[pattern]; exist {</code></span>
<span class="codeline" id="line-2433"><code>		panic("http: multiple registrations for " + pattern)</code></span>
<span class="codeline" id="line-2434"><code>	}</code></span>
<span class="codeline" id="line-2435"><code></code></span>
<span class="codeline" id="line-2436"><code>	if mux.m == nil {</code></span>
<span class="codeline" id="line-2437"><code>		mux.m = make(map[string]muxEntry)</code></span>
<span class="codeline" id="line-2438"><code>	}</code></span>
<span class="codeline" id="line-2439"><code>	e := muxEntry{h: handler, pattern: pattern}</code></span>
<span class="codeline" id="line-2440"><code>	mux.m[pattern] = e</code></span>
<span class="codeline" id="line-2441"><code>	if pattern[len(pattern)-1] == '/' {</code></span>
<span class="codeline" id="line-2442"><code>		mux.es = appendSorted(mux.es, e)</code></span>
<span class="codeline" id="line-2443"><code>	}</code></span>
<span class="codeline" id="line-2444"><code></code></span>
<span class="codeline" id="line-2445"><code>	if pattern[0] != '/' {</code></span>
<span class="codeline" id="line-2446"><code>		mux.hosts = true</code></span>
<span class="codeline" id="line-2447"><code>	}</code></span>
<span class="codeline" id="line-2448"><code>}</code></span>
<span class="codeline" id="line-2449"><code></code></span>
<span class="codeline" id="line-2450"><code>func appendSorted(es []muxEntry, e muxEntry) []muxEntry {</code></span>
<span class="codeline" id="line-2451"><code>	n := len(es)</code></span>
<span class="codeline" id="line-2452"><code>	i := sort.Search(n, func(i int) bool {</code></span>
<span class="codeline" id="line-2453"><code>		return len(es[i].pattern) &lt; len(e.pattern)</code></span>
<span class="codeline" id="line-2454"><code>	})</code></span>
<span class="codeline" id="line-2455"><code>	if i == n {</code></span>
<span class="codeline" id="line-2456"><code>		return append(es, e)</code></span>
<span class="codeline" id="line-2457"><code>	}</code></span>
<span class="codeline" id="line-2458"><code>	// we now know that i points at where we want to insert</code></span>
<span class="codeline" id="line-2459"><code>	es = append(es, muxEntry{}) // try to grow the slice in place, any entry works.</code></span>
<span class="codeline" id="line-2460"><code>	copy(es[i+1:], es[i:])      // Move shorter entries down</code></span>
<span class="codeline" id="line-2461"><code>	es[i] = e</code></span>
<span class="codeline" id="line-2462"><code>	return es</code></span>
<span class="codeline" id="line-2463"><code>}</code></span>
<span class="codeline" id="line-2464"><code></code></span>
<span class="codeline" id="line-2465"><code>// HandleFunc registers the handler function for the given pattern.</code></span>
<span class="codeline" id="line-2466"><code>func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {</code></span>
<span class="codeline" id="line-2467"><code>	if handler == nil {</code></span>
<span class="codeline" id="line-2468"><code>		panic("http: nil handler")</code></span>
<span class="codeline" id="line-2469"><code>	}</code></span>
<span class="codeline" id="line-2470"><code>	mux.Handle(pattern, HandlerFunc(handler))</code></span>
<span class="codeline" id="line-2471"><code>}</code></span>
<span class="codeline" id="line-2472"><code></code></span>
<span class="codeline" id="line-2473"><code>// Handle registers the handler for the given pattern</code></span>
<span class="codeline" id="line-2474"><code>// in the DefaultServeMux.</code></span>
<span class="codeline" id="line-2475"><code>// The documentation for ServeMux explains how patterns are matched.</code></span>
<span class="codeline" id="line-2476"><code>func Handle(pattern string, handler Handler) { DefaultServeMux.Handle(pattern, handler) }</code></span>
<span class="codeline" id="line-2477"><code></code></span>
<span class="codeline" id="line-2478"><code>// HandleFunc registers the handler function for the given pattern</code></span>
<span class="codeline" id="line-2479"><code>// in the DefaultServeMux.</code></span>
<span class="codeline" id="line-2480"><code>// The documentation for ServeMux explains how patterns are matched.</code></span>
<span class="codeline" id="line-2481"><code>func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {</code></span>
<span class="codeline" id="line-2482"><code>	DefaultServeMux.HandleFunc(pattern, handler)</code></span>
<span class="codeline" id="line-2483"><code>}</code></span>
<span class="codeline" id="line-2484"><code></code></span>
<span class="codeline" id="line-2485"><code>// Serve accepts incoming HTTP connections on the listener l,</code></span>
<span class="codeline" id="line-2486"><code>// creating a new service goroutine for each. The service goroutines</code></span>
<span class="codeline" id="line-2487"><code>// read requests and then call handler to reply to them.</code></span>
<span class="codeline" id="line-2488"><code>//</code></span>
<span class="codeline" id="line-2489"><code>// The handler is typically nil, in which case the DefaultServeMux is used.</code></span>
<span class="codeline" id="line-2490"><code>//</code></span>
<span class="codeline" id="line-2491"><code>// HTTP/2 support is only enabled if the Listener returns *tls.Conn</code></span>
<span class="codeline" id="line-2492"><code>// connections and they were configured with "h2" in the TLS</code></span>
<span class="codeline" id="line-2493"><code>// Config.NextProtos.</code></span>
<span class="codeline" id="line-2494"><code>//</code></span>
<span class="codeline" id="line-2495"><code>// Serve always returns a non-nil error.</code></span>
<span class="codeline" id="line-2496"><code>func Serve(l net.Listener, handler Handler) error {</code></span>
<span class="codeline" id="line-2497"><code>	srv := &amp;Server{Handler: handler}</code></span>
<span class="codeline" id="line-2498"><code>	return srv.Serve(l)</code></span>
<span class="codeline" id="line-2499"><code>}</code></span>
<span class="codeline" id="line-2500"><code></code></span>
<span class="codeline" id="line-2501"><code>// ServeTLS accepts incoming HTTPS connections on the listener l,</code></span>
<span class="codeline" id="line-2502"><code>// creating a new service goroutine for each. The service goroutines</code></span>
<span class="codeline" id="line-2503"><code>// read requests and then call handler to reply to them.</code></span>
<span class="codeline" id="line-2504"><code>//</code></span>
<span class="codeline" id="line-2505"><code>// The handler is typically nil, in which case the DefaultServeMux is used.</code></span>
<span class="codeline" id="line-2506"><code>//</code></span>
<span class="codeline" id="line-2507"><code>// Additionally, files containing a certificate and matching private key</code></span>
<span class="codeline" id="line-2508"><code>// for the server must be provided. If the certificate is signed by a</code></span>
<span class="codeline" id="line-2509"><code>// certificate authority, the certFile should be the concatenation</code></span>
<span class="codeline" id="line-2510"><code>// of the server's certificate, any intermediates, and the CA's certificate.</code></span>
<span class="codeline" id="line-2511"><code>//</code></span>
<span class="codeline" id="line-2512"><code>// ServeTLS always returns a non-nil error.</code></span>
<span class="codeline" id="line-2513"><code>func ServeTLS(l net.Listener, handler Handler, certFile, keyFile string) error {</code></span>
<span class="codeline" id="line-2514"><code>	srv := &amp;Server{Handler: handler}</code></span>
<span class="codeline" id="line-2515"><code>	return srv.ServeTLS(l, certFile, keyFile)</code></span>
<span class="codeline" id="line-2516"><code>}</code></span>
<span class="codeline" id="line-2517"><code></code></span>
<span class="codeline" id="line-2518"><code>// A Server defines parameters for running an HTTP server.</code></span>
<span class="codeline" id="line-2519"><code>// The zero value for Server is a valid configuration.</code></span>
<span class="codeline" id="line-2520"><code>type Server struct {</code></span>
<span class="codeline" id="line-2521"><code>	// Addr optionally specifies the TCP address for the server to listen on,</code></span>
<span class="codeline" id="line-2522"><code>	// in the form "host:port". If empty, ":http" (port 80) is used.</code></span>
<span class="codeline" id="line-2523"><code>	// The service names are defined in RFC 6335 and assigned by IANA.</code></span>
<span class="codeline" id="line-2524"><code>	// See net.Dial for details of the address format.</code></span>
<span class="codeline" id="line-2525"><code>	Addr string</code></span>
<span class="codeline" id="line-2526"><code></code></span>
<span class="codeline" id="line-2527"><code>	Handler Handler // handler to invoke, http.DefaultServeMux if nil</code></span>
<span class="codeline" id="line-2528"><code></code></span>
<span class="codeline" id="line-2529"><code>	// TLSConfig optionally provides a TLS configuration for use</code></span>
<span class="codeline" id="line-2530"><code>	// by ServeTLS and ListenAndServeTLS. Note that this value is</code></span>
<span class="codeline" id="line-2531"><code>	// cloned by ServeTLS and ListenAndServeTLS, so it's not</code></span>
<span class="codeline" id="line-2532"><code>	// possible to modify the configuration with methods like</code></span>
<span class="codeline" id="line-2533"><code>	// tls.Config.SetSessionTicketKeys. To use</code></span>
<span class="codeline" id="line-2534"><code>	// SetSessionTicketKeys, use Server.Serve with a TLS Listener</code></span>
<span class="codeline" id="line-2535"><code>	// instead.</code></span>
<span class="codeline" id="line-2536"><code>	TLSConfig *tls.Config</code></span>
<span class="codeline" id="line-2537"><code></code></span>
<span class="codeline" id="line-2538"><code>	// ReadTimeout is the maximum duration for reading the entire</code></span>
<span class="codeline" id="line-2539"><code>	// request, including the body.</code></span>
<span class="codeline" id="line-2540"><code>	//</code></span>
<span class="codeline" id="line-2541"><code>	// Because ReadTimeout does not let Handlers make per-request</code></span>
<span class="codeline" id="line-2542"><code>	// decisions on each request body's acceptable deadline or</code></span>
<span class="codeline" id="line-2543"><code>	// upload rate, most users will prefer to use</code></span>
<span class="codeline" id="line-2544"><code>	// ReadHeaderTimeout. It is valid to use them both.</code></span>
<span class="codeline" id="line-2545"><code>	ReadTimeout time.Duration</code></span>
<span class="codeline" id="line-2546"><code></code></span>
<span class="codeline" id="line-2547"><code>	// ReadHeaderTimeout is the amount of time allowed to read</code></span>
<span class="codeline" id="line-2548"><code>	// request headers. The connection's read deadline is reset</code></span>
<span class="codeline" id="line-2549"><code>	// after reading the headers and the Handler can decide what</code></span>
<span class="codeline" id="line-2550"><code>	// is considered too slow for the body. If ReadHeaderTimeout</code></span>
<span class="codeline" id="line-2551"><code>	// is zero, the value of ReadTimeout is used. If both are</code></span>
<span class="codeline" id="line-2552"><code>	// zero, there is no timeout.</code></span>
<span class="codeline" id="line-2553"><code>	ReadHeaderTimeout time.Duration</code></span>
<span class="codeline" id="line-2554"><code></code></span>
<span class="codeline" id="line-2555"><code>	// WriteTimeout is the maximum duration before timing out</code></span>
<span class="codeline" id="line-2556"><code>	// writes of the response. It is reset whenever a new</code></span>
<span class="codeline" id="line-2557"><code>	// request's header is read. Like ReadTimeout, it does not</code></span>
<span class="codeline" id="line-2558"><code>	// let Handlers make decisions on a per-request basis.</code></span>
<span class="codeline" id="line-2559"><code>	WriteTimeout time.Duration</code></span>
<span class="codeline" id="line-2560"><code></code></span>
<span class="codeline" id="line-2561"><code>	// IdleTimeout is the maximum amount of time to wait for the</code></span>
<span class="codeline" id="line-2562"><code>	// next request when keep-alives are enabled. If IdleTimeout</code></span>
<span class="codeline" id="line-2563"><code>	// is zero, the value of ReadTimeout is used. If both are</code></span>
<span class="codeline" id="line-2564"><code>	// zero, there is no timeout.</code></span>
<span class="codeline" id="line-2565"><code>	IdleTimeout time.Duration</code></span>
<span class="codeline" id="line-2566"><code></code></span>
<span class="codeline" id="line-2567"><code>	// MaxHeaderBytes controls the maximum number of bytes the</code></span>
<span class="codeline" id="line-2568"><code>	// server will read parsing the request header's keys and</code></span>
<span class="codeline" id="line-2569"><code>	// values, including the request line. It does not limit the</code></span>
<span class="codeline" id="line-2570"><code>	// size of the request body.</code></span>
<span class="codeline" id="line-2571"><code>	// If zero, DefaultMaxHeaderBytes is used.</code></span>
<span class="codeline" id="line-2572"><code>	MaxHeaderBytes int</code></span>
<span class="codeline" id="line-2573"><code></code></span>
<span class="codeline" id="line-2574"><code>	// TLSNextProto optionally specifies a function to take over</code></span>
<span class="codeline" id="line-2575"><code>	// ownership of the provided TLS connection when an ALPN</code></span>
<span class="codeline" id="line-2576"><code>	// protocol upgrade has occurred. The map key is the protocol</code></span>
<span class="codeline" id="line-2577"><code>	// name negotiated. The Handler argument should be used to</code></span>
<span class="codeline" id="line-2578"><code>	// handle HTTP requests and will initialize the Request's TLS</code></span>
<span class="codeline" id="line-2579"><code>	// and RemoteAddr if not already set. The connection is</code></span>
<span class="codeline" id="line-2580"><code>	// automatically closed when the function returns.</code></span>
<span class="codeline" id="line-2581"><code>	// If TLSNextProto is not nil, HTTP/2 support is not enabled</code></span>
<span class="codeline" id="line-2582"><code>	// automatically.</code></span>
<span class="codeline" id="line-2583"><code>	TLSNextProto map[string]func(*Server, *tls.Conn, Handler)</code></span>
<span class="codeline" id="line-2584"><code></code></span>
<span class="codeline" id="line-2585"><code>	// ConnState specifies an optional callback function that is</code></span>
<span class="codeline" id="line-2586"><code>	// called when a client connection changes state. See the</code></span>
<span class="codeline" id="line-2587"><code>	// ConnState type and associated constants for details.</code></span>
<span class="codeline" id="line-2588"><code>	ConnState func(net.Conn, ConnState)</code></span>
<span class="codeline" id="line-2589"><code></code></span>
<span class="codeline" id="line-2590"><code>	// ErrorLog specifies an optional logger for errors accepting</code></span>
<span class="codeline" id="line-2591"><code>	// connections, unexpected behavior from handlers, and</code></span>
<span class="codeline" id="line-2592"><code>	// underlying FileSystem errors.</code></span>
<span class="codeline" id="line-2593"><code>	// If nil, logging is done via the log package's standard logger.</code></span>
<span class="codeline" id="line-2594"><code>	ErrorLog *log.Logger</code></span>
<span class="codeline" id="line-2595"><code></code></span>
<span class="codeline" id="line-2596"><code>	// BaseContext optionally specifies a function that returns</code></span>
<span class="codeline" id="line-2597"><code>	// the base context for incoming requests on this server.</code></span>
<span class="codeline" id="line-2598"><code>	// The provided Listener is the specific Listener that's</code></span>
<span class="codeline" id="line-2599"><code>	// about to start accepting requests.</code></span>
<span class="codeline" id="line-2600"><code>	// If BaseContext is nil, the default is context.Background().</code></span>
<span class="codeline" id="line-2601"><code>	// If non-nil, it must return a non-nil context.</code></span>
<span class="codeline" id="line-2602"><code>	BaseContext func(net.Listener) context.Context</code></span>
<span class="codeline" id="line-2603"><code></code></span>
<span class="codeline" id="line-2604"><code>	// ConnContext optionally specifies a function that modifies</code></span>
<span class="codeline" id="line-2605"><code>	// the context used for a new connection c. The provided ctx</code></span>
<span class="codeline" id="line-2606"><code>	// is derived from the base context and has a ServerContextKey</code></span>
<span class="codeline" id="line-2607"><code>	// value.</code></span>
<span class="codeline" id="line-2608"><code>	ConnContext func(ctx context.Context, c net.Conn) context.Context</code></span>
<span class="codeline" id="line-2609"><code></code></span>
<span class="codeline" id="line-2610"><code>	inShutdown atomicBool // true when when server is in shutdown</code></span>
<span class="codeline" id="line-2611"><code></code></span>
<span class="codeline" id="line-2612"><code>	disableKeepAlives int32     // accessed atomically.</code></span>
<span class="codeline" id="line-2613"><code>	nextProtoOnce     sync.Once // guards setupHTTP2_* init</code></span>
<span class="codeline" id="line-2614"><code>	nextProtoErr      error     // result of http2.ConfigureServer if used</code></span>
<span class="codeline" id="line-2615"><code></code></span>
<span class="codeline" id="line-2616"><code>	mu         sync.Mutex</code></span>
<span class="codeline" id="line-2617"><code>	listeners  map[*net.Listener]struct{}</code></span>
<span class="codeline" id="line-2618"><code>	activeConn map[*conn]struct{}</code></span>
<span class="codeline" id="line-2619"><code>	doneChan   chan struct{}</code></span>
<span class="codeline" id="line-2620"><code>	onShutdown []func()</code></span>
<span class="codeline" id="line-2621"><code>}</code></span>
<span class="codeline" id="line-2622"><code></code></span>
<span class="codeline" id="line-2623"><code>func (s *Server) getDoneChan() &lt;-chan struct{} {</code></span>
<span class="codeline" id="line-2624"><code>	s.mu.Lock()</code></span>
<span class="codeline" id="line-2625"><code>	defer s.mu.Unlock()</code></span>
<span class="codeline" id="line-2626"><code>	return s.getDoneChanLocked()</code></span>
<span class="codeline" id="line-2627"><code>}</code></span>
<span class="codeline" id="line-2628"><code></code></span>
<span class="codeline" id="line-2629"><code>func (s *Server) getDoneChanLocked() chan struct{} {</code></span>
<span class="codeline" id="line-2630"><code>	if s.doneChan == nil {</code></span>
<span class="codeline" id="line-2631"><code>		s.doneChan = make(chan struct{})</code></span>
<span class="codeline" id="line-2632"><code>	}</code></span>
<span class="codeline" id="line-2633"><code>	return s.doneChan</code></span>
<span class="codeline" id="line-2634"><code>}</code></span>
<span class="codeline" id="line-2635"><code></code></span>
<span class="codeline" id="line-2636"><code>func (s *Server) closeDoneChanLocked() {</code></span>
<span class="codeline" id="line-2637"><code>	ch := s.getDoneChanLocked()</code></span>
<span class="codeline" id="line-2638"><code>	select {</code></span>
<span class="codeline" id="line-2639"><code>	case &lt;-ch:</code></span>
<span class="codeline" id="line-2640"><code>		// Already closed. Don't close again.</code></span>
<span class="codeline" id="line-2641"><code>	default:</code></span>
<span class="codeline" id="line-2642"><code>		// Safe to close here. We're the only closer, guarded</code></span>
<span class="codeline" id="line-2643"><code>		// by s.mu.</code></span>
<span class="codeline" id="line-2644"><code>		close(ch)</code></span>
<span class="codeline" id="line-2645"><code>	}</code></span>
<span class="codeline" id="line-2646"><code>}</code></span>
<span class="codeline" id="line-2647"><code></code></span>
<span class="codeline" id="line-2648"><code>// Close immediately closes all active net.Listeners and any</code></span>
<span class="codeline" id="line-2649"><code>// connections in state StateNew, StateActive, or StateIdle. For a</code></span>
<span class="codeline" id="line-2650"><code>// graceful shutdown, use Shutdown.</code></span>
<span class="codeline" id="line-2651"><code>//</code></span>
<span class="codeline" id="line-2652"><code>// Close does not attempt to close (and does not even know about)</code></span>
<span class="codeline" id="line-2653"><code>// any hijacked connections, such as WebSockets.</code></span>
<span class="codeline" id="line-2654"><code>//</code></span>
<span class="codeline" id="line-2655"><code>// Close returns any error returned from closing the Server's</code></span>
<span class="codeline" id="line-2656"><code>// underlying Listener(s).</code></span>
<span class="codeline" id="line-2657"><code>func (srv *Server) Close() error {</code></span>
<span class="codeline" id="line-2658"><code>	srv.inShutdown.setTrue()</code></span>
<span class="codeline" id="line-2659"><code>	srv.mu.Lock()</code></span>
<span class="codeline" id="line-2660"><code>	defer srv.mu.Unlock()</code></span>
<span class="codeline" id="line-2661"><code>	srv.closeDoneChanLocked()</code></span>
<span class="codeline" id="line-2662"><code>	err := srv.closeListenersLocked()</code></span>
<span class="codeline" id="line-2663"><code>	for c := range srv.activeConn {</code></span>
<span class="codeline" id="line-2664"><code>		c.rwc.Close()</code></span>
<span class="codeline" id="line-2665"><code>		delete(srv.activeConn, c)</code></span>
<span class="codeline" id="line-2666"><code>	}</code></span>
<span class="codeline" id="line-2667"><code>	return err</code></span>
<span class="codeline" id="line-2668"><code>}</code></span>
<span class="codeline" id="line-2669"><code></code></span>
<span class="codeline" id="line-2670"><code>// shutdownPollInterval is how often we poll for quiescence</code></span>
<span class="codeline" id="line-2671"><code>// during Server.Shutdown. This is lower during tests, to</code></span>
<span class="codeline" id="line-2672"><code>// speed up tests.</code></span>
<span class="codeline" id="line-2673"><code>// Ideally we could find a solution that doesn't involve polling,</code></span>
<span class="codeline" id="line-2674"><code>// but which also doesn't have a high runtime cost (and doesn't</code></span>
<span class="codeline" id="line-2675"><code>// involve any contentious mutexes), but that is left as an</code></span>
<span class="codeline" id="line-2676"><code>// exercise for the reader.</code></span>
<span class="codeline" id="line-2677"><code>var shutdownPollInterval = 500 * time.Millisecond</code></span>
<span class="codeline" id="line-2678"><code></code></span>
<span class="codeline" id="line-2679"><code>// Shutdown gracefully shuts down the server without interrupting any</code></span>
<span class="codeline" id="line-2680"><code>// active connections. Shutdown works by first closing all open</code></span>
<span class="codeline" id="line-2681"><code>// listeners, then closing all idle connections, and then waiting</code></span>
<span class="codeline" id="line-2682"><code>// indefinitely for connections to return to idle and then shut down.</code></span>
<span class="codeline" id="line-2683"><code>// If the provided context expires before the shutdown is complete,</code></span>
<span class="codeline" id="line-2684"><code>// Shutdown returns the context's error, otherwise it returns any</code></span>
<span class="codeline" id="line-2685"><code>// error returned from closing the Server's underlying Listener(s).</code></span>
<span class="codeline" id="line-2686"><code>//</code></span>
<span class="codeline" id="line-2687"><code>// When Shutdown is called, Serve, ListenAndServe, and</code></span>
<span class="codeline" id="line-2688"><code>// ListenAndServeTLS immediately return ErrServerClosed. Make sure the</code></span>
<span class="codeline" id="line-2689"><code>// program doesn't exit and waits instead for Shutdown to return.</code></span>
<span class="codeline" id="line-2690"><code>//</code></span>
<span class="codeline" id="line-2691"><code>// Shutdown does not attempt to close nor wait for hijacked</code></span>
<span class="codeline" id="line-2692"><code>// connections such as WebSockets. The caller of Shutdown should</code></span>
<span class="codeline" id="line-2693"><code>// separately notify such long-lived connections of shutdown and wait</code></span>
<span class="codeline" id="line-2694"><code>// for them to close, if desired. See RegisterOnShutdown for a way to</code></span>
<span class="codeline" id="line-2695"><code>// register shutdown notification functions.</code></span>
<span class="codeline" id="line-2696"><code>//</code></span>
<span class="codeline" id="line-2697"><code>// Once Shutdown has been called on a server, it may not be reused;</code></span>
<span class="codeline" id="line-2698"><code>// future calls to methods such as Serve will return ErrServerClosed.</code></span>
<span class="codeline" id="line-2699"><code>func (srv *Server) Shutdown(ctx context.Context) error {</code></span>
<span class="codeline" id="line-2700"><code>	srv.inShutdown.setTrue()</code></span>
<span class="codeline" id="line-2701"><code></code></span>
<span class="codeline" id="line-2702"><code>	srv.mu.Lock()</code></span>
<span class="codeline" id="line-2703"><code>	lnerr := srv.closeListenersLocked()</code></span>
<span class="codeline" id="line-2704"><code>	srv.closeDoneChanLocked()</code></span>
<span class="codeline" id="line-2705"><code>	for _, f := range srv.onShutdown {</code></span>
<span class="codeline" id="line-2706"><code>		go f()</code></span>
<span class="codeline" id="line-2707"><code>	}</code></span>
<span class="codeline" id="line-2708"><code>	srv.mu.Unlock()</code></span>
<span class="codeline" id="line-2709"><code></code></span>
<span class="codeline" id="line-2710"><code>	ticker := time.NewTicker(shutdownPollInterval)</code></span>
<span class="codeline" id="line-2711"><code>	defer ticker.Stop()</code></span>
<span class="codeline" id="line-2712"><code>	for {</code></span>
<span class="codeline" id="line-2713"><code>		if srv.closeIdleConns() &amp;&amp; srv.numListeners() == 0 {</code></span>
<span class="codeline" id="line-2714"><code>			return lnerr</code></span>
<span class="codeline" id="line-2715"><code>		}</code></span>
<span class="codeline" id="line-2716"><code>		select {</code></span>
<span class="codeline" id="line-2717"><code>		case &lt;-ctx.Done():</code></span>
<span class="codeline" id="line-2718"><code>			return ctx.Err()</code></span>
<span class="codeline" id="line-2719"><code>		case &lt;-ticker.C:</code></span>
<span class="codeline" id="line-2720"><code>		}</code></span>
<span class="codeline" id="line-2721"><code>	}</code></span>
<span class="codeline" id="line-2722"><code>}</code></span>
<span class="codeline" id="line-2723"><code></code></span>
<span class="codeline" id="line-2724"><code>// RegisterOnShutdown registers a function to call on Shutdown.</code></span>
<span class="codeline" id="line-2725"><code>// This can be used to gracefully shutdown connections that have</code></span>
<span class="codeline" id="line-2726"><code>// undergone ALPN protocol upgrade or that have been hijacked.</code></span>
<span class="codeline" id="line-2727"><code>// This function should start protocol-specific graceful shutdown,</code></span>
<span class="codeline" id="line-2728"><code>// but should not wait for shutdown to complete.</code></span>
<span class="codeline" id="line-2729"><code>func (srv *Server) RegisterOnShutdown(f func()) {</code></span>
<span class="codeline" id="line-2730"><code>	srv.mu.Lock()</code></span>
<span class="codeline" id="line-2731"><code>	srv.onShutdown = append(srv.onShutdown, f)</code></span>
<span class="codeline" id="line-2732"><code>	srv.mu.Unlock()</code></span>
<span class="codeline" id="line-2733"><code>}</code></span>
<span class="codeline" id="line-2734"><code></code></span>
<span class="codeline" id="line-2735"><code>func (s *Server) numListeners() int {</code></span>
<span class="codeline" id="line-2736"><code>	s.mu.Lock()</code></span>
<span class="codeline" id="line-2737"><code>	defer s.mu.Unlock()</code></span>
<span class="codeline" id="line-2738"><code>	return len(s.listeners)</code></span>
<span class="codeline" id="line-2739"><code>}</code></span>
<span class="codeline" id="line-2740"><code></code></span>
<span class="codeline" id="line-2741"><code>// closeIdleConns closes all idle connections and reports whether the</code></span>
<span class="codeline" id="line-2742"><code>// server is quiescent.</code></span>
<span class="codeline" id="line-2743"><code>func (s *Server) closeIdleConns() bool {</code></span>
<span class="codeline" id="line-2744"><code>	s.mu.Lock()</code></span>
<span class="codeline" id="line-2745"><code>	defer s.mu.Unlock()</code></span>
<span class="codeline" id="line-2746"><code>	quiescent := true</code></span>
<span class="codeline" id="line-2747"><code>	for c := range s.activeConn {</code></span>
<span class="codeline" id="line-2748"><code>		st, unixSec := c.getState()</code></span>
<span class="codeline" id="line-2749"><code>		// Issue 22682: treat StateNew connections as if</code></span>
<span class="codeline" id="line-2750"><code>		// they're idle if we haven't read the first request's</code></span>
<span class="codeline" id="line-2751"><code>		// header in over 5 seconds.</code></span>
<span class="codeline" id="line-2752"><code>		if st == StateNew &amp;&amp; unixSec &lt; time.Now().Unix()-5 {</code></span>
<span class="codeline" id="line-2753"><code>			st = StateIdle</code></span>
<span class="codeline" id="line-2754"><code>		}</code></span>
<span class="codeline" id="line-2755"><code>		if st != StateIdle || unixSec == 0 {</code></span>
<span class="codeline" id="line-2756"><code>			// Assume unixSec == 0 means it's a very new</code></span>
<span class="codeline" id="line-2757"><code>			// connection, without state set yet.</code></span>
<span class="codeline" id="line-2758"><code>			quiescent = false</code></span>
<span class="codeline" id="line-2759"><code>			continue</code></span>
<span class="codeline" id="line-2760"><code>		}</code></span>
<span class="codeline" id="line-2761"><code>		c.rwc.Close()</code></span>
<span class="codeline" id="line-2762"><code>		delete(s.activeConn, c)</code></span>
<span class="codeline" id="line-2763"><code>	}</code></span>
<span class="codeline" id="line-2764"><code>	return quiescent</code></span>
<span class="codeline" id="line-2765"><code>}</code></span>
<span class="codeline" id="line-2766"><code></code></span>
<span class="codeline" id="line-2767"><code>func (s *Server) closeListenersLocked() error {</code></span>
<span class="codeline" id="line-2768"><code>	var err error</code></span>
<span class="codeline" id="line-2769"><code>	for ln := range s.listeners {</code></span>
<span class="codeline" id="line-2770"><code>		if cerr := (*ln).Close(); cerr != nil &amp;&amp; err == nil {</code></span>
<span class="codeline" id="line-2771"><code>			err = cerr</code></span>
<span class="codeline" id="line-2772"><code>		}</code></span>
<span class="codeline" id="line-2773"><code>	}</code></span>
<span class="codeline" id="line-2774"><code>	return err</code></span>
<span class="codeline" id="line-2775"><code>}</code></span>
<span class="codeline" id="line-2776"><code></code></span>
<span class="codeline" id="line-2777"><code>// A ConnState represents the state of a client connection to a server.</code></span>
<span class="codeline" id="line-2778"><code>// It's used by the optional Server.ConnState hook.</code></span>
<span class="codeline" id="line-2779"><code>type ConnState int</code></span>
<span class="codeline" id="line-2780"><code></code></span>
<span class="codeline" id="line-2781"><code>const (</code></span>
<span class="codeline" id="line-2782"><code>	// StateNew represents a new connection that is expected to</code></span>
<span class="codeline" id="line-2783"><code>	// send a request immediately. Connections begin at this</code></span>
<span class="codeline" id="line-2784"><code>	// state and then transition to either StateActive or</code></span>
<span class="codeline" id="line-2785"><code>	// StateClosed.</code></span>
<span class="codeline" id="line-2786"><code>	StateNew ConnState = iota</code></span>
<span class="codeline" id="line-2787"><code></code></span>
<span class="codeline" id="line-2788"><code>	// StateActive represents a connection that has read 1 or more</code></span>
<span class="codeline" id="line-2789"><code>	// bytes of a request. The Server.ConnState hook for</code></span>
<span class="codeline" id="line-2790"><code>	// StateActive fires before the request has entered a handler</code></span>
<span class="codeline" id="line-2791"><code>	// and doesn't fire again until the request has been</code></span>
<span class="codeline" id="line-2792"><code>	// handled. After the request is handled, the state</code></span>
<span class="codeline" id="line-2793"><code>	// transitions to StateClosed, StateHijacked, or StateIdle.</code></span>
<span class="codeline" id="line-2794"><code>	// For HTTP/2, StateActive fires on the transition from zero</code></span>
<span class="codeline" id="line-2795"><code>	// to one active request, and only transitions away once all</code></span>
<span class="codeline" id="line-2796"><code>	// active requests are complete. That means that ConnState</code></span>
<span class="codeline" id="line-2797"><code>	// cannot be used to do per-request work; ConnState only notes</code></span>
<span class="codeline" id="line-2798"><code>	// the overall state of the connection.</code></span>
<span class="codeline" id="line-2799"><code>	StateActive</code></span>
<span class="codeline" id="line-2800"><code></code></span>
<span class="codeline" id="line-2801"><code>	// StateIdle represents a connection that has finished</code></span>
<span class="codeline" id="line-2802"><code>	// handling a request and is in the keep-alive state, waiting</code></span>
<span class="codeline" id="line-2803"><code>	// for a new request. Connections transition from StateIdle</code></span>
<span class="codeline" id="line-2804"><code>	// to either StateActive or StateClosed.</code></span>
<span class="codeline" id="line-2805"><code>	StateIdle</code></span>
<span class="codeline" id="line-2806"><code></code></span>
<span class="codeline" id="line-2807"><code>	// StateHijacked represents a hijacked connection.</code></span>
<span class="codeline" id="line-2808"><code>	// This is a terminal state. It does not transition to StateClosed.</code></span>
<span class="codeline" id="line-2809"><code>	StateHijacked</code></span>
<span class="codeline" id="line-2810"><code></code></span>
<span class="codeline" id="line-2811"><code>	// StateClosed represents a closed connection.</code></span>
<span class="codeline" id="line-2812"><code>	// This is a terminal state. Hijacked connections do not</code></span>
<span class="codeline" id="line-2813"><code>	// transition to StateClosed.</code></span>
<span class="codeline" id="line-2814"><code>	StateClosed</code></span>
<span class="codeline" id="line-2815"><code>)</code></span>
<span class="codeline" id="line-2816"><code></code></span>
<span class="codeline" id="line-2817"><code>var stateName = map[ConnState]string{</code></span>
<span class="codeline" id="line-2818"><code>	StateNew:      "new",</code></span>
<span class="codeline" id="line-2819"><code>	StateActive:   "active",</code></span>
<span class="codeline" id="line-2820"><code>	StateIdle:     "idle",</code></span>
<span class="codeline" id="line-2821"><code>	StateHijacked: "hijacked",</code></span>
<span class="codeline" id="line-2822"><code>	StateClosed:   "closed",</code></span>
<span class="codeline" id="line-2823"><code>}</code></span>
<span class="codeline" id="line-2824"><code></code></span>
<span class="codeline" id="line-2825"><code>func (c ConnState) String() string {</code></span>
<span class="codeline" id="line-2826"><code>	return stateName[c]</code></span>
<span class="codeline" id="line-2827"><code>}</code></span>
<span class="codeline" id="line-2828"><code></code></span>
<span class="codeline" id="line-2829"><code>// serverHandler delegates to either the server's Handler or</code></span>
<span class="codeline" id="line-2830"><code>// DefaultServeMux and also handles "OPTIONS *" requests.</code></span>
<span class="codeline" id="line-2831"><code>type serverHandler struct {</code></span>
<span class="codeline" id="line-2832"><code>	srv *Server</code></span>
<span class="codeline" id="line-2833"><code>}</code></span>
<span class="codeline" id="line-2834"><code></code></span>
<span class="codeline" id="line-2835"><code>func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {</code></span>
<span class="codeline" id="line-2836"><code>	handler := sh.srv.Handler</code></span>
<span class="codeline" id="line-2837"><code>	if handler == nil {</code></span>
<span class="codeline" id="line-2838"><code>		handler = DefaultServeMux</code></span>
<span class="codeline" id="line-2839"><code>	}</code></span>
<span class="codeline" id="line-2840"><code>	if req.RequestURI == "*" &amp;&amp; req.Method == "OPTIONS" {</code></span>
<span class="codeline" id="line-2841"><code>		handler = globalOptionsHandler{}</code></span>
<span class="codeline" id="line-2842"><code>	}</code></span>
<span class="codeline" id="line-2843"><code>	handler.ServeHTTP(rw, req)</code></span>
<span class="codeline" id="line-2844"><code>}</code></span>
<span class="codeline" id="line-2845"><code></code></span>
<span class="codeline" id="line-2846"><code>// ListenAndServe listens on the TCP network address srv.Addr and then</code></span>
<span class="codeline" id="line-2847"><code>// calls Serve to handle requests on incoming connections.</code></span>
<span class="codeline" id="line-2848"><code>// Accepted connections are configured to enable TCP keep-alives.</code></span>
<span class="codeline" id="line-2849"><code>//</code></span>
<span class="codeline" id="line-2850"><code>// If srv.Addr is blank, ":http" is used.</code></span>
<span class="codeline" id="line-2851"><code>//</code></span>
<span class="codeline" id="line-2852"><code>// ListenAndServe always returns a non-nil error. After Shutdown or Close,</code></span>
<span class="codeline" id="line-2853"><code>// the returned error is ErrServerClosed.</code></span>
<span class="codeline" id="line-2854"><code>func (srv *Server) ListenAndServe() error {</code></span>
<span class="codeline" id="line-2855"><code>	if srv.shuttingDown() {</code></span>
<span class="codeline" id="line-2856"><code>		return ErrServerClosed</code></span>
<span class="codeline" id="line-2857"><code>	}</code></span>
<span class="codeline" id="line-2858"><code>	addr := srv.Addr</code></span>
<span class="codeline" id="line-2859"><code>	if addr == "" {</code></span>
<span class="codeline" id="line-2860"><code>		addr = ":http"</code></span>
<span class="codeline" id="line-2861"><code>	}</code></span>
<span class="codeline" id="line-2862"><code>	ln, err := net.Listen("tcp", addr)</code></span>
<span class="codeline" id="line-2863"><code>	if err != nil {</code></span>
<span class="codeline" id="line-2864"><code>		return err</code></span>
<span class="codeline" id="line-2865"><code>	}</code></span>
<span class="codeline" id="line-2866"><code>	return srv.Serve(ln)</code></span>
<span class="codeline" id="line-2867"><code>}</code></span>
<span class="codeline" id="line-2868"><code></code></span>
<span class="codeline" id="line-2869"><code>var testHookServerServe func(*Server, net.Listener) // used if non-nil</code></span>
<span class="codeline" id="line-2870"><code></code></span>
<span class="codeline" id="line-2871"><code>// shouldDoServeHTTP2 reports whether Server.Serve should configure</code></span>
<span class="codeline" id="line-2872"><code>// automatic HTTP/2. (which sets up the srv.TLSNextProto map)</code></span>
<span class="codeline" id="line-2873"><code>func (srv *Server) shouldConfigureHTTP2ForServe() bool {</code></span>
<span class="codeline" id="line-2874"><code>	if srv.TLSConfig == nil {</code></span>
<span class="codeline" id="line-2875"><code>		// Compatibility with Go 1.6:</code></span>
<span class="codeline" id="line-2876"><code>		// If there's no TLSConfig, it's possible that the user just</code></span>
<span class="codeline" id="line-2877"><code>		// didn't set it on the http.Server, but did pass it to</code></span>
<span class="codeline" id="line-2878"><code>		// tls.NewListener and passed that listener to Serve.</code></span>
<span class="codeline" id="line-2879"><code>		// So we should configure HTTP/2 (to set up srv.TLSNextProto)</code></span>
<span class="codeline" id="line-2880"><code>		// in case the listener returns an "h2" *tls.Conn.</code></span>
<span class="codeline" id="line-2881"><code>		return true</code></span>
<span class="codeline" id="line-2882"><code>	}</code></span>
<span class="codeline" id="line-2883"><code>	// The user specified a TLSConfig on their http.Server.</code></span>
<span class="codeline" id="line-2884"><code>	// In this, case, only configure HTTP/2 if their tls.Config</code></span>
<span class="codeline" id="line-2885"><code>	// explicitly mentions "h2". Otherwise http2.ConfigureServer</code></span>
<span class="codeline" id="line-2886"><code>	// would modify the tls.Config to add it, but they probably already</code></span>
<span class="codeline" id="line-2887"><code>	// passed this tls.Config to tls.NewListener. And if they did,</code></span>
<span class="codeline" id="line-2888"><code>	// it's too late anyway to fix it. It would only be potentially racy.</code></span>
<span class="codeline" id="line-2889"><code>	// See Issue 15908.</code></span>
<span class="codeline" id="line-2890"><code>	return strSliceContains(srv.TLSConfig.NextProtos, http2NextProtoTLS)</code></span>
<span class="codeline" id="line-2891"><code>}</code></span>
<span class="codeline" id="line-2892"><code></code></span>
<span class="codeline" id="line-2893"><code>// ErrServerClosed is returned by the Server's Serve, ServeTLS, ListenAndServe,</code></span>
<span class="codeline" id="line-2894"><code>// and ListenAndServeTLS methods after a call to Shutdown or Close.</code></span>
<span class="codeline" id="line-2895"><code>var ErrServerClosed = errors.New("http: Server closed")</code></span>
<span class="codeline" id="line-2896"><code></code></span>
<span class="codeline" id="line-2897"><code>// Serve accepts incoming connections on the Listener l, creating a</code></span>
<span class="codeline" id="line-2898"><code>// new service goroutine for each. The service goroutines read requests and</code></span>
<span class="codeline" id="line-2899"><code>// then call srv.Handler to reply to them.</code></span>
<span class="codeline" id="line-2900"><code>//</code></span>
<span class="codeline" id="line-2901"><code>// HTTP/2 support is only enabled if the Listener returns *tls.Conn</code></span>
<span class="codeline" id="line-2902"><code>// connections and they were configured with "h2" in the TLS</code></span>
<span class="codeline" id="line-2903"><code>// Config.NextProtos.</code></span>
<span class="codeline" id="line-2904"><code>//</code></span>
<span class="codeline" id="line-2905"><code>// Serve always returns a non-nil error and closes l.</code></span>
<span class="codeline" id="line-2906"><code>// After Shutdown or Close, the returned error is ErrServerClosed.</code></span>
<span class="codeline" id="line-2907"><code>func (srv *Server) Serve(l net.Listener) error {</code></span>
<span class="codeline" id="line-2908"><code>	if fn := testHookServerServe; fn != nil {</code></span>
<span class="codeline" id="line-2909"><code>		fn(srv, l) // call hook with unwrapped listener</code></span>
<span class="codeline" id="line-2910"><code>	}</code></span>
<span class="codeline" id="line-2911"><code></code></span>
<span class="codeline" id="line-2912"><code>	origListener := l</code></span>
<span class="codeline" id="line-2913"><code>	l = &amp;onceCloseListener{Listener: l}</code></span>
<span class="codeline" id="line-2914"><code>	defer l.Close()</code></span>
<span class="codeline" id="line-2915"><code></code></span>
<span class="codeline" id="line-2916"><code>	if err := srv.setupHTTP2_Serve(); err != nil {</code></span>
<span class="codeline" id="line-2917"><code>		return err</code></span>
<span class="codeline" id="line-2918"><code>	}</code></span>
<span class="codeline" id="line-2919"><code></code></span>
<span class="codeline" id="line-2920"><code>	if !srv.trackListener(&amp;l, true) {</code></span>
<span class="codeline" id="line-2921"><code>		return ErrServerClosed</code></span>
<span class="codeline" id="line-2922"><code>	}</code></span>
<span class="codeline" id="line-2923"><code>	defer srv.trackListener(&amp;l, false)</code></span>
<span class="codeline" id="line-2924"><code></code></span>
<span class="codeline" id="line-2925"><code>	baseCtx := context.Background()</code></span>
<span class="codeline" id="line-2926"><code>	if srv.BaseContext != nil {</code></span>
<span class="codeline" id="line-2927"><code>		baseCtx = srv.BaseContext(origListener)</code></span>
<span class="codeline" id="line-2928"><code>		if baseCtx == nil {</code></span>
<span class="codeline" id="line-2929"><code>			panic("BaseContext returned a nil context")</code></span>
<span class="codeline" id="line-2930"><code>		}</code></span>
<span class="codeline" id="line-2931"><code>	}</code></span>
<span class="codeline" id="line-2932"><code></code></span>
<span class="codeline" id="line-2933"><code>	var tempDelay time.Duration // how long to sleep on accept failure</code></span>
<span class="codeline" id="line-2934"><code></code></span>
<span class="codeline" id="line-2935"><code>	ctx := context.WithValue(baseCtx, ServerContextKey, srv)</code></span>
<span class="codeline" id="line-2936"><code>	for {</code></span>
<span class="codeline" id="line-2937"><code>		rw, err := l.Accept()</code></span>
<span class="codeline" id="line-2938"><code>		if err != nil {</code></span>
<span class="codeline" id="line-2939"><code>			select {</code></span>
<span class="codeline" id="line-2940"><code>			case &lt;-srv.getDoneChan():</code></span>
<span class="codeline" id="line-2941"><code>				return ErrServerClosed</code></span>
<span class="codeline" id="line-2942"><code>			default:</code></span>
<span class="codeline" id="line-2943"><code>			}</code></span>
<span class="codeline" id="line-2944"><code>			if ne, ok := err.(net.Error); ok &amp;&amp; ne.Temporary() {</code></span>
<span class="codeline" id="line-2945"><code>				if tempDelay == 0 {</code></span>
<span class="codeline" id="line-2946"><code>					tempDelay = 5 * time.Millisecond</code></span>
<span class="codeline" id="line-2947"><code>				} else {</code></span>
<span class="codeline" id="line-2948"><code>					tempDelay *= 2</code></span>
<span class="codeline" id="line-2949"><code>				}</code></span>
<span class="codeline" id="line-2950"><code>				if max := 1 * time.Second; tempDelay &gt; max {</code></span>
<span class="codeline" id="line-2951"><code>					tempDelay = max</code></span>
<span class="codeline" id="line-2952"><code>				}</code></span>
<span class="codeline" id="line-2953"><code>				srv.logf("http: Accept error: %v; retrying in %v", err, tempDelay)</code></span>
<span class="codeline" id="line-2954"><code>				time.Sleep(tempDelay)</code></span>
<span class="codeline" id="line-2955"><code>				continue</code></span>
<span class="codeline" id="line-2956"><code>			}</code></span>
<span class="codeline" id="line-2957"><code>			return err</code></span>
<span class="codeline" id="line-2958"><code>		}</code></span>
<span class="codeline" id="line-2959"><code>		connCtx := ctx</code></span>
<span class="codeline" id="line-2960"><code>		if cc := srv.ConnContext; cc != nil {</code></span>
<span class="codeline" id="line-2961"><code>			connCtx = cc(connCtx, rw)</code></span>
<span class="codeline" id="line-2962"><code>			if connCtx == nil {</code></span>
<span class="codeline" id="line-2963"><code>				panic("ConnContext returned nil")</code></span>
<span class="codeline" id="line-2964"><code>			}</code></span>
<span class="codeline" id="line-2965"><code>		}</code></span>
<span class="codeline" id="line-2966"><code>		tempDelay = 0</code></span>
<span class="codeline" id="line-2967"><code>		c := srv.newConn(rw)</code></span>
<span class="codeline" id="line-2968"><code>		c.setState(c.rwc, StateNew) // before Serve can return</code></span>
<span class="codeline" id="line-2969"><code>		go c.serve(connCtx)</code></span>
<span class="codeline" id="line-2970"><code>	}</code></span>
<span class="codeline" id="line-2971"><code>}</code></span>
<span class="codeline" id="line-2972"><code></code></span>
<span class="codeline" id="line-2973"><code>// ServeTLS accepts incoming connections on the Listener l, creating a</code></span>
<span class="codeline" id="line-2974"><code>// new service goroutine for each. The service goroutines perform TLS</code></span>
<span class="codeline" id="line-2975"><code>// setup and then read requests, calling srv.Handler to reply to them.</code></span>
<span class="codeline" id="line-2976"><code>//</code></span>
<span class="codeline" id="line-2977"><code>// Files containing a certificate and matching private key for the</code></span>
<span class="codeline" id="line-2978"><code>// server must be provided if neither the Server's</code></span>
<span class="codeline" id="line-2979"><code>// TLSConfig.Certificates nor TLSConfig.GetCertificate are populated.</code></span>
<span class="codeline" id="line-2980"><code>// If the certificate is signed by a certificate authority, the</code></span>
<span class="codeline" id="line-2981"><code>// certFile should be the concatenation of the server's certificate,</code></span>
<span class="codeline" id="line-2982"><code>// any intermediates, and the CA's certificate.</code></span>
<span class="codeline" id="line-2983"><code>//</code></span>
<span class="codeline" id="line-2984"><code>// ServeTLS always returns a non-nil error. After Shutdown or Close, the</code></span>
<span class="codeline" id="line-2985"><code>// returned error is ErrServerClosed.</code></span>
<span class="codeline" id="line-2986"><code>func (srv *Server) ServeTLS(l net.Listener, certFile, keyFile string) error {</code></span>
<span class="codeline" id="line-2987"><code>	// Setup HTTP/2 before srv.Serve, to initialize srv.TLSConfig</code></span>
<span class="codeline" id="line-2988"><code>	// before we clone it and create the TLS Listener.</code></span>
<span class="codeline" id="line-2989"><code>	if err := srv.setupHTTP2_ServeTLS(); err != nil {</code></span>
<span class="codeline" id="line-2990"><code>		return err</code></span>
<span class="codeline" id="line-2991"><code>	}</code></span>
<span class="codeline" id="line-2992"><code></code></span>
<span class="codeline" id="line-2993"><code>	config := cloneTLSConfig(srv.TLSConfig)</code></span>
<span class="codeline" id="line-2994"><code>	if !strSliceContains(config.NextProtos, "http/1.1") {</code></span>
<span class="codeline" id="line-2995"><code>		config.NextProtos = append(config.NextProtos, "http/1.1")</code></span>
<span class="codeline" id="line-2996"><code>	}</code></span>
<span class="codeline" id="line-2997"><code></code></span>
<span class="codeline" id="line-2998"><code>	configHasCert := len(config.Certificates) &gt; 0 || config.GetCertificate != nil</code></span>
<span class="codeline" id="line-2999"><code>	if !configHasCert || certFile != "" || keyFile != "" {</code></span>
<span class="codeline" id="line-3000"><code>		var err error</code></span>
<span class="codeline" id="line-3001"><code>		config.Certificates = make([]tls.Certificate, 1)</code></span>
<span class="codeline" id="line-3002"><code>		config.Certificates[0], err = tls.LoadX509KeyPair(certFile, keyFile)</code></span>
<span class="codeline" id="line-3003"><code>		if err != nil {</code></span>
<span class="codeline" id="line-3004"><code>			return err</code></span>
<span class="codeline" id="line-3005"><code>		}</code></span>
<span class="codeline" id="line-3006"><code>	}</code></span>
<span class="codeline" id="line-3007"><code></code></span>
<span class="codeline" id="line-3008"><code>	tlsListener := tls.NewListener(l, config)</code></span>
<span class="codeline" id="line-3009"><code>	return srv.Serve(tlsListener)</code></span>
<span class="codeline" id="line-3010"><code>}</code></span>
<span class="codeline" id="line-3011"><code></code></span>
<span class="codeline" id="line-3012"><code>// trackListener adds or removes a net.Listener to the set of tracked</code></span>
<span class="codeline" id="line-3013"><code>// listeners.</code></span>
<span class="codeline" id="line-3014"><code>//</code></span>
<span class="codeline" id="line-3015"><code>// We store a pointer to interface in the map set, in case the</code></span>
<span class="codeline" id="line-3016"><code>// net.Listener is not comparable. This is safe because we only call</code></span>
<span class="codeline" id="line-3017"><code>// trackListener via Serve and can track+defer untrack the same</code></span>
<span class="codeline" id="line-3018"><code>// pointer to local variable there. We never need to compare a</code></span>
<span class="codeline" id="line-3019"><code>// Listener from another caller.</code></span>
<span class="codeline" id="line-3020"><code>//</code></span>
<span class="codeline" id="line-3021"><code>// It reports whether the server is still up (not Shutdown or Closed).</code></span>
<span class="codeline" id="line-3022"><code>func (s *Server) trackListener(ln *net.Listener, add bool) bool {</code></span>
<span class="codeline" id="line-3023"><code>	s.mu.Lock()</code></span>
<span class="codeline" id="line-3024"><code>	defer s.mu.Unlock()</code></span>
<span class="codeline" id="line-3025"><code>	if s.listeners == nil {</code></span>
<span class="codeline" id="line-3026"><code>		s.listeners = make(map[*net.Listener]struct{})</code></span>
<span class="codeline" id="line-3027"><code>	}</code></span>
<span class="codeline" id="line-3028"><code>	if add {</code></span>
<span class="codeline" id="line-3029"><code>		if s.shuttingDown() {</code></span>
<span class="codeline" id="line-3030"><code>			return false</code></span>
<span class="codeline" id="line-3031"><code>		}</code></span>
<span class="codeline" id="line-3032"><code>		s.listeners[ln] = struct{}{}</code></span>
<span class="codeline" id="line-3033"><code>	} else {</code></span>
<span class="codeline" id="line-3034"><code>		delete(s.listeners, ln)</code></span>
<span class="codeline" id="line-3035"><code>	}</code></span>
<span class="codeline" id="line-3036"><code>	return true</code></span>
<span class="codeline" id="line-3037"><code>}</code></span>
<span class="codeline" id="line-3038"><code></code></span>
<span class="codeline" id="line-3039"><code>func (s *Server) trackConn(c *conn, add bool) {</code></span>
<span class="codeline" id="line-3040"><code>	s.mu.Lock()</code></span>
<span class="codeline" id="line-3041"><code>	defer s.mu.Unlock()</code></span>
<span class="codeline" id="line-3042"><code>	if s.activeConn == nil {</code></span>
<span class="codeline" id="line-3043"><code>		s.activeConn = make(map[*conn]struct{})</code></span>
<span class="codeline" id="line-3044"><code>	}</code></span>
<span class="codeline" id="line-3045"><code>	if add {</code></span>
<span class="codeline" id="line-3046"><code>		s.activeConn[c] = struct{}{}</code></span>
<span class="codeline" id="line-3047"><code>	} else {</code></span>
<span class="codeline" id="line-3048"><code>		delete(s.activeConn, c)</code></span>
<span class="codeline" id="line-3049"><code>	}</code></span>
<span class="codeline" id="line-3050"><code>}</code></span>
<span class="codeline" id="line-3051"><code></code></span>
<span class="codeline" id="line-3052"><code>func (s *Server) idleTimeout() time.Duration {</code></span>
<span class="codeline" id="line-3053"><code>	if s.IdleTimeout != 0 {</code></span>
<span class="codeline" id="line-3054"><code>		return s.IdleTimeout</code></span>
<span class="codeline" id="line-3055"><code>	}</code></span>
<span class="codeline" id="line-3056"><code>	return s.ReadTimeout</code></span>
<span class="codeline" id="line-3057"><code>}</code></span>
<span class="codeline" id="line-3058"><code></code></span>
<span class="codeline" id="line-3059"><code>func (s *Server) readHeaderTimeout() time.Duration {</code></span>
<span class="codeline" id="line-3060"><code>	if s.ReadHeaderTimeout != 0 {</code></span>
<span class="codeline" id="line-3061"><code>		return s.ReadHeaderTimeout</code></span>
<span class="codeline" id="line-3062"><code>	}</code></span>
<span class="codeline" id="line-3063"><code>	return s.ReadTimeout</code></span>
<span class="codeline" id="line-3064"><code>}</code></span>
<span class="codeline" id="line-3065"><code></code></span>
<span class="codeline" id="line-3066"><code>func (s *Server) doKeepAlives() bool {</code></span>
<span class="codeline" id="line-3067"><code>	return atomic.LoadInt32(&amp;s.disableKeepAlives) == 0 &amp;&amp; !s.shuttingDown()</code></span>
<span class="codeline" id="line-3068"><code>}</code></span>
<span class="codeline" id="line-3069"><code></code></span>
<span class="codeline" id="line-3070"><code>func (s *Server) shuttingDown() bool {</code></span>
<span class="codeline" id="line-3071"><code>	return s.inShutdown.isSet()</code></span>
<span class="codeline" id="line-3072"><code>}</code></span>
<span class="codeline" id="line-3073"><code></code></span>
<span class="codeline" id="line-3074"><code>// SetKeepAlivesEnabled controls whether HTTP keep-alives are enabled.</code></span>
<span class="codeline" id="line-3075"><code>// By default, keep-alives are always enabled. Only very</code></span>
<span class="codeline" id="line-3076"><code>// resource-constrained environments or servers in the process of</code></span>
<span class="codeline" id="line-3077"><code>// shutting down should disable them.</code></span>
<span class="codeline" id="line-3078"><code>func (srv *Server) SetKeepAlivesEnabled(v bool) {</code></span>
<span class="codeline" id="line-3079"><code>	if v {</code></span>
<span class="codeline" id="line-3080"><code>		atomic.StoreInt32(&amp;srv.disableKeepAlives, 0)</code></span>
<span class="codeline" id="line-3081"><code>		return</code></span>
<span class="codeline" id="line-3082"><code>	}</code></span>
<span class="codeline" id="line-3083"><code>	atomic.StoreInt32(&amp;srv.disableKeepAlives, 1)</code></span>
<span class="codeline" id="line-3084"><code></code></span>
<span class="codeline" id="line-3085"><code>	// Close idle HTTP/1 conns:</code></span>
<span class="codeline" id="line-3086"><code>	srv.closeIdleConns()</code></span>
<span class="codeline" id="line-3087"><code></code></span>
<span class="codeline" id="line-3088"><code>	// TODO: Issue 26303: close HTTP/2 conns as soon as they become idle.</code></span>
<span class="codeline" id="line-3089"><code>}</code></span>
<span class="codeline" id="line-3090"><code></code></span>
<span class="codeline" id="line-3091"><code>func (s *Server) logf(format string, args ...interface{}) {</code></span>
<span class="codeline" id="line-3092"><code>	if s.ErrorLog != nil {</code></span>
<span class="codeline" id="line-3093"><code>		s.ErrorLog.Printf(format, args...)</code></span>
<span class="codeline" id="line-3094"><code>	} else {</code></span>
<span class="codeline" id="line-3095"><code>		log.Printf(format, args...)</code></span>
<span class="codeline" id="line-3096"><code>	}</code></span>
<span class="codeline" id="line-3097"><code>}</code></span>
<span class="codeline" id="line-3098"><code></code></span>
<span class="codeline" id="line-3099"><code>// logf prints to the ErrorLog of the *Server associated with request r</code></span>
<span class="codeline" id="line-3100"><code>// via ServerContextKey. If there's no associated server, or if ErrorLog</code></span>
<span class="codeline" id="line-3101"><code>// is nil, logging is done via the log package's standard logger.</code></span>
<span class="codeline" id="line-3102"><code>func logf(r *Request, format string, args ...interface{}) {</code></span>
<span class="codeline" id="line-3103"><code>	s, _ := r.Context().Value(ServerContextKey).(*Server)</code></span>
<span class="codeline" id="line-3104"><code>	if s != nil &amp;&amp; s.ErrorLog != nil {</code></span>
<span class="codeline" id="line-3105"><code>		s.ErrorLog.Printf(format, args...)</code></span>
<span class="codeline" id="line-3106"><code>	} else {</code></span>
<span class="codeline" id="line-3107"><code>		log.Printf(format, args...)</code></span>
<span class="codeline" id="line-3108"><code>	}</code></span>
<span class="codeline" id="line-3109"><code>}</code></span>
<span class="codeline" id="line-3110"><code></code></span>
<span class="codeline" id="line-3111"><code>// ListenAndServe listens on the TCP network address addr and then calls</code></span>
<span class="codeline" id="line-3112"><code>// Serve with handler to handle requests on incoming connections.</code></span>
<span class="codeline" id="line-3113"><code>// Accepted connections are configured to enable TCP keep-alives.</code></span>
<span class="codeline" id="line-3114"><code>//</code></span>
<span class="codeline" id="line-3115"><code>// The handler is typically nil, in which case the DefaultServeMux is used.</code></span>
<span class="codeline" id="line-3116"><code>//</code></span>
<span class="codeline" id="line-3117"><code>// ListenAndServe always returns a non-nil error.</code></span>
<span class="codeline" id="line-3118"><code>func ListenAndServe(addr string, handler Handler) error {</code></span>
<span class="codeline" id="line-3119"><code>	server := &amp;Server{Addr: addr, Handler: handler}</code></span>
<span class="codeline" id="line-3120"><code>	return server.ListenAndServe()</code></span>
<span class="codeline" id="line-3121"><code>}</code></span>
<span class="codeline" id="line-3122"><code></code></span>
<span class="codeline" id="line-3123"><code>// ListenAndServeTLS acts identically to ListenAndServe, except that it</code></span>
<span class="codeline" id="line-3124"><code>// expects HTTPS connections. Additionally, files containing a certificate and</code></span>
<span class="codeline" id="line-3125"><code>// matching private key for the server must be provided. If the certificate</code></span>
<span class="codeline" id="line-3126"><code>// is signed by a certificate authority, the certFile should be the concatenation</code></span>
<span class="codeline" id="line-3127"><code>// of the server's certificate, any intermediates, and the CA's certificate.</code></span>
<span class="codeline" id="line-3128"><code>func ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error {</code></span>
<span class="codeline" id="line-3129"><code>	server := &amp;Server{Addr: addr, Handler: handler}</code></span>
<span class="codeline" id="line-3130"><code>	return server.ListenAndServeTLS(certFile, keyFile)</code></span>
<span class="codeline" id="line-3131"><code>}</code></span>
<span class="codeline" id="line-3132"><code></code></span>
<span class="codeline" id="line-3133"><code>// ListenAndServeTLS listens on the TCP network address srv.Addr and</code></span>
<span class="codeline" id="line-3134"><code>// then calls ServeTLS to handle requests on incoming TLS connections.</code></span>
<span class="codeline" id="line-3135"><code>// Accepted connections are configured to enable TCP keep-alives.</code></span>
<span class="codeline" id="line-3136"><code>//</code></span>
<span class="codeline" id="line-3137"><code>// Filenames containing a certificate and matching private key for the</code></span>
<span class="codeline" id="line-3138"><code>// server must be provided if neither the Server's TLSConfig.Certificates</code></span>
<span class="codeline" id="line-3139"><code>// nor TLSConfig.GetCertificate are populated. If the certificate is</code></span>
<span class="codeline" id="line-3140"><code>// signed by a certificate authority, the certFile should be the</code></span>
<span class="codeline" id="line-3141"><code>// concatenation of the server's certificate, any intermediates, and</code></span>
<span class="codeline" id="line-3142"><code>// the CA's certificate.</code></span>
<span class="codeline" id="line-3143"><code>//</code></span>
<span class="codeline" id="line-3144"><code>// If srv.Addr is blank, ":https" is used.</code></span>
<span class="codeline" id="line-3145"><code>//</code></span>
<span class="codeline" id="line-3146"><code>// ListenAndServeTLS always returns a non-nil error. After Shutdown or</code></span>
<span class="codeline" id="line-3147"><code>// Close, the returned error is ErrServerClosed.</code></span>
<span class="codeline" id="line-3148"><code>func (srv *Server) ListenAndServeTLS(certFile, keyFile string) error {</code></span>
<span class="codeline" id="line-3149"><code>	if srv.shuttingDown() {</code></span>
<span class="codeline" id="line-3150"><code>		return ErrServerClosed</code></span>
<span class="codeline" id="line-3151"><code>	}</code></span>
<span class="codeline" id="line-3152"><code>	addr := srv.Addr</code></span>
<span class="codeline" id="line-3153"><code>	if addr == "" {</code></span>
<span class="codeline" id="line-3154"><code>		addr = ":https"</code></span>
<span class="codeline" id="line-3155"><code>	}</code></span>
<span class="codeline" id="line-3156"><code></code></span>
<span class="codeline" id="line-3157"><code>	ln, err := net.Listen("tcp", addr)</code></span>
<span class="codeline" id="line-3158"><code>	if err != nil {</code></span>
<span class="codeline" id="line-3159"><code>		return err</code></span>
<span class="codeline" id="line-3160"><code>	}</code></span>
<span class="codeline" id="line-3161"><code></code></span>
<span class="codeline" id="line-3162"><code>	defer ln.Close()</code></span>
<span class="codeline" id="line-3163"><code></code></span>
<span class="codeline" id="line-3164"><code>	return srv.ServeTLS(ln, certFile, keyFile)</code></span>
<span class="codeline" id="line-3165"><code>}</code></span>
<span class="codeline" id="line-3166"><code></code></span>
<span class="codeline" id="line-3167"><code>// setupHTTP2_ServeTLS conditionally configures HTTP/2 on</code></span>
<span class="codeline" id="line-3168"><code>// srv and reports whether there was an error setting it up. If it is</code></span>
<span class="codeline" id="line-3169"><code>// not configured for policy reasons, nil is returned.</code></span>
<span class="codeline" id="line-3170"><code>func (srv *Server) setupHTTP2_ServeTLS() error {</code></span>
<span class="codeline" id="line-3171"><code>	srv.nextProtoOnce.Do(srv.onceSetNextProtoDefaults)</code></span>
<span class="codeline" id="line-3172"><code>	return srv.nextProtoErr</code></span>
<span class="codeline" id="line-3173"><code>}</code></span>
<span class="codeline" id="line-3174"><code></code></span>
<span class="codeline" id="line-3175"><code>// setupHTTP2_Serve is called from (*Server).Serve and conditionally</code></span>
<span class="codeline" id="line-3176"><code>// configures HTTP/2 on srv using a more conservative policy than</code></span>
<span class="codeline" id="line-3177"><code>// setupHTTP2_ServeTLS because Serve is called after tls.Listen,</code></span>
<span class="codeline" id="line-3178"><code>// and may be called concurrently. See shouldConfigureHTTP2ForServe.</code></span>
<span class="codeline" id="line-3179"><code>//</code></span>
<span class="codeline" id="line-3180"><code>// The tests named TestTransportAutomaticHTTP2* and</code></span>
<span class="codeline" id="line-3181"><code>// TestConcurrentServerServe in server_test.go demonstrate some</code></span>
<span class="codeline" id="line-3182"><code>// of the supported use cases and motivations.</code></span>
<span class="codeline" id="line-3183"><code>func (srv *Server) setupHTTP2_Serve() error {</code></span>
<span class="codeline" id="line-3184"><code>	srv.nextProtoOnce.Do(srv.onceSetNextProtoDefaults_Serve)</code></span>
<span class="codeline" id="line-3185"><code>	return srv.nextProtoErr</code></span>
<span class="codeline" id="line-3186"><code>}</code></span>
<span class="codeline" id="line-3187"><code></code></span>
<span class="codeline" id="line-3188"><code>func (srv *Server) onceSetNextProtoDefaults_Serve() {</code></span>
<span class="codeline" id="line-3189"><code>	if srv.shouldConfigureHTTP2ForServe() {</code></span>
<span class="codeline" id="line-3190"><code>		srv.onceSetNextProtoDefaults()</code></span>
<span class="codeline" id="line-3191"><code>	}</code></span>
<span class="codeline" id="line-3192"><code>}</code></span>
<span class="codeline" id="line-3193"><code></code></span>
<span class="codeline" id="line-3194"><code>// onceSetNextProtoDefaults configures HTTP/2, if the user hasn't</code></span>
<span class="codeline" id="line-3195"><code>// configured otherwise. (by setting srv.TLSNextProto non-nil)</code></span>
<span class="codeline" id="line-3196"><code>// It must only be called via srv.nextProtoOnce (use srv.setupHTTP2_*).</code></span>
<span class="codeline" id="line-3197"><code>func (srv *Server) onceSetNextProtoDefaults() {</code></span>
<span class="codeline" id="line-3198"><code>	if omitBundledHTTP2 || strings.Contains(os.Getenv("GODEBUG"), "http2server=0") {</code></span>
<span class="codeline" id="line-3199"><code>		return</code></span>
<span class="codeline" id="line-3200"><code>	}</code></span>
<span class="codeline" id="line-3201"><code>	// Enable HTTP/2 by default if the user hasn't otherwise</code></span>
<span class="codeline" id="line-3202"><code>	// configured their TLSNextProto map.</code></span>
<span class="codeline" id="line-3203"><code>	if srv.TLSNextProto == nil {</code></span>
<span class="codeline" id="line-3204"><code>		conf := &amp;http2Server{</code></span>
<span class="codeline" id="line-3205"><code>			NewWriteScheduler: func() http2WriteScheduler { return http2NewPriorityWriteScheduler(nil) },</code></span>
<span class="codeline" id="line-3206"><code>		}</code></span>
<span class="codeline" id="line-3207"><code>		srv.nextProtoErr = http2ConfigureServer(srv, conf)</code></span>
<span class="codeline" id="line-3208"><code>	}</code></span>
<span class="codeline" id="line-3209"><code>}</code></span>
<span class="codeline" id="line-3210"><code></code></span>
<span class="codeline" id="line-3211"><code>// TimeoutHandler returns a Handler that runs h with the given time limit.</code></span>
<span class="codeline" id="line-3212"><code>//</code></span>
<span class="codeline" id="line-3213"><code>// The new Handler calls h.ServeHTTP to handle each request, but if a</code></span>
<span class="codeline" id="line-3214"><code>// call runs for longer than its time limit, the handler responds with</code></span>
<span class="codeline" id="line-3215"><code>// a 503 Service Unavailable error and the given message in its body.</code></span>
<span class="codeline" id="line-3216"><code>// (If msg is empty, a suitable default message will be sent.)</code></span>
<span class="codeline" id="line-3217"><code>// After such a timeout, writes by h to its ResponseWriter will return</code></span>
<span class="codeline" id="line-3218"><code>// ErrHandlerTimeout.</code></span>
<span class="codeline" id="line-3219"><code>//</code></span>
<span class="codeline" id="line-3220"><code>// TimeoutHandler supports the Pusher interface but does not support</code></span>
<span class="codeline" id="line-3221"><code>// the Hijacker or Flusher interfaces.</code></span>
<span class="codeline" id="line-3222"><code>func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler {</code></span>
<span class="codeline" id="line-3223"><code>	return &amp;timeoutHandler{</code></span>
<span class="codeline" id="line-3224"><code>		handler: h,</code></span>
<span class="codeline" id="line-3225"><code>		body:    msg,</code></span>
<span class="codeline" id="line-3226"><code>		dt:      dt,</code></span>
<span class="codeline" id="line-3227"><code>	}</code></span>
<span class="codeline" id="line-3228"><code>}</code></span>
<span class="codeline" id="line-3229"><code></code></span>
<span class="codeline" id="line-3230"><code>// ErrHandlerTimeout is returned on ResponseWriter Write calls</code></span>
<span class="codeline" id="line-3231"><code>// in handlers which have timed out.</code></span>
<span class="codeline" id="line-3232"><code>var ErrHandlerTimeout = errors.New("http: Handler timeout")</code></span>
<span class="codeline" id="line-3233"><code></code></span>
<span class="codeline" id="line-3234"><code>type timeoutHandler struct {</code></span>
<span class="codeline" id="line-3235"><code>	handler Handler</code></span>
<span class="codeline" id="line-3236"><code>	body    string</code></span>
<span class="codeline" id="line-3237"><code>	dt      time.Duration</code></span>
<span class="codeline" id="line-3238"><code></code></span>
<span class="codeline" id="line-3239"><code>	// When set, no context will be created and this context will</code></span>
<span class="codeline" id="line-3240"><code>	// be used instead.</code></span>
<span class="codeline" id="line-3241"><code>	testContext context.Context</code></span>
<span class="codeline" id="line-3242"><code>}</code></span>
<span class="codeline" id="line-3243"><code></code></span>
<span class="codeline" id="line-3244"><code>func (h *timeoutHandler) errorBody() string {</code></span>
<span class="codeline" id="line-3245"><code>	if h.body != "" {</code></span>
<span class="codeline" id="line-3246"><code>		return h.body</code></span>
<span class="codeline" id="line-3247"><code>	}</code></span>
<span class="codeline" id="line-3248"><code>	return "&lt;html&gt;&lt;head&gt;&lt;title&gt;Timeout&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Timeout&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;"</code></span>
<span class="codeline" id="line-3249"><code>}</code></span>
<span class="codeline" id="line-3250"><code></code></span>
<span class="codeline" id="line-3251"><code>func (h *timeoutHandler) ServeHTTP(w ResponseWriter, r *Request) {</code></span>
<span class="codeline" id="line-3252"><code>	ctx := h.testContext</code></span>
<span class="codeline" id="line-3253"><code>	if ctx == nil {</code></span>
<span class="codeline" id="line-3254"><code>		var cancelCtx context.CancelFunc</code></span>
<span class="codeline" id="line-3255"><code>		ctx, cancelCtx = context.WithTimeout(r.Context(), h.dt)</code></span>
<span class="codeline" id="line-3256"><code>		defer cancelCtx()</code></span>
<span class="codeline" id="line-3257"><code>	}</code></span>
<span class="codeline" id="line-3258"><code>	r = r.WithContext(ctx)</code></span>
<span class="codeline" id="line-3259"><code>	done := make(chan struct{})</code></span>
<span class="codeline" id="line-3260"><code>	tw := &amp;timeoutWriter{</code></span>
<span class="codeline" id="line-3261"><code>		w:   w,</code></span>
<span class="codeline" id="line-3262"><code>		h:   make(Header),</code></span>
<span class="codeline" id="line-3263"><code>		req: r,</code></span>
<span class="codeline" id="line-3264"><code>	}</code></span>
<span class="codeline" id="line-3265"><code>	panicChan := make(chan interface{}, 1)</code></span>
<span class="codeline" id="line-3266"><code>	go func() {</code></span>
<span class="codeline" id="line-3267"><code>		defer func() {</code></span>
<span class="codeline" id="line-3268"><code>			if p := recover(); p != nil {</code></span>
<span class="codeline" id="line-3269"><code>				panicChan &lt;- p</code></span>
<span class="codeline" id="line-3270"><code>			}</code></span>
<span class="codeline" id="line-3271"><code>		}()</code></span>
<span class="codeline" id="line-3272"><code>		h.handler.ServeHTTP(tw, r)</code></span>
<span class="codeline" id="line-3273"><code>		close(done)</code></span>
<span class="codeline" id="line-3274"><code>	}()</code></span>
<span class="codeline" id="line-3275"><code>	select {</code></span>
<span class="codeline" id="line-3276"><code>	case p := &lt;-panicChan:</code></span>
<span class="codeline" id="line-3277"><code>		panic(p)</code></span>
<span class="codeline" id="line-3278"><code>	case &lt;-done:</code></span>
<span class="codeline" id="line-3279"><code>		tw.mu.Lock()</code></span>
<span class="codeline" id="line-3280"><code>		defer tw.mu.Unlock()</code></span>
<span class="codeline" id="line-3281"><code>		dst := w.Header()</code></span>
<span class="codeline" id="line-3282"><code>		for k, vv := range tw.h {</code></span>
<span class="codeline" id="line-3283"><code>			dst[k] = vv</code></span>
<span class="codeline" id="line-3284"><code>		}</code></span>
<span class="codeline" id="line-3285"><code>		if !tw.wroteHeader {</code></span>
<span class="codeline" id="line-3286"><code>			tw.code = StatusOK</code></span>
<span class="codeline" id="line-3287"><code>		}</code></span>
<span class="codeline" id="line-3288"><code>		w.WriteHeader(tw.code)</code></span>
<span class="codeline" id="line-3289"><code>		w.Write(tw.wbuf.Bytes())</code></span>
<span class="codeline" id="line-3290"><code>	case &lt;-ctx.Done():</code></span>
<span class="codeline" id="line-3291"><code>		tw.mu.Lock()</code></span>
<span class="codeline" id="line-3292"><code>		defer tw.mu.Unlock()</code></span>
<span class="codeline" id="line-3293"><code>		w.WriteHeader(StatusServiceUnavailable)</code></span>
<span class="codeline" id="line-3294"><code>		io.WriteString(w, h.errorBody())</code></span>
<span class="codeline" id="line-3295"><code>		tw.timedOut = true</code></span>
<span class="codeline" id="line-3296"><code>	}</code></span>
<span class="codeline" id="line-3297"><code>}</code></span>
<span class="codeline" id="line-3298"><code></code></span>
<span class="codeline" id="line-3299"><code>type timeoutWriter struct {</code></span>
<span class="codeline" id="line-3300"><code>	w    ResponseWriter</code></span>
<span class="codeline" id="line-3301"><code>	h    Header</code></span>
<span class="codeline" id="line-3302"><code>	wbuf bytes.Buffer</code></span>
<span class="codeline" id="line-3303"><code>	req  *Request</code></span>
<span class="codeline" id="line-3304"><code></code></span>
<span class="codeline" id="line-3305"><code>	mu          sync.Mutex</code></span>
<span class="codeline" id="line-3306"><code>	timedOut    bool</code></span>
<span class="codeline" id="line-3307"><code>	wroteHeader bool</code></span>
<span class="codeline" id="line-3308"><code>	code        int</code></span>
<span class="codeline" id="line-3309"><code>}</code></span>
<span class="codeline" id="line-3310"><code></code></span>
<span class="codeline" id="line-3311"><code>var _ Pusher = (*timeoutWriter)(nil)</code></span>
<span class="codeline" id="line-3312"><code></code></span>
<span class="codeline" id="line-3313"><code>// Push implements the Pusher interface.</code></span>
<span class="codeline" id="line-3314"><code>func (tw *timeoutWriter) Push(target string, opts *PushOptions) error {</code></span>
<span class="codeline" id="line-3315"><code>	if pusher, ok := tw.w.(Pusher); ok {</code></span>
<span class="codeline" id="line-3316"><code>		return pusher.Push(target, opts)</code></span>
<span class="codeline" id="line-3317"><code>	}</code></span>
<span class="codeline" id="line-3318"><code>	return ErrNotSupported</code></span>
<span class="codeline" id="line-3319"><code>}</code></span>
<span class="codeline" id="line-3320"><code></code></span>
<span class="codeline" id="line-3321"><code>func (tw *timeoutWriter) Header() Header { return tw.h }</code></span>
<span class="codeline" id="line-3322"><code></code></span>
<span class="codeline" id="line-3323"><code>func (tw *timeoutWriter) Write(p []byte) (int, error) {</code></span>
<span class="codeline" id="line-3324"><code>	tw.mu.Lock()</code></span>
<span class="codeline" id="line-3325"><code>	defer tw.mu.Unlock()</code></span>
<span class="codeline" id="line-3326"><code>	if tw.timedOut {</code></span>
<span class="codeline" id="line-3327"><code>		return 0, ErrHandlerTimeout</code></span>
<span class="codeline" id="line-3328"><code>	}</code></span>
<span class="codeline" id="line-3329"><code>	if !tw.wroteHeader {</code></span>
<span class="codeline" id="line-3330"><code>		tw.writeHeaderLocked(StatusOK)</code></span>
<span class="codeline" id="line-3331"><code>	}</code></span>
<span class="codeline" id="line-3332"><code>	return tw.wbuf.Write(p)</code></span>
<span class="codeline" id="line-3333"><code>}</code></span>
<span class="codeline" id="line-3334"><code></code></span>
<span class="codeline" id="line-3335"><code>func (tw *timeoutWriter) writeHeaderLocked(code int) {</code></span>
<span class="codeline" id="line-3336"><code>	checkWriteHeaderCode(code)</code></span>
<span class="codeline" id="line-3337"><code></code></span>
<span class="codeline" id="line-3338"><code>	switch {</code></span>
<span class="codeline" id="line-3339"><code>	case tw.timedOut:</code></span>
<span class="codeline" id="line-3340"><code>		return</code></span>
<span class="codeline" id="line-3341"><code>	case tw.wroteHeader:</code></span>
<span class="codeline" id="line-3342"><code>		if tw.req != nil {</code></span>
<span class="codeline" id="line-3343"><code>			caller := relevantCaller()</code></span>
<span class="codeline" id="line-3344"><code>			logf(tw.req, "http: superfluous response.WriteHeader call from %s (%s:%d)", caller.Function, path.Base(caller.File), caller.Line)</code></span>
<span class="codeline" id="line-3345"><code>		}</code></span>
<span class="codeline" id="line-3346"><code>	default:</code></span>
<span class="codeline" id="line-3347"><code>		tw.wroteHeader = true</code></span>
<span class="codeline" id="line-3348"><code>		tw.code = code</code></span>
<span class="codeline" id="line-3349"><code>	}</code></span>
<span class="codeline" id="line-3350"><code>}</code></span>
<span class="codeline" id="line-3351"><code></code></span>
<span class="codeline" id="line-3352"><code>func (tw *timeoutWriter) WriteHeader(code int) {</code></span>
<span class="codeline" id="line-3353"><code>	tw.mu.Lock()</code></span>
<span class="codeline" id="line-3354"><code>	defer tw.mu.Unlock()</code></span>
<span class="codeline" id="line-3355"><code>	tw.writeHeaderLocked(code)</code></span>
<span class="codeline" id="line-3356"><code>}</code></span>
<span class="codeline" id="line-3357"><code></code></span>
<span class="codeline" id="line-3358"><code>// onceCloseListener wraps a net.Listener, protecting it from</code></span>
<span class="codeline" id="line-3359"><code>// multiple Close calls.</code></span>
<span class="codeline" id="line-3360"><code>type onceCloseListener struct {</code></span>
<span class="codeline" id="line-3361"><code>	net.Listener</code></span>
<span class="codeline" id="line-3362"><code>	once     sync.Once</code></span>
<span class="codeline" id="line-3363"><code>	closeErr error</code></span>
<span class="codeline" id="line-3364"><code>}</code></span>
<span class="codeline" id="line-3365"><code></code></span>
<span class="codeline" id="line-3366"><code>func (oc *onceCloseListener) Close() error {</code></span>
<span class="codeline" id="line-3367"><code>	oc.once.Do(oc.close)</code></span>
<span class="codeline" id="line-3368"><code>	return oc.closeErr</code></span>
<span class="codeline" id="line-3369"><code>}</code></span>
<span class="codeline" id="line-3370"><code></code></span>
<span class="codeline" id="line-3371"><code>func (oc *onceCloseListener) close() { oc.closeErr = oc.Listener.Close() }</code></span>
<span class="codeline" id="line-3372"><code></code></span>
<span class="codeline" id="line-3373"><code>// globalOptionsHandler responds to "OPTIONS *" requests.</code></span>
<span class="codeline" id="line-3374"><code>type globalOptionsHandler struct{}</code></span>
<span class="codeline" id="line-3375"><code></code></span>
<span class="codeline" id="line-3376"><code>func (globalOptionsHandler) ServeHTTP(w ResponseWriter, r *Request) {</code></span>
<span class="codeline" id="line-3377"><code>	w.Header().Set("Content-Length", "0")</code></span>
<span class="codeline" id="line-3378"><code>	if r.ContentLength != 0 {</code></span>
<span class="codeline" id="line-3379"><code>		// Read up to 4KB of OPTIONS body (as mentioned in the</code></span>
<span class="codeline" id="line-3380"><code>		// spec as being reserved for future use), but anything</code></span>
<span class="codeline" id="line-3381"><code>		// over that is considered a waste of server resources</code></span>
<span class="codeline" id="line-3382"><code>		// (or an attack) and we abort and close the connection,</code></span>
<span class="codeline" id="line-3383"><code>		// courtesy of MaxBytesReader's EOF behavior.</code></span>
<span class="codeline" id="line-3384"><code>		mb := MaxBytesReader(w, r.Body, 4&lt;&lt;10)</code></span>
<span class="codeline" id="line-3385"><code>		io.Copy(ioutil.Discard, mb)</code></span>
<span class="codeline" id="line-3386"><code>	}</code></span>
<span class="codeline" id="line-3387"><code>}</code></span>
<span class="codeline" id="line-3388"><code></code></span>
<span class="codeline" id="line-3389"><code>// initALPNRequest is an HTTP handler that initializes certain</code></span>
<span class="codeline" id="line-3390"><code>// uninitialized fields in its *Request. Such partially-initialized</code></span>
<span class="codeline" id="line-3391"><code>// Requests come from ALPN protocol handlers.</code></span>
<span class="codeline" id="line-3392"><code>type initALPNRequest struct {</code></span>
<span class="codeline" id="line-3393"><code>	ctx context.Context</code></span>
<span class="codeline" id="line-3394"><code>	c   *tls.Conn</code></span>
<span class="codeline" id="line-3395"><code>	h   serverHandler</code></span>
<span class="codeline" id="line-3396"><code>}</code></span>
<span class="codeline" id="line-3397"><code></code></span>
<span class="codeline" id="line-3398"><code>// BaseContext is an exported but unadvertised http.Handler method</code></span>
<span class="codeline" id="line-3399"><code>// recognized by x/net/http2 to pass down a context; the TLSNextProto</code></span>
<span class="codeline" id="line-3400"><code>// API predates context support so we shoehorn through the only</code></span>
<span class="codeline" id="line-3401"><code>// interface we have available.</code></span>
<span class="codeline" id="line-3402"><code>func (h initALPNRequest) BaseContext() context.Context { return h.ctx }</code></span>
<span class="codeline" id="line-3403"><code></code></span>
<span class="codeline" id="line-3404"><code>func (h initALPNRequest) ServeHTTP(rw ResponseWriter, req *Request) {</code></span>
<span class="codeline" id="line-3405"><code>	if req.TLS == nil {</code></span>
<span class="codeline" id="line-3406"><code>		req.TLS = &amp;tls.ConnectionState{}</code></span>
<span class="codeline" id="line-3407"><code>		*req.TLS = h.c.ConnectionState()</code></span>
<span class="codeline" id="line-3408"><code>	}</code></span>
<span class="codeline" id="line-3409"><code>	if req.Body == nil {</code></span>
<span class="codeline" id="line-3410"><code>		req.Body = NoBody</code></span>
<span class="codeline" id="line-3411"><code>	}</code></span>
<span class="codeline" id="line-3412"><code>	if req.RemoteAddr == "" {</code></span>
<span class="codeline" id="line-3413"><code>		req.RemoteAddr = h.c.RemoteAddr().String()</code></span>
<span class="codeline" id="line-3414"><code>	}</code></span>
<span class="codeline" id="line-3415"><code>	h.h.ServeHTTP(rw, req)</code></span>
<span class="codeline" id="line-3416"><code>}</code></span>
<span class="codeline" id="line-3417"><code></code></span>
<span class="codeline" id="line-3418"><code>// loggingConn is used for debugging.</code></span>
<span class="codeline" id="line-3419"><code>type loggingConn struct {</code></span>
<span class="codeline" id="line-3420"><code>	name string</code></span>
<span class="codeline" id="line-3421"><code>	net.Conn</code></span>
<span class="codeline" id="line-3422"><code>}</code></span>
<span class="codeline" id="line-3423"><code></code></span>
<span class="codeline" id="line-3424"><code>var (</code></span>
<span class="codeline" id="line-3425"><code>	uniqNameMu   sync.Mutex</code></span>
<span class="codeline" id="line-3426"><code>	uniqNameNext = make(map[string]int)</code></span>
<span class="codeline" id="line-3427"><code>)</code></span>
<span class="codeline" id="line-3428"><code></code></span>
<span class="codeline" id="line-3429"><code>func newLoggingConn(baseName string, c net.Conn) net.Conn {</code></span>
<span class="codeline" id="line-3430"><code>	uniqNameMu.Lock()</code></span>
<span class="codeline" id="line-3431"><code>	defer uniqNameMu.Unlock()</code></span>
<span class="codeline" id="line-3432"><code>	uniqNameNext[baseName]++</code></span>
<span class="codeline" id="line-3433"><code>	return &amp;loggingConn{</code></span>
<span class="codeline" id="line-3434"><code>		name: fmt.Sprintf("%s-%d", baseName, uniqNameNext[baseName]),</code></span>
<span class="codeline" id="line-3435"><code>		Conn: c,</code></span>
<span class="codeline" id="line-3436"><code>	}</code></span>
<span class="codeline" id="line-3437"><code>}</code></span>
<span class="codeline" id="line-3438"><code></code></span>
<span class="codeline" id="line-3439"><code>func (c *loggingConn) Write(p []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-3440"><code>	log.Printf("%s.Write(%d) = ....", c.name, len(p))</code></span>
<span class="codeline" id="line-3441"><code>	n, err = c.Conn.Write(p)</code></span>
<span class="codeline" id="line-3442"><code>	log.Printf("%s.Write(%d) = %d, %v", c.name, len(p), n, err)</code></span>
<span class="codeline" id="line-3443"><code>	return</code></span>
<span class="codeline" id="line-3444"><code>}</code></span>
<span class="codeline" id="line-3445"><code></code></span>
<span class="codeline" id="line-3446"><code>func (c *loggingConn) Read(p []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-3447"><code>	log.Printf("%s.Read(%d) = ....", c.name, len(p))</code></span>
<span class="codeline" id="line-3448"><code>	n, err = c.Conn.Read(p)</code></span>
<span class="codeline" id="line-3449"><code>	log.Printf("%s.Read(%d) = %d, %v", c.name, len(p), n, err)</code></span>
<span class="codeline" id="line-3450"><code>	return</code></span>
<span class="codeline" id="line-3451"><code>}</code></span>
<span class="codeline" id="line-3452"><code></code></span>
<span class="codeline" id="line-3453"><code>func (c *loggingConn) Close() (err error) {</code></span>
<span class="codeline" id="line-3454"><code>	log.Printf("%s.Close() = ...", c.name)</code></span>
<span class="codeline" id="line-3455"><code>	err = c.Conn.Close()</code></span>
<span class="codeline" id="line-3456"><code>	log.Printf("%s.Close() = %v", c.name, err)</code></span>
<span class="codeline" id="line-3457"><code>	return</code></span>
<span class="codeline" id="line-3458"><code>}</code></span>
<span class="codeline" id="line-3459"><code></code></span>
<span class="codeline" id="line-3460"><code>// checkConnErrorWriter writes to c.rwc and records any write errors to c.werr.</code></span>
<span class="codeline" id="line-3461"><code>// It only contains one field (and a pointer field at that), so it</code></span>
<span class="codeline" id="line-3462"><code>// fits in an interface value without an extra allocation.</code></span>
<span class="codeline" id="line-3463"><code>type checkConnErrorWriter struct {</code></span>
<span class="codeline" id="line-3464"><code>	c *conn</code></span>
<span class="codeline" id="line-3465"><code>}</code></span>
<span class="codeline" id="line-3466"><code></code></span>
<span class="codeline" id="line-3467"><code>func (w checkConnErrorWriter) Write(p []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-3468"><code>	n, err = w.c.rwc.Write(p)</code></span>
<span class="codeline" id="line-3469"><code>	if err != nil &amp;&amp; w.c.werr == nil {</code></span>
<span class="codeline" id="line-3470"><code>		w.c.werr = err</code></span>
<span class="codeline" id="line-3471"><code>		w.c.cancelCtx()</code></span>
<span class="codeline" id="line-3472"><code>	}</code></span>
<span class="codeline" id="line-3473"><code>	return</code></span>
<span class="codeline" id="line-3474"><code>}</code></span>
<span class="codeline" id="line-3475"><code></code></span>
<span class="codeline" id="line-3476"><code>func numLeadingCRorLF(v []byte) (n int) {</code></span>
<span class="codeline" id="line-3477"><code>	for _, b := range v {</code></span>
<span class="codeline" id="line-3478"><code>		if b == '\r' || b == '\n' {</code></span>
<span class="codeline" id="line-3479"><code>			n++</code></span>
<span class="codeline" id="line-3480"><code>			continue</code></span>
<span class="codeline" id="line-3481"><code>		}</code></span>
<span class="codeline" id="line-3482"><code>		break</code></span>
<span class="codeline" id="line-3483"><code>	}</code></span>
<span class="codeline" id="line-3484"><code>	return</code></span>
<span class="codeline" id="line-3485"><code></code></span>
<span class="codeline" id="line-3486"><code>}</code></span>
<span class="codeline" id="line-3487"><code></code></span>
<span class="codeline" id="line-3488"><code>func strSliceContains(ss []string, s string) bool {</code></span>
<span class="codeline" id="line-3489"><code>	for _, v := range ss {</code></span>
<span class="codeline" id="line-3490"><code>		if v == s {</code></span>
<span class="codeline" id="line-3491"><code>			return true</code></span>
<span class="codeline" id="line-3492"><code>		}</code></span>
<span class="codeline" id="line-3493"><code>	}</code></span>
<span class="codeline" id="line-3494"><code>	return false</code></span>
<span class="codeline" id="line-3495"><code>}</code></span>
<span class="codeline" id="line-3496"><code></code></span>
<span class="codeline" id="line-3497"><code>// tlsRecordHeaderLooksLikeHTTP reports whether a TLS record header</code></span>
<span class="codeline" id="line-3498"><code>// looks like it might've been a misdirected plaintext HTTP request.</code></span>
<span class="codeline" id="line-3499"><code>func tlsRecordHeaderLooksLikeHTTP(hdr [5]byte) bool {</code></span>
<span class="codeline" id="line-3500"><code>	switch string(hdr[:]) {</code></span>
<span class="codeline" id="line-3501"><code>	case "GET /", "HEAD ", "POST ", "PUT /", "OPTIO":</code></span>
<span class="codeline" id="line-3502"><code>		return true</code></span>
<span class="codeline" id="line-3503"><code>	}</code></span>
<span class="codeline" id="line-3504"><code>	return false</code></span>
<span class="codeline" id="line-3505"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.1.6</i>. (GOOS=darwin GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project and developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table
</pre>
</div></body></html>