<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: finisher_api.go in package gorm.io/gorm</title>
<link href="../../../css/light-v0.1.6.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.1.6.js"></script>
<body><div>

<pre id="header"><code><span class="title">Source File</span>
	finisher_api.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/gorm.io/gorm.html">gorm.io/gorm</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>package gorm</code></span>
<span class="codeline" id="line-2"><code></code></span>
<span class="codeline" id="line-3"><code>import (</code></span>
<span class="codeline" id="line-4"><code>	"database/sql"</code></span>
<span class="codeline" id="line-5"><code>	"errors"</code></span>
<span class="codeline" id="line-6"><code>	"fmt"</code></span>
<span class="codeline" id="line-7"><code>	"reflect"</code></span>
<span class="codeline" id="line-8"><code>	"strings"</code></span>
<span class="codeline" id="line-9"><code></code></span>
<span class="codeline" id="line-10"><code>	"gorm.io/gorm/clause"</code></span>
<span class="codeline" id="line-11"><code>	"gorm.io/gorm/logger"</code></span>
<span class="codeline" id="line-12"><code>	"gorm.io/gorm/schema"</code></span>
<span class="codeline" id="line-13"><code>	"gorm.io/gorm/utils"</code></span>
<span class="codeline" id="line-14"><code>)</code></span>
<span class="codeline" id="line-15"><code></code></span>
<span class="codeline" id="line-16"><code>// Create insert the value into database</code></span>
<span class="codeline" id="line-17"><code>func (db *DB) Create(value interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-18"><code>	tx = db.getInstance()</code></span>
<span class="codeline" id="line-19"><code>	tx.Statement.Dest = value</code></span>
<span class="codeline" id="line-20"><code>	tx.callbacks.Create().Execute(tx)</code></span>
<span class="codeline" id="line-21"><code>	return</code></span>
<span class="codeline" id="line-22"><code>}</code></span>
<span class="codeline" id="line-23"><code></code></span>
<span class="codeline" id="line-24"><code>// Save update value in database, if the value doesn't have primary key, will insert it</code></span>
<span class="codeline" id="line-25"><code>func (db *DB) Save(value interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-26"><code>	tx = db.getInstance()</code></span>
<span class="codeline" id="line-27"><code>	tx.Statement.Dest = value</code></span>
<span class="codeline" id="line-28"><code></code></span>
<span class="codeline" id="line-29"><code>	reflectValue := reflect.Indirect(reflect.ValueOf(value))</code></span>
<span class="codeline" id="line-30"><code>	switch reflectValue.Kind() {</code></span>
<span class="codeline" id="line-31"><code>	case reflect.Slice, reflect.Array:</code></span>
<span class="codeline" id="line-32"><code>		tx.Statement.UpdatingColumn = true</code></span>
<span class="codeline" id="line-33"><code>		tx.callbacks.Create().Execute(tx)</code></span>
<span class="codeline" id="line-34"><code>	case reflect.Struct:</code></span>
<span class="codeline" id="line-35"><code>		if err := tx.Statement.Parse(value); err == nil &amp;&amp; tx.Statement.Schema != nil {</code></span>
<span class="codeline" id="line-36"><code>			for _, pf := range tx.Statement.Schema.PrimaryFields {</code></span>
<span class="codeline" id="line-37"><code>				if _, isZero := pf.ValueOf(reflectValue); isZero {</code></span>
<span class="codeline" id="line-38"><code>					tx.callbacks.Create().Execute(tx)</code></span>
<span class="codeline" id="line-39"><code>					return</code></span>
<span class="codeline" id="line-40"><code>				}</code></span>
<span class="codeline" id="line-41"><code>			}</code></span>
<span class="codeline" id="line-42"><code>		}</code></span>
<span class="codeline" id="line-43"><code></code></span>
<span class="codeline" id="line-44"><code>		fallthrough</code></span>
<span class="codeline" id="line-45"><code>	default:</code></span>
<span class="codeline" id="line-46"><code>		selectedUpdate := len(tx.Statement.Selects) != 0</code></span>
<span class="codeline" id="line-47"><code>		// when updating, use all fields including those zero-value fields</code></span>
<span class="codeline" id="line-48"><code>		if !selectedUpdate {</code></span>
<span class="codeline" id="line-49"><code>			tx.Statement.Selects = append(tx.Statement.Selects, "*")</code></span>
<span class="codeline" id="line-50"><code>		}</code></span>
<span class="codeline" id="line-51"><code></code></span>
<span class="codeline" id="line-52"><code>		tx.callbacks.Update().Execute(tx)</code></span>
<span class="codeline" id="line-53"><code></code></span>
<span class="codeline" id="line-54"><code>		if tx.Error == nil &amp;&amp; tx.RowsAffected == 0 &amp;&amp; !tx.DryRun &amp;&amp; !selectedUpdate {</code></span>
<span class="codeline" id="line-55"><code>			result := reflect.New(tx.Statement.Schema.ModelType).Interface()</code></span>
<span class="codeline" id="line-56"><code>			if err := tx.Session(&amp;Session{WithConditions: true}).First(result).Error; errors.Is(err, ErrRecordNotFound) {</code></span>
<span class="codeline" id="line-57"><code>				return tx.Create(value)</code></span>
<span class="codeline" id="line-58"><code>			}</code></span>
<span class="codeline" id="line-59"><code>		}</code></span>
<span class="codeline" id="line-60"><code>	}</code></span>
<span class="codeline" id="line-61"><code></code></span>
<span class="codeline" id="line-62"><code>	return</code></span>
<span class="codeline" id="line-63"><code>}</code></span>
<span class="codeline" id="line-64"><code></code></span>
<span class="codeline" id="line-65"><code>// First find first record that match given conditions, order by primary key</code></span>
<span class="codeline" id="line-66"><code>func (db *DB) First(dest interface{}, conds ...interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-67"><code>	tx = db.Limit(1).Order(clause.OrderByColumn{</code></span>
<span class="codeline" id="line-68"><code>		Column: clause.Column{Table: clause.CurrentTable, Name: clause.PrimaryKey},</code></span>
<span class="codeline" id="line-69"><code>	})</code></span>
<span class="codeline" id="line-70"><code>	if len(conds) &gt; 0 {</code></span>
<span class="codeline" id="line-71"><code>		tx.Statement.AddClause(clause.Where{Exprs: tx.Statement.BuildCondition(conds[0], conds[1:]...)})</code></span>
<span class="codeline" id="line-72"><code>	}</code></span>
<span class="codeline" id="line-73"><code>	tx.Statement.RaiseErrorOnNotFound = true</code></span>
<span class="codeline" id="line-74"><code>	tx.Statement.Dest = dest</code></span>
<span class="codeline" id="line-75"><code>	tx.callbacks.Query().Execute(tx)</code></span>
<span class="codeline" id="line-76"><code>	return</code></span>
<span class="codeline" id="line-77"><code>}</code></span>
<span class="codeline" id="line-78"><code></code></span>
<span class="codeline" id="line-79"><code>// Take return a record that match given conditions, the order will depend on the database implementation</code></span>
<span class="codeline" id="line-80"><code>func (db *DB) Take(dest interface{}, conds ...interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-81"><code>	tx = db.Limit(1)</code></span>
<span class="codeline" id="line-82"><code>	if len(conds) &gt; 0 {</code></span>
<span class="codeline" id="line-83"><code>		tx.Statement.AddClause(clause.Where{Exprs: tx.Statement.BuildCondition(conds[0], conds[1:]...)})</code></span>
<span class="codeline" id="line-84"><code>	}</code></span>
<span class="codeline" id="line-85"><code>	tx.Statement.RaiseErrorOnNotFound = true</code></span>
<span class="codeline" id="line-86"><code>	tx.Statement.Dest = dest</code></span>
<span class="codeline" id="line-87"><code>	tx.callbacks.Query().Execute(tx)</code></span>
<span class="codeline" id="line-88"><code>	return</code></span>
<span class="codeline" id="line-89"><code>}</code></span>
<span class="codeline" id="line-90"><code></code></span>
<span class="codeline" id="line-91"><code>// Last find last record that match given conditions, order by primary key</code></span>
<span class="codeline" id="line-92"><code>func (db *DB) Last(dest interface{}, conds ...interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-93"><code>	tx = db.Limit(1).Order(clause.OrderByColumn{</code></span>
<span class="codeline" id="line-94"><code>		Column: clause.Column{Table: clause.CurrentTable, Name: clause.PrimaryKey},</code></span>
<span class="codeline" id="line-95"><code>		Desc:   true,</code></span>
<span class="codeline" id="line-96"><code>	})</code></span>
<span class="codeline" id="line-97"><code>	if len(conds) &gt; 0 {</code></span>
<span class="codeline" id="line-98"><code>		tx.Statement.AddClause(clause.Where{Exprs: tx.Statement.BuildCondition(conds[0], conds[1:]...)})</code></span>
<span class="codeline" id="line-99"><code>	}</code></span>
<span class="codeline" id="line-100"><code>	tx.Statement.RaiseErrorOnNotFound = true</code></span>
<span class="codeline" id="line-101"><code>	tx.Statement.Dest = dest</code></span>
<span class="codeline" id="line-102"><code>	tx.callbacks.Query().Execute(tx)</code></span>
<span class="codeline" id="line-103"><code>	return</code></span>
<span class="codeline" id="line-104"><code>}</code></span>
<span class="codeline" id="line-105"><code></code></span>
<span class="codeline" id="line-106"><code>// Find find records that match given conditions</code></span>
<span class="codeline" id="line-107"><code>func (db *DB) Find(dest interface{}, conds ...interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-108"><code>	tx = db.getInstance()</code></span>
<span class="codeline" id="line-109"><code>	if len(conds) &gt; 0 {</code></span>
<span class="codeline" id="line-110"><code>		tx.Statement.AddClause(clause.Where{Exprs: tx.Statement.BuildCondition(conds[0], conds[1:]...)})</code></span>
<span class="codeline" id="line-111"><code>	}</code></span>
<span class="codeline" id="line-112"><code>	tx.Statement.Dest = dest</code></span>
<span class="codeline" id="line-113"><code>	tx.callbacks.Query().Execute(tx)</code></span>
<span class="codeline" id="line-114"><code>	return</code></span>
<span class="codeline" id="line-115"><code>}</code></span>
<span class="codeline" id="line-116"><code></code></span>
<span class="codeline" id="line-117"><code>// FindInBatches find records in batches</code></span>
<span class="codeline" id="line-118"><code>func (db *DB) FindInBatches(dest interface{}, batchSize int, fc func(tx *DB, batch int) error) (tx *DB) {</code></span>
<span class="codeline" id="line-119"><code>	tx = db.Session(&amp;Session{WithConditions: true})</code></span>
<span class="codeline" id="line-120"><code>	rowsAffected := int64(0)</code></span>
<span class="codeline" id="line-121"><code>	batch := 0</code></span>
<span class="codeline" id="line-122"><code></code></span>
<span class="codeline" id="line-123"><code>	for {</code></span>
<span class="codeline" id="line-124"><code>		result := tx.Limit(batchSize).Offset(batch * batchSize).Find(dest)</code></span>
<span class="codeline" id="line-125"><code>		rowsAffected += result.RowsAffected</code></span>
<span class="codeline" id="line-126"><code>		batch++</code></span>
<span class="codeline" id="line-127"><code></code></span>
<span class="codeline" id="line-128"><code>		if result.Error == nil &amp;&amp; result.RowsAffected != 0 {</code></span>
<span class="codeline" id="line-129"><code>			tx.AddError(fc(result, batch))</code></span>
<span class="codeline" id="line-130"><code>		}</code></span>
<span class="codeline" id="line-131"><code></code></span>
<span class="codeline" id="line-132"><code>		if tx.Error != nil || int(result.RowsAffected) &lt; batchSize {</code></span>
<span class="codeline" id="line-133"><code>			break</code></span>
<span class="codeline" id="line-134"><code>		}</code></span>
<span class="codeline" id="line-135"><code>	}</code></span>
<span class="codeline" id="line-136"><code></code></span>
<span class="codeline" id="line-137"><code>	tx.RowsAffected = rowsAffected</code></span>
<span class="codeline" id="line-138"><code>	return</code></span>
<span class="codeline" id="line-139"><code>}</code></span>
<span class="codeline" id="line-140"><code></code></span>
<span class="codeline" id="line-141"><code>func (tx *DB) assignInterfacesToValue(values ...interface{}) {</code></span>
<span class="codeline" id="line-142"><code>	for _, value := range values {</code></span>
<span class="codeline" id="line-143"><code>		switch v := value.(type) {</code></span>
<span class="codeline" id="line-144"><code>		case []clause.Expression:</code></span>
<span class="codeline" id="line-145"><code>			for _, expr := range v {</code></span>
<span class="codeline" id="line-146"><code>				if eq, ok := expr.(clause.Eq); ok {</code></span>
<span class="codeline" id="line-147"><code>					switch column := eq.Column.(type) {</code></span>
<span class="codeline" id="line-148"><code>					case string:</code></span>
<span class="codeline" id="line-149"><code>						if field := tx.Statement.Schema.LookUpField(column); field != nil {</code></span>
<span class="codeline" id="line-150"><code>							tx.AddError(field.Set(tx.Statement.ReflectValue, eq.Value))</code></span>
<span class="codeline" id="line-151"><code>						}</code></span>
<span class="codeline" id="line-152"><code>					case clause.Column:</code></span>
<span class="codeline" id="line-153"><code>						if field := tx.Statement.Schema.LookUpField(column.Name); field != nil {</code></span>
<span class="codeline" id="line-154"><code>							tx.AddError(field.Set(tx.Statement.ReflectValue, eq.Value))</code></span>
<span class="codeline" id="line-155"><code>						}</code></span>
<span class="codeline" id="line-156"><code>					}</code></span>
<span class="codeline" id="line-157"><code>				} else if andCond, ok := expr.(clause.AndConditions); ok {</code></span>
<span class="codeline" id="line-158"><code>					tx.assignInterfacesToValue(andCond.Exprs)</code></span>
<span class="codeline" id="line-159"><code>				}</code></span>
<span class="codeline" id="line-160"><code>			}</code></span>
<span class="codeline" id="line-161"><code>		case clause.Expression, map[string]string, map[interface{}]interface{}, map[string]interface{}:</code></span>
<span class="codeline" id="line-162"><code>			exprs := tx.Statement.BuildCondition(value)</code></span>
<span class="codeline" id="line-163"><code>			tx.assignInterfacesToValue(exprs)</code></span>
<span class="codeline" id="line-164"><code>		default:</code></span>
<span class="codeline" id="line-165"><code>			if s, err := schema.Parse(value, tx.cacheStore, tx.NamingStrategy); err == nil {</code></span>
<span class="codeline" id="line-166"><code>				reflectValue := reflect.Indirect(reflect.ValueOf(value))</code></span>
<span class="codeline" id="line-167"><code>				switch reflectValue.Kind() {</code></span>
<span class="codeline" id="line-168"><code>				case reflect.Struct:</code></span>
<span class="codeline" id="line-169"><code>					for _, f := range s.Fields {</code></span>
<span class="codeline" id="line-170"><code>						if f.Readable {</code></span>
<span class="codeline" id="line-171"><code>							if v, isZero := f.ValueOf(reflectValue); !isZero {</code></span>
<span class="codeline" id="line-172"><code>								if field := tx.Statement.Schema.LookUpField(f.Name); field != nil {</code></span>
<span class="codeline" id="line-173"><code>									tx.AddError(field.Set(tx.Statement.ReflectValue, v))</code></span>
<span class="codeline" id="line-174"><code>								}</code></span>
<span class="codeline" id="line-175"><code>							}</code></span>
<span class="codeline" id="line-176"><code>						}</code></span>
<span class="codeline" id="line-177"><code>					}</code></span>
<span class="codeline" id="line-178"><code>				}</code></span>
<span class="codeline" id="line-179"><code>			} else if len(values) &gt; 0 {</code></span>
<span class="codeline" id="line-180"><code>				exprs := tx.Statement.BuildCondition(values[0], values[1:]...)</code></span>
<span class="codeline" id="line-181"><code>				tx.assignInterfacesToValue(exprs)</code></span>
<span class="codeline" id="line-182"><code>				return</code></span>
<span class="codeline" id="line-183"><code>			}</code></span>
<span class="codeline" id="line-184"><code>		}</code></span>
<span class="codeline" id="line-185"><code>	}</code></span>
<span class="codeline" id="line-186"><code>}</code></span>
<span class="codeline" id="line-187"><code></code></span>
<span class="codeline" id="line-188"><code>func (db *DB) FirstOrInit(dest interface{}, conds ...interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-189"><code>	if tx = db.First(dest, conds...); errors.Is(tx.Error, ErrRecordNotFound) {</code></span>
<span class="codeline" id="line-190"><code>		if c, ok := tx.Statement.Clauses["WHERE"]; ok {</code></span>
<span class="codeline" id="line-191"><code>			if where, ok := c.Expression.(clause.Where); ok {</code></span>
<span class="codeline" id="line-192"><code>				tx.assignInterfacesToValue(where.Exprs)</code></span>
<span class="codeline" id="line-193"><code>			}</code></span>
<span class="codeline" id="line-194"><code>		}</code></span>
<span class="codeline" id="line-195"><code></code></span>
<span class="codeline" id="line-196"><code>		// initialize with attrs, conds</code></span>
<span class="codeline" id="line-197"><code>		if len(tx.Statement.attrs) &gt; 0 {</code></span>
<span class="codeline" id="line-198"><code>			tx.assignInterfacesToValue(tx.Statement.attrs...)</code></span>
<span class="codeline" id="line-199"><code>		}</code></span>
<span class="codeline" id="line-200"><code>		tx.Error = nil</code></span>
<span class="codeline" id="line-201"><code>	}</code></span>
<span class="codeline" id="line-202"><code></code></span>
<span class="codeline" id="line-203"><code>	// initialize with attrs, conds</code></span>
<span class="codeline" id="line-204"><code>	if len(tx.Statement.assigns) &gt; 0 {</code></span>
<span class="codeline" id="line-205"><code>		tx.assignInterfacesToValue(tx.Statement.assigns...)</code></span>
<span class="codeline" id="line-206"><code>	}</code></span>
<span class="codeline" id="line-207"><code>	return</code></span>
<span class="codeline" id="line-208"><code>}</code></span>
<span class="codeline" id="line-209"><code></code></span>
<span class="codeline" id="line-210"><code>func (db *DB) FirstOrCreate(dest interface{}, conds ...interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-211"><code>	if tx = db.First(dest, conds...); errors.Is(tx.Error, ErrRecordNotFound) {</code></span>
<span class="codeline" id="line-212"><code>		tx.Error = nil</code></span>
<span class="codeline" id="line-213"><code></code></span>
<span class="codeline" id="line-214"><code>		if c, ok := tx.Statement.Clauses["WHERE"]; ok {</code></span>
<span class="codeline" id="line-215"><code>			if where, ok := c.Expression.(clause.Where); ok {</code></span>
<span class="codeline" id="line-216"><code>				tx.assignInterfacesToValue(where.Exprs)</code></span>
<span class="codeline" id="line-217"><code>			}</code></span>
<span class="codeline" id="line-218"><code>		}</code></span>
<span class="codeline" id="line-219"><code></code></span>
<span class="codeline" id="line-220"><code>		// initialize with attrs, conds</code></span>
<span class="codeline" id="line-221"><code>		if len(tx.Statement.attrs) &gt; 0 {</code></span>
<span class="codeline" id="line-222"><code>			tx.assignInterfacesToValue(tx.Statement.attrs...)</code></span>
<span class="codeline" id="line-223"><code>		}</code></span>
<span class="codeline" id="line-224"><code></code></span>
<span class="codeline" id="line-225"><code>		// initialize with attrs, conds</code></span>
<span class="codeline" id="line-226"><code>		if len(tx.Statement.assigns) &gt; 0 {</code></span>
<span class="codeline" id="line-227"><code>			tx.assignInterfacesToValue(tx.Statement.assigns...)</code></span>
<span class="codeline" id="line-228"><code>		}</code></span>
<span class="codeline" id="line-229"><code></code></span>
<span class="codeline" id="line-230"><code>		return tx.Create(dest)</code></span>
<span class="codeline" id="line-231"><code>	} else if len(db.Statement.assigns) &gt; 0 {</code></span>
<span class="codeline" id="line-232"><code>		exprs := tx.Statement.BuildCondition(tx.Statement.assigns[0], tx.Statement.assigns[1:]...)</code></span>
<span class="codeline" id="line-233"><code>		assigns := map[string]interface{}{}</code></span>
<span class="codeline" id="line-234"><code>		for _, expr := range exprs {</code></span>
<span class="codeline" id="line-235"><code>			if eq, ok := expr.(clause.Eq); ok {</code></span>
<span class="codeline" id="line-236"><code>				switch column := eq.Column.(type) {</code></span>
<span class="codeline" id="line-237"><code>				case string:</code></span>
<span class="codeline" id="line-238"><code>					assigns[column] = eq.Value</code></span>
<span class="codeline" id="line-239"><code>				case clause.Column:</code></span>
<span class="codeline" id="line-240"><code>					assigns[column.Name] = eq.Value</code></span>
<span class="codeline" id="line-241"><code>				default:</code></span>
<span class="codeline" id="line-242"><code>				}</code></span>
<span class="codeline" id="line-243"><code>			}</code></span>
<span class="codeline" id="line-244"><code>		}</code></span>
<span class="codeline" id="line-245"><code></code></span>
<span class="codeline" id="line-246"><code>		return tx.Model(dest).Updates(assigns)</code></span>
<span class="codeline" id="line-247"><code>	}</code></span>
<span class="codeline" id="line-248"><code></code></span>
<span class="codeline" id="line-249"><code>	return db</code></span>
<span class="codeline" id="line-250"><code>}</code></span>
<span class="codeline" id="line-251"><code></code></span>
<span class="codeline" id="line-252"><code>// Update update attributes with callbacks, refer: https://gorm.io/docs/update.html#Update-Changed-Fields</code></span>
<span class="codeline" id="line-253"><code>func (db *DB) Update(column string, value interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-254"><code>	tx = db.getInstance()</code></span>
<span class="codeline" id="line-255"><code>	tx.Statement.Dest = map[string]interface{}{column: value}</code></span>
<span class="codeline" id="line-256"><code>	tx.callbacks.Update().Execute(tx)</code></span>
<span class="codeline" id="line-257"><code>	return</code></span>
<span class="codeline" id="line-258"><code>}</code></span>
<span class="codeline" id="line-259"><code></code></span>
<span class="codeline" id="line-260"><code>// Updates update attributes with callbacks, refer: https://gorm.io/docs/update.html#Update-Changed-Fields</code></span>
<span class="codeline" id="line-261"><code>func (db *DB) Updates(values interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-262"><code>	tx = db.getInstance()</code></span>
<span class="codeline" id="line-263"><code>	tx.Statement.Dest = values</code></span>
<span class="codeline" id="line-264"><code>	tx.callbacks.Update().Execute(tx)</code></span>
<span class="codeline" id="line-265"><code>	return</code></span>
<span class="codeline" id="line-266"><code>}</code></span>
<span class="codeline" id="line-267"><code></code></span>
<span class="codeline" id="line-268"><code>func (db *DB) UpdateColumn(column string, value interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-269"><code>	tx = db.getInstance()</code></span>
<span class="codeline" id="line-270"><code>	tx.Statement.Dest = map[string]interface{}{column: value}</code></span>
<span class="codeline" id="line-271"><code>	tx.Statement.UpdatingColumn = true</code></span>
<span class="codeline" id="line-272"><code>	tx.callbacks.Update().Execute(tx)</code></span>
<span class="codeline" id="line-273"><code>	return</code></span>
<span class="codeline" id="line-274"><code>}</code></span>
<span class="codeline" id="line-275"><code></code></span>
<span class="codeline" id="line-276"><code>func (db *DB) UpdateColumns(values interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-277"><code>	tx = db.getInstance()</code></span>
<span class="codeline" id="line-278"><code>	tx.Statement.Dest = values</code></span>
<span class="codeline" id="line-279"><code>	tx.Statement.UpdatingColumn = true</code></span>
<span class="codeline" id="line-280"><code>	tx.callbacks.Update().Execute(tx)</code></span>
<span class="codeline" id="line-281"><code>	return</code></span>
<span class="codeline" id="line-282"><code>}</code></span>
<span class="codeline" id="line-283"><code></code></span>
<span class="codeline" id="line-284"><code>// Delete delete value match given conditions, if the value has primary key, then will including the primary key as condition</code></span>
<span class="codeline" id="line-285"><code>func (db *DB) Delete(value interface{}, conds ...interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-286"><code>	tx = db.getInstance()</code></span>
<span class="codeline" id="line-287"><code>	if len(conds) &gt; 0 {</code></span>
<span class="codeline" id="line-288"><code>		tx.Statement.AddClause(clause.Where{Exprs: tx.Statement.BuildCondition(conds[0], conds[1:]...)})</code></span>
<span class="codeline" id="line-289"><code>	}</code></span>
<span class="codeline" id="line-290"><code>	tx.Statement.Dest = value</code></span>
<span class="codeline" id="line-291"><code>	tx.callbacks.Delete().Execute(tx)</code></span>
<span class="codeline" id="line-292"><code>	return</code></span>
<span class="codeline" id="line-293"><code>}</code></span>
<span class="codeline" id="line-294"><code></code></span>
<span class="codeline" id="line-295"><code>func (db *DB) Count(count *int64) (tx *DB) {</code></span>
<span class="codeline" id="line-296"><code>	tx = db.getInstance()</code></span>
<span class="codeline" id="line-297"><code>	if tx.Statement.Model == nil {</code></span>
<span class="codeline" id="line-298"><code>		tx.Statement.Model = tx.Statement.Dest</code></span>
<span class="codeline" id="line-299"><code>		defer func() {</code></span>
<span class="codeline" id="line-300"><code>			tx.Statement.Model = nil</code></span>
<span class="codeline" id="line-301"><code>		}()</code></span>
<span class="codeline" id="line-302"><code>	}</code></span>
<span class="codeline" id="line-303"><code></code></span>
<span class="codeline" id="line-304"><code>	if len(tx.Statement.Selects) == 0 {</code></span>
<span class="codeline" id="line-305"><code>		tx.Statement.AddClause(clause.Select{Expression: clause.Expr{SQL: "count(1)"}})</code></span>
<span class="codeline" id="line-306"><code>		defer delete(tx.Statement.Clauses, "SELECT")</code></span>
<span class="codeline" id="line-307"><code>	} else if !strings.Contains(strings.ToLower(tx.Statement.Selects[0]), "count(") {</code></span>
<span class="codeline" id="line-308"><code>		expr := clause.Expr{SQL: "count(1)"}</code></span>
<span class="codeline" id="line-309"><code></code></span>
<span class="codeline" id="line-310"><code>		if len(tx.Statement.Selects) == 1 {</code></span>
<span class="codeline" id="line-311"><code>			dbName := tx.Statement.Selects[0]</code></span>
<span class="codeline" id="line-312"><code>			if tx.Statement.Parse(tx.Statement.Model) == nil {</code></span>
<span class="codeline" id="line-313"><code>				if f := tx.Statement.Schema.LookUpField(dbName); f != nil {</code></span>
<span class="codeline" id="line-314"><code>					dbName = f.DBName</code></span>
<span class="codeline" id="line-315"><code>				}</code></span>
<span class="codeline" id="line-316"><code>			}</code></span>
<span class="codeline" id="line-317"><code></code></span>
<span class="codeline" id="line-318"><code>			if tx.Statement.Distinct {</code></span>
<span class="codeline" id="line-319"><code>				expr = clause.Expr{SQL: "COUNT(DISTINCT(?))", Vars: []interface{}{clause.Column{Name: dbName}}}</code></span>
<span class="codeline" id="line-320"><code>			} else {</code></span>
<span class="codeline" id="line-321"><code>				expr = clause.Expr{SQL: "COUNT(?)", Vars: []interface{}{clause.Column{Name: dbName}}}</code></span>
<span class="codeline" id="line-322"><code>			}</code></span>
<span class="codeline" id="line-323"><code>		}</code></span>
<span class="codeline" id="line-324"><code></code></span>
<span class="codeline" id="line-325"><code>		tx.Statement.AddClause(clause.Select{Expression: expr})</code></span>
<span class="codeline" id="line-326"><code>		defer tx.Statement.AddClause(clause.Select{})</code></span>
<span class="codeline" id="line-327"><code>	}</code></span>
<span class="codeline" id="line-328"><code></code></span>
<span class="codeline" id="line-329"><code>	if orderByClause, ok := db.Statement.Clauses["ORDER BY"]; ok {</code></span>
<span class="codeline" id="line-330"><code>		if _, ok := db.Statement.Clauses["GROUP BY"]; !ok {</code></span>
<span class="codeline" id="line-331"><code>			delete(db.Statement.Clauses, "ORDER BY")</code></span>
<span class="codeline" id="line-332"><code>			defer func() {</code></span>
<span class="codeline" id="line-333"><code>				db.Statement.Clauses["ORDER BY"] = orderByClause</code></span>
<span class="codeline" id="line-334"><code>			}()</code></span>
<span class="codeline" id="line-335"><code>		}</code></span>
<span class="codeline" id="line-336"><code>	}</code></span>
<span class="codeline" id="line-337"><code></code></span>
<span class="codeline" id="line-338"><code>	tx.Statement.Dest = count</code></span>
<span class="codeline" id="line-339"><code>	tx.callbacks.Query().Execute(tx)</code></span>
<span class="codeline" id="line-340"><code>	if tx.RowsAffected != 1 {</code></span>
<span class="codeline" id="line-341"><code>		*count = tx.RowsAffected</code></span>
<span class="codeline" id="line-342"><code>	}</code></span>
<span class="codeline" id="line-343"><code>	return</code></span>
<span class="codeline" id="line-344"><code>}</code></span>
<span class="codeline" id="line-345"><code></code></span>
<span class="codeline" id="line-346"><code>func (db *DB) Row() *sql.Row {</code></span>
<span class="codeline" id="line-347"><code>	tx := db.getInstance().InstanceSet("rows", false)</code></span>
<span class="codeline" id="line-348"><code>	tx.callbacks.Row().Execute(tx)</code></span>
<span class="codeline" id="line-349"><code>	row, ok := tx.Statement.Dest.(*sql.Row)</code></span>
<span class="codeline" id="line-350"><code>	if !ok &amp;&amp; tx.DryRun {</code></span>
<span class="codeline" id="line-351"><code>		db.Logger.Error(tx.Statement.Context, ErrDryRunModeUnsupported.Error())</code></span>
<span class="codeline" id="line-352"><code>	}</code></span>
<span class="codeline" id="line-353"><code>	return row</code></span>
<span class="codeline" id="line-354"><code>}</code></span>
<span class="codeline" id="line-355"><code></code></span>
<span class="codeline" id="line-356"><code>func (db *DB) Rows() (*sql.Rows, error) {</code></span>
<span class="codeline" id="line-357"><code>	tx := db.getInstance().InstanceSet("rows", true)</code></span>
<span class="codeline" id="line-358"><code>	tx.callbacks.Row().Execute(tx)</code></span>
<span class="codeline" id="line-359"><code>	rows, ok := tx.Statement.Dest.(*sql.Rows)</code></span>
<span class="codeline" id="line-360"><code>	if !ok &amp;&amp; tx.DryRun &amp;&amp; tx.Error == nil {</code></span>
<span class="codeline" id="line-361"><code>		tx.Error = ErrDryRunModeUnsupported</code></span>
<span class="codeline" id="line-362"><code>	}</code></span>
<span class="codeline" id="line-363"><code>	return rows, tx.Error</code></span>
<span class="codeline" id="line-364"><code>}</code></span>
<span class="codeline" id="line-365"><code></code></span>
<span class="codeline" id="line-366"><code>// Scan scan value to a struct</code></span>
<span class="codeline" id="line-367"><code>func (db *DB) Scan(dest interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-368"><code>	config := *db.Config</code></span>
<span class="codeline" id="line-369"><code>	currentLogger, newLogger := config.Logger, logger.Recorder.New()</code></span>
<span class="codeline" id="line-370"><code>	config.Logger = newLogger</code></span>
<span class="codeline" id="line-371"><code></code></span>
<span class="codeline" id="line-372"><code>	tx = db.getInstance()</code></span>
<span class="codeline" id="line-373"><code>	tx.Config = &amp;config</code></span>
<span class="codeline" id="line-374"><code></code></span>
<span class="codeline" id="line-375"><code>	if rows, err := tx.Rows(); err != nil {</code></span>
<span class="codeline" id="line-376"><code>		tx.AddError(err)</code></span>
<span class="codeline" id="line-377"><code>	} else {</code></span>
<span class="codeline" id="line-378"><code>		defer rows.Close()</code></span>
<span class="codeline" id="line-379"><code>		if rows.Next() {</code></span>
<span class="codeline" id="line-380"><code>			tx.ScanRows(rows, dest)</code></span>
<span class="codeline" id="line-381"><code>		}</code></span>
<span class="codeline" id="line-382"><code>	}</code></span>
<span class="codeline" id="line-383"><code></code></span>
<span class="codeline" id="line-384"><code>	currentLogger.Trace(tx.Statement.Context, newLogger.BeginAt, func() (string, int64) {</code></span>
<span class="codeline" id="line-385"><code>		return newLogger.SQL, tx.RowsAffected</code></span>
<span class="codeline" id="line-386"><code>	}, tx.Error)</code></span>
<span class="codeline" id="line-387"><code>	tx.Logger = currentLogger</code></span>
<span class="codeline" id="line-388"><code>	return</code></span>
<span class="codeline" id="line-389"><code>}</code></span>
<span class="codeline" id="line-390"><code></code></span>
<span class="codeline" id="line-391"><code>// Pluck used to query single column from a model as a map</code></span>
<span class="codeline" id="line-392"><code>//     var ages []int64</code></span>
<span class="codeline" id="line-393"><code>//     db.Find(&amp;users).Pluck("age", &amp;ages)</code></span>
<span class="codeline" id="line-394"><code>func (db *DB) Pluck(column string, dest interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-395"><code>	tx = db.getInstance()</code></span>
<span class="codeline" id="line-396"><code>	if tx.Statement.Model != nil {</code></span>
<span class="codeline" id="line-397"><code>		if tx.Statement.Parse(tx.Statement.Model) == nil {</code></span>
<span class="codeline" id="line-398"><code>			if f := tx.Statement.Schema.LookUpField(column); f != nil {</code></span>
<span class="codeline" id="line-399"><code>				column = f.DBName</code></span>
<span class="codeline" id="line-400"><code>			}</code></span>
<span class="codeline" id="line-401"><code>		}</code></span>
<span class="codeline" id="line-402"><code>	} else if tx.Statement.Table == "" {</code></span>
<span class="codeline" id="line-403"><code>		tx.AddError(ErrModelValueRequired)</code></span>
<span class="codeline" id="line-404"><code>	}</code></span>
<span class="codeline" id="line-405"><code></code></span>
<span class="codeline" id="line-406"><code>	fields := strings.FieldsFunc(column, utils.IsValidDBNameChar)</code></span>
<span class="codeline" id="line-407"><code>	tx.Statement.AddClauseIfNotExists(clause.Select{</code></span>
<span class="codeline" id="line-408"><code>		Distinct: tx.Statement.Distinct,</code></span>
<span class="codeline" id="line-409"><code>		Columns:  []clause.Column{{Name: column, Raw: len(fields) != 1}},</code></span>
<span class="codeline" id="line-410"><code>	})</code></span>
<span class="codeline" id="line-411"><code>	tx.Statement.Dest = dest</code></span>
<span class="codeline" id="line-412"><code>	tx.callbacks.Query().Execute(tx)</code></span>
<span class="codeline" id="line-413"><code>	return</code></span>
<span class="codeline" id="line-414"><code>}</code></span>
<span class="codeline" id="line-415"><code></code></span>
<span class="codeline" id="line-416"><code>func (db *DB) ScanRows(rows *sql.Rows, dest interface{}) error {</code></span>
<span class="codeline" id="line-417"><code>	tx := db.getInstance()</code></span>
<span class="codeline" id="line-418"><code>	if err := tx.Statement.Parse(dest); !errors.Is(err, schema.ErrUnsupportedDataType) {</code></span>
<span class="codeline" id="line-419"><code>		tx.AddError(err)</code></span>
<span class="codeline" id="line-420"><code>	}</code></span>
<span class="codeline" id="line-421"><code>	tx.Statement.Dest = dest</code></span>
<span class="codeline" id="line-422"><code>	tx.Statement.ReflectValue = reflect.ValueOf(dest)</code></span>
<span class="codeline" id="line-423"><code>	for tx.Statement.ReflectValue.Kind() == reflect.Ptr {</code></span>
<span class="codeline" id="line-424"><code>		tx.Statement.ReflectValue = tx.Statement.ReflectValue.Elem()</code></span>
<span class="codeline" id="line-425"><code>	}</code></span>
<span class="codeline" id="line-426"><code>	Scan(rows, tx, true)</code></span>
<span class="codeline" id="line-427"><code>	return tx.Error</code></span>
<span class="codeline" id="line-428"><code>}</code></span>
<span class="codeline" id="line-429"><code></code></span>
<span class="codeline" id="line-430"><code>// Transaction start a transaction as a block, return error will rollback, otherwise to commit.</code></span>
<span class="codeline" id="line-431"><code>func (db *DB) Transaction(fc func(tx *DB) error, opts ...*sql.TxOptions) (err error) {</code></span>
<span class="codeline" id="line-432"><code>	panicked := true</code></span>
<span class="codeline" id="line-433"><code></code></span>
<span class="codeline" id="line-434"><code>	if committer, ok := db.Statement.ConnPool.(TxCommitter); ok &amp;&amp; committer != nil {</code></span>
<span class="codeline" id="line-435"><code>		// nested transaction</code></span>
<span class="codeline" id="line-436"><code>		db.SavePoint(fmt.Sprintf("sp%p", fc))</code></span>
<span class="codeline" id="line-437"><code>		defer func() {</code></span>
<span class="codeline" id="line-438"><code>			// Make sure to rollback when panic, Block error or Commit error</code></span>
<span class="codeline" id="line-439"><code>			if panicked || err != nil {</code></span>
<span class="codeline" id="line-440"><code>				db.RollbackTo(fmt.Sprintf("sp%p", fc))</code></span>
<span class="codeline" id="line-441"><code>			}</code></span>
<span class="codeline" id="line-442"><code>		}()</code></span>
<span class="codeline" id="line-443"><code></code></span>
<span class="codeline" id="line-444"><code>		err = fc(db.Session(&amp;Session{WithConditions: true}))</code></span>
<span class="codeline" id="line-445"><code>	} else {</code></span>
<span class="codeline" id="line-446"><code>		tx := db.Begin(opts...)</code></span>
<span class="codeline" id="line-447"><code></code></span>
<span class="codeline" id="line-448"><code>		defer func() {</code></span>
<span class="codeline" id="line-449"><code>			// Make sure to rollback when panic, Block error or Commit error</code></span>
<span class="codeline" id="line-450"><code>			if panicked || err != nil {</code></span>
<span class="codeline" id="line-451"><code>				tx.Rollback()</code></span>
<span class="codeline" id="line-452"><code>			}</code></span>
<span class="codeline" id="line-453"><code>		}()</code></span>
<span class="codeline" id="line-454"><code></code></span>
<span class="codeline" id="line-455"><code>		err = fc(tx)</code></span>
<span class="codeline" id="line-456"><code></code></span>
<span class="codeline" id="line-457"><code>		if err == nil {</code></span>
<span class="codeline" id="line-458"><code>			err = tx.Commit().Error</code></span>
<span class="codeline" id="line-459"><code>		}</code></span>
<span class="codeline" id="line-460"><code>	}</code></span>
<span class="codeline" id="line-461"><code></code></span>
<span class="codeline" id="line-462"><code>	panicked = false</code></span>
<span class="codeline" id="line-463"><code>	return</code></span>
<span class="codeline" id="line-464"><code>}</code></span>
<span class="codeline" id="line-465"><code></code></span>
<span class="codeline" id="line-466"><code>// Begin begins a transaction</code></span>
<span class="codeline" id="line-467"><code>func (db *DB) Begin(opts ...*sql.TxOptions) *DB {</code></span>
<span class="codeline" id="line-468"><code>	var (</code></span>
<span class="codeline" id="line-469"><code>		// clone statement</code></span>
<span class="codeline" id="line-470"><code>		tx  = db.Session(&amp;Session{WithConditions: true, Context: db.Statement.Context})</code></span>
<span class="codeline" id="line-471"><code>		opt *sql.TxOptions</code></span>
<span class="codeline" id="line-472"><code>		err error</code></span>
<span class="codeline" id="line-473"><code>	)</code></span>
<span class="codeline" id="line-474"><code></code></span>
<span class="codeline" id="line-475"><code>	if len(opts) &gt; 0 {</code></span>
<span class="codeline" id="line-476"><code>		opt = opts[0]</code></span>
<span class="codeline" id="line-477"><code>	}</code></span>
<span class="codeline" id="line-478"><code></code></span>
<span class="codeline" id="line-479"><code>	if beginner, ok := tx.Statement.ConnPool.(TxBeginner); ok {</code></span>
<span class="codeline" id="line-480"><code>		tx.Statement.ConnPool, err = beginner.BeginTx(tx.Statement.Context, opt)</code></span>
<span class="codeline" id="line-481"><code>	} else if beginner, ok := tx.Statement.ConnPool.(ConnPoolBeginner); ok {</code></span>
<span class="codeline" id="line-482"><code>		tx.Statement.ConnPool, err = beginner.BeginTx(tx.Statement.Context, opt)</code></span>
<span class="codeline" id="line-483"><code>	} else {</code></span>
<span class="codeline" id="line-484"><code>		err = ErrInvalidTransaction</code></span>
<span class="codeline" id="line-485"><code>	}</code></span>
<span class="codeline" id="line-486"><code></code></span>
<span class="codeline" id="line-487"><code>	if err != nil {</code></span>
<span class="codeline" id="line-488"><code>		tx.AddError(err)</code></span>
<span class="codeline" id="line-489"><code>	}</code></span>
<span class="codeline" id="line-490"><code></code></span>
<span class="codeline" id="line-491"><code>	return tx</code></span>
<span class="codeline" id="line-492"><code>}</code></span>
<span class="codeline" id="line-493"><code></code></span>
<span class="codeline" id="line-494"><code>// Commit commit a transaction</code></span>
<span class="codeline" id="line-495"><code>func (db *DB) Commit() *DB {</code></span>
<span class="codeline" id="line-496"><code>	if committer, ok := db.Statement.ConnPool.(TxCommitter); ok &amp;&amp; committer != nil &amp;&amp; !reflect.ValueOf(committer).IsNil() {</code></span>
<span class="codeline" id="line-497"><code>		db.AddError(committer.Commit())</code></span>
<span class="codeline" id="line-498"><code>	} else {</code></span>
<span class="codeline" id="line-499"><code>		db.AddError(ErrInvalidTransaction)</code></span>
<span class="codeline" id="line-500"><code>	}</code></span>
<span class="codeline" id="line-501"><code>	return db</code></span>
<span class="codeline" id="line-502"><code>}</code></span>
<span class="codeline" id="line-503"><code></code></span>
<span class="codeline" id="line-504"><code>// Rollback rollback a transaction</code></span>
<span class="codeline" id="line-505"><code>func (db *DB) Rollback() *DB {</code></span>
<span class="codeline" id="line-506"><code>	if committer, ok := db.Statement.ConnPool.(TxCommitter); ok &amp;&amp; committer != nil {</code></span>
<span class="codeline" id="line-507"><code>		if !reflect.ValueOf(committer).IsNil() {</code></span>
<span class="codeline" id="line-508"><code>			db.AddError(committer.Rollback())</code></span>
<span class="codeline" id="line-509"><code>		}</code></span>
<span class="codeline" id="line-510"><code>	} else {</code></span>
<span class="codeline" id="line-511"><code>		db.AddError(ErrInvalidTransaction)</code></span>
<span class="codeline" id="line-512"><code>	}</code></span>
<span class="codeline" id="line-513"><code>	return db</code></span>
<span class="codeline" id="line-514"><code>}</code></span>
<span class="codeline" id="line-515"><code></code></span>
<span class="codeline" id="line-516"><code>func (db *DB) SavePoint(name string) *DB {</code></span>
<span class="codeline" id="line-517"><code>	if savePointer, ok := db.Dialector.(SavePointerDialectorInterface); ok {</code></span>
<span class="codeline" id="line-518"><code>		db.AddError(savePointer.SavePoint(db, name))</code></span>
<span class="codeline" id="line-519"><code>	} else {</code></span>
<span class="codeline" id="line-520"><code>		db.AddError(ErrUnsupportedDriver)</code></span>
<span class="codeline" id="line-521"><code>	}</code></span>
<span class="codeline" id="line-522"><code>	return db</code></span>
<span class="codeline" id="line-523"><code>}</code></span>
<span class="codeline" id="line-524"><code></code></span>
<span class="codeline" id="line-525"><code>func (db *DB) RollbackTo(name string) *DB {</code></span>
<span class="codeline" id="line-526"><code>	if savePointer, ok := db.Dialector.(SavePointerDialectorInterface); ok {</code></span>
<span class="codeline" id="line-527"><code>		db.AddError(savePointer.RollbackTo(db, name))</code></span>
<span class="codeline" id="line-528"><code>	} else {</code></span>
<span class="codeline" id="line-529"><code>		db.AddError(ErrUnsupportedDriver)</code></span>
<span class="codeline" id="line-530"><code>	}</code></span>
<span class="codeline" id="line-531"><code>	return db</code></span>
<span class="codeline" id="line-532"><code>}</code></span>
<span class="codeline" id="line-533"><code></code></span>
<span class="codeline" id="line-534"><code>// Exec execute raw sql</code></span>
<span class="codeline" id="line-535"><code>func (db *DB) Exec(sql string, values ...interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-536"><code>	tx = db.getInstance()</code></span>
<span class="codeline" id="line-537"><code>	tx.Statement.SQL = strings.Builder{}</code></span>
<span class="codeline" id="line-538"><code></code></span>
<span class="codeline" id="line-539"><code>	if strings.Contains(sql, "@") {</code></span>
<span class="codeline" id="line-540"><code>		clause.NamedExpr{SQL: sql, Vars: values}.Build(tx.Statement)</code></span>
<span class="codeline" id="line-541"><code>	} else {</code></span>
<span class="codeline" id="line-542"><code>		clause.Expr{SQL: sql, Vars: values}.Build(tx.Statement)</code></span>
<span class="codeline" id="line-543"><code>	}</code></span>
<span class="codeline" id="line-544"><code></code></span>
<span class="codeline" id="line-545"><code>	tx.callbacks.Raw().Execute(tx)</code></span>
<span class="codeline" id="line-546"><code>	return</code></span>
<span class="codeline" id="line-547"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.1.6</i>. (GOOS=darwin GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project and developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table
</pre>
</div></body></html>