<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: rat.go in package math/big</title>
<link href="../../../css/light-v0.1.6.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.1.6.js"></script>
<body><div>

<pre id="header"><code><span class="title">Source File</span>
	rat.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/math/big.html">math/big</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2010 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>// This file implements multi-precision rational numbers.</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>package big</code></span>
<span class="codeline" id="line-8"><code></code></span>
<span class="codeline" id="line-9"><code>import (</code></span>
<span class="codeline" id="line-10"><code>	"fmt"</code></span>
<span class="codeline" id="line-11"><code>	"math"</code></span>
<span class="codeline" id="line-12"><code>)</code></span>
<span class="codeline" id="line-13"><code></code></span>
<span class="codeline" id="line-14"><code>// A Rat represents a quotient a/b of arbitrary precision.</code></span>
<span class="codeline" id="line-15"><code>// The zero value for a Rat represents the value 0.</code></span>
<span class="codeline" id="line-16"><code>//</code></span>
<span class="codeline" id="line-17"><code>// Operations always take pointer arguments (*Rat) rather</code></span>
<span class="codeline" id="line-18"><code>// than Rat values, and each unique Rat value requires</code></span>
<span class="codeline" id="line-19"><code>// its own unique *Rat pointer. To "copy" a Rat value,</code></span>
<span class="codeline" id="line-20"><code>// an existing (or newly allocated) Rat must be set to</code></span>
<span class="codeline" id="line-21"><code>// a new value using the Rat.Set method; shallow copies</code></span>
<span class="codeline" id="line-22"><code>// of Rats are not supported and may lead to errors.</code></span>
<span class="codeline" id="line-23"><code>type Rat struct {</code></span>
<span class="codeline" id="line-24"><code>	// To make zero values for Rat work w/o initialization,</code></span>
<span class="codeline" id="line-25"><code>	// a zero value of b (len(b) == 0) acts like b == 1. At</code></span>
<span class="codeline" id="line-26"><code>	// the earliest opportunity (when an assignment to the Rat</code></span>
<span class="codeline" id="line-27"><code>	// is made), such uninitialized denominators are set to 1.</code></span>
<span class="codeline" id="line-28"><code>	// a.neg determines the sign of the Rat, b.neg is ignored.</code></span>
<span class="codeline" id="line-29"><code>	a, b Int</code></span>
<span class="codeline" id="line-30"><code>}</code></span>
<span class="codeline" id="line-31"><code></code></span>
<span class="codeline" id="line-32"><code>// NewRat creates a new Rat with numerator a and denominator b.</code></span>
<span class="codeline" id="line-33"><code>func NewRat(a, b int64) *Rat {</code></span>
<span class="codeline" id="line-34"><code>	return new(Rat).SetFrac64(a, b)</code></span>
<span class="codeline" id="line-35"><code>}</code></span>
<span class="codeline" id="line-36"><code></code></span>
<span class="codeline" id="line-37"><code>// SetFloat64 sets z to exactly f and returns z.</code></span>
<span class="codeline" id="line-38"><code>// If f is not finite, SetFloat returns nil.</code></span>
<span class="codeline" id="line-39"><code>func (z *Rat) SetFloat64(f float64) *Rat {</code></span>
<span class="codeline" id="line-40"><code>	const expMask = 1&lt;&lt;11 - 1</code></span>
<span class="codeline" id="line-41"><code>	bits := math.Float64bits(f)</code></span>
<span class="codeline" id="line-42"><code>	mantissa := bits &amp; (1&lt;&lt;52 - 1)</code></span>
<span class="codeline" id="line-43"><code>	exp := int((bits &gt;&gt; 52) &amp; expMask)</code></span>
<span class="codeline" id="line-44"><code>	switch exp {</code></span>
<span class="codeline" id="line-45"><code>	case expMask: // non-finite</code></span>
<span class="codeline" id="line-46"><code>		return nil</code></span>
<span class="codeline" id="line-47"><code>	case 0: // denormal</code></span>
<span class="codeline" id="line-48"><code>		exp -= 1022</code></span>
<span class="codeline" id="line-49"><code>	default: // normal</code></span>
<span class="codeline" id="line-50"><code>		mantissa |= 1 &lt;&lt; 52</code></span>
<span class="codeline" id="line-51"><code>		exp -= 1023</code></span>
<span class="codeline" id="line-52"><code>	}</code></span>
<span class="codeline" id="line-53"><code></code></span>
<span class="codeline" id="line-54"><code>	shift := 52 - exp</code></span>
<span class="codeline" id="line-55"><code></code></span>
<span class="codeline" id="line-56"><code>	// Optimization (?): partially pre-normalise.</code></span>
<span class="codeline" id="line-57"><code>	for mantissa&amp;1 == 0 &amp;&amp; shift &gt; 0 {</code></span>
<span class="codeline" id="line-58"><code>		mantissa &gt;&gt;= 1</code></span>
<span class="codeline" id="line-59"><code>		shift--</code></span>
<span class="codeline" id="line-60"><code>	}</code></span>
<span class="codeline" id="line-61"><code></code></span>
<span class="codeline" id="line-62"><code>	z.a.SetUint64(mantissa)</code></span>
<span class="codeline" id="line-63"><code>	z.a.neg = f &lt; 0</code></span>
<span class="codeline" id="line-64"><code>	z.b.Set(intOne)</code></span>
<span class="codeline" id="line-65"><code>	if shift &gt; 0 {</code></span>
<span class="codeline" id="line-66"><code>		z.b.Lsh(&amp;z.b, uint(shift))</code></span>
<span class="codeline" id="line-67"><code>	} else {</code></span>
<span class="codeline" id="line-68"><code>		z.a.Lsh(&amp;z.a, uint(-shift))</code></span>
<span class="codeline" id="line-69"><code>	}</code></span>
<span class="codeline" id="line-70"><code>	return z.norm()</code></span>
<span class="codeline" id="line-71"><code>}</code></span>
<span class="codeline" id="line-72"><code></code></span>
<span class="codeline" id="line-73"><code>// quotToFloat32 returns the non-negative float32 value</code></span>
<span class="codeline" id="line-74"><code>// nearest to the quotient a/b, using round-to-even in</code></span>
<span class="codeline" id="line-75"><code>// halfway cases. It does not mutate its arguments.</code></span>
<span class="codeline" id="line-76"><code>// Preconditions: b is non-zero; a and b have no common factors.</code></span>
<span class="codeline" id="line-77"><code>func quotToFloat32(a, b nat) (f float32, exact bool) {</code></span>
<span class="codeline" id="line-78"><code>	const (</code></span>
<span class="codeline" id="line-79"><code>		// float size in bits</code></span>
<span class="codeline" id="line-80"><code>		Fsize = 32</code></span>
<span class="codeline" id="line-81"><code></code></span>
<span class="codeline" id="line-82"><code>		// mantissa</code></span>
<span class="codeline" id="line-83"><code>		Msize  = 23</code></span>
<span class="codeline" id="line-84"><code>		Msize1 = Msize + 1 // incl. implicit 1</code></span>
<span class="codeline" id="line-85"><code>		Msize2 = Msize1 + 1</code></span>
<span class="codeline" id="line-86"><code></code></span>
<span class="codeline" id="line-87"><code>		// exponent</code></span>
<span class="codeline" id="line-88"><code>		Esize = Fsize - Msize1</code></span>
<span class="codeline" id="line-89"><code>		Ebias = 1&lt;&lt;(Esize-1) - 1</code></span>
<span class="codeline" id="line-90"><code>		Emin  = 1 - Ebias</code></span>
<span class="codeline" id="line-91"><code>		Emax  = Ebias</code></span>
<span class="codeline" id="line-92"><code>	)</code></span>
<span class="codeline" id="line-93"><code></code></span>
<span class="codeline" id="line-94"><code>	// TODO(adonovan): specialize common degenerate cases: 1.0, integers.</code></span>
<span class="codeline" id="line-95"><code>	alen := a.bitLen()</code></span>
<span class="codeline" id="line-96"><code>	if alen == 0 {</code></span>
<span class="codeline" id="line-97"><code>		return 0, true</code></span>
<span class="codeline" id="line-98"><code>	}</code></span>
<span class="codeline" id="line-99"><code>	blen := b.bitLen()</code></span>
<span class="codeline" id="line-100"><code>	if blen == 0 {</code></span>
<span class="codeline" id="line-101"><code>		panic("division by zero")</code></span>
<span class="codeline" id="line-102"><code>	}</code></span>
<span class="codeline" id="line-103"><code></code></span>
<span class="codeline" id="line-104"><code>	// 1. Left-shift A or B such that quotient A/B is in [1&lt;&lt;Msize1, 1&lt;&lt;(Msize2+1)</code></span>
<span class="codeline" id="line-105"><code>	// (Msize2 bits if A &lt; B when they are left-aligned, Msize2+1 bits if A &gt;= B).</code></span>
<span class="codeline" id="line-106"><code>	// This is 2 or 3 more than the float32 mantissa field width of Msize:</code></span>
<span class="codeline" id="line-107"><code>	// - the optional extra bit is shifted away in step 3 below.</code></span>
<span class="codeline" id="line-108"><code>	// - the high-order 1 is omitted in "normal" representation;</code></span>
<span class="codeline" id="line-109"><code>	// - the low-order 1 will be used during rounding then discarded.</code></span>
<span class="codeline" id="line-110"><code>	exp := alen - blen</code></span>
<span class="codeline" id="line-111"><code>	var a2, b2 nat</code></span>
<span class="codeline" id="line-112"><code>	a2 = a2.set(a)</code></span>
<span class="codeline" id="line-113"><code>	b2 = b2.set(b)</code></span>
<span class="codeline" id="line-114"><code>	if shift := Msize2 - exp; shift &gt; 0 {</code></span>
<span class="codeline" id="line-115"><code>		a2 = a2.shl(a2, uint(shift))</code></span>
<span class="codeline" id="line-116"><code>	} else if shift &lt; 0 {</code></span>
<span class="codeline" id="line-117"><code>		b2 = b2.shl(b2, uint(-shift))</code></span>
<span class="codeline" id="line-118"><code>	}</code></span>
<span class="codeline" id="line-119"><code></code></span>
<span class="codeline" id="line-120"><code>	// 2. Compute quotient and remainder (q, r).  NB: due to the</code></span>
<span class="codeline" id="line-121"><code>	// extra shift, the low-order bit of q is logically the</code></span>
<span class="codeline" id="line-122"><code>	// high-order bit of r.</code></span>
<span class="codeline" id="line-123"><code>	var q nat</code></span>
<span class="codeline" id="line-124"><code>	q, r := q.div(a2, a2, b2) // (recycle a2)</code></span>
<span class="codeline" id="line-125"><code>	mantissa := low32(q)</code></span>
<span class="codeline" id="line-126"><code>	haveRem := len(r) &gt; 0 // mantissa&amp;1 &amp;&amp; !haveRem =&gt; remainder is exactly half</code></span>
<span class="codeline" id="line-127"><code></code></span>
<span class="codeline" id="line-128"><code>	// 3. If quotient didn't fit in Msize2 bits, redo division by b2&lt;&lt;1</code></span>
<span class="codeline" id="line-129"><code>	// (in effect---we accomplish this incrementally).</code></span>
<span class="codeline" id="line-130"><code>	if mantissa&gt;&gt;Msize2 == 1 {</code></span>
<span class="codeline" id="line-131"><code>		if mantissa&amp;1 == 1 {</code></span>
<span class="codeline" id="line-132"><code>			haveRem = true</code></span>
<span class="codeline" id="line-133"><code>		}</code></span>
<span class="codeline" id="line-134"><code>		mantissa &gt;&gt;= 1</code></span>
<span class="codeline" id="line-135"><code>		exp++</code></span>
<span class="codeline" id="line-136"><code>	}</code></span>
<span class="codeline" id="line-137"><code>	if mantissa&gt;&gt;Msize1 != 1 {</code></span>
<span class="codeline" id="line-138"><code>		panic(fmt.Sprintf("expected exactly %d bits of result", Msize2))</code></span>
<span class="codeline" id="line-139"><code>	}</code></span>
<span class="codeline" id="line-140"><code></code></span>
<span class="codeline" id="line-141"><code>	// 4. Rounding.</code></span>
<span class="codeline" id="line-142"><code>	if Emin-Msize &lt;= exp &amp;&amp; exp &lt;= Emin {</code></span>
<span class="codeline" id="line-143"><code>		// Denormal case; lose 'shift' bits of precision.</code></span>
<span class="codeline" id="line-144"><code>		shift := uint(Emin - (exp - 1)) // [1..Esize1)</code></span>
<span class="codeline" id="line-145"><code>		lostbits := mantissa &amp; (1&lt;&lt;shift - 1)</code></span>
<span class="codeline" id="line-146"><code>		haveRem = haveRem || lostbits != 0</code></span>
<span class="codeline" id="line-147"><code>		mantissa &gt;&gt;= shift</code></span>
<span class="codeline" id="line-148"><code>		exp = 2 - Ebias // == exp + shift</code></span>
<span class="codeline" id="line-149"><code>	}</code></span>
<span class="codeline" id="line-150"><code>	// Round q using round-half-to-even.</code></span>
<span class="codeline" id="line-151"><code>	exact = !haveRem</code></span>
<span class="codeline" id="line-152"><code>	if mantissa&amp;1 != 0 {</code></span>
<span class="codeline" id="line-153"><code>		exact = false</code></span>
<span class="codeline" id="line-154"><code>		if haveRem || mantissa&amp;2 != 0 {</code></span>
<span class="codeline" id="line-155"><code>			if mantissa++; mantissa &gt;= 1&lt;&lt;Msize2 {</code></span>
<span class="codeline" id="line-156"><code>				// Complete rollover 11...1 =&gt; 100...0, so shift is safe</code></span>
<span class="codeline" id="line-157"><code>				mantissa &gt;&gt;= 1</code></span>
<span class="codeline" id="line-158"><code>				exp++</code></span>
<span class="codeline" id="line-159"><code>			}</code></span>
<span class="codeline" id="line-160"><code>		}</code></span>
<span class="codeline" id="line-161"><code>	}</code></span>
<span class="codeline" id="line-162"><code>	mantissa &gt;&gt;= 1 // discard rounding bit.  Mantissa now scaled by 1&lt;&lt;Msize1.</code></span>
<span class="codeline" id="line-163"><code></code></span>
<span class="codeline" id="line-164"><code>	f = float32(math.Ldexp(float64(mantissa), exp-Msize1))</code></span>
<span class="codeline" id="line-165"><code>	if math.IsInf(float64(f), 0) {</code></span>
<span class="codeline" id="line-166"><code>		exact = false</code></span>
<span class="codeline" id="line-167"><code>	}</code></span>
<span class="codeline" id="line-168"><code>	return</code></span>
<span class="codeline" id="line-169"><code>}</code></span>
<span class="codeline" id="line-170"><code></code></span>
<span class="codeline" id="line-171"><code>// quotToFloat64 returns the non-negative float64 value</code></span>
<span class="codeline" id="line-172"><code>// nearest to the quotient a/b, using round-to-even in</code></span>
<span class="codeline" id="line-173"><code>// halfway cases. It does not mutate its arguments.</code></span>
<span class="codeline" id="line-174"><code>// Preconditions: b is non-zero; a and b have no common factors.</code></span>
<span class="codeline" id="line-175"><code>func quotToFloat64(a, b nat) (f float64, exact bool) {</code></span>
<span class="codeline" id="line-176"><code>	const (</code></span>
<span class="codeline" id="line-177"><code>		// float size in bits</code></span>
<span class="codeline" id="line-178"><code>		Fsize = 64</code></span>
<span class="codeline" id="line-179"><code></code></span>
<span class="codeline" id="line-180"><code>		// mantissa</code></span>
<span class="codeline" id="line-181"><code>		Msize  = 52</code></span>
<span class="codeline" id="line-182"><code>		Msize1 = Msize + 1 // incl. implicit 1</code></span>
<span class="codeline" id="line-183"><code>		Msize2 = Msize1 + 1</code></span>
<span class="codeline" id="line-184"><code></code></span>
<span class="codeline" id="line-185"><code>		// exponent</code></span>
<span class="codeline" id="line-186"><code>		Esize = Fsize - Msize1</code></span>
<span class="codeline" id="line-187"><code>		Ebias = 1&lt;&lt;(Esize-1) - 1</code></span>
<span class="codeline" id="line-188"><code>		Emin  = 1 - Ebias</code></span>
<span class="codeline" id="line-189"><code>		Emax  = Ebias</code></span>
<span class="codeline" id="line-190"><code>	)</code></span>
<span class="codeline" id="line-191"><code></code></span>
<span class="codeline" id="line-192"><code>	// TODO(adonovan): specialize common degenerate cases: 1.0, integers.</code></span>
<span class="codeline" id="line-193"><code>	alen := a.bitLen()</code></span>
<span class="codeline" id="line-194"><code>	if alen == 0 {</code></span>
<span class="codeline" id="line-195"><code>		return 0, true</code></span>
<span class="codeline" id="line-196"><code>	}</code></span>
<span class="codeline" id="line-197"><code>	blen := b.bitLen()</code></span>
<span class="codeline" id="line-198"><code>	if blen == 0 {</code></span>
<span class="codeline" id="line-199"><code>		panic("division by zero")</code></span>
<span class="codeline" id="line-200"><code>	}</code></span>
<span class="codeline" id="line-201"><code></code></span>
<span class="codeline" id="line-202"><code>	// 1. Left-shift A or B such that quotient A/B is in [1&lt;&lt;Msize1, 1&lt;&lt;(Msize2+1)</code></span>
<span class="codeline" id="line-203"><code>	// (Msize2 bits if A &lt; B when they are left-aligned, Msize2+1 bits if A &gt;= B).</code></span>
<span class="codeline" id="line-204"><code>	// This is 2 or 3 more than the float64 mantissa field width of Msize:</code></span>
<span class="codeline" id="line-205"><code>	// - the optional extra bit is shifted away in step 3 below.</code></span>
<span class="codeline" id="line-206"><code>	// - the high-order 1 is omitted in "normal" representation;</code></span>
<span class="codeline" id="line-207"><code>	// - the low-order 1 will be used during rounding then discarded.</code></span>
<span class="codeline" id="line-208"><code>	exp := alen - blen</code></span>
<span class="codeline" id="line-209"><code>	var a2, b2 nat</code></span>
<span class="codeline" id="line-210"><code>	a2 = a2.set(a)</code></span>
<span class="codeline" id="line-211"><code>	b2 = b2.set(b)</code></span>
<span class="codeline" id="line-212"><code>	if shift := Msize2 - exp; shift &gt; 0 {</code></span>
<span class="codeline" id="line-213"><code>		a2 = a2.shl(a2, uint(shift))</code></span>
<span class="codeline" id="line-214"><code>	} else if shift &lt; 0 {</code></span>
<span class="codeline" id="line-215"><code>		b2 = b2.shl(b2, uint(-shift))</code></span>
<span class="codeline" id="line-216"><code>	}</code></span>
<span class="codeline" id="line-217"><code></code></span>
<span class="codeline" id="line-218"><code>	// 2. Compute quotient and remainder (q, r).  NB: due to the</code></span>
<span class="codeline" id="line-219"><code>	// extra shift, the low-order bit of q is logically the</code></span>
<span class="codeline" id="line-220"><code>	// high-order bit of r.</code></span>
<span class="codeline" id="line-221"><code>	var q nat</code></span>
<span class="codeline" id="line-222"><code>	q, r := q.div(a2, a2, b2) // (recycle a2)</code></span>
<span class="codeline" id="line-223"><code>	mantissa := low64(q)</code></span>
<span class="codeline" id="line-224"><code>	haveRem := len(r) &gt; 0 // mantissa&amp;1 &amp;&amp; !haveRem =&gt; remainder is exactly half</code></span>
<span class="codeline" id="line-225"><code></code></span>
<span class="codeline" id="line-226"><code>	// 3. If quotient didn't fit in Msize2 bits, redo division by b2&lt;&lt;1</code></span>
<span class="codeline" id="line-227"><code>	// (in effect---we accomplish this incrementally).</code></span>
<span class="codeline" id="line-228"><code>	if mantissa&gt;&gt;Msize2 == 1 {</code></span>
<span class="codeline" id="line-229"><code>		if mantissa&amp;1 == 1 {</code></span>
<span class="codeline" id="line-230"><code>			haveRem = true</code></span>
<span class="codeline" id="line-231"><code>		}</code></span>
<span class="codeline" id="line-232"><code>		mantissa &gt;&gt;= 1</code></span>
<span class="codeline" id="line-233"><code>		exp++</code></span>
<span class="codeline" id="line-234"><code>	}</code></span>
<span class="codeline" id="line-235"><code>	if mantissa&gt;&gt;Msize1 != 1 {</code></span>
<span class="codeline" id="line-236"><code>		panic(fmt.Sprintf("expected exactly %d bits of result", Msize2))</code></span>
<span class="codeline" id="line-237"><code>	}</code></span>
<span class="codeline" id="line-238"><code></code></span>
<span class="codeline" id="line-239"><code>	// 4. Rounding.</code></span>
<span class="codeline" id="line-240"><code>	if Emin-Msize &lt;= exp &amp;&amp; exp &lt;= Emin {</code></span>
<span class="codeline" id="line-241"><code>		// Denormal case; lose 'shift' bits of precision.</code></span>
<span class="codeline" id="line-242"><code>		shift := uint(Emin - (exp - 1)) // [1..Esize1)</code></span>
<span class="codeline" id="line-243"><code>		lostbits := mantissa &amp; (1&lt;&lt;shift - 1)</code></span>
<span class="codeline" id="line-244"><code>		haveRem = haveRem || lostbits != 0</code></span>
<span class="codeline" id="line-245"><code>		mantissa &gt;&gt;= shift</code></span>
<span class="codeline" id="line-246"><code>		exp = 2 - Ebias // == exp + shift</code></span>
<span class="codeline" id="line-247"><code>	}</code></span>
<span class="codeline" id="line-248"><code>	// Round q using round-half-to-even.</code></span>
<span class="codeline" id="line-249"><code>	exact = !haveRem</code></span>
<span class="codeline" id="line-250"><code>	if mantissa&amp;1 != 0 {</code></span>
<span class="codeline" id="line-251"><code>		exact = false</code></span>
<span class="codeline" id="line-252"><code>		if haveRem || mantissa&amp;2 != 0 {</code></span>
<span class="codeline" id="line-253"><code>			if mantissa++; mantissa &gt;= 1&lt;&lt;Msize2 {</code></span>
<span class="codeline" id="line-254"><code>				// Complete rollover 11...1 =&gt; 100...0, so shift is safe</code></span>
<span class="codeline" id="line-255"><code>				mantissa &gt;&gt;= 1</code></span>
<span class="codeline" id="line-256"><code>				exp++</code></span>
<span class="codeline" id="line-257"><code>			}</code></span>
<span class="codeline" id="line-258"><code>		}</code></span>
<span class="codeline" id="line-259"><code>	}</code></span>
<span class="codeline" id="line-260"><code>	mantissa &gt;&gt;= 1 // discard rounding bit.  Mantissa now scaled by 1&lt;&lt;Msize1.</code></span>
<span class="codeline" id="line-261"><code></code></span>
<span class="codeline" id="line-262"><code>	f = math.Ldexp(float64(mantissa), exp-Msize1)</code></span>
<span class="codeline" id="line-263"><code>	if math.IsInf(f, 0) {</code></span>
<span class="codeline" id="line-264"><code>		exact = false</code></span>
<span class="codeline" id="line-265"><code>	}</code></span>
<span class="codeline" id="line-266"><code>	return</code></span>
<span class="codeline" id="line-267"><code>}</code></span>
<span class="codeline" id="line-268"><code></code></span>
<span class="codeline" id="line-269"><code>// Float32 returns the nearest float32 value for x and a bool indicating</code></span>
<span class="codeline" id="line-270"><code>// whether f represents x exactly. If the magnitude of x is too large to</code></span>
<span class="codeline" id="line-271"><code>// be represented by a float32, f is an infinity and exact is false.</code></span>
<span class="codeline" id="line-272"><code>// The sign of f always matches the sign of x, even if f == 0.</code></span>
<span class="codeline" id="line-273"><code>func (x *Rat) Float32() (f float32, exact bool) {</code></span>
<span class="codeline" id="line-274"><code>	b := x.b.abs</code></span>
<span class="codeline" id="line-275"><code>	if len(b) == 0 {</code></span>
<span class="codeline" id="line-276"><code>		b = natOne</code></span>
<span class="codeline" id="line-277"><code>	}</code></span>
<span class="codeline" id="line-278"><code>	f, exact = quotToFloat32(x.a.abs, b)</code></span>
<span class="codeline" id="line-279"><code>	if x.a.neg {</code></span>
<span class="codeline" id="line-280"><code>		f = -f</code></span>
<span class="codeline" id="line-281"><code>	}</code></span>
<span class="codeline" id="line-282"><code>	return</code></span>
<span class="codeline" id="line-283"><code>}</code></span>
<span class="codeline" id="line-284"><code></code></span>
<span class="codeline" id="line-285"><code>// Float64 returns the nearest float64 value for x and a bool indicating</code></span>
<span class="codeline" id="line-286"><code>// whether f represents x exactly. If the magnitude of x is too large to</code></span>
<span class="codeline" id="line-287"><code>// be represented by a float64, f is an infinity and exact is false.</code></span>
<span class="codeline" id="line-288"><code>// The sign of f always matches the sign of x, even if f == 0.</code></span>
<span class="codeline" id="line-289"><code>func (x *Rat) Float64() (f float64, exact bool) {</code></span>
<span class="codeline" id="line-290"><code>	b := x.b.abs</code></span>
<span class="codeline" id="line-291"><code>	if len(b) == 0 {</code></span>
<span class="codeline" id="line-292"><code>		b = natOne</code></span>
<span class="codeline" id="line-293"><code>	}</code></span>
<span class="codeline" id="line-294"><code>	f, exact = quotToFloat64(x.a.abs, b)</code></span>
<span class="codeline" id="line-295"><code>	if x.a.neg {</code></span>
<span class="codeline" id="line-296"><code>		f = -f</code></span>
<span class="codeline" id="line-297"><code>	}</code></span>
<span class="codeline" id="line-298"><code>	return</code></span>
<span class="codeline" id="line-299"><code>}</code></span>
<span class="codeline" id="line-300"><code></code></span>
<span class="codeline" id="line-301"><code>// SetFrac sets z to a/b and returns z.</code></span>
<span class="codeline" id="line-302"><code>// If b == 0, SetFrac panics.</code></span>
<span class="codeline" id="line-303"><code>func (z *Rat) SetFrac(a, b *Int) *Rat {</code></span>
<span class="codeline" id="line-304"><code>	z.a.neg = a.neg != b.neg</code></span>
<span class="codeline" id="line-305"><code>	babs := b.abs</code></span>
<span class="codeline" id="line-306"><code>	if len(babs) == 0 {</code></span>
<span class="codeline" id="line-307"><code>		panic("division by zero")</code></span>
<span class="codeline" id="line-308"><code>	}</code></span>
<span class="codeline" id="line-309"><code>	if &amp;z.a == b || alias(z.a.abs, babs) {</code></span>
<span class="codeline" id="line-310"><code>		babs = nat(nil).set(babs) // make a copy</code></span>
<span class="codeline" id="line-311"><code>	}</code></span>
<span class="codeline" id="line-312"><code>	z.a.abs = z.a.abs.set(a.abs)</code></span>
<span class="codeline" id="line-313"><code>	z.b.abs = z.b.abs.set(babs)</code></span>
<span class="codeline" id="line-314"><code>	return z.norm()</code></span>
<span class="codeline" id="line-315"><code>}</code></span>
<span class="codeline" id="line-316"><code></code></span>
<span class="codeline" id="line-317"><code>// SetFrac64 sets z to a/b and returns z.</code></span>
<span class="codeline" id="line-318"><code>// If b == 0, SetFrac64 panics.</code></span>
<span class="codeline" id="line-319"><code>func (z *Rat) SetFrac64(a, b int64) *Rat {</code></span>
<span class="codeline" id="line-320"><code>	if b == 0 {</code></span>
<span class="codeline" id="line-321"><code>		panic("division by zero")</code></span>
<span class="codeline" id="line-322"><code>	}</code></span>
<span class="codeline" id="line-323"><code>	z.a.SetInt64(a)</code></span>
<span class="codeline" id="line-324"><code>	if b &lt; 0 {</code></span>
<span class="codeline" id="line-325"><code>		b = -b</code></span>
<span class="codeline" id="line-326"><code>		z.a.neg = !z.a.neg</code></span>
<span class="codeline" id="line-327"><code>	}</code></span>
<span class="codeline" id="line-328"><code>	z.b.abs = z.b.abs.setUint64(uint64(b))</code></span>
<span class="codeline" id="line-329"><code>	return z.norm()</code></span>
<span class="codeline" id="line-330"><code>}</code></span>
<span class="codeline" id="line-331"><code></code></span>
<span class="codeline" id="line-332"><code>// SetInt sets z to x (by making a copy of x) and returns z.</code></span>
<span class="codeline" id="line-333"><code>func (z *Rat) SetInt(x *Int) *Rat {</code></span>
<span class="codeline" id="line-334"><code>	z.a.Set(x)</code></span>
<span class="codeline" id="line-335"><code>	z.b.abs = z.b.abs.setWord(1)</code></span>
<span class="codeline" id="line-336"><code>	return z</code></span>
<span class="codeline" id="line-337"><code>}</code></span>
<span class="codeline" id="line-338"><code></code></span>
<span class="codeline" id="line-339"><code>// SetInt64 sets z to x and returns z.</code></span>
<span class="codeline" id="line-340"><code>func (z *Rat) SetInt64(x int64) *Rat {</code></span>
<span class="codeline" id="line-341"><code>	z.a.SetInt64(x)</code></span>
<span class="codeline" id="line-342"><code>	z.b.abs = z.b.abs.setWord(1)</code></span>
<span class="codeline" id="line-343"><code>	return z</code></span>
<span class="codeline" id="line-344"><code>}</code></span>
<span class="codeline" id="line-345"><code></code></span>
<span class="codeline" id="line-346"><code>// SetUint64 sets z to x and returns z.</code></span>
<span class="codeline" id="line-347"><code>func (z *Rat) SetUint64(x uint64) *Rat {</code></span>
<span class="codeline" id="line-348"><code>	z.a.SetUint64(x)</code></span>
<span class="codeline" id="line-349"><code>	z.b.abs = z.b.abs.setWord(1)</code></span>
<span class="codeline" id="line-350"><code>	return z</code></span>
<span class="codeline" id="line-351"><code>}</code></span>
<span class="codeline" id="line-352"><code></code></span>
<span class="codeline" id="line-353"><code>// Set sets z to x (by making a copy of x) and returns z.</code></span>
<span class="codeline" id="line-354"><code>func (z *Rat) Set(x *Rat) *Rat {</code></span>
<span class="codeline" id="line-355"><code>	if z != x {</code></span>
<span class="codeline" id="line-356"><code>		z.a.Set(&amp;x.a)</code></span>
<span class="codeline" id="line-357"><code>		z.b.Set(&amp;x.b)</code></span>
<span class="codeline" id="line-358"><code>	}</code></span>
<span class="codeline" id="line-359"><code>	if len(z.b.abs) == 0 {</code></span>
<span class="codeline" id="line-360"><code>		z.b.abs = z.b.abs.setWord(1)</code></span>
<span class="codeline" id="line-361"><code>	}</code></span>
<span class="codeline" id="line-362"><code>	return z</code></span>
<span class="codeline" id="line-363"><code>}</code></span>
<span class="codeline" id="line-364"><code></code></span>
<span class="codeline" id="line-365"><code>// Abs sets z to |x| (the absolute value of x) and returns z.</code></span>
<span class="codeline" id="line-366"><code>func (z *Rat) Abs(x *Rat) *Rat {</code></span>
<span class="codeline" id="line-367"><code>	z.Set(x)</code></span>
<span class="codeline" id="line-368"><code>	z.a.neg = false</code></span>
<span class="codeline" id="line-369"><code>	return z</code></span>
<span class="codeline" id="line-370"><code>}</code></span>
<span class="codeline" id="line-371"><code></code></span>
<span class="codeline" id="line-372"><code>// Neg sets z to -x and returns z.</code></span>
<span class="codeline" id="line-373"><code>func (z *Rat) Neg(x *Rat) *Rat {</code></span>
<span class="codeline" id="line-374"><code>	z.Set(x)</code></span>
<span class="codeline" id="line-375"><code>	z.a.neg = len(z.a.abs) &gt; 0 &amp;&amp; !z.a.neg // 0 has no sign</code></span>
<span class="codeline" id="line-376"><code>	return z</code></span>
<span class="codeline" id="line-377"><code>}</code></span>
<span class="codeline" id="line-378"><code></code></span>
<span class="codeline" id="line-379"><code>// Inv sets z to 1/x and returns z.</code></span>
<span class="codeline" id="line-380"><code>// If x == 0, Inv panics.</code></span>
<span class="codeline" id="line-381"><code>func (z *Rat) Inv(x *Rat) *Rat {</code></span>
<span class="codeline" id="line-382"><code>	if len(x.a.abs) == 0 {</code></span>
<span class="codeline" id="line-383"><code>		panic("division by zero")</code></span>
<span class="codeline" id="line-384"><code>	}</code></span>
<span class="codeline" id="line-385"><code>	z.Set(x)</code></span>
<span class="codeline" id="line-386"><code>	z.a.abs, z.b.abs = z.b.abs, z.a.abs</code></span>
<span class="codeline" id="line-387"><code>	return z</code></span>
<span class="codeline" id="line-388"><code>}</code></span>
<span class="codeline" id="line-389"><code></code></span>
<span class="codeline" id="line-390"><code>// Sign returns:</code></span>
<span class="codeline" id="line-391"><code>//</code></span>
<span class="codeline" id="line-392"><code>//	-1 if x &lt;  0</code></span>
<span class="codeline" id="line-393"><code>//	 0 if x == 0</code></span>
<span class="codeline" id="line-394"><code>//	+1 if x &gt;  0</code></span>
<span class="codeline" id="line-395"><code>//</code></span>
<span class="codeline" id="line-396"><code>func (x *Rat) Sign() int {</code></span>
<span class="codeline" id="line-397"><code>	return x.a.Sign()</code></span>
<span class="codeline" id="line-398"><code>}</code></span>
<span class="codeline" id="line-399"><code></code></span>
<span class="codeline" id="line-400"><code>// IsInt reports whether the denominator of x is 1.</code></span>
<span class="codeline" id="line-401"><code>func (x *Rat) IsInt() bool {</code></span>
<span class="codeline" id="line-402"><code>	return len(x.b.abs) == 0 || x.b.abs.cmp(natOne) == 0</code></span>
<span class="codeline" id="line-403"><code>}</code></span>
<span class="codeline" id="line-404"><code></code></span>
<span class="codeline" id="line-405"><code>// Num returns the numerator of x; it may be &lt;= 0.</code></span>
<span class="codeline" id="line-406"><code>// The result is a reference to x's numerator; it</code></span>
<span class="codeline" id="line-407"><code>// may change if a new value is assigned to x, and vice versa.</code></span>
<span class="codeline" id="line-408"><code>// The sign of the numerator corresponds to the sign of x.</code></span>
<span class="codeline" id="line-409"><code>func (x *Rat) Num() *Int {</code></span>
<span class="codeline" id="line-410"><code>	return &amp;x.a</code></span>
<span class="codeline" id="line-411"><code>}</code></span>
<span class="codeline" id="line-412"><code></code></span>
<span class="codeline" id="line-413"><code>// Denom returns the denominator of x; it is always &gt; 0.</code></span>
<span class="codeline" id="line-414"><code>// The result is a reference to x's denominator, unless</code></span>
<span class="codeline" id="line-415"><code>// x is an uninitialized (zero value) Rat, in which case</code></span>
<span class="codeline" id="line-416"><code>// the result is a new Int of value 1. (To initialize x,</code></span>
<span class="codeline" id="line-417"><code>// any operation that sets x will do, including x.Set(x).)</code></span>
<span class="codeline" id="line-418"><code>// If the result is a reference to x's denominator it</code></span>
<span class="codeline" id="line-419"><code>// may change if a new value is assigned to x, and vice versa.</code></span>
<span class="codeline" id="line-420"><code>func (x *Rat) Denom() *Int {</code></span>
<span class="codeline" id="line-421"><code>	x.b.neg = false // the result is always &gt;= 0</code></span>
<span class="codeline" id="line-422"><code>	if len(x.b.abs) == 0 {</code></span>
<span class="codeline" id="line-423"><code>		// Note: If this proves problematic, we could</code></span>
<span class="codeline" id="line-424"><code>		//       panic instead and require the Rat to</code></span>
<span class="codeline" id="line-425"><code>		//       be explicitly initialized.</code></span>
<span class="codeline" id="line-426"><code>		return &amp;Int{abs: nat{1}}</code></span>
<span class="codeline" id="line-427"><code>	}</code></span>
<span class="codeline" id="line-428"><code>	return &amp;x.b</code></span>
<span class="codeline" id="line-429"><code>}</code></span>
<span class="codeline" id="line-430"><code></code></span>
<span class="codeline" id="line-431"><code>func (z *Rat) norm() *Rat {</code></span>
<span class="codeline" id="line-432"><code>	switch {</code></span>
<span class="codeline" id="line-433"><code>	case len(z.a.abs) == 0:</code></span>
<span class="codeline" id="line-434"><code>		// z == 0; normalize sign and denominator</code></span>
<span class="codeline" id="line-435"><code>		z.a.neg = false</code></span>
<span class="codeline" id="line-436"><code>		fallthrough</code></span>
<span class="codeline" id="line-437"><code>	case len(z.b.abs) == 0:</code></span>
<span class="codeline" id="line-438"><code>		// z is integer; normalize denominator</code></span>
<span class="codeline" id="line-439"><code>		z.b.abs = z.b.abs.setWord(1)</code></span>
<span class="codeline" id="line-440"><code>	default:</code></span>
<span class="codeline" id="line-441"><code>		// z is fraction; normalize numerator and denominator</code></span>
<span class="codeline" id="line-442"><code>		neg := z.a.neg</code></span>
<span class="codeline" id="line-443"><code>		z.a.neg = false</code></span>
<span class="codeline" id="line-444"><code>		z.b.neg = false</code></span>
<span class="codeline" id="line-445"><code>		if f := NewInt(0).lehmerGCD(nil, nil, &amp;z.a, &amp;z.b); f.Cmp(intOne) != 0 {</code></span>
<span class="codeline" id="line-446"><code>			z.a.abs, _ = z.a.abs.div(nil, z.a.abs, f.abs)</code></span>
<span class="codeline" id="line-447"><code>			z.b.abs, _ = z.b.abs.div(nil, z.b.abs, f.abs)</code></span>
<span class="codeline" id="line-448"><code>		}</code></span>
<span class="codeline" id="line-449"><code>		z.a.neg = neg</code></span>
<span class="codeline" id="line-450"><code>	}</code></span>
<span class="codeline" id="line-451"><code>	return z</code></span>
<span class="codeline" id="line-452"><code>}</code></span>
<span class="codeline" id="line-453"><code></code></span>
<span class="codeline" id="line-454"><code>// mulDenom sets z to the denominator product x*y (by taking into</code></span>
<span class="codeline" id="line-455"><code>// account that 0 values for x or y must be interpreted as 1) and</code></span>
<span class="codeline" id="line-456"><code>// returns z.</code></span>
<span class="codeline" id="line-457"><code>func mulDenom(z, x, y nat) nat {</code></span>
<span class="codeline" id="line-458"><code>	switch {</code></span>
<span class="codeline" id="line-459"><code>	case len(x) == 0 &amp;&amp; len(y) == 0:</code></span>
<span class="codeline" id="line-460"><code>		return z.setWord(1)</code></span>
<span class="codeline" id="line-461"><code>	case len(x) == 0:</code></span>
<span class="codeline" id="line-462"><code>		return z.set(y)</code></span>
<span class="codeline" id="line-463"><code>	case len(y) == 0:</code></span>
<span class="codeline" id="line-464"><code>		return z.set(x)</code></span>
<span class="codeline" id="line-465"><code>	}</code></span>
<span class="codeline" id="line-466"><code>	return z.mul(x, y)</code></span>
<span class="codeline" id="line-467"><code>}</code></span>
<span class="codeline" id="line-468"><code></code></span>
<span class="codeline" id="line-469"><code>// scaleDenom sets z to the product x*f.</code></span>
<span class="codeline" id="line-470"><code>// If f == 0 (zero value of denominator), z is set to (a copy of) x.</code></span>
<span class="codeline" id="line-471"><code>func (z *Int) scaleDenom(x *Int, f nat) {</code></span>
<span class="codeline" id="line-472"><code>	if len(f) == 0 {</code></span>
<span class="codeline" id="line-473"><code>		z.Set(x)</code></span>
<span class="codeline" id="line-474"><code>		return</code></span>
<span class="codeline" id="line-475"><code>	}</code></span>
<span class="codeline" id="line-476"><code>	z.abs = z.abs.mul(x.abs, f)</code></span>
<span class="codeline" id="line-477"><code>	z.neg = x.neg</code></span>
<span class="codeline" id="line-478"><code>}</code></span>
<span class="codeline" id="line-479"><code></code></span>
<span class="codeline" id="line-480"><code>// Cmp compares x and y and returns:</code></span>
<span class="codeline" id="line-481"><code>//</code></span>
<span class="codeline" id="line-482"><code>//   -1 if x &lt;  y</code></span>
<span class="codeline" id="line-483"><code>//    0 if x == y</code></span>
<span class="codeline" id="line-484"><code>//   +1 if x &gt;  y</code></span>
<span class="codeline" id="line-485"><code>//</code></span>
<span class="codeline" id="line-486"><code>func (x *Rat) Cmp(y *Rat) int {</code></span>
<span class="codeline" id="line-487"><code>	var a, b Int</code></span>
<span class="codeline" id="line-488"><code>	a.scaleDenom(&amp;x.a, y.b.abs)</code></span>
<span class="codeline" id="line-489"><code>	b.scaleDenom(&amp;y.a, x.b.abs)</code></span>
<span class="codeline" id="line-490"><code>	return a.Cmp(&amp;b)</code></span>
<span class="codeline" id="line-491"><code>}</code></span>
<span class="codeline" id="line-492"><code></code></span>
<span class="codeline" id="line-493"><code>// Add sets z to the sum x+y and returns z.</code></span>
<span class="codeline" id="line-494"><code>func (z *Rat) Add(x, y *Rat) *Rat {</code></span>
<span class="codeline" id="line-495"><code>	var a1, a2 Int</code></span>
<span class="codeline" id="line-496"><code>	a1.scaleDenom(&amp;x.a, y.b.abs)</code></span>
<span class="codeline" id="line-497"><code>	a2.scaleDenom(&amp;y.a, x.b.abs)</code></span>
<span class="codeline" id="line-498"><code>	z.a.Add(&amp;a1, &amp;a2)</code></span>
<span class="codeline" id="line-499"><code>	z.b.abs = mulDenom(z.b.abs, x.b.abs, y.b.abs)</code></span>
<span class="codeline" id="line-500"><code>	return z.norm()</code></span>
<span class="codeline" id="line-501"><code>}</code></span>
<span class="codeline" id="line-502"><code></code></span>
<span class="codeline" id="line-503"><code>// Sub sets z to the difference x-y and returns z.</code></span>
<span class="codeline" id="line-504"><code>func (z *Rat) Sub(x, y *Rat) *Rat {</code></span>
<span class="codeline" id="line-505"><code>	var a1, a2 Int</code></span>
<span class="codeline" id="line-506"><code>	a1.scaleDenom(&amp;x.a, y.b.abs)</code></span>
<span class="codeline" id="line-507"><code>	a2.scaleDenom(&amp;y.a, x.b.abs)</code></span>
<span class="codeline" id="line-508"><code>	z.a.Sub(&amp;a1, &amp;a2)</code></span>
<span class="codeline" id="line-509"><code>	z.b.abs = mulDenom(z.b.abs, x.b.abs, y.b.abs)</code></span>
<span class="codeline" id="line-510"><code>	return z.norm()</code></span>
<span class="codeline" id="line-511"><code>}</code></span>
<span class="codeline" id="line-512"><code></code></span>
<span class="codeline" id="line-513"><code>// Mul sets z to the product x*y and returns z.</code></span>
<span class="codeline" id="line-514"><code>func (z *Rat) Mul(x, y *Rat) *Rat {</code></span>
<span class="codeline" id="line-515"><code>	if x == y {</code></span>
<span class="codeline" id="line-516"><code>		// a squared Rat is positive and can't be reduced (no need to call norm())</code></span>
<span class="codeline" id="line-517"><code>		z.a.neg = false</code></span>
<span class="codeline" id="line-518"><code>		z.a.abs = z.a.abs.sqr(x.a.abs)</code></span>
<span class="codeline" id="line-519"><code>		if len(x.b.abs) == 0 {</code></span>
<span class="codeline" id="line-520"><code>			z.b.abs = z.b.abs.setWord(1)</code></span>
<span class="codeline" id="line-521"><code>		} else {</code></span>
<span class="codeline" id="line-522"><code>			z.b.abs = z.b.abs.sqr(x.b.abs)</code></span>
<span class="codeline" id="line-523"><code>		}</code></span>
<span class="codeline" id="line-524"><code>		return z</code></span>
<span class="codeline" id="line-525"><code>	}</code></span>
<span class="codeline" id="line-526"><code>	z.a.Mul(&amp;x.a, &amp;y.a)</code></span>
<span class="codeline" id="line-527"><code>	z.b.abs = mulDenom(z.b.abs, x.b.abs, y.b.abs)</code></span>
<span class="codeline" id="line-528"><code>	return z.norm()</code></span>
<span class="codeline" id="line-529"><code>}</code></span>
<span class="codeline" id="line-530"><code></code></span>
<span class="codeline" id="line-531"><code>// Quo sets z to the quotient x/y and returns z.</code></span>
<span class="codeline" id="line-532"><code>// If y == 0, Quo panics.</code></span>
<span class="codeline" id="line-533"><code>func (z *Rat) Quo(x, y *Rat) *Rat {</code></span>
<span class="codeline" id="line-534"><code>	if len(y.a.abs) == 0 {</code></span>
<span class="codeline" id="line-535"><code>		panic("division by zero")</code></span>
<span class="codeline" id="line-536"><code>	}</code></span>
<span class="codeline" id="line-537"><code>	var a, b Int</code></span>
<span class="codeline" id="line-538"><code>	a.scaleDenom(&amp;x.a, y.b.abs)</code></span>
<span class="codeline" id="line-539"><code>	b.scaleDenom(&amp;y.a, x.b.abs)</code></span>
<span class="codeline" id="line-540"><code>	z.a.abs = a.abs</code></span>
<span class="codeline" id="line-541"><code>	z.b.abs = b.abs</code></span>
<span class="codeline" id="line-542"><code>	z.a.neg = a.neg != b.neg</code></span>
<span class="codeline" id="line-543"><code>	return z.norm()</code></span>
<span class="codeline" id="line-544"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.1.6</i>. (GOOS=darwin GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project and developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table
</pre>
</div></body></html>