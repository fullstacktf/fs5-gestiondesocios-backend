<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: auth.go in package github.com/go-sql-driver/mysql</title>
<link href="../../../../css/light-v0.1.6.css" rel="stylesheet">
<script src="../../../../jvs/golds-v0.1.6.js"></script>
<body><div>

<pre id="header"><code><span class="title">Source File</span>
	auth.go

<span class="title">Belonging Package</span>
	<a href="../../../../pkg/github.com/go-sql-driver/mysql.html">github.com/go-sql-driver/mysql</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Go MySQL Driver - A MySQL-Driver for Go's database/sql package</code></span>
<span class="codeline" id="line-2"><code>//</code></span>
<span class="codeline" id="line-3"><code>// Copyright 2018 The Go-MySQL-Driver Authors. All rights reserved.</code></span>
<span class="codeline" id="line-4"><code>//</code></span>
<span class="codeline" id="line-5"><code>// This Source Code Form is subject to the terms of the Mozilla Public</code></span>
<span class="codeline" id="line-6"><code>// License, v. 2.0. If a copy of the MPL was not distributed with this file,</code></span>
<span class="codeline" id="line-7"><code>// You can obtain one at http://mozilla.org/MPL/2.0/.</code></span>
<span class="codeline" id="line-8"><code></code></span>
<span class="codeline" id="line-9"><code>package mysql</code></span>
<span class="codeline" id="line-10"><code></code></span>
<span class="codeline" id="line-11"><code>import (</code></span>
<span class="codeline" id="line-12"><code>	"crypto/rand"</code></span>
<span class="codeline" id="line-13"><code>	"crypto/rsa"</code></span>
<span class="codeline" id="line-14"><code>	"crypto/sha1"</code></span>
<span class="codeline" id="line-15"><code>	"crypto/sha256"</code></span>
<span class="codeline" id="line-16"><code>	"crypto/x509"</code></span>
<span class="codeline" id="line-17"><code>	"encoding/pem"</code></span>
<span class="codeline" id="line-18"><code>	"sync"</code></span>
<span class="codeline" id="line-19"><code>)</code></span>
<span class="codeline" id="line-20"><code></code></span>
<span class="codeline" id="line-21"><code>// server pub keys registry</code></span>
<span class="codeline" id="line-22"><code>var (</code></span>
<span class="codeline" id="line-23"><code>	serverPubKeyLock     sync.RWMutex</code></span>
<span class="codeline" id="line-24"><code>	serverPubKeyRegistry map[string]*rsa.PublicKey</code></span>
<span class="codeline" id="line-25"><code>)</code></span>
<span class="codeline" id="line-26"><code></code></span>
<span class="codeline" id="line-27"><code>// RegisterServerPubKey registers a server RSA public key which can be used to</code></span>
<span class="codeline" id="line-28"><code>// send data in a secure manner to the server without receiving the public key</code></span>
<span class="codeline" id="line-29"><code>// in a potentially insecure way from the server first.</code></span>
<span class="codeline" id="line-30"><code>// Registered keys can afterwards be used adding serverPubKey=&lt;name&gt; to the DSN.</code></span>
<span class="codeline" id="line-31"><code>//</code></span>
<span class="codeline" id="line-32"><code>// Note: The provided rsa.PublicKey instance is exclusively owned by the driver</code></span>
<span class="codeline" id="line-33"><code>// after registering it and may not be modified.</code></span>
<span class="codeline" id="line-34"><code>//</code></span>
<span class="codeline" id="line-35"><code>//  data, err := ioutil.ReadFile("mykey.pem")</code></span>
<span class="codeline" id="line-36"><code>//  if err != nil {</code></span>
<span class="codeline" id="line-37"><code>//  	log.Fatal(err)</code></span>
<span class="codeline" id="line-38"><code>//  }</code></span>
<span class="codeline" id="line-39"><code>//</code></span>
<span class="codeline" id="line-40"><code>//  block, _ := pem.Decode(data)</code></span>
<span class="codeline" id="line-41"><code>//  if block == nil || block.Type != "PUBLIC KEY" {</code></span>
<span class="codeline" id="line-42"><code>//  	log.Fatal("failed to decode PEM block containing public key")</code></span>
<span class="codeline" id="line-43"><code>//  }</code></span>
<span class="codeline" id="line-44"><code>//</code></span>
<span class="codeline" id="line-45"><code>//  pub, err := x509.ParsePKIXPublicKey(block.Bytes)</code></span>
<span class="codeline" id="line-46"><code>//  if err != nil {</code></span>
<span class="codeline" id="line-47"><code>//  	log.Fatal(err)</code></span>
<span class="codeline" id="line-48"><code>//  }</code></span>
<span class="codeline" id="line-49"><code>//</code></span>
<span class="codeline" id="line-50"><code>//  if rsaPubKey, ok := pub.(*rsa.PublicKey); ok {</code></span>
<span class="codeline" id="line-51"><code>//  	mysql.RegisterServerPubKey("mykey", rsaPubKey)</code></span>
<span class="codeline" id="line-52"><code>//  } else {</code></span>
<span class="codeline" id="line-53"><code>//  	log.Fatal("not a RSA public key")</code></span>
<span class="codeline" id="line-54"><code>//  }</code></span>
<span class="codeline" id="line-55"><code>//</code></span>
<span class="codeline" id="line-56"><code>func RegisterServerPubKey(name string, pubKey *rsa.PublicKey) {</code></span>
<span class="codeline" id="line-57"><code>	serverPubKeyLock.Lock()</code></span>
<span class="codeline" id="line-58"><code>	if serverPubKeyRegistry == nil {</code></span>
<span class="codeline" id="line-59"><code>		serverPubKeyRegistry = make(map[string]*rsa.PublicKey)</code></span>
<span class="codeline" id="line-60"><code>	}</code></span>
<span class="codeline" id="line-61"><code></code></span>
<span class="codeline" id="line-62"><code>	serverPubKeyRegistry[name] = pubKey</code></span>
<span class="codeline" id="line-63"><code>	serverPubKeyLock.Unlock()</code></span>
<span class="codeline" id="line-64"><code>}</code></span>
<span class="codeline" id="line-65"><code></code></span>
<span class="codeline" id="line-66"><code>// DeregisterServerPubKey removes the public key registered with the given name.</code></span>
<span class="codeline" id="line-67"><code>func DeregisterServerPubKey(name string) {</code></span>
<span class="codeline" id="line-68"><code>	serverPubKeyLock.Lock()</code></span>
<span class="codeline" id="line-69"><code>	if serverPubKeyRegistry != nil {</code></span>
<span class="codeline" id="line-70"><code>		delete(serverPubKeyRegistry, name)</code></span>
<span class="codeline" id="line-71"><code>	}</code></span>
<span class="codeline" id="line-72"><code>	serverPubKeyLock.Unlock()</code></span>
<span class="codeline" id="line-73"><code>}</code></span>
<span class="codeline" id="line-74"><code></code></span>
<span class="codeline" id="line-75"><code>func getServerPubKey(name string) (pubKey *rsa.PublicKey) {</code></span>
<span class="codeline" id="line-76"><code>	serverPubKeyLock.RLock()</code></span>
<span class="codeline" id="line-77"><code>	if v, ok := serverPubKeyRegistry[name]; ok {</code></span>
<span class="codeline" id="line-78"><code>		pubKey = v</code></span>
<span class="codeline" id="line-79"><code>	}</code></span>
<span class="codeline" id="line-80"><code>	serverPubKeyLock.RUnlock()</code></span>
<span class="codeline" id="line-81"><code>	return</code></span>
<span class="codeline" id="line-82"><code>}</code></span>
<span class="codeline" id="line-83"><code></code></span>
<span class="codeline" id="line-84"><code>// Hash password using pre 4.1 (old password) method</code></span>
<span class="codeline" id="line-85"><code>// https://github.com/atcurtis/mariadb/blob/master/mysys/my_rnd.c</code></span>
<span class="codeline" id="line-86"><code>type myRnd struct {</code></span>
<span class="codeline" id="line-87"><code>	seed1, seed2 uint32</code></span>
<span class="codeline" id="line-88"><code>}</code></span>
<span class="codeline" id="line-89"><code></code></span>
<span class="codeline" id="line-90"><code>const myRndMaxVal = 0x3FFFFFFF</code></span>
<span class="codeline" id="line-91"><code></code></span>
<span class="codeline" id="line-92"><code>// Pseudo random number generator</code></span>
<span class="codeline" id="line-93"><code>func newMyRnd(seed1, seed2 uint32) *myRnd {</code></span>
<span class="codeline" id="line-94"><code>	return &amp;myRnd{</code></span>
<span class="codeline" id="line-95"><code>		seed1: seed1 % myRndMaxVal,</code></span>
<span class="codeline" id="line-96"><code>		seed2: seed2 % myRndMaxVal,</code></span>
<span class="codeline" id="line-97"><code>	}</code></span>
<span class="codeline" id="line-98"><code>}</code></span>
<span class="codeline" id="line-99"><code></code></span>
<span class="codeline" id="line-100"><code>// Tested to be equivalent to MariaDB's floating point variant</code></span>
<span class="codeline" id="line-101"><code>// http://play.golang.org/p/QHvhd4qved</code></span>
<span class="codeline" id="line-102"><code>// http://play.golang.org/p/RG0q4ElWDx</code></span>
<span class="codeline" id="line-103"><code>func (r *myRnd) NextByte() byte {</code></span>
<span class="codeline" id="line-104"><code>	r.seed1 = (r.seed1*3 + r.seed2) % myRndMaxVal</code></span>
<span class="codeline" id="line-105"><code>	r.seed2 = (r.seed1 + r.seed2 + 33) % myRndMaxVal</code></span>
<span class="codeline" id="line-106"><code></code></span>
<span class="codeline" id="line-107"><code>	return byte(uint64(r.seed1) * 31 / myRndMaxVal)</code></span>
<span class="codeline" id="line-108"><code>}</code></span>
<span class="codeline" id="line-109"><code></code></span>
<span class="codeline" id="line-110"><code>// Generate binary hash from byte string using insecure pre 4.1 method</code></span>
<span class="codeline" id="line-111"><code>func pwHash(password []byte) (result [2]uint32) {</code></span>
<span class="codeline" id="line-112"><code>	var add uint32 = 7</code></span>
<span class="codeline" id="line-113"><code>	var tmp uint32</code></span>
<span class="codeline" id="line-114"><code></code></span>
<span class="codeline" id="line-115"><code>	result[0] = 1345345333</code></span>
<span class="codeline" id="line-116"><code>	result[1] = 0x12345671</code></span>
<span class="codeline" id="line-117"><code></code></span>
<span class="codeline" id="line-118"><code>	for _, c := range password {</code></span>
<span class="codeline" id="line-119"><code>		// skip spaces and tabs in password</code></span>
<span class="codeline" id="line-120"><code>		if c == ' ' || c == '\t' {</code></span>
<span class="codeline" id="line-121"><code>			continue</code></span>
<span class="codeline" id="line-122"><code>		}</code></span>
<span class="codeline" id="line-123"><code></code></span>
<span class="codeline" id="line-124"><code>		tmp = uint32(c)</code></span>
<span class="codeline" id="line-125"><code>		result[0] ^= (((result[0] &amp; 63) + add) * tmp) + (result[0] &lt;&lt; 8)</code></span>
<span class="codeline" id="line-126"><code>		result[1] += (result[1] &lt;&lt; 8) ^ result[0]</code></span>
<span class="codeline" id="line-127"><code>		add += tmp</code></span>
<span class="codeline" id="line-128"><code>	}</code></span>
<span class="codeline" id="line-129"><code></code></span>
<span class="codeline" id="line-130"><code>	// Remove sign bit (1&lt;&lt;31)-1)</code></span>
<span class="codeline" id="line-131"><code>	result[0] &amp;= 0x7FFFFFFF</code></span>
<span class="codeline" id="line-132"><code>	result[1] &amp;= 0x7FFFFFFF</code></span>
<span class="codeline" id="line-133"><code></code></span>
<span class="codeline" id="line-134"><code>	return</code></span>
<span class="codeline" id="line-135"><code>}</code></span>
<span class="codeline" id="line-136"><code></code></span>
<span class="codeline" id="line-137"><code>// Hash password using insecure pre 4.1 method</code></span>
<span class="codeline" id="line-138"><code>func scrambleOldPassword(scramble []byte, password string) []byte {</code></span>
<span class="codeline" id="line-139"><code>	if len(password) == 0 {</code></span>
<span class="codeline" id="line-140"><code>		return nil</code></span>
<span class="codeline" id="line-141"><code>	}</code></span>
<span class="codeline" id="line-142"><code></code></span>
<span class="codeline" id="line-143"><code>	scramble = scramble[:8]</code></span>
<span class="codeline" id="line-144"><code></code></span>
<span class="codeline" id="line-145"><code>	hashPw := pwHash([]byte(password))</code></span>
<span class="codeline" id="line-146"><code>	hashSc := pwHash(scramble)</code></span>
<span class="codeline" id="line-147"><code></code></span>
<span class="codeline" id="line-148"><code>	r := newMyRnd(hashPw[0]^hashSc[0], hashPw[1]^hashSc[1])</code></span>
<span class="codeline" id="line-149"><code></code></span>
<span class="codeline" id="line-150"><code>	var out [8]byte</code></span>
<span class="codeline" id="line-151"><code>	for i := range out {</code></span>
<span class="codeline" id="line-152"><code>		out[i] = r.NextByte() + 64</code></span>
<span class="codeline" id="line-153"><code>	}</code></span>
<span class="codeline" id="line-154"><code></code></span>
<span class="codeline" id="line-155"><code>	mask := r.NextByte()</code></span>
<span class="codeline" id="line-156"><code>	for i := range out {</code></span>
<span class="codeline" id="line-157"><code>		out[i] ^= mask</code></span>
<span class="codeline" id="line-158"><code>	}</code></span>
<span class="codeline" id="line-159"><code></code></span>
<span class="codeline" id="line-160"><code>	return out[:]</code></span>
<span class="codeline" id="line-161"><code>}</code></span>
<span class="codeline" id="line-162"><code></code></span>
<span class="codeline" id="line-163"><code>// Hash password using 4.1+ method (SHA1)</code></span>
<span class="codeline" id="line-164"><code>func scramblePassword(scramble []byte, password string) []byte {</code></span>
<span class="codeline" id="line-165"><code>	if len(password) == 0 {</code></span>
<span class="codeline" id="line-166"><code>		return nil</code></span>
<span class="codeline" id="line-167"><code>	}</code></span>
<span class="codeline" id="line-168"><code></code></span>
<span class="codeline" id="line-169"><code>	// stage1Hash = SHA1(password)</code></span>
<span class="codeline" id="line-170"><code>	crypt := sha1.New()</code></span>
<span class="codeline" id="line-171"><code>	crypt.Write([]byte(password))</code></span>
<span class="codeline" id="line-172"><code>	stage1 := crypt.Sum(nil)</code></span>
<span class="codeline" id="line-173"><code></code></span>
<span class="codeline" id="line-174"><code>	// scrambleHash = SHA1(scramble + SHA1(stage1Hash))</code></span>
<span class="codeline" id="line-175"><code>	// inner Hash</code></span>
<span class="codeline" id="line-176"><code>	crypt.Reset()</code></span>
<span class="codeline" id="line-177"><code>	crypt.Write(stage1)</code></span>
<span class="codeline" id="line-178"><code>	hash := crypt.Sum(nil)</code></span>
<span class="codeline" id="line-179"><code></code></span>
<span class="codeline" id="line-180"><code>	// outer Hash</code></span>
<span class="codeline" id="line-181"><code>	crypt.Reset()</code></span>
<span class="codeline" id="line-182"><code>	crypt.Write(scramble)</code></span>
<span class="codeline" id="line-183"><code>	crypt.Write(hash)</code></span>
<span class="codeline" id="line-184"><code>	scramble = crypt.Sum(nil)</code></span>
<span class="codeline" id="line-185"><code></code></span>
<span class="codeline" id="line-186"><code>	// token = scrambleHash XOR stage1Hash</code></span>
<span class="codeline" id="line-187"><code>	for i := range scramble {</code></span>
<span class="codeline" id="line-188"><code>		scramble[i] ^= stage1[i]</code></span>
<span class="codeline" id="line-189"><code>	}</code></span>
<span class="codeline" id="line-190"><code>	return scramble</code></span>
<span class="codeline" id="line-191"><code>}</code></span>
<span class="codeline" id="line-192"><code></code></span>
<span class="codeline" id="line-193"><code>// Hash password using MySQL 8+ method (SHA256)</code></span>
<span class="codeline" id="line-194"><code>func scrambleSHA256Password(scramble []byte, password string) []byte {</code></span>
<span class="codeline" id="line-195"><code>	if len(password) == 0 {</code></span>
<span class="codeline" id="line-196"><code>		return nil</code></span>
<span class="codeline" id="line-197"><code>	}</code></span>
<span class="codeline" id="line-198"><code></code></span>
<span class="codeline" id="line-199"><code>	// XOR(SHA256(password), SHA256(SHA256(SHA256(password)), scramble))</code></span>
<span class="codeline" id="line-200"><code></code></span>
<span class="codeline" id="line-201"><code>	crypt := sha256.New()</code></span>
<span class="codeline" id="line-202"><code>	crypt.Write([]byte(password))</code></span>
<span class="codeline" id="line-203"><code>	message1 := crypt.Sum(nil)</code></span>
<span class="codeline" id="line-204"><code></code></span>
<span class="codeline" id="line-205"><code>	crypt.Reset()</code></span>
<span class="codeline" id="line-206"><code>	crypt.Write(message1)</code></span>
<span class="codeline" id="line-207"><code>	message1Hash := crypt.Sum(nil)</code></span>
<span class="codeline" id="line-208"><code></code></span>
<span class="codeline" id="line-209"><code>	crypt.Reset()</code></span>
<span class="codeline" id="line-210"><code>	crypt.Write(message1Hash)</code></span>
<span class="codeline" id="line-211"><code>	crypt.Write(scramble)</code></span>
<span class="codeline" id="line-212"><code>	message2 := crypt.Sum(nil)</code></span>
<span class="codeline" id="line-213"><code></code></span>
<span class="codeline" id="line-214"><code>	for i := range message1 {</code></span>
<span class="codeline" id="line-215"><code>		message1[i] ^= message2[i]</code></span>
<span class="codeline" id="line-216"><code>	}</code></span>
<span class="codeline" id="line-217"><code></code></span>
<span class="codeline" id="line-218"><code>	return message1</code></span>
<span class="codeline" id="line-219"><code>}</code></span>
<span class="codeline" id="line-220"><code></code></span>
<span class="codeline" id="line-221"><code>func encryptPassword(password string, seed []byte, pub *rsa.PublicKey) ([]byte, error) {</code></span>
<span class="codeline" id="line-222"><code>	plain := make([]byte, len(password)+1)</code></span>
<span class="codeline" id="line-223"><code>	copy(plain, password)</code></span>
<span class="codeline" id="line-224"><code>	for i := range plain {</code></span>
<span class="codeline" id="line-225"><code>		j := i % len(seed)</code></span>
<span class="codeline" id="line-226"><code>		plain[i] ^= seed[j]</code></span>
<span class="codeline" id="line-227"><code>	}</code></span>
<span class="codeline" id="line-228"><code>	sha1 := sha1.New()</code></span>
<span class="codeline" id="line-229"><code>	return rsa.EncryptOAEP(sha1, rand.Reader, pub, plain, nil)</code></span>
<span class="codeline" id="line-230"><code>}</code></span>
<span class="codeline" id="line-231"><code></code></span>
<span class="codeline" id="line-232"><code>func (mc *mysqlConn) sendEncryptedPassword(seed []byte, pub *rsa.PublicKey) error {</code></span>
<span class="codeline" id="line-233"><code>	enc, err := encryptPassword(mc.cfg.Passwd, seed, pub)</code></span>
<span class="codeline" id="line-234"><code>	if err != nil {</code></span>
<span class="codeline" id="line-235"><code>		return err</code></span>
<span class="codeline" id="line-236"><code>	}</code></span>
<span class="codeline" id="line-237"><code>	return mc.writeAuthSwitchPacket(enc)</code></span>
<span class="codeline" id="line-238"><code>}</code></span>
<span class="codeline" id="line-239"><code></code></span>
<span class="codeline" id="line-240"><code>func (mc *mysqlConn) auth(authData []byte, plugin string) ([]byte, error) {</code></span>
<span class="codeline" id="line-241"><code>	switch plugin {</code></span>
<span class="codeline" id="line-242"><code>	case "caching_sha2_password":</code></span>
<span class="codeline" id="line-243"><code>		authResp := scrambleSHA256Password(authData, mc.cfg.Passwd)</code></span>
<span class="codeline" id="line-244"><code>		return authResp, nil</code></span>
<span class="codeline" id="line-245"><code></code></span>
<span class="codeline" id="line-246"><code>	case "mysql_old_password":</code></span>
<span class="codeline" id="line-247"><code>		if !mc.cfg.AllowOldPasswords {</code></span>
<span class="codeline" id="line-248"><code>			return nil, ErrOldPassword</code></span>
<span class="codeline" id="line-249"><code>		}</code></span>
<span class="codeline" id="line-250"><code>		// Note: there are edge cases where this should work but doesn't;</code></span>
<span class="codeline" id="line-251"><code>		// this is currently "wontfix":</code></span>
<span class="codeline" id="line-252"><code>		// https://github.com/go-sql-driver/mysql/issues/184</code></span>
<span class="codeline" id="line-253"><code>		authResp := append(scrambleOldPassword(authData[:8], mc.cfg.Passwd), 0)</code></span>
<span class="codeline" id="line-254"><code>		return authResp, nil</code></span>
<span class="codeline" id="line-255"><code></code></span>
<span class="codeline" id="line-256"><code>	case "mysql_clear_password":</code></span>
<span class="codeline" id="line-257"><code>		if !mc.cfg.AllowCleartextPasswords {</code></span>
<span class="codeline" id="line-258"><code>			return nil, ErrCleartextPassword</code></span>
<span class="codeline" id="line-259"><code>		}</code></span>
<span class="codeline" id="line-260"><code>		// http://dev.mysql.com/doc/refman/5.7/en/cleartext-authentication-plugin.html</code></span>
<span class="codeline" id="line-261"><code>		// http://dev.mysql.com/doc/refman/5.7/en/pam-authentication-plugin.html</code></span>
<span class="codeline" id="line-262"><code>		return append([]byte(mc.cfg.Passwd), 0), nil</code></span>
<span class="codeline" id="line-263"><code></code></span>
<span class="codeline" id="line-264"><code>	case "mysql_native_password":</code></span>
<span class="codeline" id="line-265"><code>		if !mc.cfg.AllowNativePasswords {</code></span>
<span class="codeline" id="line-266"><code>			return nil, ErrNativePassword</code></span>
<span class="codeline" id="line-267"><code>		}</code></span>
<span class="codeline" id="line-268"><code>		// https://dev.mysql.com/doc/internals/en/secure-password-authentication.html</code></span>
<span class="codeline" id="line-269"><code>		// Native password authentication only need and will need 20-byte challenge.</code></span>
<span class="codeline" id="line-270"><code>		authResp := scramblePassword(authData[:20], mc.cfg.Passwd)</code></span>
<span class="codeline" id="line-271"><code>		return authResp, nil</code></span>
<span class="codeline" id="line-272"><code></code></span>
<span class="codeline" id="line-273"><code>	case "sha256_password":</code></span>
<span class="codeline" id="line-274"><code>		if len(mc.cfg.Passwd) == 0 {</code></span>
<span class="codeline" id="line-275"><code>			return []byte{0}, nil</code></span>
<span class="codeline" id="line-276"><code>		}</code></span>
<span class="codeline" id="line-277"><code>		if mc.cfg.tls != nil || mc.cfg.Net == "unix" {</code></span>
<span class="codeline" id="line-278"><code>			// write cleartext auth packet</code></span>
<span class="codeline" id="line-279"><code>			return append([]byte(mc.cfg.Passwd), 0), nil</code></span>
<span class="codeline" id="line-280"><code>		}</code></span>
<span class="codeline" id="line-281"><code></code></span>
<span class="codeline" id="line-282"><code>		pubKey := mc.cfg.pubKey</code></span>
<span class="codeline" id="line-283"><code>		if pubKey == nil {</code></span>
<span class="codeline" id="line-284"><code>			// request public key from server</code></span>
<span class="codeline" id="line-285"><code>			return []byte{1}, nil</code></span>
<span class="codeline" id="line-286"><code>		}</code></span>
<span class="codeline" id="line-287"><code></code></span>
<span class="codeline" id="line-288"><code>		// encrypted password</code></span>
<span class="codeline" id="line-289"><code>		enc, err := encryptPassword(mc.cfg.Passwd, authData, pubKey)</code></span>
<span class="codeline" id="line-290"><code>		return enc, err</code></span>
<span class="codeline" id="line-291"><code></code></span>
<span class="codeline" id="line-292"><code>	default:</code></span>
<span class="codeline" id="line-293"><code>		errLog.Print("unknown auth plugin:", plugin)</code></span>
<span class="codeline" id="line-294"><code>		return nil, ErrUnknownPlugin</code></span>
<span class="codeline" id="line-295"><code>	}</code></span>
<span class="codeline" id="line-296"><code>}</code></span>
<span class="codeline" id="line-297"><code></code></span>
<span class="codeline" id="line-298"><code>func (mc *mysqlConn) handleAuthResult(oldAuthData []byte, plugin string) error {</code></span>
<span class="codeline" id="line-299"><code>	// Read Result Packet</code></span>
<span class="codeline" id="line-300"><code>	authData, newPlugin, err := mc.readAuthResult()</code></span>
<span class="codeline" id="line-301"><code>	if err != nil {</code></span>
<span class="codeline" id="line-302"><code>		return err</code></span>
<span class="codeline" id="line-303"><code>	}</code></span>
<span class="codeline" id="line-304"><code></code></span>
<span class="codeline" id="line-305"><code>	// handle auth plugin switch, if requested</code></span>
<span class="codeline" id="line-306"><code>	if newPlugin != "" {</code></span>
<span class="codeline" id="line-307"><code>		// If CLIENT_PLUGIN_AUTH capability is not supported, no new cipher is</code></span>
<span class="codeline" id="line-308"><code>		// sent and we have to keep using the cipher sent in the init packet.</code></span>
<span class="codeline" id="line-309"><code>		if authData == nil {</code></span>
<span class="codeline" id="line-310"><code>			authData = oldAuthData</code></span>
<span class="codeline" id="line-311"><code>		} else {</code></span>
<span class="codeline" id="line-312"><code>			// copy data from read buffer to owned slice</code></span>
<span class="codeline" id="line-313"><code>			copy(oldAuthData, authData)</code></span>
<span class="codeline" id="line-314"><code>		}</code></span>
<span class="codeline" id="line-315"><code></code></span>
<span class="codeline" id="line-316"><code>		plugin = newPlugin</code></span>
<span class="codeline" id="line-317"><code></code></span>
<span class="codeline" id="line-318"><code>		authResp, err := mc.auth(authData, plugin)</code></span>
<span class="codeline" id="line-319"><code>		if err != nil {</code></span>
<span class="codeline" id="line-320"><code>			return err</code></span>
<span class="codeline" id="line-321"><code>		}</code></span>
<span class="codeline" id="line-322"><code>		if err = mc.writeAuthSwitchPacket(authResp); err != nil {</code></span>
<span class="codeline" id="line-323"><code>			return err</code></span>
<span class="codeline" id="line-324"><code>		}</code></span>
<span class="codeline" id="line-325"><code></code></span>
<span class="codeline" id="line-326"><code>		// Read Result Packet</code></span>
<span class="codeline" id="line-327"><code>		authData, newPlugin, err = mc.readAuthResult()</code></span>
<span class="codeline" id="line-328"><code>		if err != nil {</code></span>
<span class="codeline" id="line-329"><code>			return err</code></span>
<span class="codeline" id="line-330"><code>		}</code></span>
<span class="codeline" id="line-331"><code></code></span>
<span class="codeline" id="line-332"><code>		// Do not allow to change the auth plugin more than once</code></span>
<span class="codeline" id="line-333"><code>		if newPlugin != "" {</code></span>
<span class="codeline" id="line-334"><code>			return ErrMalformPkt</code></span>
<span class="codeline" id="line-335"><code>		}</code></span>
<span class="codeline" id="line-336"><code>	}</code></span>
<span class="codeline" id="line-337"><code></code></span>
<span class="codeline" id="line-338"><code>	switch plugin {</code></span>
<span class="codeline" id="line-339"><code></code></span>
<span class="codeline" id="line-340"><code>	// https://insidemysql.com/preparing-your-community-connector-for-mysql-8-part-2-sha256/</code></span>
<span class="codeline" id="line-341"><code>	case "caching_sha2_password":</code></span>
<span class="codeline" id="line-342"><code>		switch len(authData) {</code></span>
<span class="codeline" id="line-343"><code>		case 0:</code></span>
<span class="codeline" id="line-344"><code>			return nil // auth successful</code></span>
<span class="codeline" id="line-345"><code>		case 1:</code></span>
<span class="codeline" id="line-346"><code>			switch authData[0] {</code></span>
<span class="codeline" id="line-347"><code>			case cachingSha2PasswordFastAuthSuccess:</code></span>
<span class="codeline" id="line-348"><code>				if err = mc.readResultOK(); err == nil {</code></span>
<span class="codeline" id="line-349"><code>					return nil // auth successful</code></span>
<span class="codeline" id="line-350"><code>				}</code></span>
<span class="codeline" id="line-351"><code></code></span>
<span class="codeline" id="line-352"><code>			case cachingSha2PasswordPerformFullAuthentication:</code></span>
<span class="codeline" id="line-353"><code>				if mc.cfg.tls != nil || mc.cfg.Net == "unix" {</code></span>
<span class="codeline" id="line-354"><code>					// write cleartext auth packet</code></span>
<span class="codeline" id="line-355"><code>					err = mc.writeAuthSwitchPacket(append([]byte(mc.cfg.Passwd), 0))</code></span>
<span class="codeline" id="line-356"><code>					if err != nil {</code></span>
<span class="codeline" id="line-357"><code>						return err</code></span>
<span class="codeline" id="line-358"><code>					}</code></span>
<span class="codeline" id="line-359"><code>				} else {</code></span>
<span class="codeline" id="line-360"><code>					pubKey := mc.cfg.pubKey</code></span>
<span class="codeline" id="line-361"><code>					if pubKey == nil {</code></span>
<span class="codeline" id="line-362"><code>						// request public key from server</code></span>
<span class="codeline" id="line-363"><code>						data, err := mc.buf.takeSmallBuffer(4 + 1)</code></span>
<span class="codeline" id="line-364"><code>						if err != nil {</code></span>
<span class="codeline" id="line-365"><code>							return err</code></span>
<span class="codeline" id="line-366"><code>						}</code></span>
<span class="codeline" id="line-367"><code>						data[4] = cachingSha2PasswordRequestPublicKey</code></span>
<span class="codeline" id="line-368"><code>						mc.writePacket(data)</code></span>
<span class="codeline" id="line-369"><code></code></span>
<span class="codeline" id="line-370"><code>						// parse public key</code></span>
<span class="codeline" id="line-371"><code>						if data, err = mc.readPacket(); err != nil {</code></span>
<span class="codeline" id="line-372"><code>							return err</code></span>
<span class="codeline" id="line-373"><code>						}</code></span>
<span class="codeline" id="line-374"><code></code></span>
<span class="codeline" id="line-375"><code>						block, _ := pem.Decode(data[1:])</code></span>
<span class="codeline" id="line-376"><code>						pkix, err := x509.ParsePKIXPublicKey(block.Bytes)</code></span>
<span class="codeline" id="line-377"><code>						if err != nil {</code></span>
<span class="codeline" id="line-378"><code>							return err</code></span>
<span class="codeline" id="line-379"><code>						}</code></span>
<span class="codeline" id="line-380"><code>						pubKey = pkix.(*rsa.PublicKey)</code></span>
<span class="codeline" id="line-381"><code>					}</code></span>
<span class="codeline" id="line-382"><code></code></span>
<span class="codeline" id="line-383"><code>					// send encrypted password</code></span>
<span class="codeline" id="line-384"><code>					err = mc.sendEncryptedPassword(oldAuthData, pubKey)</code></span>
<span class="codeline" id="line-385"><code>					if err != nil {</code></span>
<span class="codeline" id="line-386"><code>						return err</code></span>
<span class="codeline" id="line-387"><code>					}</code></span>
<span class="codeline" id="line-388"><code>				}</code></span>
<span class="codeline" id="line-389"><code>				return mc.readResultOK()</code></span>
<span class="codeline" id="line-390"><code></code></span>
<span class="codeline" id="line-391"><code>			default:</code></span>
<span class="codeline" id="line-392"><code>				return ErrMalformPkt</code></span>
<span class="codeline" id="line-393"><code>			}</code></span>
<span class="codeline" id="line-394"><code>		default:</code></span>
<span class="codeline" id="line-395"><code>			return ErrMalformPkt</code></span>
<span class="codeline" id="line-396"><code>		}</code></span>
<span class="codeline" id="line-397"><code></code></span>
<span class="codeline" id="line-398"><code>	case "sha256_password":</code></span>
<span class="codeline" id="line-399"><code>		switch len(authData) {</code></span>
<span class="codeline" id="line-400"><code>		case 0:</code></span>
<span class="codeline" id="line-401"><code>			return nil // auth successful</code></span>
<span class="codeline" id="line-402"><code>		default:</code></span>
<span class="codeline" id="line-403"><code>			block, _ := pem.Decode(authData)</code></span>
<span class="codeline" id="line-404"><code>			pub, err := x509.ParsePKIXPublicKey(block.Bytes)</code></span>
<span class="codeline" id="line-405"><code>			if err != nil {</code></span>
<span class="codeline" id="line-406"><code>				return err</code></span>
<span class="codeline" id="line-407"><code>			}</code></span>
<span class="codeline" id="line-408"><code></code></span>
<span class="codeline" id="line-409"><code>			// send encrypted password</code></span>
<span class="codeline" id="line-410"><code>			err = mc.sendEncryptedPassword(oldAuthData, pub.(*rsa.PublicKey))</code></span>
<span class="codeline" id="line-411"><code>			if err != nil {</code></span>
<span class="codeline" id="line-412"><code>				return err</code></span>
<span class="codeline" id="line-413"><code>			}</code></span>
<span class="codeline" id="line-414"><code>			return mc.readResultOK()</code></span>
<span class="codeline" id="line-415"><code>		}</code></span>
<span class="codeline" id="line-416"><code></code></span>
<span class="codeline" id="line-417"><code>	default:</code></span>
<span class="codeline" id="line-418"><code>		return nil // auth successful</code></span>
<span class="codeline" id="line-419"><code>	}</code></span>
<span class="codeline" id="line-420"><code></code></span>
<span class="codeline" id="line-421"><code>	return err</code></span>
<span class="codeline" id="line-422"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.1.6</i>. (GOOS=darwin GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project and developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table
</pre>
</div></body></html>