<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: proc.go in package runtime</title>
<link href="../../css/light-v0.1.6.css" rel="stylesheet">
<script src="../../jvs/golds-v0.1.6.js"></script>
<body><div>

<pre id="header"><code><span class="title">Source File</span>
	proc.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/runtime.html">runtime</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2014 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>package runtime</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>import (</code></span>
<span class="codeline" id="line-8"><code>	"internal/cpu"</code></span>
<span class="codeline" id="line-9"><code>	"runtime/internal/atomic"</code></span>
<span class="codeline" id="line-10"><code>	"runtime/internal/sys"</code></span>
<span class="codeline" id="line-11"><code>	"unsafe"</code></span>
<span class="codeline" id="line-12"><code>)</code></span>
<span class="codeline" id="line-13"><code></code></span>
<span class="codeline" id="line-14"><code>var buildVersion = sys.TheVersion</code></span>
<span class="codeline" id="line-15"><code></code></span>
<span class="codeline" id="line-16"><code>// set using cmd/go/internal/modload.ModInfoProg</code></span>
<span class="codeline" id="line-17"><code>var modinfo string</code></span>
<span class="codeline" id="line-18"><code></code></span>
<span class="codeline" id="line-19"><code>// Goroutine scheduler</code></span>
<span class="codeline" id="line-20"><code>// The scheduler's job is to distribute ready-to-run goroutines over worker threads.</code></span>
<span class="codeline" id="line-21"><code>//</code></span>
<span class="codeline" id="line-22"><code>// The main concepts are:</code></span>
<span class="codeline" id="line-23"><code>// G - goroutine.</code></span>
<span class="codeline" id="line-24"><code>// M - worker thread, or machine.</code></span>
<span class="codeline" id="line-25"><code>// P - processor, a resource that is required to execute Go code.</code></span>
<span class="codeline" id="line-26"><code>//     M must have an associated P to execute Go code, however it can be</code></span>
<span class="codeline" id="line-27"><code>//     blocked or in a syscall w/o an associated P.</code></span>
<span class="codeline" id="line-28"><code>//</code></span>
<span class="codeline" id="line-29"><code>// Design doc at https://golang.org/s/go11sched.</code></span>
<span class="codeline" id="line-30"><code></code></span>
<span class="codeline" id="line-31"><code>// Worker thread parking/unparking.</code></span>
<span class="codeline" id="line-32"><code>// We need to balance between keeping enough running worker threads to utilize</code></span>
<span class="codeline" id="line-33"><code>// available hardware parallelism and parking excessive running worker threads</code></span>
<span class="codeline" id="line-34"><code>// to conserve CPU resources and power. This is not simple for two reasons:</code></span>
<span class="codeline" id="line-35"><code>// (1) scheduler state is intentionally distributed (in particular, per-P work</code></span>
<span class="codeline" id="line-36"><code>// queues), so it is not possible to compute global predicates on fast paths;</code></span>
<span class="codeline" id="line-37"><code>// (2) for optimal thread management we would need to know the future (don't park</code></span>
<span class="codeline" id="line-38"><code>// a worker thread when a new goroutine will be readied in near future).</code></span>
<span class="codeline" id="line-39"><code>//</code></span>
<span class="codeline" id="line-40"><code>// Three rejected approaches that would work badly:</code></span>
<span class="codeline" id="line-41"><code>// 1. Centralize all scheduler state (would inhibit scalability).</code></span>
<span class="codeline" id="line-42"><code>// 2. Direct goroutine handoff. That is, when we ready a new goroutine and there</code></span>
<span class="codeline" id="line-43"><code>//    is a spare P, unpark a thread and handoff it the thread and the goroutine.</code></span>
<span class="codeline" id="line-44"><code>//    This would lead to thread state thrashing, as the thread that readied the</code></span>
<span class="codeline" id="line-45"><code>//    goroutine can be out of work the very next moment, we will need to park it.</code></span>
<span class="codeline" id="line-46"><code>//    Also, it would destroy locality of computation as we want to preserve</code></span>
<span class="codeline" id="line-47"><code>//    dependent goroutines on the same thread; and introduce additional latency.</code></span>
<span class="codeline" id="line-48"><code>// 3. Unpark an additional thread whenever we ready a goroutine and there is an</code></span>
<span class="codeline" id="line-49"><code>//    idle P, but don't do handoff. This would lead to excessive thread parking/</code></span>
<span class="codeline" id="line-50"><code>//    unparking as the additional threads will instantly park without discovering</code></span>
<span class="codeline" id="line-51"><code>//    any work to do.</code></span>
<span class="codeline" id="line-52"><code>//</code></span>
<span class="codeline" id="line-53"><code>// The current approach:</code></span>
<span class="codeline" id="line-54"><code>// We unpark an additional thread when we ready a goroutine if (1) there is an</code></span>
<span class="codeline" id="line-55"><code>// idle P and there are no "spinning" worker threads. A worker thread is considered</code></span>
<span class="codeline" id="line-56"><code>// spinning if it is out of local work and did not find work in global run queue/</code></span>
<span class="codeline" id="line-57"><code>// netpoller; the spinning state is denoted in m.spinning and in sched.nmspinning.</code></span>
<span class="codeline" id="line-58"><code>// Threads unparked this way are also considered spinning; we don't do goroutine</code></span>
<span class="codeline" id="line-59"><code>// handoff so such threads are out of work initially. Spinning threads do some</code></span>
<span class="codeline" id="line-60"><code>// spinning looking for work in per-P run queues before parking. If a spinning</code></span>
<span class="codeline" id="line-61"><code>// thread finds work it takes itself out of the spinning state and proceeds to</code></span>
<span class="codeline" id="line-62"><code>// execution. If it does not find work it takes itself out of the spinning state</code></span>
<span class="codeline" id="line-63"><code>// and then parks.</code></span>
<span class="codeline" id="line-64"><code>// If there is at least one spinning thread (sched.nmspinning&gt;1), we don't unpark</code></span>
<span class="codeline" id="line-65"><code>// new threads when readying goroutines. To compensate for that, if the last spinning</code></span>
<span class="codeline" id="line-66"><code>// thread finds work and stops spinning, it must unpark a new spinning thread.</code></span>
<span class="codeline" id="line-67"><code>// This approach smooths out unjustified spikes of thread unparking,</code></span>
<span class="codeline" id="line-68"><code>// but at the same time guarantees eventual maximal CPU parallelism utilization.</code></span>
<span class="codeline" id="line-69"><code>//</code></span>
<span class="codeline" id="line-70"><code>// The main implementation complication is that we need to be very careful during</code></span>
<span class="codeline" id="line-71"><code>// spinning-&gt;non-spinning thread transition. This transition can race with submission</code></span>
<span class="codeline" id="line-72"><code>// of a new goroutine, and either one part or another needs to unpark another worker</code></span>
<span class="codeline" id="line-73"><code>// thread. If they both fail to do that, we can end up with semi-persistent CPU</code></span>
<span class="codeline" id="line-74"><code>// underutilization. The general pattern for goroutine readying is: submit a goroutine</code></span>
<span class="codeline" id="line-75"><code>// to local work queue, #StoreLoad-style memory barrier, check sched.nmspinning.</code></span>
<span class="codeline" id="line-76"><code>// The general pattern for spinning-&gt;non-spinning transition is: decrement nmspinning,</code></span>
<span class="codeline" id="line-77"><code>// #StoreLoad-style memory barrier, check all per-P work queues for new work.</code></span>
<span class="codeline" id="line-78"><code>// Note that all this complexity does not apply to global run queue as we are not</code></span>
<span class="codeline" id="line-79"><code>// sloppy about thread unparking when submitting to global queue. Also see comments</code></span>
<span class="codeline" id="line-80"><code>// for nmspinning manipulation.</code></span>
<span class="codeline" id="line-81"><code></code></span>
<span class="codeline" id="line-82"><code>var (</code></span>
<span class="codeline" id="line-83"><code>	m0           m</code></span>
<span class="codeline" id="line-84"><code>	g0           g</code></span>
<span class="codeline" id="line-85"><code>	mcache0      *mcache</code></span>
<span class="codeline" id="line-86"><code>	raceprocctx0 uintptr</code></span>
<span class="codeline" id="line-87"><code>)</code></span>
<span class="codeline" id="line-88"><code></code></span>
<span class="codeline" id="line-89"><code>//go:linkname runtime_inittask runtime..inittask</code></span>
<span class="codeline" id="line-90"><code>var runtime_inittask initTask</code></span>
<span class="codeline" id="line-91"><code></code></span>
<span class="codeline" id="line-92"><code>//go:linkname main_inittask main..inittask</code></span>
<span class="codeline" id="line-93"><code>var main_inittask initTask</code></span>
<span class="codeline" id="line-94"><code></code></span>
<span class="codeline" id="line-95"><code>// main_init_done is a signal used by cgocallbackg that initialization</code></span>
<span class="codeline" id="line-96"><code>// has been completed. It is made before _cgo_notify_runtime_init_done,</code></span>
<span class="codeline" id="line-97"><code>// so all cgo calls can rely on it existing. When main_init is complete,</code></span>
<span class="codeline" id="line-98"><code>// it is closed, meaning cgocallbackg can reliably receive from it.</code></span>
<span class="codeline" id="line-99"><code>var main_init_done chan bool</code></span>
<span class="codeline" id="line-100"><code></code></span>
<span class="codeline" id="line-101"><code>//go:linkname main_main main.main</code></span>
<span class="codeline" id="line-102"><code>func main_main()</code></span>
<span class="codeline" id="line-103"><code></code></span>
<span class="codeline" id="line-104"><code>// mainStarted indicates that the main M has started.</code></span>
<span class="codeline" id="line-105"><code>var mainStarted bool</code></span>
<span class="codeline" id="line-106"><code></code></span>
<span class="codeline" id="line-107"><code>// runtimeInitTime is the nanotime() at which the runtime started.</code></span>
<span class="codeline" id="line-108"><code>var runtimeInitTime int64</code></span>
<span class="codeline" id="line-109"><code></code></span>
<span class="codeline" id="line-110"><code>// Value to use for signal mask for newly created M's.</code></span>
<span class="codeline" id="line-111"><code>var initSigmask sigset</code></span>
<span class="codeline" id="line-112"><code></code></span>
<span class="codeline" id="line-113"><code>// The main goroutine.</code></span>
<span class="codeline" id="line-114"><code>func main() {</code></span>
<span class="codeline" id="line-115"><code>	g := getg()</code></span>
<span class="codeline" id="line-116"><code></code></span>
<span class="codeline" id="line-117"><code>	// Racectx of m0-&gt;g0 is used only as the parent of the main goroutine.</code></span>
<span class="codeline" id="line-118"><code>	// It must not be used for anything else.</code></span>
<span class="codeline" id="line-119"><code>	g.m.g0.racectx = 0</code></span>
<span class="codeline" id="line-120"><code></code></span>
<span class="codeline" id="line-121"><code>	// Max stack size is 1 GB on 64-bit, 250 MB on 32-bit.</code></span>
<span class="codeline" id="line-122"><code>	// Using decimal instead of binary GB and MB because</code></span>
<span class="codeline" id="line-123"><code>	// they look nicer in the stack overflow failure message.</code></span>
<span class="codeline" id="line-124"><code>	if sys.PtrSize == 8 {</code></span>
<span class="codeline" id="line-125"><code>		maxstacksize = 1000000000</code></span>
<span class="codeline" id="line-126"><code>	} else {</code></span>
<span class="codeline" id="line-127"><code>		maxstacksize = 250000000</code></span>
<span class="codeline" id="line-128"><code>	}</code></span>
<span class="codeline" id="line-129"><code></code></span>
<span class="codeline" id="line-130"><code>	// Allow newproc to start new Ms.</code></span>
<span class="codeline" id="line-131"><code>	mainStarted = true</code></span>
<span class="codeline" id="line-132"><code></code></span>
<span class="codeline" id="line-133"><code>	if GOARCH != "wasm" { // no threads on wasm yet, so no sysmon</code></span>
<span class="codeline" id="line-134"><code>		systemstack(func() {</code></span>
<span class="codeline" id="line-135"><code>			newm(sysmon, nil, -1)</code></span>
<span class="codeline" id="line-136"><code>		})</code></span>
<span class="codeline" id="line-137"><code>	}</code></span>
<span class="codeline" id="line-138"><code></code></span>
<span class="codeline" id="line-139"><code>	// Lock the main goroutine onto this, the main OS thread,</code></span>
<span class="codeline" id="line-140"><code>	// during initialization. Most programs won't care, but a few</code></span>
<span class="codeline" id="line-141"><code>	// do require certain calls to be made by the main thread.</code></span>
<span class="codeline" id="line-142"><code>	// Those can arrange for main.main to run in the main thread</code></span>
<span class="codeline" id="line-143"><code>	// by calling runtime.LockOSThread during initialization</code></span>
<span class="codeline" id="line-144"><code>	// to preserve the lock.</code></span>
<span class="codeline" id="line-145"><code>	lockOSThread()</code></span>
<span class="codeline" id="line-146"><code></code></span>
<span class="codeline" id="line-147"><code>	if g.m != &amp;m0 {</code></span>
<span class="codeline" id="line-148"><code>		throw("runtime.main not on m0")</code></span>
<span class="codeline" id="line-149"><code>	}</code></span>
<span class="codeline" id="line-150"><code></code></span>
<span class="codeline" id="line-151"><code>	doInit(&amp;runtime_inittask) // must be before defer</code></span>
<span class="codeline" id="line-152"><code>	if nanotime() == 0 {</code></span>
<span class="codeline" id="line-153"><code>		throw("nanotime returning zero")</code></span>
<span class="codeline" id="line-154"><code>	}</code></span>
<span class="codeline" id="line-155"><code></code></span>
<span class="codeline" id="line-156"><code>	// Defer unlock so that runtime.Goexit during init does the unlock too.</code></span>
<span class="codeline" id="line-157"><code>	needUnlock := true</code></span>
<span class="codeline" id="line-158"><code>	defer func() {</code></span>
<span class="codeline" id="line-159"><code>		if needUnlock {</code></span>
<span class="codeline" id="line-160"><code>			unlockOSThread()</code></span>
<span class="codeline" id="line-161"><code>		}</code></span>
<span class="codeline" id="line-162"><code>	}()</code></span>
<span class="codeline" id="line-163"><code></code></span>
<span class="codeline" id="line-164"><code>	// Record when the world started.</code></span>
<span class="codeline" id="line-165"><code>	runtimeInitTime = nanotime()</code></span>
<span class="codeline" id="line-166"><code></code></span>
<span class="codeline" id="line-167"><code>	gcenable()</code></span>
<span class="codeline" id="line-168"><code></code></span>
<span class="codeline" id="line-169"><code>	main_init_done = make(chan bool)</code></span>
<span class="codeline" id="line-170"><code>	if iscgo {</code></span>
<span class="codeline" id="line-171"><code>		if _cgo_thread_start == nil {</code></span>
<span class="codeline" id="line-172"><code>			throw("_cgo_thread_start missing")</code></span>
<span class="codeline" id="line-173"><code>		}</code></span>
<span class="codeline" id="line-174"><code>		if GOOS != "windows" {</code></span>
<span class="codeline" id="line-175"><code>			if _cgo_setenv == nil {</code></span>
<span class="codeline" id="line-176"><code>				throw("_cgo_setenv missing")</code></span>
<span class="codeline" id="line-177"><code>			}</code></span>
<span class="codeline" id="line-178"><code>			if _cgo_unsetenv == nil {</code></span>
<span class="codeline" id="line-179"><code>				throw("_cgo_unsetenv missing")</code></span>
<span class="codeline" id="line-180"><code>			}</code></span>
<span class="codeline" id="line-181"><code>		}</code></span>
<span class="codeline" id="line-182"><code>		if _cgo_notify_runtime_init_done == nil {</code></span>
<span class="codeline" id="line-183"><code>			throw("_cgo_notify_runtime_init_done missing")</code></span>
<span class="codeline" id="line-184"><code>		}</code></span>
<span class="codeline" id="line-185"><code>		// Start the template thread in case we enter Go from</code></span>
<span class="codeline" id="line-186"><code>		// a C-created thread and need to create a new thread.</code></span>
<span class="codeline" id="line-187"><code>		startTemplateThread()</code></span>
<span class="codeline" id="line-188"><code>		cgocall(_cgo_notify_runtime_init_done, nil)</code></span>
<span class="codeline" id="line-189"><code>	}</code></span>
<span class="codeline" id="line-190"><code></code></span>
<span class="codeline" id="line-191"><code>	doInit(&amp;main_inittask)</code></span>
<span class="codeline" id="line-192"><code></code></span>
<span class="codeline" id="line-193"><code>	close(main_init_done)</code></span>
<span class="codeline" id="line-194"><code></code></span>
<span class="codeline" id="line-195"><code>	needUnlock = false</code></span>
<span class="codeline" id="line-196"><code>	unlockOSThread()</code></span>
<span class="codeline" id="line-197"><code></code></span>
<span class="codeline" id="line-198"><code>	if isarchive || islibrary {</code></span>
<span class="codeline" id="line-199"><code>		// A program compiled with -buildmode=c-archive or c-shared</code></span>
<span class="codeline" id="line-200"><code>		// has a main, but it is not executed.</code></span>
<span class="codeline" id="line-201"><code>		return</code></span>
<span class="codeline" id="line-202"><code>	}</code></span>
<span class="codeline" id="line-203"><code>	fn := main_main // make an indirect call, as the linker doesn't know the address of the main package when laying down the runtime</code></span>
<span class="codeline" id="line-204"><code>	fn()</code></span>
<span class="codeline" id="line-205"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-206"><code>		racefini()</code></span>
<span class="codeline" id="line-207"><code>	}</code></span>
<span class="codeline" id="line-208"><code></code></span>
<span class="codeline" id="line-209"><code>	// Make racy client program work: if panicking on</code></span>
<span class="codeline" id="line-210"><code>	// another goroutine at the same time as main returns,</code></span>
<span class="codeline" id="line-211"><code>	// let the other goroutine finish printing the panic trace.</code></span>
<span class="codeline" id="line-212"><code>	// Once it does, it will exit. See issues 3934 and 20018.</code></span>
<span class="codeline" id="line-213"><code>	if atomic.Load(&amp;runningPanicDefers) != 0 {</code></span>
<span class="codeline" id="line-214"><code>		// Running deferred functions should not take long.</code></span>
<span class="codeline" id="line-215"><code>		for c := 0; c &lt; 1000; c++ {</code></span>
<span class="codeline" id="line-216"><code>			if atomic.Load(&amp;runningPanicDefers) == 0 {</code></span>
<span class="codeline" id="line-217"><code>				break</code></span>
<span class="codeline" id="line-218"><code>			}</code></span>
<span class="codeline" id="line-219"><code>			Gosched()</code></span>
<span class="codeline" id="line-220"><code>		}</code></span>
<span class="codeline" id="line-221"><code>	}</code></span>
<span class="codeline" id="line-222"><code>	if atomic.Load(&amp;panicking) != 0 {</code></span>
<span class="codeline" id="line-223"><code>		gopark(nil, nil, waitReasonPanicWait, traceEvGoStop, 1)</code></span>
<span class="codeline" id="line-224"><code>	}</code></span>
<span class="codeline" id="line-225"><code></code></span>
<span class="codeline" id="line-226"><code>	exit(0)</code></span>
<span class="codeline" id="line-227"><code>	for {</code></span>
<span class="codeline" id="line-228"><code>		var x *int32</code></span>
<span class="codeline" id="line-229"><code>		*x = 0</code></span>
<span class="codeline" id="line-230"><code>	}</code></span>
<span class="codeline" id="line-231"><code>}</code></span>
<span class="codeline" id="line-232"><code></code></span>
<span class="codeline" id="line-233"><code>// os_beforeExit is called from os.Exit(0).</code></span>
<span class="codeline" id="line-234"><code>//go:linkname os_beforeExit os.runtime_beforeExit</code></span>
<span class="codeline" id="line-235"><code>func os_beforeExit() {</code></span>
<span class="codeline" id="line-236"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-237"><code>		racefini()</code></span>
<span class="codeline" id="line-238"><code>	}</code></span>
<span class="codeline" id="line-239"><code>}</code></span>
<span class="codeline" id="line-240"><code></code></span>
<span class="codeline" id="line-241"><code>// start forcegc helper goroutine</code></span>
<span class="codeline" id="line-242"><code>func init() {</code></span>
<span class="codeline" id="line-243"><code>	go forcegchelper()</code></span>
<span class="codeline" id="line-244"><code>}</code></span>
<span class="codeline" id="line-245"><code></code></span>
<span class="codeline" id="line-246"><code>func forcegchelper() {</code></span>
<span class="codeline" id="line-247"><code>	forcegc.g = getg()</code></span>
<span class="codeline" id="line-248"><code>	lockInit(&amp;forcegc.lock, lockRankForcegc)</code></span>
<span class="codeline" id="line-249"><code>	for {</code></span>
<span class="codeline" id="line-250"><code>		lock(&amp;forcegc.lock)</code></span>
<span class="codeline" id="line-251"><code>		if forcegc.idle != 0 {</code></span>
<span class="codeline" id="line-252"><code>			throw("forcegc: phase error")</code></span>
<span class="codeline" id="line-253"><code>		}</code></span>
<span class="codeline" id="line-254"><code>		atomic.Store(&amp;forcegc.idle, 1)</code></span>
<span class="codeline" id="line-255"><code>		goparkunlock(&amp;forcegc.lock, waitReasonForceGCIdle, traceEvGoBlock, 1)</code></span>
<span class="codeline" id="line-256"><code>		// this goroutine is explicitly resumed by sysmon</code></span>
<span class="codeline" id="line-257"><code>		if debug.gctrace &gt; 0 {</code></span>
<span class="codeline" id="line-258"><code>			println("GC forced")</code></span>
<span class="codeline" id="line-259"><code>		}</code></span>
<span class="codeline" id="line-260"><code>		// Time-triggered, fully concurrent.</code></span>
<span class="codeline" id="line-261"><code>		gcStart(gcTrigger{kind: gcTriggerTime, now: nanotime()})</code></span>
<span class="codeline" id="line-262"><code>	}</code></span>
<span class="codeline" id="line-263"><code>}</code></span>
<span class="codeline" id="line-264"><code></code></span>
<span class="codeline" id="line-265"><code>//go:nosplit</code></span>
<span class="codeline" id="line-266"><code></code></span>
<span class="codeline" id="line-267"><code>// Gosched yields the processor, allowing other goroutines to run. It does not</code></span>
<span class="codeline" id="line-268"><code>// suspend the current goroutine, so execution resumes automatically.</code></span>
<span class="codeline" id="line-269"><code>func Gosched() {</code></span>
<span class="codeline" id="line-270"><code>	checkTimeouts()</code></span>
<span class="codeline" id="line-271"><code>	mcall(gosched_m)</code></span>
<span class="codeline" id="line-272"><code>}</code></span>
<span class="codeline" id="line-273"><code></code></span>
<span class="codeline" id="line-274"><code>// goschedguarded yields the processor like gosched, but also checks</code></span>
<span class="codeline" id="line-275"><code>// for forbidden states and opts out of the yield in those cases.</code></span>
<span class="codeline" id="line-276"><code>//go:nosplit</code></span>
<span class="codeline" id="line-277"><code>func goschedguarded() {</code></span>
<span class="codeline" id="line-278"><code>	mcall(goschedguarded_m)</code></span>
<span class="codeline" id="line-279"><code>}</code></span>
<span class="codeline" id="line-280"><code></code></span>
<span class="codeline" id="line-281"><code>// Puts the current goroutine into a waiting state and calls unlockf.</code></span>
<span class="codeline" id="line-282"><code>// If unlockf returns false, the goroutine is resumed.</code></span>
<span class="codeline" id="line-283"><code>// unlockf must not access this G's stack, as it may be moved between</code></span>
<span class="codeline" id="line-284"><code>// the call to gopark and the call to unlockf.</code></span>
<span class="codeline" id="line-285"><code>// Reason explains why the goroutine has been parked.</code></span>
<span class="codeline" id="line-286"><code>// It is displayed in stack traces and heap dumps.</code></span>
<span class="codeline" id="line-287"><code>// Reasons should be unique and descriptive.</code></span>
<span class="codeline" id="line-288"><code>// Do not re-use reasons, add new ones.</code></span>
<span class="codeline" id="line-289"><code>func gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason waitReason, traceEv byte, traceskip int) {</code></span>
<span class="codeline" id="line-290"><code>	if reason != waitReasonSleep {</code></span>
<span class="codeline" id="line-291"><code>		checkTimeouts() // timeouts may expire while two goroutines keep the scheduler busy</code></span>
<span class="codeline" id="line-292"><code>	}</code></span>
<span class="codeline" id="line-293"><code>	mp := acquirem()</code></span>
<span class="codeline" id="line-294"><code>	gp := mp.curg</code></span>
<span class="codeline" id="line-295"><code>	status := readgstatus(gp)</code></span>
<span class="codeline" id="line-296"><code>	if status != _Grunning &amp;&amp; status != _Gscanrunning {</code></span>
<span class="codeline" id="line-297"><code>		throw("gopark: bad g status")</code></span>
<span class="codeline" id="line-298"><code>	}</code></span>
<span class="codeline" id="line-299"><code>	mp.waitlock = lock</code></span>
<span class="codeline" id="line-300"><code>	mp.waitunlockf = unlockf</code></span>
<span class="codeline" id="line-301"><code>	gp.waitreason = reason</code></span>
<span class="codeline" id="line-302"><code>	mp.waittraceev = traceEv</code></span>
<span class="codeline" id="line-303"><code>	mp.waittraceskip = traceskip</code></span>
<span class="codeline" id="line-304"><code>	releasem(mp)</code></span>
<span class="codeline" id="line-305"><code>	// can't do anything that might move the G between Ms here.</code></span>
<span class="codeline" id="line-306"><code>	mcall(park_m)</code></span>
<span class="codeline" id="line-307"><code>}</code></span>
<span class="codeline" id="line-308"><code></code></span>
<span class="codeline" id="line-309"><code>// Puts the current goroutine into a waiting state and unlocks the lock.</code></span>
<span class="codeline" id="line-310"><code>// The goroutine can be made runnable again by calling goready(gp).</code></span>
<span class="codeline" id="line-311"><code>func goparkunlock(lock *mutex, reason waitReason, traceEv byte, traceskip int) {</code></span>
<span class="codeline" id="line-312"><code>	gopark(parkunlock_c, unsafe.Pointer(lock), reason, traceEv, traceskip)</code></span>
<span class="codeline" id="line-313"><code>}</code></span>
<span class="codeline" id="line-314"><code></code></span>
<span class="codeline" id="line-315"><code>func goready(gp *g, traceskip int) {</code></span>
<span class="codeline" id="line-316"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-317"><code>		ready(gp, traceskip, true)</code></span>
<span class="codeline" id="line-318"><code>	})</code></span>
<span class="codeline" id="line-319"><code>}</code></span>
<span class="codeline" id="line-320"><code></code></span>
<span class="codeline" id="line-321"><code>//go:nosplit</code></span>
<span class="codeline" id="line-322"><code>func acquireSudog() *sudog {</code></span>
<span class="codeline" id="line-323"><code>	// Delicate dance: the semaphore implementation calls</code></span>
<span class="codeline" id="line-324"><code>	// acquireSudog, acquireSudog calls new(sudog),</code></span>
<span class="codeline" id="line-325"><code>	// new calls malloc, malloc can call the garbage collector,</code></span>
<span class="codeline" id="line-326"><code>	// and the garbage collector calls the semaphore implementation</code></span>
<span class="codeline" id="line-327"><code>	// in stopTheWorld.</code></span>
<span class="codeline" id="line-328"><code>	// Break the cycle by doing acquirem/releasem around new(sudog).</code></span>
<span class="codeline" id="line-329"><code>	// The acquirem/releasem increments m.locks during new(sudog),</code></span>
<span class="codeline" id="line-330"><code>	// which keeps the garbage collector from being invoked.</code></span>
<span class="codeline" id="line-331"><code>	mp := acquirem()</code></span>
<span class="codeline" id="line-332"><code>	pp := mp.p.ptr()</code></span>
<span class="codeline" id="line-333"><code>	if len(pp.sudogcache) == 0 {</code></span>
<span class="codeline" id="line-334"><code>		lock(&amp;sched.sudoglock)</code></span>
<span class="codeline" id="line-335"><code>		// First, try to grab a batch from central cache.</code></span>
<span class="codeline" id="line-336"><code>		for len(pp.sudogcache) &lt; cap(pp.sudogcache)/2 &amp;&amp; sched.sudogcache != nil {</code></span>
<span class="codeline" id="line-337"><code>			s := sched.sudogcache</code></span>
<span class="codeline" id="line-338"><code>			sched.sudogcache = s.next</code></span>
<span class="codeline" id="line-339"><code>			s.next = nil</code></span>
<span class="codeline" id="line-340"><code>			pp.sudogcache = append(pp.sudogcache, s)</code></span>
<span class="codeline" id="line-341"><code>		}</code></span>
<span class="codeline" id="line-342"><code>		unlock(&amp;sched.sudoglock)</code></span>
<span class="codeline" id="line-343"><code>		// If the central cache is empty, allocate a new one.</code></span>
<span class="codeline" id="line-344"><code>		if len(pp.sudogcache) == 0 {</code></span>
<span class="codeline" id="line-345"><code>			pp.sudogcache = append(pp.sudogcache, new(sudog))</code></span>
<span class="codeline" id="line-346"><code>		}</code></span>
<span class="codeline" id="line-347"><code>	}</code></span>
<span class="codeline" id="line-348"><code>	n := len(pp.sudogcache)</code></span>
<span class="codeline" id="line-349"><code>	s := pp.sudogcache[n-1]</code></span>
<span class="codeline" id="line-350"><code>	pp.sudogcache[n-1] = nil</code></span>
<span class="codeline" id="line-351"><code>	pp.sudogcache = pp.sudogcache[:n-1]</code></span>
<span class="codeline" id="line-352"><code>	if s.elem != nil {</code></span>
<span class="codeline" id="line-353"><code>		throw("acquireSudog: found s.elem != nil in cache")</code></span>
<span class="codeline" id="line-354"><code>	}</code></span>
<span class="codeline" id="line-355"><code>	releasem(mp)</code></span>
<span class="codeline" id="line-356"><code>	return s</code></span>
<span class="codeline" id="line-357"><code>}</code></span>
<span class="codeline" id="line-358"><code></code></span>
<span class="codeline" id="line-359"><code>//go:nosplit</code></span>
<span class="codeline" id="line-360"><code>func releaseSudog(s *sudog) {</code></span>
<span class="codeline" id="line-361"><code>	if s.elem != nil {</code></span>
<span class="codeline" id="line-362"><code>		throw("runtime: sudog with non-nil elem")</code></span>
<span class="codeline" id="line-363"><code>	}</code></span>
<span class="codeline" id="line-364"><code>	if s.isSelect {</code></span>
<span class="codeline" id="line-365"><code>		throw("runtime: sudog with non-false isSelect")</code></span>
<span class="codeline" id="line-366"><code>	}</code></span>
<span class="codeline" id="line-367"><code>	if s.next != nil {</code></span>
<span class="codeline" id="line-368"><code>		throw("runtime: sudog with non-nil next")</code></span>
<span class="codeline" id="line-369"><code>	}</code></span>
<span class="codeline" id="line-370"><code>	if s.prev != nil {</code></span>
<span class="codeline" id="line-371"><code>		throw("runtime: sudog with non-nil prev")</code></span>
<span class="codeline" id="line-372"><code>	}</code></span>
<span class="codeline" id="line-373"><code>	if s.waitlink != nil {</code></span>
<span class="codeline" id="line-374"><code>		throw("runtime: sudog with non-nil waitlink")</code></span>
<span class="codeline" id="line-375"><code>	}</code></span>
<span class="codeline" id="line-376"><code>	if s.c != nil {</code></span>
<span class="codeline" id="line-377"><code>		throw("runtime: sudog with non-nil c")</code></span>
<span class="codeline" id="line-378"><code>	}</code></span>
<span class="codeline" id="line-379"><code>	gp := getg()</code></span>
<span class="codeline" id="line-380"><code>	if gp.param != nil {</code></span>
<span class="codeline" id="line-381"><code>		throw("runtime: releaseSudog with non-nil gp.param")</code></span>
<span class="codeline" id="line-382"><code>	}</code></span>
<span class="codeline" id="line-383"><code>	mp := acquirem() // avoid rescheduling to another P</code></span>
<span class="codeline" id="line-384"><code>	pp := mp.p.ptr()</code></span>
<span class="codeline" id="line-385"><code>	if len(pp.sudogcache) == cap(pp.sudogcache) {</code></span>
<span class="codeline" id="line-386"><code>		// Transfer half of local cache to the central cache.</code></span>
<span class="codeline" id="line-387"><code>		var first, last *sudog</code></span>
<span class="codeline" id="line-388"><code>		for len(pp.sudogcache) &gt; cap(pp.sudogcache)/2 {</code></span>
<span class="codeline" id="line-389"><code>			n := len(pp.sudogcache)</code></span>
<span class="codeline" id="line-390"><code>			p := pp.sudogcache[n-1]</code></span>
<span class="codeline" id="line-391"><code>			pp.sudogcache[n-1] = nil</code></span>
<span class="codeline" id="line-392"><code>			pp.sudogcache = pp.sudogcache[:n-1]</code></span>
<span class="codeline" id="line-393"><code>			if first == nil {</code></span>
<span class="codeline" id="line-394"><code>				first = p</code></span>
<span class="codeline" id="line-395"><code>			} else {</code></span>
<span class="codeline" id="line-396"><code>				last.next = p</code></span>
<span class="codeline" id="line-397"><code>			}</code></span>
<span class="codeline" id="line-398"><code>			last = p</code></span>
<span class="codeline" id="line-399"><code>		}</code></span>
<span class="codeline" id="line-400"><code>		lock(&amp;sched.sudoglock)</code></span>
<span class="codeline" id="line-401"><code>		last.next = sched.sudogcache</code></span>
<span class="codeline" id="line-402"><code>		sched.sudogcache = first</code></span>
<span class="codeline" id="line-403"><code>		unlock(&amp;sched.sudoglock)</code></span>
<span class="codeline" id="line-404"><code>	}</code></span>
<span class="codeline" id="line-405"><code>	pp.sudogcache = append(pp.sudogcache, s)</code></span>
<span class="codeline" id="line-406"><code>	releasem(mp)</code></span>
<span class="codeline" id="line-407"><code>}</code></span>
<span class="codeline" id="line-408"><code></code></span>
<span class="codeline" id="line-409"><code>// funcPC returns the entry PC of the function f.</code></span>
<span class="codeline" id="line-410"><code>// It assumes that f is a func value. Otherwise the behavior is undefined.</code></span>
<span class="codeline" id="line-411"><code>// CAREFUL: In programs with plugins, funcPC can return different values</code></span>
<span class="codeline" id="line-412"><code>// for the same function (because there are actually multiple copies of</code></span>
<span class="codeline" id="line-413"><code>// the same function in the address space). To be safe, don't use the</code></span>
<span class="codeline" id="line-414"><code>// results of this function in any == expression. It is only safe to</code></span>
<span class="codeline" id="line-415"><code>// use the result as an address at which to start executing code.</code></span>
<span class="codeline" id="line-416"><code>//go:nosplit</code></span>
<span class="codeline" id="line-417"><code>func funcPC(f interface{}) uintptr {</code></span>
<span class="codeline" id="line-418"><code>	return *(*uintptr)(efaceOf(&amp;f).data)</code></span>
<span class="codeline" id="line-419"><code>}</code></span>
<span class="codeline" id="line-420"><code></code></span>
<span class="codeline" id="line-421"><code>// called from assembly</code></span>
<span class="codeline" id="line-422"><code>func badmcall(fn func(*g)) {</code></span>
<span class="codeline" id="line-423"><code>	throw("runtime: mcall called on m-&gt;g0 stack")</code></span>
<span class="codeline" id="line-424"><code>}</code></span>
<span class="codeline" id="line-425"><code></code></span>
<span class="codeline" id="line-426"><code>func badmcall2(fn func(*g)) {</code></span>
<span class="codeline" id="line-427"><code>	throw("runtime: mcall function returned")</code></span>
<span class="codeline" id="line-428"><code>}</code></span>
<span class="codeline" id="line-429"><code></code></span>
<span class="codeline" id="line-430"><code>func badreflectcall() {</code></span>
<span class="codeline" id="line-431"><code>	panic(plainError("arg size to reflect.call more than 1GB"))</code></span>
<span class="codeline" id="line-432"><code>}</code></span>
<span class="codeline" id="line-433"><code></code></span>
<span class="codeline" id="line-434"><code>var badmorestackg0Msg = "fatal: morestack on g0\n"</code></span>
<span class="codeline" id="line-435"><code></code></span>
<span class="codeline" id="line-436"><code>//go:nosplit</code></span>
<span class="codeline" id="line-437"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-438"><code>func badmorestackg0() {</code></span>
<span class="codeline" id="line-439"><code>	sp := stringStructOf(&amp;badmorestackg0Msg)</code></span>
<span class="codeline" id="line-440"><code>	write(2, sp.str, int32(sp.len))</code></span>
<span class="codeline" id="line-441"><code>}</code></span>
<span class="codeline" id="line-442"><code></code></span>
<span class="codeline" id="line-443"><code>var badmorestackgsignalMsg = "fatal: morestack on gsignal\n"</code></span>
<span class="codeline" id="line-444"><code></code></span>
<span class="codeline" id="line-445"><code>//go:nosplit</code></span>
<span class="codeline" id="line-446"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-447"><code>func badmorestackgsignal() {</code></span>
<span class="codeline" id="line-448"><code>	sp := stringStructOf(&amp;badmorestackgsignalMsg)</code></span>
<span class="codeline" id="line-449"><code>	write(2, sp.str, int32(sp.len))</code></span>
<span class="codeline" id="line-450"><code>}</code></span>
<span class="codeline" id="line-451"><code></code></span>
<span class="codeline" id="line-452"><code>//go:nosplit</code></span>
<span class="codeline" id="line-453"><code>func badctxt() {</code></span>
<span class="codeline" id="line-454"><code>	throw("ctxt != 0")</code></span>
<span class="codeline" id="line-455"><code>}</code></span>
<span class="codeline" id="line-456"><code></code></span>
<span class="codeline" id="line-457"><code>func lockedOSThread() bool {</code></span>
<span class="codeline" id="line-458"><code>	gp := getg()</code></span>
<span class="codeline" id="line-459"><code>	return gp.lockedm != 0 &amp;&amp; gp.m.lockedg != 0</code></span>
<span class="codeline" id="line-460"><code>}</code></span>
<span class="codeline" id="line-461"><code></code></span>
<span class="codeline" id="line-462"><code>var (</code></span>
<span class="codeline" id="line-463"><code>	allgs    []*g</code></span>
<span class="codeline" id="line-464"><code>	allglock mutex</code></span>
<span class="codeline" id="line-465"><code>)</code></span>
<span class="codeline" id="line-466"><code></code></span>
<span class="codeline" id="line-467"><code>func allgadd(gp *g) {</code></span>
<span class="codeline" id="line-468"><code>	if readgstatus(gp) == _Gidle {</code></span>
<span class="codeline" id="line-469"><code>		throw("allgadd: bad status Gidle")</code></span>
<span class="codeline" id="line-470"><code>	}</code></span>
<span class="codeline" id="line-471"><code></code></span>
<span class="codeline" id="line-472"><code>	lock(&amp;allglock)</code></span>
<span class="codeline" id="line-473"><code>	allgs = append(allgs, gp)</code></span>
<span class="codeline" id="line-474"><code>	allglen = uintptr(len(allgs))</code></span>
<span class="codeline" id="line-475"><code>	unlock(&amp;allglock)</code></span>
<span class="codeline" id="line-476"><code>}</code></span>
<span class="codeline" id="line-477"><code></code></span>
<span class="codeline" id="line-478"><code>const (</code></span>
<span class="codeline" id="line-479"><code>	// Number of goroutine ids to grab from sched.goidgen to local per-P cache at once.</code></span>
<span class="codeline" id="line-480"><code>	// 16 seems to provide enough amortization, but other than that it's mostly arbitrary number.</code></span>
<span class="codeline" id="line-481"><code>	_GoidCacheBatch = 16</code></span>
<span class="codeline" id="line-482"><code>)</code></span>
<span class="codeline" id="line-483"><code></code></span>
<span class="codeline" id="line-484"><code>// cpuinit extracts the environment variable GODEBUG from the environment on</code></span>
<span class="codeline" id="line-485"><code>// Unix-like operating systems and calls internal/cpu.Initialize.</code></span>
<span class="codeline" id="line-486"><code>func cpuinit() {</code></span>
<span class="codeline" id="line-487"><code>	const prefix = "GODEBUG="</code></span>
<span class="codeline" id="line-488"><code>	var env string</code></span>
<span class="codeline" id="line-489"><code></code></span>
<span class="codeline" id="line-490"><code>	switch GOOS {</code></span>
<span class="codeline" id="line-491"><code>	case "aix", "darwin", "dragonfly", "freebsd", "netbsd", "openbsd", "illumos", "solaris", "linux":</code></span>
<span class="codeline" id="line-492"><code>		cpu.DebugOptions = true</code></span>
<span class="codeline" id="line-493"><code></code></span>
<span class="codeline" id="line-494"><code>		// Similar to goenv_unix but extracts the environment value for</code></span>
<span class="codeline" id="line-495"><code>		// GODEBUG directly.</code></span>
<span class="codeline" id="line-496"><code>		// TODO(moehrmann): remove when general goenvs() can be called before cpuinit()</code></span>
<span class="codeline" id="line-497"><code>		n := int32(0)</code></span>
<span class="codeline" id="line-498"><code>		for argv_index(argv, argc+1+n) != nil {</code></span>
<span class="codeline" id="line-499"><code>			n++</code></span>
<span class="codeline" id="line-500"><code>		}</code></span>
<span class="codeline" id="line-501"><code></code></span>
<span class="codeline" id="line-502"><code>		for i := int32(0); i &lt; n; i++ {</code></span>
<span class="codeline" id="line-503"><code>			p := argv_index(argv, argc+1+i)</code></span>
<span class="codeline" id="line-504"><code>			s := *(*string)(unsafe.Pointer(&amp;stringStruct{unsafe.Pointer(p), findnull(p)}))</code></span>
<span class="codeline" id="line-505"><code></code></span>
<span class="codeline" id="line-506"><code>			if hasPrefix(s, prefix) {</code></span>
<span class="codeline" id="line-507"><code>				env = gostring(p)[len(prefix):]</code></span>
<span class="codeline" id="line-508"><code>				break</code></span>
<span class="codeline" id="line-509"><code>			}</code></span>
<span class="codeline" id="line-510"><code>		}</code></span>
<span class="codeline" id="line-511"><code>	}</code></span>
<span class="codeline" id="line-512"><code></code></span>
<span class="codeline" id="line-513"><code>	cpu.Initialize(env)</code></span>
<span class="codeline" id="line-514"><code></code></span>
<span class="codeline" id="line-515"><code>	// Support cpu feature variables are used in code generated by the compiler</code></span>
<span class="codeline" id="line-516"><code>	// to guard execution of instructions that can not be assumed to be always supported.</code></span>
<span class="codeline" id="line-517"><code>	x86HasPOPCNT = cpu.X86.HasPOPCNT</code></span>
<span class="codeline" id="line-518"><code>	x86HasSSE41 = cpu.X86.HasSSE41</code></span>
<span class="codeline" id="line-519"><code>	x86HasFMA = cpu.X86.HasFMA</code></span>
<span class="codeline" id="line-520"><code></code></span>
<span class="codeline" id="line-521"><code>	armHasVFPv4 = cpu.ARM.HasVFPv4</code></span>
<span class="codeline" id="line-522"><code></code></span>
<span class="codeline" id="line-523"><code>	arm64HasATOMICS = cpu.ARM64.HasATOMICS</code></span>
<span class="codeline" id="line-524"><code>}</code></span>
<span class="codeline" id="line-525"><code></code></span>
<span class="codeline" id="line-526"><code>// The bootstrap sequence is:</code></span>
<span class="codeline" id="line-527"><code>//</code></span>
<span class="codeline" id="line-528"><code>//	call osinit</code></span>
<span class="codeline" id="line-529"><code>//	call schedinit</code></span>
<span class="codeline" id="line-530"><code>//	make &amp; queue new G</code></span>
<span class="codeline" id="line-531"><code>//	call runtime·mstart</code></span>
<span class="codeline" id="line-532"><code>//</code></span>
<span class="codeline" id="line-533"><code>// The new G calls runtime·main.</code></span>
<span class="codeline" id="line-534"><code>func schedinit() {</code></span>
<span class="codeline" id="line-535"><code>	lockInit(&amp;sched.lock, lockRankSched)</code></span>
<span class="codeline" id="line-536"><code>	lockInit(&amp;sched.sysmonlock, lockRankSysmon)</code></span>
<span class="codeline" id="line-537"><code>	lockInit(&amp;sched.deferlock, lockRankDefer)</code></span>
<span class="codeline" id="line-538"><code>	lockInit(&amp;sched.sudoglock, lockRankSudog)</code></span>
<span class="codeline" id="line-539"><code>	lockInit(&amp;deadlock, lockRankDeadlock)</code></span>
<span class="codeline" id="line-540"><code>	lockInit(&amp;paniclk, lockRankPanic)</code></span>
<span class="codeline" id="line-541"><code>	lockInit(&amp;allglock, lockRankAllg)</code></span>
<span class="codeline" id="line-542"><code>	lockInit(&amp;allpLock, lockRankAllp)</code></span>
<span class="codeline" id="line-543"><code>	lockInit(&amp;reflectOffs.lock, lockRankReflectOffs)</code></span>
<span class="codeline" id="line-544"><code>	lockInit(&amp;finlock, lockRankFin)</code></span>
<span class="codeline" id="line-545"><code>	lockInit(&amp;trace.bufLock, lockRankTraceBuf)</code></span>
<span class="codeline" id="line-546"><code>	lockInit(&amp;trace.stringsLock, lockRankTraceStrings)</code></span>
<span class="codeline" id="line-547"><code>	lockInit(&amp;trace.lock, lockRankTrace)</code></span>
<span class="codeline" id="line-548"><code>	lockInit(&amp;cpuprof.lock, lockRankCpuprof)</code></span>
<span class="codeline" id="line-549"><code>	lockInit(&amp;trace.stackTab.lock, lockRankTraceStackTab)</code></span>
<span class="codeline" id="line-550"><code></code></span>
<span class="codeline" id="line-551"><code>	// raceinit must be the first call to race detector.</code></span>
<span class="codeline" id="line-552"><code>	// In particular, it must be done before mallocinit below calls racemapshadow.</code></span>
<span class="codeline" id="line-553"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-554"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-555"><code>		_g_.racectx, raceprocctx0 = raceinit()</code></span>
<span class="codeline" id="line-556"><code>	}</code></span>
<span class="codeline" id="line-557"><code></code></span>
<span class="codeline" id="line-558"><code>	sched.maxmcount = 10000</code></span>
<span class="codeline" id="line-559"><code></code></span>
<span class="codeline" id="line-560"><code>	tracebackinit()</code></span>
<span class="codeline" id="line-561"><code>	moduledataverify()</code></span>
<span class="codeline" id="line-562"><code>	stackinit()</code></span>
<span class="codeline" id="line-563"><code>	mallocinit()</code></span>
<span class="codeline" id="line-564"><code>	fastrandinit() // must run before mcommoninit</code></span>
<span class="codeline" id="line-565"><code>	mcommoninit(_g_.m, -1)</code></span>
<span class="codeline" id="line-566"><code>	cpuinit()       // must run before alginit</code></span>
<span class="codeline" id="line-567"><code>	alginit()       // maps must not be used before this call</code></span>
<span class="codeline" id="line-568"><code>	modulesinit()   // provides activeModules</code></span>
<span class="codeline" id="line-569"><code>	typelinksinit() // uses maps, activeModules</code></span>
<span class="codeline" id="line-570"><code>	itabsinit()     // uses activeModules</code></span>
<span class="codeline" id="line-571"><code></code></span>
<span class="codeline" id="line-572"><code>	msigsave(_g_.m)</code></span>
<span class="codeline" id="line-573"><code>	initSigmask = _g_.m.sigmask</code></span>
<span class="codeline" id="line-574"><code></code></span>
<span class="codeline" id="line-575"><code>	goargs()</code></span>
<span class="codeline" id="line-576"><code>	goenvs()</code></span>
<span class="codeline" id="line-577"><code>	parsedebugvars()</code></span>
<span class="codeline" id="line-578"><code>	gcinit()</code></span>
<span class="codeline" id="line-579"><code></code></span>
<span class="codeline" id="line-580"><code>	sched.lastpoll = uint64(nanotime())</code></span>
<span class="codeline" id="line-581"><code>	procs := ncpu</code></span>
<span class="codeline" id="line-582"><code>	if n, ok := atoi32(gogetenv("GOMAXPROCS")); ok &amp;&amp; n &gt; 0 {</code></span>
<span class="codeline" id="line-583"><code>		procs = n</code></span>
<span class="codeline" id="line-584"><code>	}</code></span>
<span class="codeline" id="line-585"><code>	if procresize(procs) != nil {</code></span>
<span class="codeline" id="line-586"><code>		throw("unknown runnable goroutine during bootstrap")</code></span>
<span class="codeline" id="line-587"><code>	}</code></span>
<span class="codeline" id="line-588"><code></code></span>
<span class="codeline" id="line-589"><code>	// For cgocheck &gt; 1, we turn on the write barrier at all times</code></span>
<span class="codeline" id="line-590"><code>	// and check all pointer writes. We can't do this until after</code></span>
<span class="codeline" id="line-591"><code>	// procresize because the write barrier needs a P.</code></span>
<span class="codeline" id="line-592"><code>	if debug.cgocheck &gt; 1 {</code></span>
<span class="codeline" id="line-593"><code>		writeBarrier.cgo = true</code></span>
<span class="codeline" id="line-594"><code>		writeBarrier.enabled = true</code></span>
<span class="codeline" id="line-595"><code>		for _, p := range allp {</code></span>
<span class="codeline" id="line-596"><code>			p.wbBuf.reset()</code></span>
<span class="codeline" id="line-597"><code>		}</code></span>
<span class="codeline" id="line-598"><code>	}</code></span>
<span class="codeline" id="line-599"><code></code></span>
<span class="codeline" id="line-600"><code>	if buildVersion == "" {</code></span>
<span class="codeline" id="line-601"><code>		// Condition should never trigger. This code just serves</code></span>
<span class="codeline" id="line-602"><code>		// to ensure runtime·buildVersion is kept in the resulting binary.</code></span>
<span class="codeline" id="line-603"><code>		buildVersion = "unknown"</code></span>
<span class="codeline" id="line-604"><code>	}</code></span>
<span class="codeline" id="line-605"><code>	if len(modinfo) == 1 {</code></span>
<span class="codeline" id="line-606"><code>		// Condition should never trigger. This code just serves</code></span>
<span class="codeline" id="line-607"><code>		// to ensure runtime·modinfo is kept in the resulting binary.</code></span>
<span class="codeline" id="line-608"><code>		modinfo = ""</code></span>
<span class="codeline" id="line-609"><code>	}</code></span>
<span class="codeline" id="line-610"><code>}</code></span>
<span class="codeline" id="line-611"><code></code></span>
<span class="codeline" id="line-612"><code>func dumpgstatus(gp *g) {</code></span>
<span class="codeline" id="line-613"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-614"><code>	print("runtime: gp: gp=", gp, ", goid=", gp.goid, ", gp-&gt;atomicstatus=", readgstatus(gp), "\n")</code></span>
<span class="codeline" id="line-615"><code>	print("runtime:  g:  g=", _g_, ", goid=", _g_.goid, ",  g-&gt;atomicstatus=", readgstatus(_g_), "\n")</code></span>
<span class="codeline" id="line-616"><code>}</code></span>
<span class="codeline" id="line-617"><code></code></span>
<span class="codeline" id="line-618"><code>func checkmcount() {</code></span>
<span class="codeline" id="line-619"><code>	// sched lock is held</code></span>
<span class="codeline" id="line-620"><code>	if mcount() &gt; sched.maxmcount {</code></span>
<span class="codeline" id="line-621"><code>		print("runtime: program exceeds ", sched.maxmcount, "-thread limit\n")</code></span>
<span class="codeline" id="line-622"><code>		throw("thread exhaustion")</code></span>
<span class="codeline" id="line-623"><code>	}</code></span>
<span class="codeline" id="line-624"><code>}</code></span>
<span class="codeline" id="line-625"><code></code></span>
<span class="codeline" id="line-626"><code>// mReserveID returns the next ID to use for a new m. This new m is immediately</code></span>
<span class="codeline" id="line-627"><code>// considered 'running' by checkdead.</code></span>
<span class="codeline" id="line-628"><code>//</code></span>
<span class="codeline" id="line-629"><code>// sched.lock must be held.</code></span>
<span class="codeline" id="line-630"><code>func mReserveID() int64 {</code></span>
<span class="codeline" id="line-631"><code>	if sched.mnext+1 &lt; sched.mnext {</code></span>
<span class="codeline" id="line-632"><code>		throw("runtime: thread ID overflow")</code></span>
<span class="codeline" id="line-633"><code>	}</code></span>
<span class="codeline" id="line-634"><code>	id := sched.mnext</code></span>
<span class="codeline" id="line-635"><code>	sched.mnext++</code></span>
<span class="codeline" id="line-636"><code>	checkmcount()</code></span>
<span class="codeline" id="line-637"><code>	return id</code></span>
<span class="codeline" id="line-638"><code>}</code></span>
<span class="codeline" id="line-639"><code></code></span>
<span class="codeline" id="line-640"><code>// Pre-allocated ID may be passed as 'id', or omitted by passing -1.</code></span>
<span class="codeline" id="line-641"><code>func mcommoninit(mp *m, id int64) {</code></span>
<span class="codeline" id="line-642"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-643"><code></code></span>
<span class="codeline" id="line-644"><code>	// g0 stack won't make sense for user (and is not necessary unwindable).</code></span>
<span class="codeline" id="line-645"><code>	if _g_ != _g_.m.g0 {</code></span>
<span class="codeline" id="line-646"><code>		callers(1, mp.createstack[:])</code></span>
<span class="codeline" id="line-647"><code>	}</code></span>
<span class="codeline" id="line-648"><code></code></span>
<span class="codeline" id="line-649"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-650"><code></code></span>
<span class="codeline" id="line-651"><code>	if id &gt;= 0 {</code></span>
<span class="codeline" id="line-652"><code>		mp.id = id</code></span>
<span class="codeline" id="line-653"><code>	} else {</code></span>
<span class="codeline" id="line-654"><code>		mp.id = mReserveID()</code></span>
<span class="codeline" id="line-655"><code>	}</code></span>
<span class="codeline" id="line-656"><code></code></span>
<span class="codeline" id="line-657"><code>	mp.fastrand[0] = uint32(int64Hash(uint64(mp.id), fastrandseed))</code></span>
<span class="codeline" id="line-658"><code>	mp.fastrand[1] = uint32(int64Hash(uint64(cputicks()), ^fastrandseed))</code></span>
<span class="codeline" id="line-659"><code>	if mp.fastrand[0]|mp.fastrand[1] == 0 {</code></span>
<span class="codeline" id="line-660"><code>		mp.fastrand[1] = 1</code></span>
<span class="codeline" id="line-661"><code>	}</code></span>
<span class="codeline" id="line-662"><code></code></span>
<span class="codeline" id="line-663"><code>	mpreinit(mp)</code></span>
<span class="codeline" id="line-664"><code>	if mp.gsignal != nil {</code></span>
<span class="codeline" id="line-665"><code>		mp.gsignal.stackguard1 = mp.gsignal.stack.lo + _StackGuard</code></span>
<span class="codeline" id="line-666"><code>	}</code></span>
<span class="codeline" id="line-667"><code></code></span>
<span class="codeline" id="line-668"><code>	// Add to allm so garbage collector doesn't free g-&gt;m</code></span>
<span class="codeline" id="line-669"><code>	// when it is just in a register or thread-local storage.</code></span>
<span class="codeline" id="line-670"><code>	mp.alllink = allm</code></span>
<span class="codeline" id="line-671"><code></code></span>
<span class="codeline" id="line-672"><code>	// NumCgoCall() iterates over allm w/o schedlock,</code></span>
<span class="codeline" id="line-673"><code>	// so we need to publish it safely.</code></span>
<span class="codeline" id="line-674"><code>	atomicstorep(unsafe.Pointer(&amp;allm), unsafe.Pointer(mp))</code></span>
<span class="codeline" id="line-675"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-676"><code></code></span>
<span class="codeline" id="line-677"><code>	// Allocate memory to hold a cgo traceback if the cgo call crashes.</code></span>
<span class="codeline" id="line-678"><code>	if iscgo || GOOS == "solaris" || GOOS == "illumos" || GOOS == "windows" {</code></span>
<span class="codeline" id="line-679"><code>		mp.cgoCallers = new(cgoCallers)</code></span>
<span class="codeline" id="line-680"><code>	}</code></span>
<span class="codeline" id="line-681"><code>}</code></span>
<span class="codeline" id="line-682"><code></code></span>
<span class="codeline" id="line-683"><code>var fastrandseed uintptr</code></span>
<span class="codeline" id="line-684"><code></code></span>
<span class="codeline" id="line-685"><code>func fastrandinit() {</code></span>
<span class="codeline" id="line-686"><code>	s := (*[unsafe.Sizeof(fastrandseed)]byte)(unsafe.Pointer(&amp;fastrandseed))[:]</code></span>
<span class="codeline" id="line-687"><code>	getRandomData(s)</code></span>
<span class="codeline" id="line-688"><code>}</code></span>
<span class="codeline" id="line-689"><code></code></span>
<span class="codeline" id="line-690"><code>// Mark gp ready to run.</code></span>
<span class="codeline" id="line-691"><code>func ready(gp *g, traceskip int, next bool) {</code></span>
<span class="codeline" id="line-692"><code>	if trace.enabled {</code></span>
<span class="codeline" id="line-693"><code>		traceGoUnpark(gp, traceskip)</code></span>
<span class="codeline" id="line-694"><code>	}</code></span>
<span class="codeline" id="line-695"><code></code></span>
<span class="codeline" id="line-696"><code>	status := readgstatus(gp)</code></span>
<span class="codeline" id="line-697"><code></code></span>
<span class="codeline" id="line-698"><code>	// Mark runnable.</code></span>
<span class="codeline" id="line-699"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-700"><code>	mp := acquirem() // disable preemption because it can be holding p in a local var</code></span>
<span class="codeline" id="line-701"><code>	if status&amp;^_Gscan != _Gwaiting {</code></span>
<span class="codeline" id="line-702"><code>		dumpgstatus(gp)</code></span>
<span class="codeline" id="line-703"><code>		throw("bad g-&gt;status in ready")</code></span>
<span class="codeline" id="line-704"><code>	}</code></span>
<span class="codeline" id="line-705"><code></code></span>
<span class="codeline" id="line-706"><code>	// status is Gwaiting or Gscanwaiting, make Grunnable and put on runq</code></span>
<span class="codeline" id="line-707"><code>	casgstatus(gp, _Gwaiting, _Grunnable)</code></span>
<span class="codeline" id="line-708"><code>	runqput(_g_.m.p.ptr(), gp, next)</code></span>
<span class="codeline" id="line-709"><code>	wakep()</code></span>
<span class="codeline" id="line-710"><code>	releasem(mp)</code></span>
<span class="codeline" id="line-711"><code>}</code></span>
<span class="codeline" id="line-712"><code></code></span>
<span class="codeline" id="line-713"><code>// freezeStopWait is a large value that freezetheworld sets</code></span>
<span class="codeline" id="line-714"><code>// sched.stopwait to in order to request that all Gs permanently stop.</code></span>
<span class="codeline" id="line-715"><code>const freezeStopWait = 0x7fffffff</code></span>
<span class="codeline" id="line-716"><code></code></span>
<span class="codeline" id="line-717"><code>// freezing is set to non-zero if the runtime is trying to freeze the</code></span>
<span class="codeline" id="line-718"><code>// world.</code></span>
<span class="codeline" id="line-719"><code>var freezing uint32</code></span>
<span class="codeline" id="line-720"><code></code></span>
<span class="codeline" id="line-721"><code>// Similar to stopTheWorld but best-effort and can be called several times.</code></span>
<span class="codeline" id="line-722"><code>// There is no reverse operation, used during crashing.</code></span>
<span class="codeline" id="line-723"><code>// This function must not lock any mutexes.</code></span>
<span class="codeline" id="line-724"><code>func freezetheworld() {</code></span>
<span class="codeline" id="line-725"><code>	atomic.Store(&amp;freezing, 1)</code></span>
<span class="codeline" id="line-726"><code>	// stopwait and preemption requests can be lost</code></span>
<span class="codeline" id="line-727"><code>	// due to races with concurrently executing threads,</code></span>
<span class="codeline" id="line-728"><code>	// so try several times</code></span>
<span class="codeline" id="line-729"><code>	for i := 0; i &lt; 5; i++ {</code></span>
<span class="codeline" id="line-730"><code>		// this should tell the scheduler to not start any new goroutines</code></span>
<span class="codeline" id="line-731"><code>		sched.stopwait = freezeStopWait</code></span>
<span class="codeline" id="line-732"><code>		atomic.Store(&amp;sched.gcwaiting, 1)</code></span>
<span class="codeline" id="line-733"><code>		// this should stop running goroutines</code></span>
<span class="codeline" id="line-734"><code>		if !preemptall() {</code></span>
<span class="codeline" id="line-735"><code>			break // no running goroutines</code></span>
<span class="codeline" id="line-736"><code>		}</code></span>
<span class="codeline" id="line-737"><code>		usleep(1000)</code></span>
<span class="codeline" id="line-738"><code>	}</code></span>
<span class="codeline" id="line-739"><code>	// to be sure</code></span>
<span class="codeline" id="line-740"><code>	usleep(1000)</code></span>
<span class="codeline" id="line-741"><code>	preemptall()</code></span>
<span class="codeline" id="line-742"><code>	usleep(1000)</code></span>
<span class="codeline" id="line-743"><code>}</code></span>
<span class="codeline" id="line-744"><code></code></span>
<span class="codeline" id="line-745"><code>// All reads and writes of g's status go through readgstatus, casgstatus</code></span>
<span class="codeline" id="line-746"><code>// castogscanstatus, casfrom_Gscanstatus.</code></span>
<span class="codeline" id="line-747"><code>//go:nosplit</code></span>
<span class="codeline" id="line-748"><code>func readgstatus(gp *g) uint32 {</code></span>
<span class="codeline" id="line-749"><code>	return atomic.Load(&amp;gp.atomicstatus)</code></span>
<span class="codeline" id="line-750"><code>}</code></span>
<span class="codeline" id="line-751"><code></code></span>
<span class="codeline" id="line-752"><code>// The Gscanstatuses are acting like locks and this releases them.</code></span>
<span class="codeline" id="line-753"><code>// If it proves to be a performance hit we should be able to make these</code></span>
<span class="codeline" id="line-754"><code>// simple atomic stores but for now we are going to throw if</code></span>
<span class="codeline" id="line-755"><code>// we see an inconsistent state.</code></span>
<span class="codeline" id="line-756"><code>func casfrom_Gscanstatus(gp *g, oldval, newval uint32) {</code></span>
<span class="codeline" id="line-757"><code>	success := false</code></span>
<span class="codeline" id="line-758"><code></code></span>
<span class="codeline" id="line-759"><code>	// Check that transition is valid.</code></span>
<span class="codeline" id="line-760"><code>	switch oldval {</code></span>
<span class="codeline" id="line-761"><code>	default:</code></span>
<span class="codeline" id="line-762"><code>		print("runtime: casfrom_Gscanstatus bad oldval gp=", gp, ", oldval=", hex(oldval), ", newval=", hex(newval), "\n")</code></span>
<span class="codeline" id="line-763"><code>		dumpgstatus(gp)</code></span>
<span class="codeline" id="line-764"><code>		throw("casfrom_Gscanstatus:top gp-&gt;status is not in scan state")</code></span>
<span class="codeline" id="line-765"><code>	case _Gscanrunnable,</code></span>
<span class="codeline" id="line-766"><code>		_Gscanwaiting,</code></span>
<span class="codeline" id="line-767"><code>		_Gscanrunning,</code></span>
<span class="codeline" id="line-768"><code>		_Gscansyscall,</code></span>
<span class="codeline" id="line-769"><code>		_Gscanpreempted:</code></span>
<span class="codeline" id="line-770"><code>		if newval == oldval&amp;^_Gscan {</code></span>
<span class="codeline" id="line-771"><code>			success = atomic.Cas(&amp;gp.atomicstatus, oldval, newval)</code></span>
<span class="codeline" id="line-772"><code>		}</code></span>
<span class="codeline" id="line-773"><code>	}</code></span>
<span class="codeline" id="line-774"><code>	if !success {</code></span>
<span class="codeline" id="line-775"><code>		print("runtime: casfrom_Gscanstatus failed gp=", gp, ", oldval=", hex(oldval), ", newval=", hex(newval), "\n")</code></span>
<span class="codeline" id="line-776"><code>		dumpgstatus(gp)</code></span>
<span class="codeline" id="line-777"><code>		throw("casfrom_Gscanstatus: gp-&gt;status is not in scan state")</code></span>
<span class="codeline" id="line-778"><code>	}</code></span>
<span class="codeline" id="line-779"><code>	releaseLockRank(lockRankGscan)</code></span>
<span class="codeline" id="line-780"><code>}</code></span>
<span class="codeline" id="line-781"><code></code></span>
<span class="codeline" id="line-782"><code>// This will return false if the gp is not in the expected status and the cas fails.</code></span>
<span class="codeline" id="line-783"><code>// This acts like a lock acquire while the casfromgstatus acts like a lock release.</code></span>
<span class="codeline" id="line-784"><code>func castogscanstatus(gp *g, oldval, newval uint32) bool {</code></span>
<span class="codeline" id="line-785"><code>	switch oldval {</code></span>
<span class="codeline" id="line-786"><code>	case _Grunnable,</code></span>
<span class="codeline" id="line-787"><code>		_Grunning,</code></span>
<span class="codeline" id="line-788"><code>		_Gwaiting,</code></span>
<span class="codeline" id="line-789"><code>		_Gsyscall:</code></span>
<span class="codeline" id="line-790"><code>		if newval == oldval|_Gscan {</code></span>
<span class="codeline" id="line-791"><code>			r := atomic.Cas(&amp;gp.atomicstatus, oldval, newval)</code></span>
<span class="codeline" id="line-792"><code>			if r {</code></span>
<span class="codeline" id="line-793"><code>				acquireLockRank(lockRankGscan)</code></span>
<span class="codeline" id="line-794"><code>			}</code></span>
<span class="codeline" id="line-795"><code>			return r</code></span>
<span class="codeline" id="line-796"><code></code></span>
<span class="codeline" id="line-797"><code>		}</code></span>
<span class="codeline" id="line-798"><code>	}</code></span>
<span class="codeline" id="line-799"><code>	print("runtime: castogscanstatus oldval=", hex(oldval), " newval=", hex(newval), "\n")</code></span>
<span class="codeline" id="line-800"><code>	throw("castogscanstatus")</code></span>
<span class="codeline" id="line-801"><code>	panic("not reached")</code></span>
<span class="codeline" id="line-802"><code>}</code></span>
<span class="codeline" id="line-803"><code></code></span>
<span class="codeline" id="line-804"><code>// If asked to move to or from a Gscanstatus this will throw. Use the castogscanstatus</code></span>
<span class="codeline" id="line-805"><code>// and casfrom_Gscanstatus instead.</code></span>
<span class="codeline" id="line-806"><code>// casgstatus will loop if the g-&gt;atomicstatus is in a Gscan status until the routine that</code></span>
<span class="codeline" id="line-807"><code>// put it in the Gscan state is finished.</code></span>
<span class="codeline" id="line-808"><code>//go:nosplit</code></span>
<span class="codeline" id="line-809"><code>func casgstatus(gp *g, oldval, newval uint32) {</code></span>
<span class="codeline" id="line-810"><code>	if (oldval&amp;_Gscan != 0) || (newval&amp;_Gscan != 0) || oldval == newval {</code></span>
<span class="codeline" id="line-811"><code>		systemstack(func() {</code></span>
<span class="codeline" id="line-812"><code>			print("runtime: casgstatus: oldval=", hex(oldval), " newval=", hex(newval), "\n")</code></span>
<span class="codeline" id="line-813"><code>			throw("casgstatus: bad incoming values")</code></span>
<span class="codeline" id="line-814"><code>		})</code></span>
<span class="codeline" id="line-815"><code>	}</code></span>
<span class="codeline" id="line-816"><code></code></span>
<span class="codeline" id="line-817"><code>	acquireLockRank(lockRankGscan)</code></span>
<span class="codeline" id="line-818"><code>	releaseLockRank(lockRankGscan)</code></span>
<span class="codeline" id="line-819"><code></code></span>
<span class="codeline" id="line-820"><code>	// See https://golang.org/cl/21503 for justification of the yield delay.</code></span>
<span class="codeline" id="line-821"><code>	const yieldDelay = 5 * 1000</code></span>
<span class="codeline" id="line-822"><code>	var nextYield int64</code></span>
<span class="codeline" id="line-823"><code></code></span>
<span class="codeline" id="line-824"><code>	// loop if gp-&gt;atomicstatus is in a scan state giving</code></span>
<span class="codeline" id="line-825"><code>	// GC time to finish and change the state to oldval.</code></span>
<span class="codeline" id="line-826"><code>	for i := 0; !atomic.Cas(&amp;gp.atomicstatus, oldval, newval); i++ {</code></span>
<span class="codeline" id="line-827"><code>		if oldval == _Gwaiting &amp;&amp; gp.atomicstatus == _Grunnable {</code></span>
<span class="codeline" id="line-828"><code>			throw("casgstatus: waiting for Gwaiting but is Grunnable")</code></span>
<span class="codeline" id="line-829"><code>		}</code></span>
<span class="codeline" id="line-830"><code>		if i == 0 {</code></span>
<span class="codeline" id="line-831"><code>			nextYield = nanotime() + yieldDelay</code></span>
<span class="codeline" id="line-832"><code>		}</code></span>
<span class="codeline" id="line-833"><code>		if nanotime() &lt; nextYield {</code></span>
<span class="codeline" id="line-834"><code>			for x := 0; x &lt; 10 &amp;&amp; gp.atomicstatus != oldval; x++ {</code></span>
<span class="codeline" id="line-835"><code>				procyield(1)</code></span>
<span class="codeline" id="line-836"><code>			}</code></span>
<span class="codeline" id="line-837"><code>		} else {</code></span>
<span class="codeline" id="line-838"><code>			osyield()</code></span>
<span class="codeline" id="line-839"><code>			nextYield = nanotime() + yieldDelay/2</code></span>
<span class="codeline" id="line-840"><code>		}</code></span>
<span class="codeline" id="line-841"><code>	}</code></span>
<span class="codeline" id="line-842"><code>}</code></span>
<span class="codeline" id="line-843"><code></code></span>
<span class="codeline" id="line-844"><code>// casgstatus(gp, oldstatus, Gcopystack), assuming oldstatus is Gwaiting or Grunnable.</code></span>
<span class="codeline" id="line-845"><code>// Returns old status. Cannot call casgstatus directly, because we are racing with an</code></span>
<span class="codeline" id="line-846"><code>// async wakeup that might come in from netpoll. If we see Gwaiting from the readgstatus,</code></span>
<span class="codeline" id="line-847"><code>// it might have become Grunnable by the time we get to the cas. If we called casgstatus,</code></span>
<span class="codeline" id="line-848"><code>// it would loop waiting for the status to go back to Gwaiting, which it never will.</code></span>
<span class="codeline" id="line-849"><code>//go:nosplit</code></span>
<span class="codeline" id="line-850"><code>func casgcopystack(gp *g) uint32 {</code></span>
<span class="codeline" id="line-851"><code>	for {</code></span>
<span class="codeline" id="line-852"><code>		oldstatus := readgstatus(gp) &amp;^ _Gscan</code></span>
<span class="codeline" id="line-853"><code>		if oldstatus != _Gwaiting &amp;&amp; oldstatus != _Grunnable {</code></span>
<span class="codeline" id="line-854"><code>			throw("copystack: bad status, not Gwaiting or Grunnable")</code></span>
<span class="codeline" id="line-855"><code>		}</code></span>
<span class="codeline" id="line-856"><code>		if atomic.Cas(&amp;gp.atomicstatus, oldstatus, _Gcopystack) {</code></span>
<span class="codeline" id="line-857"><code>			return oldstatus</code></span>
<span class="codeline" id="line-858"><code>		}</code></span>
<span class="codeline" id="line-859"><code>	}</code></span>
<span class="codeline" id="line-860"><code>}</code></span>
<span class="codeline" id="line-861"><code></code></span>
<span class="codeline" id="line-862"><code>// casGToPreemptScan transitions gp from _Grunning to _Gscan|_Gpreempted.</code></span>
<span class="codeline" id="line-863"><code>//</code></span>
<span class="codeline" id="line-864"><code>// TODO(austin): This is the only status operation that both changes</code></span>
<span class="codeline" id="line-865"><code>// the status and locks the _Gscan bit. Rethink this.</code></span>
<span class="codeline" id="line-866"><code>func casGToPreemptScan(gp *g, old, new uint32) {</code></span>
<span class="codeline" id="line-867"><code>	if old != _Grunning || new != _Gscan|_Gpreempted {</code></span>
<span class="codeline" id="line-868"><code>		throw("bad g transition")</code></span>
<span class="codeline" id="line-869"><code>	}</code></span>
<span class="codeline" id="line-870"><code>	acquireLockRank(lockRankGscan)</code></span>
<span class="codeline" id="line-871"><code>	for !atomic.Cas(&amp;gp.atomicstatus, _Grunning, _Gscan|_Gpreempted) {</code></span>
<span class="codeline" id="line-872"><code>	}</code></span>
<span class="codeline" id="line-873"><code>}</code></span>
<span class="codeline" id="line-874"><code></code></span>
<span class="codeline" id="line-875"><code>// casGFromPreempted attempts to transition gp from _Gpreempted to</code></span>
<span class="codeline" id="line-876"><code>// _Gwaiting. If successful, the caller is responsible for</code></span>
<span class="codeline" id="line-877"><code>// re-scheduling gp.</code></span>
<span class="codeline" id="line-878"><code>func casGFromPreempted(gp *g, old, new uint32) bool {</code></span>
<span class="codeline" id="line-879"><code>	if old != _Gpreempted || new != _Gwaiting {</code></span>
<span class="codeline" id="line-880"><code>		throw("bad g transition")</code></span>
<span class="codeline" id="line-881"><code>	}</code></span>
<span class="codeline" id="line-882"><code>	return atomic.Cas(&amp;gp.atomicstatus, _Gpreempted, _Gwaiting)</code></span>
<span class="codeline" id="line-883"><code>}</code></span>
<span class="codeline" id="line-884"><code></code></span>
<span class="codeline" id="line-885"><code>// stopTheWorld stops all P's from executing goroutines, interrupting</code></span>
<span class="codeline" id="line-886"><code>// all goroutines at GC safe points and records reason as the reason</code></span>
<span class="codeline" id="line-887"><code>// for the stop. On return, only the current goroutine's P is running.</code></span>
<span class="codeline" id="line-888"><code>// stopTheWorld must not be called from a system stack and the caller</code></span>
<span class="codeline" id="line-889"><code>// must not hold worldsema. The caller must call startTheWorld when</code></span>
<span class="codeline" id="line-890"><code>// other P's should resume execution.</code></span>
<span class="codeline" id="line-891"><code>//</code></span>
<span class="codeline" id="line-892"><code>// stopTheWorld is safe for multiple goroutines to call at the</code></span>
<span class="codeline" id="line-893"><code>// same time. Each will execute its own stop, and the stops will</code></span>
<span class="codeline" id="line-894"><code>// be serialized.</code></span>
<span class="codeline" id="line-895"><code>//</code></span>
<span class="codeline" id="line-896"><code>// This is also used by routines that do stack dumps. If the system is</code></span>
<span class="codeline" id="line-897"><code>// in panic or being exited, this may not reliably stop all</code></span>
<span class="codeline" id="line-898"><code>// goroutines.</code></span>
<span class="codeline" id="line-899"><code>func stopTheWorld(reason string) {</code></span>
<span class="codeline" id="line-900"><code>	semacquire(&amp;worldsema)</code></span>
<span class="codeline" id="line-901"><code>	gp := getg()</code></span>
<span class="codeline" id="line-902"><code>	gp.m.preemptoff = reason</code></span>
<span class="codeline" id="line-903"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-904"><code>		// Mark the goroutine which called stopTheWorld preemptible so its</code></span>
<span class="codeline" id="line-905"><code>		// stack may be scanned.</code></span>
<span class="codeline" id="line-906"><code>		// This lets a mark worker scan us while we try to stop the world</code></span>
<span class="codeline" id="line-907"><code>		// since otherwise we could get in a mutual preemption deadlock.</code></span>
<span class="codeline" id="line-908"><code>		// We must not modify anything on the G stack because a stack shrink</code></span>
<span class="codeline" id="line-909"><code>		// may occur. A stack shrink is otherwise OK though because in order</code></span>
<span class="codeline" id="line-910"><code>		// to return from this function (and to leave the system stack) we</code></span>
<span class="codeline" id="line-911"><code>		// must have preempted all goroutines, including any attempting</code></span>
<span class="codeline" id="line-912"><code>		// to scan our stack, in which case, any stack shrinking will</code></span>
<span class="codeline" id="line-913"><code>		// have already completed by the time we exit.</code></span>
<span class="codeline" id="line-914"><code>		casgstatus(gp, _Grunning, _Gwaiting)</code></span>
<span class="codeline" id="line-915"><code>		stopTheWorldWithSema()</code></span>
<span class="codeline" id="line-916"><code>		casgstatus(gp, _Gwaiting, _Grunning)</code></span>
<span class="codeline" id="line-917"><code>	})</code></span>
<span class="codeline" id="line-918"><code>}</code></span>
<span class="codeline" id="line-919"><code></code></span>
<span class="codeline" id="line-920"><code>// startTheWorld undoes the effects of stopTheWorld.</code></span>
<span class="codeline" id="line-921"><code>func startTheWorld() {</code></span>
<span class="codeline" id="line-922"><code>	systemstack(func() { startTheWorldWithSema(false) })</code></span>
<span class="codeline" id="line-923"><code>	// worldsema must be held over startTheWorldWithSema to ensure</code></span>
<span class="codeline" id="line-924"><code>	// gomaxprocs cannot change while worldsema is held.</code></span>
<span class="codeline" id="line-925"><code>	semrelease(&amp;worldsema)</code></span>
<span class="codeline" id="line-926"><code>	getg().m.preemptoff = ""</code></span>
<span class="codeline" id="line-927"><code>}</code></span>
<span class="codeline" id="line-928"><code></code></span>
<span class="codeline" id="line-929"><code>// stopTheWorldGC has the same effect as stopTheWorld, but blocks</code></span>
<span class="codeline" id="line-930"><code>// until the GC is not running. It also blocks a GC from starting</code></span>
<span class="codeline" id="line-931"><code>// until startTheWorldGC is called.</code></span>
<span class="codeline" id="line-932"><code>func stopTheWorldGC(reason string) {</code></span>
<span class="codeline" id="line-933"><code>	semacquire(&amp;gcsema)</code></span>
<span class="codeline" id="line-934"><code>	stopTheWorld(reason)</code></span>
<span class="codeline" id="line-935"><code>}</code></span>
<span class="codeline" id="line-936"><code></code></span>
<span class="codeline" id="line-937"><code>// startTheWorldGC undoes the effects of stopTheWorldGC.</code></span>
<span class="codeline" id="line-938"><code>func startTheWorldGC() {</code></span>
<span class="codeline" id="line-939"><code>	startTheWorld()</code></span>
<span class="codeline" id="line-940"><code>	semrelease(&amp;gcsema)</code></span>
<span class="codeline" id="line-941"><code>}</code></span>
<span class="codeline" id="line-942"><code></code></span>
<span class="codeline" id="line-943"><code>// Holding worldsema grants an M the right to try to stop the world.</code></span>
<span class="codeline" id="line-944"><code>var worldsema uint32 = 1</code></span>
<span class="codeline" id="line-945"><code></code></span>
<span class="codeline" id="line-946"><code>// Holding gcsema grants the M the right to block a GC, and blocks</code></span>
<span class="codeline" id="line-947"><code>// until the current GC is done. In particular, it prevents gomaxprocs</code></span>
<span class="codeline" id="line-948"><code>// from changing concurrently.</code></span>
<span class="codeline" id="line-949"><code>//</code></span>
<span class="codeline" id="line-950"><code>// TODO(mknyszek): Once gomaxprocs and the execution tracer can handle</code></span>
<span class="codeline" id="line-951"><code>// being changed/enabled during a GC, remove this.</code></span>
<span class="codeline" id="line-952"><code>var gcsema uint32 = 1</code></span>
<span class="codeline" id="line-953"><code></code></span>
<span class="codeline" id="line-954"><code>// stopTheWorldWithSema is the core implementation of stopTheWorld.</code></span>
<span class="codeline" id="line-955"><code>// The caller is responsible for acquiring worldsema and disabling</code></span>
<span class="codeline" id="line-956"><code>// preemption first and then should stopTheWorldWithSema on the system</code></span>
<span class="codeline" id="line-957"><code>// stack:</code></span>
<span class="codeline" id="line-958"><code>//</code></span>
<span class="codeline" id="line-959"><code>//	semacquire(&amp;worldsema, 0)</code></span>
<span class="codeline" id="line-960"><code>//	m.preemptoff = "reason"</code></span>
<span class="codeline" id="line-961"><code>//	systemstack(stopTheWorldWithSema)</code></span>
<span class="codeline" id="line-962"><code>//</code></span>
<span class="codeline" id="line-963"><code>// When finished, the caller must either call startTheWorld or undo</code></span>
<span class="codeline" id="line-964"><code>// these three operations separately:</code></span>
<span class="codeline" id="line-965"><code>//</code></span>
<span class="codeline" id="line-966"><code>//	m.preemptoff = ""</code></span>
<span class="codeline" id="line-967"><code>//	systemstack(startTheWorldWithSema)</code></span>
<span class="codeline" id="line-968"><code>//	semrelease(&amp;worldsema)</code></span>
<span class="codeline" id="line-969"><code>//</code></span>
<span class="codeline" id="line-970"><code>// It is allowed to acquire worldsema once and then execute multiple</code></span>
<span class="codeline" id="line-971"><code>// startTheWorldWithSema/stopTheWorldWithSema pairs.</code></span>
<span class="codeline" id="line-972"><code>// Other P's are able to execute between successive calls to</code></span>
<span class="codeline" id="line-973"><code>// startTheWorldWithSema and stopTheWorldWithSema.</code></span>
<span class="codeline" id="line-974"><code>// Holding worldsema causes any other goroutines invoking</code></span>
<span class="codeline" id="line-975"><code>// stopTheWorld to block.</code></span>
<span class="codeline" id="line-976"><code>func stopTheWorldWithSema() {</code></span>
<span class="codeline" id="line-977"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-978"><code></code></span>
<span class="codeline" id="line-979"><code>	// If we hold a lock, then we won't be able to stop another M</code></span>
<span class="codeline" id="line-980"><code>	// that is blocked trying to acquire the lock.</code></span>
<span class="codeline" id="line-981"><code>	if _g_.m.locks &gt; 0 {</code></span>
<span class="codeline" id="line-982"><code>		throw("stopTheWorld: holding locks")</code></span>
<span class="codeline" id="line-983"><code>	}</code></span>
<span class="codeline" id="line-984"><code></code></span>
<span class="codeline" id="line-985"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-986"><code>	sched.stopwait = gomaxprocs</code></span>
<span class="codeline" id="line-987"><code>	atomic.Store(&amp;sched.gcwaiting, 1)</code></span>
<span class="codeline" id="line-988"><code>	preemptall()</code></span>
<span class="codeline" id="line-989"><code>	// stop current P</code></span>
<span class="codeline" id="line-990"><code>	_g_.m.p.ptr().status = _Pgcstop // Pgcstop is only diagnostic.</code></span>
<span class="codeline" id="line-991"><code>	sched.stopwait--</code></span>
<span class="codeline" id="line-992"><code>	// try to retake all P's in Psyscall status</code></span>
<span class="codeline" id="line-993"><code>	for _, p := range allp {</code></span>
<span class="codeline" id="line-994"><code>		s := p.status</code></span>
<span class="codeline" id="line-995"><code>		if s == _Psyscall &amp;&amp; atomic.Cas(&amp;p.status, s, _Pgcstop) {</code></span>
<span class="codeline" id="line-996"><code>			if trace.enabled {</code></span>
<span class="codeline" id="line-997"><code>				traceGoSysBlock(p)</code></span>
<span class="codeline" id="line-998"><code>				traceProcStop(p)</code></span>
<span class="codeline" id="line-999"><code>			}</code></span>
<span class="codeline" id="line-1000"><code>			p.syscalltick++</code></span>
<span class="codeline" id="line-1001"><code>			sched.stopwait--</code></span>
<span class="codeline" id="line-1002"><code>		}</code></span>
<span class="codeline" id="line-1003"><code>	}</code></span>
<span class="codeline" id="line-1004"><code>	// stop idle P's</code></span>
<span class="codeline" id="line-1005"><code>	for {</code></span>
<span class="codeline" id="line-1006"><code>		p := pidleget()</code></span>
<span class="codeline" id="line-1007"><code>		if p == nil {</code></span>
<span class="codeline" id="line-1008"><code>			break</code></span>
<span class="codeline" id="line-1009"><code>		}</code></span>
<span class="codeline" id="line-1010"><code>		p.status = _Pgcstop</code></span>
<span class="codeline" id="line-1011"><code>		sched.stopwait--</code></span>
<span class="codeline" id="line-1012"><code>	}</code></span>
<span class="codeline" id="line-1013"><code>	wait := sched.stopwait &gt; 0</code></span>
<span class="codeline" id="line-1014"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1015"><code></code></span>
<span class="codeline" id="line-1016"><code>	// wait for remaining P's to stop voluntarily</code></span>
<span class="codeline" id="line-1017"><code>	if wait {</code></span>
<span class="codeline" id="line-1018"><code>		for {</code></span>
<span class="codeline" id="line-1019"><code>			// wait for 100us, then try to re-preempt in case of any races</code></span>
<span class="codeline" id="line-1020"><code>			if notetsleep(&amp;sched.stopnote, 100*1000) {</code></span>
<span class="codeline" id="line-1021"><code>				noteclear(&amp;sched.stopnote)</code></span>
<span class="codeline" id="line-1022"><code>				break</code></span>
<span class="codeline" id="line-1023"><code>			}</code></span>
<span class="codeline" id="line-1024"><code>			preemptall()</code></span>
<span class="codeline" id="line-1025"><code>		}</code></span>
<span class="codeline" id="line-1026"><code>	}</code></span>
<span class="codeline" id="line-1027"><code></code></span>
<span class="codeline" id="line-1028"><code>	// sanity checks</code></span>
<span class="codeline" id="line-1029"><code>	bad := ""</code></span>
<span class="codeline" id="line-1030"><code>	if sched.stopwait != 0 {</code></span>
<span class="codeline" id="line-1031"><code>		bad = "stopTheWorld: not stopped (stopwait != 0)"</code></span>
<span class="codeline" id="line-1032"><code>	} else {</code></span>
<span class="codeline" id="line-1033"><code>		for _, p := range allp {</code></span>
<span class="codeline" id="line-1034"><code>			if p.status != _Pgcstop {</code></span>
<span class="codeline" id="line-1035"><code>				bad = "stopTheWorld: not stopped (status != _Pgcstop)"</code></span>
<span class="codeline" id="line-1036"><code>			}</code></span>
<span class="codeline" id="line-1037"><code>		}</code></span>
<span class="codeline" id="line-1038"><code>	}</code></span>
<span class="codeline" id="line-1039"><code>	if atomic.Load(&amp;freezing) != 0 {</code></span>
<span class="codeline" id="line-1040"><code>		// Some other thread is panicking. This can cause the</code></span>
<span class="codeline" id="line-1041"><code>		// sanity checks above to fail if the panic happens in</code></span>
<span class="codeline" id="line-1042"><code>		// the signal handler on a stopped thread. Either way,</code></span>
<span class="codeline" id="line-1043"><code>		// we should halt this thread.</code></span>
<span class="codeline" id="line-1044"><code>		lock(&amp;deadlock)</code></span>
<span class="codeline" id="line-1045"><code>		lock(&amp;deadlock)</code></span>
<span class="codeline" id="line-1046"><code>	}</code></span>
<span class="codeline" id="line-1047"><code>	if bad != "" {</code></span>
<span class="codeline" id="line-1048"><code>		throw(bad)</code></span>
<span class="codeline" id="line-1049"><code>	}</code></span>
<span class="codeline" id="line-1050"><code>}</code></span>
<span class="codeline" id="line-1051"><code></code></span>
<span class="codeline" id="line-1052"><code>func startTheWorldWithSema(emitTraceEvent bool) int64 {</code></span>
<span class="codeline" id="line-1053"><code>	mp := acquirem() // disable preemption because it can be holding p in a local var</code></span>
<span class="codeline" id="line-1054"><code>	if netpollinited() {</code></span>
<span class="codeline" id="line-1055"><code>		list := netpoll(0) // non-blocking</code></span>
<span class="codeline" id="line-1056"><code>		injectglist(&amp;list)</code></span>
<span class="codeline" id="line-1057"><code>	}</code></span>
<span class="codeline" id="line-1058"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1059"><code></code></span>
<span class="codeline" id="line-1060"><code>	procs := gomaxprocs</code></span>
<span class="codeline" id="line-1061"><code>	if newprocs != 0 {</code></span>
<span class="codeline" id="line-1062"><code>		procs = newprocs</code></span>
<span class="codeline" id="line-1063"><code>		newprocs = 0</code></span>
<span class="codeline" id="line-1064"><code>	}</code></span>
<span class="codeline" id="line-1065"><code>	p1 := procresize(procs)</code></span>
<span class="codeline" id="line-1066"><code>	sched.gcwaiting = 0</code></span>
<span class="codeline" id="line-1067"><code>	if sched.sysmonwait != 0 {</code></span>
<span class="codeline" id="line-1068"><code>		sched.sysmonwait = 0</code></span>
<span class="codeline" id="line-1069"><code>		notewakeup(&amp;sched.sysmonnote)</code></span>
<span class="codeline" id="line-1070"><code>	}</code></span>
<span class="codeline" id="line-1071"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1072"><code></code></span>
<span class="codeline" id="line-1073"><code>	for p1 != nil {</code></span>
<span class="codeline" id="line-1074"><code>		p := p1</code></span>
<span class="codeline" id="line-1075"><code>		p1 = p1.link.ptr()</code></span>
<span class="codeline" id="line-1076"><code>		if p.m != 0 {</code></span>
<span class="codeline" id="line-1077"><code>			mp := p.m.ptr()</code></span>
<span class="codeline" id="line-1078"><code>			p.m = 0</code></span>
<span class="codeline" id="line-1079"><code>			if mp.nextp != 0 {</code></span>
<span class="codeline" id="line-1080"><code>				throw("startTheWorld: inconsistent mp-&gt;nextp")</code></span>
<span class="codeline" id="line-1081"><code>			}</code></span>
<span class="codeline" id="line-1082"><code>			mp.nextp.set(p)</code></span>
<span class="codeline" id="line-1083"><code>			notewakeup(&amp;mp.park)</code></span>
<span class="codeline" id="line-1084"><code>		} else {</code></span>
<span class="codeline" id="line-1085"><code>			// Start M to run P.  Do not start another M below.</code></span>
<span class="codeline" id="line-1086"><code>			newm(nil, p, -1)</code></span>
<span class="codeline" id="line-1087"><code>		}</code></span>
<span class="codeline" id="line-1088"><code>	}</code></span>
<span class="codeline" id="line-1089"><code></code></span>
<span class="codeline" id="line-1090"><code>	// Capture start-the-world time before doing clean-up tasks.</code></span>
<span class="codeline" id="line-1091"><code>	startTime := nanotime()</code></span>
<span class="codeline" id="line-1092"><code>	if emitTraceEvent {</code></span>
<span class="codeline" id="line-1093"><code>		traceGCSTWDone()</code></span>
<span class="codeline" id="line-1094"><code>	}</code></span>
<span class="codeline" id="line-1095"><code></code></span>
<span class="codeline" id="line-1096"><code>	// Wakeup an additional proc in case we have excessive runnable goroutines</code></span>
<span class="codeline" id="line-1097"><code>	// in local queues or in the global queue. If we don't, the proc will park itself.</code></span>
<span class="codeline" id="line-1098"><code>	// If we have lots of excessive work, resetspinning will unpark additional procs as necessary.</code></span>
<span class="codeline" id="line-1099"><code>	wakep()</code></span>
<span class="codeline" id="line-1100"><code></code></span>
<span class="codeline" id="line-1101"><code>	releasem(mp)</code></span>
<span class="codeline" id="line-1102"><code></code></span>
<span class="codeline" id="line-1103"><code>	return startTime</code></span>
<span class="codeline" id="line-1104"><code>}</code></span>
<span class="codeline" id="line-1105"><code></code></span>
<span class="codeline" id="line-1106"><code>// mstart is the entry-point for new Ms.</code></span>
<span class="codeline" id="line-1107"><code>//</code></span>
<span class="codeline" id="line-1108"><code>// This must not split the stack because we may not even have stack</code></span>
<span class="codeline" id="line-1109"><code>// bounds set up yet.</code></span>
<span class="codeline" id="line-1110"><code>//</code></span>
<span class="codeline" id="line-1111"><code>// May run during STW (because it doesn't have a P yet), so write</code></span>
<span class="codeline" id="line-1112"><code>// barriers are not allowed.</code></span>
<span class="codeline" id="line-1113"><code>//</code></span>
<span class="codeline" id="line-1114"><code>//go:nosplit</code></span>
<span class="codeline" id="line-1115"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-1116"><code>func mstart() {</code></span>
<span class="codeline" id="line-1117"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-1118"><code></code></span>
<span class="codeline" id="line-1119"><code>	osStack := _g_.stack.lo == 0</code></span>
<span class="codeline" id="line-1120"><code>	if osStack {</code></span>
<span class="codeline" id="line-1121"><code>		// Initialize stack bounds from system stack.</code></span>
<span class="codeline" id="line-1122"><code>		// Cgo may have left stack size in stack.hi.</code></span>
<span class="codeline" id="line-1123"><code>		// minit may update the stack bounds.</code></span>
<span class="codeline" id="line-1124"><code>		size := _g_.stack.hi</code></span>
<span class="codeline" id="line-1125"><code>		if size == 0 {</code></span>
<span class="codeline" id="line-1126"><code>			size = 8192 * sys.StackGuardMultiplier</code></span>
<span class="codeline" id="line-1127"><code>		}</code></span>
<span class="codeline" id="line-1128"><code>		_g_.stack.hi = uintptr(noescape(unsafe.Pointer(&amp;size)))</code></span>
<span class="codeline" id="line-1129"><code>		_g_.stack.lo = _g_.stack.hi - size + 1024</code></span>
<span class="codeline" id="line-1130"><code>	}</code></span>
<span class="codeline" id="line-1131"><code>	// Initialize stack guard so that we can start calling regular</code></span>
<span class="codeline" id="line-1132"><code>	// Go code.</code></span>
<span class="codeline" id="line-1133"><code>	_g_.stackguard0 = _g_.stack.lo + _StackGuard</code></span>
<span class="codeline" id="line-1134"><code>	// This is the g0, so we can also call go:systemstack</code></span>
<span class="codeline" id="line-1135"><code>	// functions, which check stackguard1.</code></span>
<span class="codeline" id="line-1136"><code>	_g_.stackguard1 = _g_.stackguard0</code></span>
<span class="codeline" id="line-1137"><code>	mstart1()</code></span>
<span class="codeline" id="line-1138"><code></code></span>
<span class="codeline" id="line-1139"><code>	// Exit this thread.</code></span>
<span class="codeline" id="line-1140"><code>	switch GOOS {</code></span>
<span class="codeline" id="line-1141"><code>	case "windows", "solaris", "illumos", "plan9", "darwin", "aix":</code></span>
<span class="codeline" id="line-1142"><code>		// Windows, Solaris, illumos, Darwin, AIX and Plan 9 always system-allocate</code></span>
<span class="codeline" id="line-1143"><code>		// the stack, but put it in _g_.stack before mstart,</code></span>
<span class="codeline" id="line-1144"><code>		// so the logic above hasn't set osStack yet.</code></span>
<span class="codeline" id="line-1145"><code>		osStack = true</code></span>
<span class="codeline" id="line-1146"><code>	}</code></span>
<span class="codeline" id="line-1147"><code>	mexit(osStack)</code></span>
<span class="codeline" id="line-1148"><code>}</code></span>
<span class="codeline" id="line-1149"><code></code></span>
<span class="codeline" id="line-1150"><code>func mstart1() {</code></span>
<span class="codeline" id="line-1151"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-1152"><code></code></span>
<span class="codeline" id="line-1153"><code>	if _g_ != _g_.m.g0 {</code></span>
<span class="codeline" id="line-1154"><code>		throw("bad runtime·mstart")</code></span>
<span class="codeline" id="line-1155"><code>	}</code></span>
<span class="codeline" id="line-1156"><code></code></span>
<span class="codeline" id="line-1157"><code>	// Record the caller for use as the top of stack in mcall and</code></span>
<span class="codeline" id="line-1158"><code>	// for terminating the thread.</code></span>
<span class="codeline" id="line-1159"><code>	// We're never coming back to mstart1 after we call schedule,</code></span>
<span class="codeline" id="line-1160"><code>	// so other calls can reuse the current frame.</code></span>
<span class="codeline" id="line-1161"><code>	save(getcallerpc(), getcallersp())</code></span>
<span class="codeline" id="line-1162"><code>	asminit()</code></span>
<span class="codeline" id="line-1163"><code>	minit()</code></span>
<span class="codeline" id="line-1164"><code></code></span>
<span class="codeline" id="line-1165"><code>	// Install signal handlers; after minit so that minit can</code></span>
<span class="codeline" id="line-1166"><code>	// prepare the thread to be able to handle the signals.</code></span>
<span class="codeline" id="line-1167"><code>	if _g_.m == &amp;m0 {</code></span>
<span class="codeline" id="line-1168"><code>		mstartm0()</code></span>
<span class="codeline" id="line-1169"><code>	}</code></span>
<span class="codeline" id="line-1170"><code></code></span>
<span class="codeline" id="line-1171"><code>	if fn := _g_.m.mstartfn; fn != nil {</code></span>
<span class="codeline" id="line-1172"><code>		fn()</code></span>
<span class="codeline" id="line-1173"><code>	}</code></span>
<span class="codeline" id="line-1174"><code></code></span>
<span class="codeline" id="line-1175"><code>	if _g_.m != &amp;m0 {</code></span>
<span class="codeline" id="line-1176"><code>		acquirep(_g_.m.nextp.ptr())</code></span>
<span class="codeline" id="line-1177"><code>		_g_.m.nextp = 0</code></span>
<span class="codeline" id="line-1178"><code>	}</code></span>
<span class="codeline" id="line-1179"><code>	schedule()</code></span>
<span class="codeline" id="line-1180"><code>}</code></span>
<span class="codeline" id="line-1181"><code></code></span>
<span class="codeline" id="line-1182"><code>// mstartm0 implements part of mstart1 that only runs on the m0.</code></span>
<span class="codeline" id="line-1183"><code>//</code></span>
<span class="codeline" id="line-1184"><code>// Write barriers are allowed here because we know the GC can't be</code></span>
<span class="codeline" id="line-1185"><code>// running yet, so they'll be no-ops.</code></span>
<span class="codeline" id="line-1186"><code>//</code></span>
<span class="codeline" id="line-1187"><code>//go:yeswritebarrierrec</code></span>
<span class="codeline" id="line-1188"><code>func mstartm0() {</code></span>
<span class="codeline" id="line-1189"><code>	// Create an extra M for callbacks on threads not created by Go.</code></span>
<span class="codeline" id="line-1190"><code>	// An extra M is also needed on Windows for callbacks created by</code></span>
<span class="codeline" id="line-1191"><code>	// syscall.NewCallback. See issue #6751 for details.</code></span>
<span class="codeline" id="line-1192"><code>	if (iscgo || GOOS == "windows") &amp;&amp; !cgoHasExtraM {</code></span>
<span class="codeline" id="line-1193"><code>		cgoHasExtraM = true</code></span>
<span class="codeline" id="line-1194"><code>		newextram()</code></span>
<span class="codeline" id="line-1195"><code>	}</code></span>
<span class="codeline" id="line-1196"><code>	initsig(false)</code></span>
<span class="codeline" id="line-1197"><code>}</code></span>
<span class="codeline" id="line-1198"><code></code></span>
<span class="codeline" id="line-1199"><code>// mexit tears down and exits the current thread.</code></span>
<span class="codeline" id="line-1200"><code>//</code></span>
<span class="codeline" id="line-1201"><code>// Don't call this directly to exit the thread, since it must run at</code></span>
<span class="codeline" id="line-1202"><code>// the top of the thread stack. Instead, use gogo(&amp;_g_.m.g0.sched) to</code></span>
<span class="codeline" id="line-1203"><code>// unwind the stack to the point that exits the thread.</code></span>
<span class="codeline" id="line-1204"><code>//</code></span>
<span class="codeline" id="line-1205"><code>// It is entered with m.p != nil, so write barriers are allowed. It</code></span>
<span class="codeline" id="line-1206"><code>// will release the P before exiting.</code></span>
<span class="codeline" id="line-1207"><code>//</code></span>
<span class="codeline" id="line-1208"><code>//go:yeswritebarrierrec</code></span>
<span class="codeline" id="line-1209"><code>func mexit(osStack bool) {</code></span>
<span class="codeline" id="line-1210"><code>	g := getg()</code></span>
<span class="codeline" id="line-1211"><code>	m := g.m</code></span>
<span class="codeline" id="line-1212"><code></code></span>
<span class="codeline" id="line-1213"><code>	if m == &amp;m0 {</code></span>
<span class="codeline" id="line-1214"><code>		// This is the main thread. Just wedge it.</code></span>
<span class="codeline" id="line-1215"><code>		//</code></span>
<span class="codeline" id="line-1216"><code>		// On Linux, exiting the main thread puts the process</code></span>
<span class="codeline" id="line-1217"><code>		// into a non-waitable zombie state. On Plan 9,</code></span>
<span class="codeline" id="line-1218"><code>		// exiting the main thread unblocks wait even though</code></span>
<span class="codeline" id="line-1219"><code>		// other threads are still running. On Solaris we can</code></span>
<span class="codeline" id="line-1220"><code>		// neither exitThread nor return from mstart. Other</code></span>
<span class="codeline" id="line-1221"><code>		// bad things probably happen on other platforms.</code></span>
<span class="codeline" id="line-1222"><code>		//</code></span>
<span class="codeline" id="line-1223"><code>		// We could try to clean up this M more before wedging</code></span>
<span class="codeline" id="line-1224"><code>		// it, but that complicates signal handling.</code></span>
<span class="codeline" id="line-1225"><code>		handoffp(releasep())</code></span>
<span class="codeline" id="line-1226"><code>		lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1227"><code>		sched.nmfreed++</code></span>
<span class="codeline" id="line-1228"><code>		checkdead()</code></span>
<span class="codeline" id="line-1229"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1230"><code>		notesleep(&amp;m.park)</code></span>
<span class="codeline" id="line-1231"><code>		throw("locked m0 woke up")</code></span>
<span class="codeline" id="line-1232"><code>	}</code></span>
<span class="codeline" id="line-1233"><code></code></span>
<span class="codeline" id="line-1234"><code>	sigblock()</code></span>
<span class="codeline" id="line-1235"><code>	unminit()</code></span>
<span class="codeline" id="line-1236"><code></code></span>
<span class="codeline" id="line-1237"><code>	// Free the gsignal stack.</code></span>
<span class="codeline" id="line-1238"><code>	if m.gsignal != nil {</code></span>
<span class="codeline" id="line-1239"><code>		stackfree(m.gsignal.stack)</code></span>
<span class="codeline" id="line-1240"><code>		// On some platforms, when calling into VDSO (e.g. nanotime)</code></span>
<span class="codeline" id="line-1241"><code>		// we store our g on the gsignal stack, if there is one.</code></span>
<span class="codeline" id="line-1242"><code>		// Now the stack is freed, unlink it from the m, so we</code></span>
<span class="codeline" id="line-1243"><code>		// won't write to it when calling VDSO code.</code></span>
<span class="codeline" id="line-1244"><code>		m.gsignal = nil</code></span>
<span class="codeline" id="line-1245"><code>	}</code></span>
<span class="codeline" id="line-1246"><code></code></span>
<span class="codeline" id="line-1247"><code>	// Remove m from allm.</code></span>
<span class="codeline" id="line-1248"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1249"><code>	for pprev := &amp;allm; *pprev != nil; pprev = &amp;(*pprev).alllink {</code></span>
<span class="codeline" id="line-1250"><code>		if *pprev == m {</code></span>
<span class="codeline" id="line-1251"><code>			*pprev = m.alllink</code></span>
<span class="codeline" id="line-1252"><code>			goto found</code></span>
<span class="codeline" id="line-1253"><code>		}</code></span>
<span class="codeline" id="line-1254"><code>	}</code></span>
<span class="codeline" id="line-1255"><code>	throw("m not found in allm")</code></span>
<span class="codeline" id="line-1256"><code>found:</code></span>
<span class="codeline" id="line-1257"><code>	if !osStack {</code></span>
<span class="codeline" id="line-1258"><code>		// Delay reaping m until it's done with the stack.</code></span>
<span class="codeline" id="line-1259"><code>		//</code></span>
<span class="codeline" id="line-1260"><code>		// If this is using an OS stack, the OS will free it</code></span>
<span class="codeline" id="line-1261"><code>		// so there's no need for reaping.</code></span>
<span class="codeline" id="line-1262"><code>		atomic.Store(&amp;m.freeWait, 1)</code></span>
<span class="codeline" id="line-1263"><code>		// Put m on the free list, though it will not be reaped until</code></span>
<span class="codeline" id="line-1264"><code>		// freeWait is 0. Note that the free list must not be linked</code></span>
<span class="codeline" id="line-1265"><code>		// through alllink because some functions walk allm without</code></span>
<span class="codeline" id="line-1266"><code>		// locking, so may be using alllink.</code></span>
<span class="codeline" id="line-1267"><code>		m.freelink = sched.freem</code></span>
<span class="codeline" id="line-1268"><code>		sched.freem = m</code></span>
<span class="codeline" id="line-1269"><code>	}</code></span>
<span class="codeline" id="line-1270"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1271"><code></code></span>
<span class="codeline" id="line-1272"><code>	// Release the P.</code></span>
<span class="codeline" id="line-1273"><code>	handoffp(releasep())</code></span>
<span class="codeline" id="line-1274"><code>	// After this point we must not have write barriers.</code></span>
<span class="codeline" id="line-1275"><code></code></span>
<span class="codeline" id="line-1276"><code>	// Invoke the deadlock detector. This must happen after</code></span>
<span class="codeline" id="line-1277"><code>	// handoffp because it may have started a new M to take our</code></span>
<span class="codeline" id="line-1278"><code>	// P's work.</code></span>
<span class="codeline" id="line-1279"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1280"><code>	sched.nmfreed++</code></span>
<span class="codeline" id="line-1281"><code>	checkdead()</code></span>
<span class="codeline" id="line-1282"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1283"><code></code></span>
<span class="codeline" id="line-1284"><code>	if osStack {</code></span>
<span class="codeline" id="line-1285"><code>		// Return from mstart and let the system thread</code></span>
<span class="codeline" id="line-1286"><code>		// library free the g0 stack and terminate the thread.</code></span>
<span class="codeline" id="line-1287"><code>		return</code></span>
<span class="codeline" id="line-1288"><code>	}</code></span>
<span class="codeline" id="line-1289"><code></code></span>
<span class="codeline" id="line-1290"><code>	// mstart is the thread's entry point, so there's nothing to</code></span>
<span class="codeline" id="line-1291"><code>	// return to. Exit the thread directly. exitThread will clear</code></span>
<span class="codeline" id="line-1292"><code>	// m.freeWait when it's done with the stack and the m can be</code></span>
<span class="codeline" id="line-1293"><code>	// reaped.</code></span>
<span class="codeline" id="line-1294"><code>	exitThread(&amp;m.freeWait)</code></span>
<span class="codeline" id="line-1295"><code>}</code></span>
<span class="codeline" id="line-1296"><code></code></span>
<span class="codeline" id="line-1297"><code>// forEachP calls fn(p) for every P p when p reaches a GC safe point.</code></span>
<span class="codeline" id="line-1298"><code>// If a P is currently executing code, this will bring the P to a GC</code></span>
<span class="codeline" id="line-1299"><code>// safe point and execute fn on that P. If the P is not executing code</code></span>
<span class="codeline" id="line-1300"><code>// (it is idle or in a syscall), this will call fn(p) directly while</code></span>
<span class="codeline" id="line-1301"><code>// preventing the P from exiting its state. This does not ensure that</code></span>
<span class="codeline" id="line-1302"><code>// fn will run on every CPU executing Go code, but it acts as a global</code></span>
<span class="codeline" id="line-1303"><code>// memory barrier. GC uses this as a "ragged barrier."</code></span>
<span class="codeline" id="line-1304"><code>//</code></span>
<span class="codeline" id="line-1305"><code>// The caller must hold worldsema.</code></span>
<span class="codeline" id="line-1306"><code>//</code></span>
<span class="codeline" id="line-1307"><code>//go:systemstack</code></span>
<span class="codeline" id="line-1308"><code>func forEachP(fn func(*p)) {</code></span>
<span class="codeline" id="line-1309"><code>	mp := acquirem()</code></span>
<span class="codeline" id="line-1310"><code>	_p_ := getg().m.p.ptr()</code></span>
<span class="codeline" id="line-1311"><code></code></span>
<span class="codeline" id="line-1312"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1313"><code>	if sched.safePointWait != 0 {</code></span>
<span class="codeline" id="line-1314"><code>		throw("forEachP: sched.safePointWait != 0")</code></span>
<span class="codeline" id="line-1315"><code>	}</code></span>
<span class="codeline" id="line-1316"><code>	sched.safePointWait = gomaxprocs - 1</code></span>
<span class="codeline" id="line-1317"><code>	sched.safePointFn = fn</code></span>
<span class="codeline" id="line-1318"><code></code></span>
<span class="codeline" id="line-1319"><code>	// Ask all Ps to run the safe point function.</code></span>
<span class="codeline" id="line-1320"><code>	for _, p := range allp {</code></span>
<span class="codeline" id="line-1321"><code>		if p != _p_ {</code></span>
<span class="codeline" id="line-1322"><code>			atomic.Store(&amp;p.runSafePointFn, 1)</code></span>
<span class="codeline" id="line-1323"><code>		}</code></span>
<span class="codeline" id="line-1324"><code>	}</code></span>
<span class="codeline" id="line-1325"><code>	preemptall()</code></span>
<span class="codeline" id="line-1326"><code></code></span>
<span class="codeline" id="line-1327"><code>	// Any P entering _Pidle or _Psyscall from now on will observe</code></span>
<span class="codeline" id="line-1328"><code>	// p.runSafePointFn == 1 and will call runSafePointFn when</code></span>
<span class="codeline" id="line-1329"><code>	// changing its status to _Pidle/_Psyscall.</code></span>
<span class="codeline" id="line-1330"><code></code></span>
<span class="codeline" id="line-1331"><code>	// Run safe point function for all idle Ps. sched.pidle will</code></span>
<span class="codeline" id="line-1332"><code>	// not change because we hold sched.lock.</code></span>
<span class="codeline" id="line-1333"><code>	for p := sched.pidle.ptr(); p != nil; p = p.link.ptr() {</code></span>
<span class="codeline" id="line-1334"><code>		if atomic.Cas(&amp;p.runSafePointFn, 1, 0) {</code></span>
<span class="codeline" id="line-1335"><code>			fn(p)</code></span>
<span class="codeline" id="line-1336"><code>			sched.safePointWait--</code></span>
<span class="codeline" id="line-1337"><code>		}</code></span>
<span class="codeline" id="line-1338"><code>	}</code></span>
<span class="codeline" id="line-1339"><code></code></span>
<span class="codeline" id="line-1340"><code>	wait := sched.safePointWait &gt; 0</code></span>
<span class="codeline" id="line-1341"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1342"><code></code></span>
<span class="codeline" id="line-1343"><code>	// Run fn for the current P.</code></span>
<span class="codeline" id="line-1344"><code>	fn(_p_)</code></span>
<span class="codeline" id="line-1345"><code></code></span>
<span class="codeline" id="line-1346"><code>	// Force Ps currently in _Psyscall into _Pidle and hand them</code></span>
<span class="codeline" id="line-1347"><code>	// off to induce safe point function execution.</code></span>
<span class="codeline" id="line-1348"><code>	for _, p := range allp {</code></span>
<span class="codeline" id="line-1349"><code>		s := p.status</code></span>
<span class="codeline" id="line-1350"><code>		if s == _Psyscall &amp;&amp; p.runSafePointFn == 1 &amp;&amp; atomic.Cas(&amp;p.status, s, _Pidle) {</code></span>
<span class="codeline" id="line-1351"><code>			if trace.enabled {</code></span>
<span class="codeline" id="line-1352"><code>				traceGoSysBlock(p)</code></span>
<span class="codeline" id="line-1353"><code>				traceProcStop(p)</code></span>
<span class="codeline" id="line-1354"><code>			}</code></span>
<span class="codeline" id="line-1355"><code>			p.syscalltick++</code></span>
<span class="codeline" id="line-1356"><code>			handoffp(p)</code></span>
<span class="codeline" id="line-1357"><code>		}</code></span>
<span class="codeline" id="line-1358"><code>	}</code></span>
<span class="codeline" id="line-1359"><code></code></span>
<span class="codeline" id="line-1360"><code>	// Wait for remaining Ps to run fn.</code></span>
<span class="codeline" id="line-1361"><code>	if wait {</code></span>
<span class="codeline" id="line-1362"><code>		for {</code></span>
<span class="codeline" id="line-1363"><code>			// Wait for 100us, then try to re-preempt in</code></span>
<span class="codeline" id="line-1364"><code>			// case of any races.</code></span>
<span class="codeline" id="line-1365"><code>			//</code></span>
<span class="codeline" id="line-1366"><code>			// Requires system stack.</code></span>
<span class="codeline" id="line-1367"><code>			if notetsleep(&amp;sched.safePointNote, 100*1000) {</code></span>
<span class="codeline" id="line-1368"><code>				noteclear(&amp;sched.safePointNote)</code></span>
<span class="codeline" id="line-1369"><code>				break</code></span>
<span class="codeline" id="line-1370"><code>			}</code></span>
<span class="codeline" id="line-1371"><code>			preemptall()</code></span>
<span class="codeline" id="line-1372"><code>		}</code></span>
<span class="codeline" id="line-1373"><code>	}</code></span>
<span class="codeline" id="line-1374"><code>	if sched.safePointWait != 0 {</code></span>
<span class="codeline" id="line-1375"><code>		throw("forEachP: not done")</code></span>
<span class="codeline" id="line-1376"><code>	}</code></span>
<span class="codeline" id="line-1377"><code>	for _, p := range allp {</code></span>
<span class="codeline" id="line-1378"><code>		if p.runSafePointFn != 0 {</code></span>
<span class="codeline" id="line-1379"><code>			throw("forEachP: P did not run fn")</code></span>
<span class="codeline" id="line-1380"><code>		}</code></span>
<span class="codeline" id="line-1381"><code>	}</code></span>
<span class="codeline" id="line-1382"><code></code></span>
<span class="codeline" id="line-1383"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1384"><code>	sched.safePointFn = nil</code></span>
<span class="codeline" id="line-1385"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1386"><code>	releasem(mp)</code></span>
<span class="codeline" id="line-1387"><code>}</code></span>
<span class="codeline" id="line-1388"><code></code></span>
<span class="codeline" id="line-1389"><code>// runSafePointFn runs the safe point function, if any, for this P.</code></span>
<span class="codeline" id="line-1390"><code>// This should be called like</code></span>
<span class="codeline" id="line-1391"><code>//</code></span>
<span class="codeline" id="line-1392"><code>//     if getg().m.p.runSafePointFn != 0 {</code></span>
<span class="codeline" id="line-1393"><code>//         runSafePointFn()</code></span>
<span class="codeline" id="line-1394"><code>//     }</code></span>
<span class="codeline" id="line-1395"><code>//</code></span>
<span class="codeline" id="line-1396"><code>// runSafePointFn must be checked on any transition in to _Pidle or</code></span>
<span class="codeline" id="line-1397"><code>// _Psyscall to avoid a race where forEachP sees that the P is running</code></span>
<span class="codeline" id="line-1398"><code>// just before the P goes into _Pidle/_Psyscall and neither forEachP</code></span>
<span class="codeline" id="line-1399"><code>// nor the P run the safe-point function.</code></span>
<span class="codeline" id="line-1400"><code>func runSafePointFn() {</code></span>
<span class="codeline" id="line-1401"><code>	p := getg().m.p.ptr()</code></span>
<span class="codeline" id="line-1402"><code>	// Resolve the race between forEachP running the safe-point</code></span>
<span class="codeline" id="line-1403"><code>	// function on this P's behalf and this P running the</code></span>
<span class="codeline" id="line-1404"><code>	// safe-point function directly.</code></span>
<span class="codeline" id="line-1405"><code>	if !atomic.Cas(&amp;p.runSafePointFn, 1, 0) {</code></span>
<span class="codeline" id="line-1406"><code>		return</code></span>
<span class="codeline" id="line-1407"><code>	}</code></span>
<span class="codeline" id="line-1408"><code>	sched.safePointFn(p)</code></span>
<span class="codeline" id="line-1409"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1410"><code>	sched.safePointWait--</code></span>
<span class="codeline" id="line-1411"><code>	if sched.safePointWait == 0 {</code></span>
<span class="codeline" id="line-1412"><code>		notewakeup(&amp;sched.safePointNote)</code></span>
<span class="codeline" id="line-1413"><code>	}</code></span>
<span class="codeline" id="line-1414"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1415"><code>}</code></span>
<span class="codeline" id="line-1416"><code></code></span>
<span class="codeline" id="line-1417"><code>// When running with cgo, we call _cgo_thread_start</code></span>
<span class="codeline" id="line-1418"><code>// to start threads for us so that we can play nicely with</code></span>
<span class="codeline" id="line-1419"><code>// foreign code.</code></span>
<span class="codeline" id="line-1420"><code>var cgoThreadStart unsafe.Pointer</code></span>
<span class="codeline" id="line-1421"><code></code></span>
<span class="codeline" id="line-1422"><code>type cgothreadstart struct {</code></span>
<span class="codeline" id="line-1423"><code>	g   guintptr</code></span>
<span class="codeline" id="line-1424"><code>	tls *uint64</code></span>
<span class="codeline" id="line-1425"><code>	fn  unsafe.Pointer</code></span>
<span class="codeline" id="line-1426"><code>}</code></span>
<span class="codeline" id="line-1427"><code></code></span>
<span class="codeline" id="line-1428"><code>// Allocate a new m unassociated with any thread.</code></span>
<span class="codeline" id="line-1429"><code>// Can use p for allocation context if needed.</code></span>
<span class="codeline" id="line-1430"><code>// fn is recorded as the new m's m.mstartfn.</code></span>
<span class="codeline" id="line-1431"><code>// id is optional pre-allocated m ID. Omit by passing -1.</code></span>
<span class="codeline" id="line-1432"><code>//</code></span>
<span class="codeline" id="line-1433"><code>// This function is allowed to have write barriers even if the caller</code></span>
<span class="codeline" id="line-1434"><code>// isn't because it borrows _p_.</code></span>
<span class="codeline" id="line-1435"><code>//</code></span>
<span class="codeline" id="line-1436"><code>//go:yeswritebarrierrec</code></span>
<span class="codeline" id="line-1437"><code>func allocm(_p_ *p, fn func(), id int64) *m {</code></span>
<span class="codeline" id="line-1438"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-1439"><code>	acquirem() // disable GC because it can be called from sysmon</code></span>
<span class="codeline" id="line-1440"><code>	if _g_.m.p == 0 {</code></span>
<span class="codeline" id="line-1441"><code>		acquirep(_p_) // temporarily borrow p for mallocs in this function</code></span>
<span class="codeline" id="line-1442"><code>	}</code></span>
<span class="codeline" id="line-1443"><code></code></span>
<span class="codeline" id="line-1444"><code>	// Release the free M list. We need to do this somewhere and</code></span>
<span class="codeline" id="line-1445"><code>	// this may free up a stack we can use.</code></span>
<span class="codeline" id="line-1446"><code>	if sched.freem != nil {</code></span>
<span class="codeline" id="line-1447"><code>		lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1448"><code>		var newList *m</code></span>
<span class="codeline" id="line-1449"><code>		for freem := sched.freem; freem != nil; {</code></span>
<span class="codeline" id="line-1450"><code>			if freem.freeWait != 0 {</code></span>
<span class="codeline" id="line-1451"><code>				next := freem.freelink</code></span>
<span class="codeline" id="line-1452"><code>				freem.freelink = newList</code></span>
<span class="codeline" id="line-1453"><code>				newList = freem</code></span>
<span class="codeline" id="line-1454"><code>				freem = next</code></span>
<span class="codeline" id="line-1455"><code>				continue</code></span>
<span class="codeline" id="line-1456"><code>			}</code></span>
<span class="codeline" id="line-1457"><code>			stackfree(freem.g0.stack)</code></span>
<span class="codeline" id="line-1458"><code>			freem = freem.freelink</code></span>
<span class="codeline" id="line-1459"><code>		}</code></span>
<span class="codeline" id="line-1460"><code>		sched.freem = newList</code></span>
<span class="codeline" id="line-1461"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1462"><code>	}</code></span>
<span class="codeline" id="line-1463"><code></code></span>
<span class="codeline" id="line-1464"><code>	mp := new(m)</code></span>
<span class="codeline" id="line-1465"><code>	mp.mstartfn = fn</code></span>
<span class="codeline" id="line-1466"><code>	mcommoninit(mp, id)</code></span>
<span class="codeline" id="line-1467"><code></code></span>
<span class="codeline" id="line-1468"><code>	// In case of cgo or Solaris or illumos or Darwin, pthread_create will make us a stack.</code></span>
<span class="codeline" id="line-1469"><code>	// Windows and Plan 9 will layout sched stack on OS stack.</code></span>
<span class="codeline" id="line-1470"><code>	if iscgo || GOOS == "solaris" || GOOS == "illumos" || GOOS == "windows" || GOOS == "plan9" || GOOS == "darwin" {</code></span>
<span class="codeline" id="line-1471"><code>		mp.g0 = malg(-1)</code></span>
<span class="codeline" id="line-1472"><code>	} else {</code></span>
<span class="codeline" id="line-1473"><code>		mp.g0 = malg(8192 * sys.StackGuardMultiplier)</code></span>
<span class="codeline" id="line-1474"><code>	}</code></span>
<span class="codeline" id="line-1475"><code>	mp.g0.m = mp</code></span>
<span class="codeline" id="line-1476"><code></code></span>
<span class="codeline" id="line-1477"><code>	if _p_ == _g_.m.p.ptr() {</code></span>
<span class="codeline" id="line-1478"><code>		releasep()</code></span>
<span class="codeline" id="line-1479"><code>	}</code></span>
<span class="codeline" id="line-1480"><code>	releasem(_g_.m)</code></span>
<span class="codeline" id="line-1481"><code></code></span>
<span class="codeline" id="line-1482"><code>	return mp</code></span>
<span class="codeline" id="line-1483"><code>}</code></span>
<span class="codeline" id="line-1484"><code></code></span>
<span class="codeline" id="line-1485"><code>// needm is called when a cgo callback happens on a</code></span>
<span class="codeline" id="line-1486"><code>// thread without an m (a thread not created by Go).</code></span>
<span class="codeline" id="line-1487"><code>// In this case, needm is expected to find an m to use</code></span>
<span class="codeline" id="line-1488"><code>// and return with m, g initialized correctly.</code></span>
<span class="codeline" id="line-1489"><code>// Since m and g are not set now (likely nil, but see below)</code></span>
<span class="codeline" id="line-1490"><code>// needm is limited in what routines it can call. In particular</code></span>
<span class="codeline" id="line-1491"><code>// it can only call nosplit functions (textflag 7) and cannot</code></span>
<span class="codeline" id="line-1492"><code>// do any scheduling that requires an m.</code></span>
<span class="codeline" id="line-1493"><code>//</code></span>
<span class="codeline" id="line-1494"><code>// In order to avoid needing heavy lifting here, we adopt</code></span>
<span class="codeline" id="line-1495"><code>// the following strategy: there is a stack of available m's</code></span>
<span class="codeline" id="line-1496"><code>// that can be stolen. Using compare-and-swap</code></span>
<span class="codeline" id="line-1497"><code>// to pop from the stack has ABA races, so we simulate</code></span>
<span class="codeline" id="line-1498"><code>// a lock by doing an exchange (via Casuintptr) to steal the stack</code></span>
<span class="codeline" id="line-1499"><code>// head and replace the top pointer with MLOCKED (1).</code></span>
<span class="codeline" id="line-1500"><code>// This serves as a simple spin lock that we can use even</code></span>
<span class="codeline" id="line-1501"><code>// without an m. The thread that locks the stack in this way</code></span>
<span class="codeline" id="line-1502"><code>// unlocks the stack by storing a valid stack head pointer.</code></span>
<span class="codeline" id="line-1503"><code>//</code></span>
<span class="codeline" id="line-1504"><code>// In order to make sure that there is always an m structure</code></span>
<span class="codeline" id="line-1505"><code>// available to be stolen, we maintain the invariant that there</code></span>
<span class="codeline" id="line-1506"><code>// is always one more than needed. At the beginning of the</code></span>
<span class="codeline" id="line-1507"><code>// program (if cgo is in use) the list is seeded with a single m.</code></span>
<span class="codeline" id="line-1508"><code>// If needm finds that it has taken the last m off the list, its job</code></span>
<span class="codeline" id="line-1509"><code>// is - once it has installed its own m so that it can do things like</code></span>
<span class="codeline" id="line-1510"><code>// allocate memory - to create a spare m and put it on the list.</code></span>
<span class="codeline" id="line-1511"><code>//</code></span>
<span class="codeline" id="line-1512"><code>// Each of these extra m's also has a g0 and a curg that are</code></span>
<span class="codeline" id="line-1513"><code>// pressed into service as the scheduling stack and current</code></span>
<span class="codeline" id="line-1514"><code>// goroutine for the duration of the cgo callback.</code></span>
<span class="codeline" id="line-1515"><code>//</code></span>
<span class="codeline" id="line-1516"><code>// When the callback is done with the m, it calls dropm to</code></span>
<span class="codeline" id="line-1517"><code>// put the m back on the list.</code></span>
<span class="codeline" id="line-1518"><code>//go:nosplit</code></span>
<span class="codeline" id="line-1519"><code>func needm(x byte) {</code></span>
<span class="codeline" id="line-1520"><code>	if (iscgo || GOOS == "windows") &amp;&amp; !cgoHasExtraM {</code></span>
<span class="codeline" id="line-1521"><code>		// Can happen if C/C++ code calls Go from a global ctor.</code></span>
<span class="codeline" id="line-1522"><code>		// Can also happen on Windows if a global ctor uses a</code></span>
<span class="codeline" id="line-1523"><code>		// callback created by syscall.NewCallback. See issue #6751</code></span>
<span class="codeline" id="line-1524"><code>		// for details.</code></span>
<span class="codeline" id="line-1525"><code>		//</code></span>
<span class="codeline" id="line-1526"><code>		// Can not throw, because scheduler is not initialized yet.</code></span>
<span class="codeline" id="line-1527"><code>		write(2, unsafe.Pointer(&amp;earlycgocallback[0]), int32(len(earlycgocallback)))</code></span>
<span class="codeline" id="line-1528"><code>		exit(1)</code></span>
<span class="codeline" id="line-1529"><code>	}</code></span>
<span class="codeline" id="line-1530"><code></code></span>
<span class="codeline" id="line-1531"><code>	// Lock extra list, take head, unlock popped list.</code></span>
<span class="codeline" id="line-1532"><code>	// nilokay=false is safe here because of the invariant above,</code></span>
<span class="codeline" id="line-1533"><code>	// that the extra list always contains or will soon contain</code></span>
<span class="codeline" id="line-1534"><code>	// at least one m.</code></span>
<span class="codeline" id="line-1535"><code>	mp := lockextra(false)</code></span>
<span class="codeline" id="line-1536"><code></code></span>
<span class="codeline" id="line-1537"><code>	// Set needextram when we've just emptied the list,</code></span>
<span class="codeline" id="line-1538"><code>	// so that the eventual call into cgocallbackg will</code></span>
<span class="codeline" id="line-1539"><code>	// allocate a new m for the extra list. We delay the</code></span>
<span class="codeline" id="line-1540"><code>	// allocation until then so that it can be done</code></span>
<span class="codeline" id="line-1541"><code>	// after exitsyscall makes sure it is okay to be</code></span>
<span class="codeline" id="line-1542"><code>	// running at all (that is, there's no garbage collection</code></span>
<span class="codeline" id="line-1543"><code>	// running right now).</code></span>
<span class="codeline" id="line-1544"><code>	mp.needextram = mp.schedlink == 0</code></span>
<span class="codeline" id="line-1545"><code>	extraMCount--</code></span>
<span class="codeline" id="line-1546"><code>	unlockextra(mp.schedlink.ptr())</code></span>
<span class="codeline" id="line-1547"><code></code></span>
<span class="codeline" id="line-1548"><code>	// Save and block signals before installing g.</code></span>
<span class="codeline" id="line-1549"><code>	// Once g is installed, any incoming signals will try to execute,</code></span>
<span class="codeline" id="line-1550"><code>	// but we won't have the sigaltstack settings and other data</code></span>
<span class="codeline" id="line-1551"><code>	// set up appropriately until the end of minit, which will</code></span>
<span class="codeline" id="line-1552"><code>	// unblock the signals. This is the same dance as when</code></span>
<span class="codeline" id="line-1553"><code>	// starting a new m to run Go code via newosproc.</code></span>
<span class="codeline" id="line-1554"><code>	msigsave(mp)</code></span>
<span class="codeline" id="line-1555"><code>	sigblock()</code></span>
<span class="codeline" id="line-1556"><code></code></span>
<span class="codeline" id="line-1557"><code>	// Install g (= m-&gt;g0) and set the stack bounds</code></span>
<span class="codeline" id="line-1558"><code>	// to match the current stack. We don't actually know</code></span>
<span class="codeline" id="line-1559"><code>	// how big the stack is, like we don't know how big any</code></span>
<span class="codeline" id="line-1560"><code>	// scheduling stack is, but we assume there's at least 32 kB,</code></span>
<span class="codeline" id="line-1561"><code>	// which is more than enough for us.</code></span>
<span class="codeline" id="line-1562"><code>	setg(mp.g0)</code></span>
<span class="codeline" id="line-1563"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-1564"><code>	_g_.stack.hi = uintptr(noescape(unsafe.Pointer(&amp;x))) + 1024</code></span>
<span class="codeline" id="line-1565"><code>	_g_.stack.lo = uintptr(noescape(unsafe.Pointer(&amp;x))) - 32*1024</code></span>
<span class="codeline" id="line-1566"><code>	_g_.stackguard0 = _g_.stack.lo + _StackGuard</code></span>
<span class="codeline" id="line-1567"><code></code></span>
<span class="codeline" id="line-1568"><code>	// Initialize this thread to use the m.</code></span>
<span class="codeline" id="line-1569"><code>	asminit()</code></span>
<span class="codeline" id="line-1570"><code>	minit()</code></span>
<span class="codeline" id="line-1571"><code></code></span>
<span class="codeline" id="line-1572"><code>	// mp.curg is now a real goroutine.</code></span>
<span class="codeline" id="line-1573"><code>	casgstatus(mp.curg, _Gdead, _Gsyscall)</code></span>
<span class="codeline" id="line-1574"><code>	atomic.Xadd(&amp;sched.ngsys, -1)</code></span>
<span class="codeline" id="line-1575"><code>}</code></span>
<span class="codeline" id="line-1576"><code></code></span>
<span class="codeline" id="line-1577"><code>var earlycgocallback = []byte("fatal error: cgo callback before cgo call\n")</code></span>
<span class="codeline" id="line-1578"><code></code></span>
<span class="codeline" id="line-1579"><code>// newextram allocates m's and puts them on the extra list.</code></span>
<span class="codeline" id="line-1580"><code>// It is called with a working local m, so that it can do things</code></span>
<span class="codeline" id="line-1581"><code>// like call schedlock and allocate.</code></span>
<span class="codeline" id="line-1582"><code>func newextram() {</code></span>
<span class="codeline" id="line-1583"><code>	c := atomic.Xchg(&amp;extraMWaiters, 0)</code></span>
<span class="codeline" id="line-1584"><code>	if c &gt; 0 {</code></span>
<span class="codeline" id="line-1585"><code>		for i := uint32(0); i &lt; c; i++ {</code></span>
<span class="codeline" id="line-1586"><code>			oneNewExtraM()</code></span>
<span class="codeline" id="line-1587"><code>		}</code></span>
<span class="codeline" id="line-1588"><code>	} else {</code></span>
<span class="codeline" id="line-1589"><code>		// Make sure there is at least one extra M.</code></span>
<span class="codeline" id="line-1590"><code>		mp := lockextra(true)</code></span>
<span class="codeline" id="line-1591"><code>		unlockextra(mp)</code></span>
<span class="codeline" id="line-1592"><code>		if mp == nil {</code></span>
<span class="codeline" id="line-1593"><code>			oneNewExtraM()</code></span>
<span class="codeline" id="line-1594"><code>		}</code></span>
<span class="codeline" id="line-1595"><code>	}</code></span>
<span class="codeline" id="line-1596"><code>}</code></span>
<span class="codeline" id="line-1597"><code></code></span>
<span class="codeline" id="line-1598"><code>// oneNewExtraM allocates an m and puts it on the extra list.</code></span>
<span class="codeline" id="line-1599"><code>func oneNewExtraM() {</code></span>
<span class="codeline" id="line-1600"><code>	// Create extra goroutine locked to extra m.</code></span>
<span class="codeline" id="line-1601"><code>	// The goroutine is the context in which the cgo callback will run.</code></span>
<span class="codeline" id="line-1602"><code>	// The sched.pc will never be returned to, but setting it to</code></span>
<span class="codeline" id="line-1603"><code>	// goexit makes clear to the traceback routines where</code></span>
<span class="codeline" id="line-1604"><code>	// the goroutine stack ends.</code></span>
<span class="codeline" id="line-1605"><code>	mp := allocm(nil, nil, -1)</code></span>
<span class="codeline" id="line-1606"><code>	gp := malg(4096)</code></span>
<span class="codeline" id="line-1607"><code>	gp.sched.pc = funcPC(goexit) + sys.PCQuantum</code></span>
<span class="codeline" id="line-1608"><code>	gp.sched.sp = gp.stack.hi</code></span>
<span class="codeline" id="line-1609"><code>	gp.sched.sp -= 4 * sys.RegSize // extra space in case of reads slightly beyond frame</code></span>
<span class="codeline" id="line-1610"><code>	gp.sched.lr = 0</code></span>
<span class="codeline" id="line-1611"><code>	gp.sched.g = guintptr(unsafe.Pointer(gp))</code></span>
<span class="codeline" id="line-1612"><code>	gp.syscallpc = gp.sched.pc</code></span>
<span class="codeline" id="line-1613"><code>	gp.syscallsp = gp.sched.sp</code></span>
<span class="codeline" id="line-1614"><code>	gp.stktopsp = gp.sched.sp</code></span>
<span class="codeline" id="line-1615"><code>	// malg returns status as _Gidle. Change to _Gdead before</code></span>
<span class="codeline" id="line-1616"><code>	// adding to allg where GC can see it. We use _Gdead to hide</code></span>
<span class="codeline" id="line-1617"><code>	// this from tracebacks and stack scans since it isn't a</code></span>
<span class="codeline" id="line-1618"><code>	// "real" goroutine until needm grabs it.</code></span>
<span class="codeline" id="line-1619"><code>	casgstatus(gp, _Gidle, _Gdead)</code></span>
<span class="codeline" id="line-1620"><code>	gp.m = mp</code></span>
<span class="codeline" id="line-1621"><code>	mp.curg = gp</code></span>
<span class="codeline" id="line-1622"><code>	mp.lockedInt++</code></span>
<span class="codeline" id="line-1623"><code>	mp.lockedg.set(gp)</code></span>
<span class="codeline" id="line-1624"><code>	gp.lockedm.set(mp)</code></span>
<span class="codeline" id="line-1625"><code>	gp.goid = int64(atomic.Xadd64(&amp;sched.goidgen, 1))</code></span>
<span class="codeline" id="line-1626"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-1627"><code>		gp.racectx = racegostart(funcPC(newextram) + sys.PCQuantum)</code></span>
<span class="codeline" id="line-1628"><code>	}</code></span>
<span class="codeline" id="line-1629"><code>	// put on allg for garbage collector</code></span>
<span class="codeline" id="line-1630"><code>	allgadd(gp)</code></span>
<span class="codeline" id="line-1631"><code></code></span>
<span class="codeline" id="line-1632"><code>	// gp is now on the allg list, but we don't want it to be</code></span>
<span class="codeline" id="line-1633"><code>	// counted by gcount. It would be more "proper" to increment</code></span>
<span class="codeline" id="line-1634"><code>	// sched.ngfree, but that requires locking. Incrementing ngsys</code></span>
<span class="codeline" id="line-1635"><code>	// has the same effect.</code></span>
<span class="codeline" id="line-1636"><code>	atomic.Xadd(&amp;sched.ngsys, +1)</code></span>
<span class="codeline" id="line-1637"><code></code></span>
<span class="codeline" id="line-1638"><code>	// Add m to the extra list.</code></span>
<span class="codeline" id="line-1639"><code>	mnext := lockextra(true)</code></span>
<span class="codeline" id="line-1640"><code>	mp.schedlink.set(mnext)</code></span>
<span class="codeline" id="line-1641"><code>	extraMCount++</code></span>
<span class="codeline" id="line-1642"><code>	unlockextra(mp)</code></span>
<span class="codeline" id="line-1643"><code>}</code></span>
<span class="codeline" id="line-1644"><code></code></span>
<span class="codeline" id="line-1645"><code>// dropm is called when a cgo callback has called needm but is now</code></span>
<span class="codeline" id="line-1646"><code>// done with the callback and returning back into the non-Go thread.</code></span>
<span class="codeline" id="line-1647"><code>// It puts the current m back onto the extra list.</code></span>
<span class="codeline" id="line-1648"><code>//</code></span>
<span class="codeline" id="line-1649"><code>// The main expense here is the call to signalstack to release the</code></span>
<span class="codeline" id="line-1650"><code>// m's signal stack, and then the call to needm on the next callback</code></span>
<span class="codeline" id="line-1651"><code>// from this thread. It is tempting to try to save the m for next time,</code></span>
<span class="codeline" id="line-1652"><code>// which would eliminate both these costs, but there might not be</code></span>
<span class="codeline" id="line-1653"><code>// a next time: the current thread (which Go does not control) might exit.</code></span>
<span class="codeline" id="line-1654"><code>// If we saved the m for that thread, there would be an m leak each time</code></span>
<span class="codeline" id="line-1655"><code>// such a thread exited. Instead, we acquire and release an m on each</code></span>
<span class="codeline" id="line-1656"><code>// call. These should typically not be scheduling operations, just a few</code></span>
<span class="codeline" id="line-1657"><code>// atomics, so the cost should be small.</code></span>
<span class="codeline" id="line-1658"><code>//</code></span>
<span class="codeline" id="line-1659"><code>// TODO(rsc): An alternative would be to allocate a dummy pthread per-thread</code></span>
<span class="codeline" id="line-1660"><code>// variable using pthread_key_create. Unlike the pthread keys we already use</code></span>
<span class="codeline" id="line-1661"><code>// on OS X, this dummy key would never be read by Go code. It would exist</code></span>
<span class="codeline" id="line-1662"><code>// only so that we could register at thread-exit-time destructor.</code></span>
<span class="codeline" id="line-1663"><code>// That destructor would put the m back onto the extra list.</code></span>
<span class="codeline" id="line-1664"><code>// This is purely a performance optimization. The current version,</code></span>
<span class="codeline" id="line-1665"><code>// in which dropm happens on each cgo call, is still correct too.</code></span>
<span class="codeline" id="line-1666"><code>// We may have to keep the current version on systems with cgo</code></span>
<span class="codeline" id="line-1667"><code>// but without pthreads, like Windows.</code></span>
<span class="codeline" id="line-1668"><code>func dropm() {</code></span>
<span class="codeline" id="line-1669"><code>	// Clear m and g, and return m to the extra list.</code></span>
<span class="codeline" id="line-1670"><code>	// After the call to setg we can only call nosplit functions</code></span>
<span class="codeline" id="line-1671"><code>	// with no pointer manipulation.</code></span>
<span class="codeline" id="line-1672"><code>	mp := getg().m</code></span>
<span class="codeline" id="line-1673"><code></code></span>
<span class="codeline" id="line-1674"><code>	// Return mp.curg to dead state.</code></span>
<span class="codeline" id="line-1675"><code>	casgstatus(mp.curg, _Gsyscall, _Gdead)</code></span>
<span class="codeline" id="line-1676"><code>	mp.curg.preemptStop = false</code></span>
<span class="codeline" id="line-1677"><code>	atomic.Xadd(&amp;sched.ngsys, +1)</code></span>
<span class="codeline" id="line-1678"><code></code></span>
<span class="codeline" id="line-1679"><code>	// Block signals before unminit.</code></span>
<span class="codeline" id="line-1680"><code>	// Unminit unregisters the signal handling stack (but needs g on some systems).</code></span>
<span class="codeline" id="line-1681"><code>	// Setg(nil) clears g, which is the signal handler's cue not to run Go handlers.</code></span>
<span class="codeline" id="line-1682"><code>	// It's important not to try to handle a signal between those two steps.</code></span>
<span class="codeline" id="line-1683"><code>	sigmask := mp.sigmask</code></span>
<span class="codeline" id="line-1684"><code>	sigblock()</code></span>
<span class="codeline" id="line-1685"><code>	unminit()</code></span>
<span class="codeline" id="line-1686"><code></code></span>
<span class="codeline" id="line-1687"><code>	mnext := lockextra(true)</code></span>
<span class="codeline" id="line-1688"><code>	extraMCount++</code></span>
<span class="codeline" id="line-1689"><code>	mp.schedlink.set(mnext)</code></span>
<span class="codeline" id="line-1690"><code></code></span>
<span class="codeline" id="line-1691"><code>	setg(nil)</code></span>
<span class="codeline" id="line-1692"><code></code></span>
<span class="codeline" id="line-1693"><code>	// Commit the release of mp.</code></span>
<span class="codeline" id="line-1694"><code>	unlockextra(mp)</code></span>
<span class="codeline" id="line-1695"><code></code></span>
<span class="codeline" id="line-1696"><code>	msigrestore(sigmask)</code></span>
<span class="codeline" id="line-1697"><code>}</code></span>
<span class="codeline" id="line-1698"><code></code></span>
<span class="codeline" id="line-1699"><code>// A helper function for EnsureDropM.</code></span>
<span class="codeline" id="line-1700"><code>func getm() uintptr {</code></span>
<span class="codeline" id="line-1701"><code>	return uintptr(unsafe.Pointer(getg().m))</code></span>
<span class="codeline" id="line-1702"><code>}</code></span>
<span class="codeline" id="line-1703"><code></code></span>
<span class="codeline" id="line-1704"><code>var extram uintptr</code></span>
<span class="codeline" id="line-1705"><code>var extraMCount uint32 // Protected by lockextra</code></span>
<span class="codeline" id="line-1706"><code>var extraMWaiters uint32</code></span>
<span class="codeline" id="line-1707"><code></code></span>
<span class="codeline" id="line-1708"><code>// lockextra locks the extra list and returns the list head.</code></span>
<span class="codeline" id="line-1709"><code>// The caller must unlock the list by storing a new list head</code></span>
<span class="codeline" id="line-1710"><code>// to extram. If nilokay is true, then lockextra will</code></span>
<span class="codeline" id="line-1711"><code>// return a nil list head if that's what it finds. If nilokay is false,</code></span>
<span class="codeline" id="line-1712"><code>// lockextra will keep waiting until the list head is no longer nil.</code></span>
<span class="codeline" id="line-1713"><code>//go:nosplit</code></span>
<span class="codeline" id="line-1714"><code>func lockextra(nilokay bool) *m {</code></span>
<span class="codeline" id="line-1715"><code>	const locked = 1</code></span>
<span class="codeline" id="line-1716"><code></code></span>
<span class="codeline" id="line-1717"><code>	incr := false</code></span>
<span class="codeline" id="line-1718"><code>	for {</code></span>
<span class="codeline" id="line-1719"><code>		old := atomic.Loaduintptr(&amp;extram)</code></span>
<span class="codeline" id="line-1720"><code>		if old == locked {</code></span>
<span class="codeline" id="line-1721"><code>			osyield()</code></span>
<span class="codeline" id="line-1722"><code>			continue</code></span>
<span class="codeline" id="line-1723"><code>		}</code></span>
<span class="codeline" id="line-1724"><code>		if old == 0 &amp;&amp; !nilokay {</code></span>
<span class="codeline" id="line-1725"><code>			if !incr {</code></span>
<span class="codeline" id="line-1726"><code>				// Add 1 to the number of threads</code></span>
<span class="codeline" id="line-1727"><code>				// waiting for an M.</code></span>
<span class="codeline" id="line-1728"><code>				// This is cleared by newextram.</code></span>
<span class="codeline" id="line-1729"><code>				atomic.Xadd(&amp;extraMWaiters, 1)</code></span>
<span class="codeline" id="line-1730"><code>				incr = true</code></span>
<span class="codeline" id="line-1731"><code>			}</code></span>
<span class="codeline" id="line-1732"><code>			usleep(1)</code></span>
<span class="codeline" id="line-1733"><code>			continue</code></span>
<span class="codeline" id="line-1734"><code>		}</code></span>
<span class="codeline" id="line-1735"><code>		if atomic.Casuintptr(&amp;extram, old, locked) {</code></span>
<span class="codeline" id="line-1736"><code>			return (*m)(unsafe.Pointer(old))</code></span>
<span class="codeline" id="line-1737"><code>		}</code></span>
<span class="codeline" id="line-1738"><code>		osyield()</code></span>
<span class="codeline" id="line-1739"><code>		continue</code></span>
<span class="codeline" id="line-1740"><code>	}</code></span>
<span class="codeline" id="line-1741"><code>}</code></span>
<span class="codeline" id="line-1742"><code></code></span>
<span class="codeline" id="line-1743"><code>//go:nosplit</code></span>
<span class="codeline" id="line-1744"><code>func unlockextra(mp *m) {</code></span>
<span class="codeline" id="line-1745"><code>	atomic.Storeuintptr(&amp;extram, uintptr(unsafe.Pointer(mp)))</code></span>
<span class="codeline" id="line-1746"><code>}</code></span>
<span class="codeline" id="line-1747"><code></code></span>
<span class="codeline" id="line-1748"><code>// execLock serializes exec and clone to avoid bugs or unspecified behaviour</code></span>
<span class="codeline" id="line-1749"><code>// around exec'ing while creating/destroying threads.  See issue #19546.</code></span>
<span class="codeline" id="line-1750"><code>var execLock rwmutex</code></span>
<span class="codeline" id="line-1751"><code></code></span>
<span class="codeline" id="line-1752"><code>// newmHandoff contains a list of m structures that need new OS threads.</code></span>
<span class="codeline" id="line-1753"><code>// This is used by newm in situations where newm itself can't safely</code></span>
<span class="codeline" id="line-1754"><code>// start an OS thread.</code></span>
<span class="codeline" id="line-1755"><code>var newmHandoff struct {</code></span>
<span class="codeline" id="line-1756"><code>	lock mutex</code></span>
<span class="codeline" id="line-1757"><code></code></span>
<span class="codeline" id="line-1758"><code>	// newm points to a list of M structures that need new OS</code></span>
<span class="codeline" id="line-1759"><code>	// threads. The list is linked through m.schedlink.</code></span>
<span class="codeline" id="line-1760"><code>	newm muintptr</code></span>
<span class="codeline" id="line-1761"><code></code></span>
<span class="codeline" id="line-1762"><code>	// waiting indicates that wake needs to be notified when an m</code></span>
<span class="codeline" id="line-1763"><code>	// is put on the list.</code></span>
<span class="codeline" id="line-1764"><code>	waiting bool</code></span>
<span class="codeline" id="line-1765"><code>	wake    note</code></span>
<span class="codeline" id="line-1766"><code></code></span>
<span class="codeline" id="line-1767"><code>	// haveTemplateThread indicates that the templateThread has</code></span>
<span class="codeline" id="line-1768"><code>	// been started. This is not protected by lock. Use cas to set</code></span>
<span class="codeline" id="line-1769"><code>	// to 1.</code></span>
<span class="codeline" id="line-1770"><code>	haveTemplateThread uint32</code></span>
<span class="codeline" id="line-1771"><code>}</code></span>
<span class="codeline" id="line-1772"><code></code></span>
<span class="codeline" id="line-1773"><code>// Create a new m. It will start off with a call to fn, or else the scheduler.</code></span>
<span class="codeline" id="line-1774"><code>// fn needs to be static and not a heap allocated closure.</code></span>
<span class="codeline" id="line-1775"><code>// May run with m.p==nil, so write barriers are not allowed.</code></span>
<span class="codeline" id="line-1776"><code>//</code></span>
<span class="codeline" id="line-1777"><code>// id is optional pre-allocated m ID. Omit by passing -1.</code></span>
<span class="codeline" id="line-1778"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-1779"><code>func newm(fn func(), _p_ *p, id int64) {</code></span>
<span class="codeline" id="line-1780"><code>	mp := allocm(_p_, fn, id)</code></span>
<span class="codeline" id="line-1781"><code>	mp.nextp.set(_p_)</code></span>
<span class="codeline" id="line-1782"><code>	mp.sigmask = initSigmask</code></span>
<span class="codeline" id="line-1783"><code>	if gp := getg(); gp != nil &amp;&amp; gp.m != nil &amp;&amp; (gp.m.lockedExt != 0 || gp.m.incgo) &amp;&amp; GOOS != "plan9" {</code></span>
<span class="codeline" id="line-1784"><code>		// We're on a locked M or a thread that may have been</code></span>
<span class="codeline" id="line-1785"><code>		// started by C. The kernel state of this thread may</code></span>
<span class="codeline" id="line-1786"><code>		// be strange (the user may have locked it for that</code></span>
<span class="codeline" id="line-1787"><code>		// purpose). We don't want to clone that into another</code></span>
<span class="codeline" id="line-1788"><code>		// thread. Instead, ask a known-good thread to create</code></span>
<span class="codeline" id="line-1789"><code>		// the thread for us.</code></span>
<span class="codeline" id="line-1790"><code>		//</code></span>
<span class="codeline" id="line-1791"><code>		// This is disabled on Plan 9. See golang.org/issue/22227.</code></span>
<span class="codeline" id="line-1792"><code>		//</code></span>
<span class="codeline" id="line-1793"><code>		// TODO: This may be unnecessary on Windows, which</code></span>
<span class="codeline" id="line-1794"><code>		// doesn't model thread creation off fork.</code></span>
<span class="codeline" id="line-1795"><code>		lock(&amp;newmHandoff.lock)</code></span>
<span class="codeline" id="line-1796"><code>		if newmHandoff.haveTemplateThread == 0 {</code></span>
<span class="codeline" id="line-1797"><code>			throw("on a locked thread with no template thread")</code></span>
<span class="codeline" id="line-1798"><code>		}</code></span>
<span class="codeline" id="line-1799"><code>		mp.schedlink = newmHandoff.newm</code></span>
<span class="codeline" id="line-1800"><code>		newmHandoff.newm.set(mp)</code></span>
<span class="codeline" id="line-1801"><code>		if newmHandoff.waiting {</code></span>
<span class="codeline" id="line-1802"><code>			newmHandoff.waiting = false</code></span>
<span class="codeline" id="line-1803"><code>			notewakeup(&amp;newmHandoff.wake)</code></span>
<span class="codeline" id="line-1804"><code>		}</code></span>
<span class="codeline" id="line-1805"><code>		unlock(&amp;newmHandoff.lock)</code></span>
<span class="codeline" id="line-1806"><code>		return</code></span>
<span class="codeline" id="line-1807"><code>	}</code></span>
<span class="codeline" id="line-1808"><code>	newm1(mp)</code></span>
<span class="codeline" id="line-1809"><code>}</code></span>
<span class="codeline" id="line-1810"><code></code></span>
<span class="codeline" id="line-1811"><code>func newm1(mp *m) {</code></span>
<span class="codeline" id="line-1812"><code>	if iscgo {</code></span>
<span class="codeline" id="line-1813"><code>		var ts cgothreadstart</code></span>
<span class="codeline" id="line-1814"><code>		if _cgo_thread_start == nil {</code></span>
<span class="codeline" id="line-1815"><code>			throw("_cgo_thread_start missing")</code></span>
<span class="codeline" id="line-1816"><code>		}</code></span>
<span class="codeline" id="line-1817"><code>		ts.g.set(mp.g0)</code></span>
<span class="codeline" id="line-1818"><code>		ts.tls = (*uint64)(unsafe.Pointer(&amp;mp.tls[0]))</code></span>
<span class="codeline" id="line-1819"><code>		ts.fn = unsafe.Pointer(funcPC(mstart))</code></span>
<span class="codeline" id="line-1820"><code>		if msanenabled {</code></span>
<span class="codeline" id="line-1821"><code>			msanwrite(unsafe.Pointer(&amp;ts), unsafe.Sizeof(ts))</code></span>
<span class="codeline" id="line-1822"><code>		}</code></span>
<span class="codeline" id="line-1823"><code>		execLock.rlock() // Prevent process clone.</code></span>
<span class="codeline" id="line-1824"><code>		asmcgocall(_cgo_thread_start, unsafe.Pointer(&amp;ts))</code></span>
<span class="codeline" id="line-1825"><code>		execLock.runlock()</code></span>
<span class="codeline" id="line-1826"><code>		return</code></span>
<span class="codeline" id="line-1827"><code>	}</code></span>
<span class="codeline" id="line-1828"><code>	execLock.rlock() // Prevent process clone.</code></span>
<span class="codeline" id="line-1829"><code>	newosproc(mp)</code></span>
<span class="codeline" id="line-1830"><code>	execLock.runlock()</code></span>
<span class="codeline" id="line-1831"><code>}</code></span>
<span class="codeline" id="line-1832"><code></code></span>
<span class="codeline" id="line-1833"><code>// startTemplateThread starts the template thread if it is not already</code></span>
<span class="codeline" id="line-1834"><code>// running.</code></span>
<span class="codeline" id="line-1835"><code>//</code></span>
<span class="codeline" id="line-1836"><code>// The calling thread must itself be in a known-good state.</code></span>
<span class="codeline" id="line-1837"><code>func startTemplateThread() {</code></span>
<span class="codeline" id="line-1838"><code>	if GOARCH == "wasm" { // no threads on wasm yet</code></span>
<span class="codeline" id="line-1839"><code>		return</code></span>
<span class="codeline" id="line-1840"><code>	}</code></span>
<span class="codeline" id="line-1841"><code></code></span>
<span class="codeline" id="line-1842"><code>	// Disable preemption to guarantee that the template thread will be</code></span>
<span class="codeline" id="line-1843"><code>	// created before a park once haveTemplateThread is set.</code></span>
<span class="codeline" id="line-1844"><code>	mp := acquirem()</code></span>
<span class="codeline" id="line-1845"><code>	if !atomic.Cas(&amp;newmHandoff.haveTemplateThread, 0, 1) {</code></span>
<span class="codeline" id="line-1846"><code>		releasem(mp)</code></span>
<span class="codeline" id="line-1847"><code>		return</code></span>
<span class="codeline" id="line-1848"><code>	}</code></span>
<span class="codeline" id="line-1849"><code>	newm(templateThread, nil, -1)</code></span>
<span class="codeline" id="line-1850"><code>	releasem(mp)</code></span>
<span class="codeline" id="line-1851"><code>}</code></span>
<span class="codeline" id="line-1852"><code></code></span>
<span class="codeline" id="line-1853"><code>// templateThread is a thread in a known-good state that exists solely</code></span>
<span class="codeline" id="line-1854"><code>// to start new threads in known-good states when the calling thread</code></span>
<span class="codeline" id="line-1855"><code>// may not be in a good state.</code></span>
<span class="codeline" id="line-1856"><code>//</code></span>
<span class="codeline" id="line-1857"><code>// Many programs never need this, so templateThread is started lazily</code></span>
<span class="codeline" id="line-1858"><code>// when we first enter a state that might lead to running on a thread</code></span>
<span class="codeline" id="line-1859"><code>// in an unknown state.</code></span>
<span class="codeline" id="line-1860"><code>//</code></span>
<span class="codeline" id="line-1861"><code>// templateThread runs on an M without a P, so it must not have write</code></span>
<span class="codeline" id="line-1862"><code>// barriers.</code></span>
<span class="codeline" id="line-1863"><code>//</code></span>
<span class="codeline" id="line-1864"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-1865"><code>func templateThread() {</code></span>
<span class="codeline" id="line-1866"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1867"><code>	sched.nmsys++</code></span>
<span class="codeline" id="line-1868"><code>	checkdead()</code></span>
<span class="codeline" id="line-1869"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1870"><code></code></span>
<span class="codeline" id="line-1871"><code>	for {</code></span>
<span class="codeline" id="line-1872"><code>		lock(&amp;newmHandoff.lock)</code></span>
<span class="codeline" id="line-1873"><code>		for newmHandoff.newm != 0 {</code></span>
<span class="codeline" id="line-1874"><code>			newm := newmHandoff.newm.ptr()</code></span>
<span class="codeline" id="line-1875"><code>			newmHandoff.newm = 0</code></span>
<span class="codeline" id="line-1876"><code>			unlock(&amp;newmHandoff.lock)</code></span>
<span class="codeline" id="line-1877"><code>			for newm != nil {</code></span>
<span class="codeline" id="line-1878"><code>				next := newm.schedlink.ptr()</code></span>
<span class="codeline" id="line-1879"><code>				newm.schedlink = 0</code></span>
<span class="codeline" id="line-1880"><code>				newm1(newm)</code></span>
<span class="codeline" id="line-1881"><code>				newm = next</code></span>
<span class="codeline" id="line-1882"><code>			}</code></span>
<span class="codeline" id="line-1883"><code>			lock(&amp;newmHandoff.lock)</code></span>
<span class="codeline" id="line-1884"><code>		}</code></span>
<span class="codeline" id="line-1885"><code>		newmHandoff.waiting = true</code></span>
<span class="codeline" id="line-1886"><code>		noteclear(&amp;newmHandoff.wake)</code></span>
<span class="codeline" id="line-1887"><code>		unlock(&amp;newmHandoff.lock)</code></span>
<span class="codeline" id="line-1888"><code>		notesleep(&amp;newmHandoff.wake)</code></span>
<span class="codeline" id="line-1889"><code>	}</code></span>
<span class="codeline" id="line-1890"><code>}</code></span>
<span class="codeline" id="line-1891"><code></code></span>
<span class="codeline" id="line-1892"><code>// Stops execution of the current m until new work is available.</code></span>
<span class="codeline" id="line-1893"><code>// Returns with acquired P.</code></span>
<span class="codeline" id="line-1894"><code>func stopm() {</code></span>
<span class="codeline" id="line-1895"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-1896"><code></code></span>
<span class="codeline" id="line-1897"><code>	if _g_.m.locks != 0 {</code></span>
<span class="codeline" id="line-1898"><code>		throw("stopm holding locks")</code></span>
<span class="codeline" id="line-1899"><code>	}</code></span>
<span class="codeline" id="line-1900"><code>	if _g_.m.p != 0 {</code></span>
<span class="codeline" id="line-1901"><code>		throw("stopm holding p")</code></span>
<span class="codeline" id="line-1902"><code>	}</code></span>
<span class="codeline" id="line-1903"><code>	if _g_.m.spinning {</code></span>
<span class="codeline" id="line-1904"><code>		throw("stopm spinning")</code></span>
<span class="codeline" id="line-1905"><code>	}</code></span>
<span class="codeline" id="line-1906"><code></code></span>
<span class="codeline" id="line-1907"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1908"><code>	mput(_g_.m)</code></span>
<span class="codeline" id="line-1909"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1910"><code>	notesleep(&amp;_g_.m.park)</code></span>
<span class="codeline" id="line-1911"><code>	noteclear(&amp;_g_.m.park)</code></span>
<span class="codeline" id="line-1912"><code>	acquirep(_g_.m.nextp.ptr())</code></span>
<span class="codeline" id="line-1913"><code>	_g_.m.nextp = 0</code></span>
<span class="codeline" id="line-1914"><code>}</code></span>
<span class="codeline" id="line-1915"><code></code></span>
<span class="codeline" id="line-1916"><code>func mspinning() {</code></span>
<span class="codeline" id="line-1917"><code>	// startm's caller incremented nmspinning. Set the new M's spinning.</code></span>
<span class="codeline" id="line-1918"><code>	getg().m.spinning = true</code></span>
<span class="codeline" id="line-1919"><code>}</code></span>
<span class="codeline" id="line-1920"><code></code></span>
<span class="codeline" id="line-1921"><code>// Schedules some M to run the p (creates an M if necessary).</code></span>
<span class="codeline" id="line-1922"><code>// If p==nil, tries to get an idle P, if no idle P's does nothing.</code></span>
<span class="codeline" id="line-1923"><code>// May run with m.p==nil, so write barriers are not allowed.</code></span>
<span class="codeline" id="line-1924"><code>// If spinning is set, the caller has incremented nmspinning and startm will</code></span>
<span class="codeline" id="line-1925"><code>// either decrement nmspinning or set m.spinning in the newly started M.</code></span>
<span class="codeline" id="line-1926"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-1927"><code>func startm(_p_ *p, spinning bool) {</code></span>
<span class="codeline" id="line-1928"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1929"><code>	if _p_ == nil {</code></span>
<span class="codeline" id="line-1930"><code>		_p_ = pidleget()</code></span>
<span class="codeline" id="line-1931"><code>		if _p_ == nil {</code></span>
<span class="codeline" id="line-1932"><code>			unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1933"><code>			if spinning {</code></span>
<span class="codeline" id="line-1934"><code>				// The caller incremented nmspinning, but there are no idle Ps,</code></span>
<span class="codeline" id="line-1935"><code>				// so it's okay to just undo the increment and give up.</code></span>
<span class="codeline" id="line-1936"><code>				if int32(atomic.Xadd(&amp;sched.nmspinning, -1)) &lt; 0 {</code></span>
<span class="codeline" id="line-1937"><code>					throw("startm: negative nmspinning")</code></span>
<span class="codeline" id="line-1938"><code>				}</code></span>
<span class="codeline" id="line-1939"><code>			}</code></span>
<span class="codeline" id="line-1940"><code>			return</code></span>
<span class="codeline" id="line-1941"><code>		}</code></span>
<span class="codeline" id="line-1942"><code>	}</code></span>
<span class="codeline" id="line-1943"><code>	mp := mget()</code></span>
<span class="codeline" id="line-1944"><code>	if mp == nil {</code></span>
<span class="codeline" id="line-1945"><code>		// No M is available, we must drop sched.lock and call newm.</code></span>
<span class="codeline" id="line-1946"><code>		// However, we already own a P to assign to the M.</code></span>
<span class="codeline" id="line-1947"><code>		//</code></span>
<span class="codeline" id="line-1948"><code>		// Once sched.lock is released, another G (e.g., in a syscall),</code></span>
<span class="codeline" id="line-1949"><code>		// could find no idle P while checkdead finds a runnable G but</code></span>
<span class="codeline" id="line-1950"><code>		// no running M's because this new M hasn't started yet, thus</code></span>
<span class="codeline" id="line-1951"><code>		// throwing in an apparent deadlock.</code></span>
<span class="codeline" id="line-1952"><code>		//</code></span>
<span class="codeline" id="line-1953"><code>		// Avoid this situation by pre-allocating the ID for the new M,</code></span>
<span class="codeline" id="line-1954"><code>		// thus marking it as 'running' before we drop sched.lock. This</code></span>
<span class="codeline" id="line-1955"><code>		// new M will eventually run the scheduler to execute any</code></span>
<span class="codeline" id="line-1956"><code>		// queued G's.</code></span>
<span class="codeline" id="line-1957"><code>		id := mReserveID()</code></span>
<span class="codeline" id="line-1958"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1959"><code></code></span>
<span class="codeline" id="line-1960"><code>		var fn func()</code></span>
<span class="codeline" id="line-1961"><code>		if spinning {</code></span>
<span class="codeline" id="line-1962"><code>			// The caller incremented nmspinning, so set m.spinning in the new M.</code></span>
<span class="codeline" id="line-1963"><code>			fn = mspinning</code></span>
<span class="codeline" id="line-1964"><code>		}</code></span>
<span class="codeline" id="line-1965"><code>		newm(fn, _p_, id)</code></span>
<span class="codeline" id="line-1966"><code>		return</code></span>
<span class="codeline" id="line-1967"><code>	}</code></span>
<span class="codeline" id="line-1968"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1969"><code>	if mp.spinning {</code></span>
<span class="codeline" id="line-1970"><code>		throw("startm: m is spinning")</code></span>
<span class="codeline" id="line-1971"><code>	}</code></span>
<span class="codeline" id="line-1972"><code>	if mp.nextp != 0 {</code></span>
<span class="codeline" id="line-1973"><code>		throw("startm: m has p")</code></span>
<span class="codeline" id="line-1974"><code>	}</code></span>
<span class="codeline" id="line-1975"><code>	if spinning &amp;&amp; !runqempty(_p_) {</code></span>
<span class="codeline" id="line-1976"><code>		throw("startm: p has runnable gs")</code></span>
<span class="codeline" id="line-1977"><code>	}</code></span>
<span class="codeline" id="line-1978"><code>	// The caller incremented nmspinning, so set m.spinning in the new M.</code></span>
<span class="codeline" id="line-1979"><code>	mp.spinning = spinning</code></span>
<span class="codeline" id="line-1980"><code>	mp.nextp.set(_p_)</code></span>
<span class="codeline" id="line-1981"><code>	notewakeup(&amp;mp.park)</code></span>
<span class="codeline" id="line-1982"><code>}</code></span>
<span class="codeline" id="line-1983"><code></code></span>
<span class="codeline" id="line-1984"><code>// Hands off P from syscall or locked M.</code></span>
<span class="codeline" id="line-1985"><code>// Always runs without a P, so write barriers are not allowed.</code></span>
<span class="codeline" id="line-1986"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-1987"><code>func handoffp(_p_ *p) {</code></span>
<span class="codeline" id="line-1988"><code>	// handoffp must start an M in any situation where</code></span>
<span class="codeline" id="line-1989"><code>	// findrunnable would return a G to run on _p_.</code></span>
<span class="codeline" id="line-1990"><code></code></span>
<span class="codeline" id="line-1991"><code>	// if it has local work, start it straight away</code></span>
<span class="codeline" id="line-1992"><code>	if !runqempty(_p_) || sched.runqsize != 0 {</code></span>
<span class="codeline" id="line-1993"><code>		startm(_p_, false)</code></span>
<span class="codeline" id="line-1994"><code>		return</code></span>
<span class="codeline" id="line-1995"><code>	}</code></span>
<span class="codeline" id="line-1996"><code>	// if it has GC work, start it straight away</code></span>
<span class="codeline" id="line-1997"><code>	if gcBlackenEnabled != 0 &amp;&amp; gcMarkWorkAvailable(_p_) {</code></span>
<span class="codeline" id="line-1998"><code>		startm(_p_, false)</code></span>
<span class="codeline" id="line-1999"><code>		return</code></span>
<span class="codeline" id="line-2000"><code>	}</code></span>
<span class="codeline" id="line-2001"><code>	// no local work, check that there are no spinning/idle M's,</code></span>
<span class="codeline" id="line-2002"><code>	// otherwise our help is not required</code></span>
<span class="codeline" id="line-2003"><code>	if atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) == 0 &amp;&amp; atomic.Cas(&amp;sched.nmspinning, 0, 1) { // TODO: fast atomic</code></span>
<span class="codeline" id="line-2004"><code>		startm(_p_, true)</code></span>
<span class="codeline" id="line-2005"><code>		return</code></span>
<span class="codeline" id="line-2006"><code>	}</code></span>
<span class="codeline" id="line-2007"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2008"><code>	if sched.gcwaiting != 0 {</code></span>
<span class="codeline" id="line-2009"><code>		_p_.status = _Pgcstop</code></span>
<span class="codeline" id="line-2010"><code>		sched.stopwait--</code></span>
<span class="codeline" id="line-2011"><code>		if sched.stopwait == 0 {</code></span>
<span class="codeline" id="line-2012"><code>			notewakeup(&amp;sched.stopnote)</code></span>
<span class="codeline" id="line-2013"><code>		}</code></span>
<span class="codeline" id="line-2014"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2015"><code>		return</code></span>
<span class="codeline" id="line-2016"><code>	}</code></span>
<span class="codeline" id="line-2017"><code>	if _p_.runSafePointFn != 0 &amp;&amp; atomic.Cas(&amp;_p_.runSafePointFn, 1, 0) {</code></span>
<span class="codeline" id="line-2018"><code>		sched.safePointFn(_p_)</code></span>
<span class="codeline" id="line-2019"><code>		sched.safePointWait--</code></span>
<span class="codeline" id="line-2020"><code>		if sched.safePointWait == 0 {</code></span>
<span class="codeline" id="line-2021"><code>			notewakeup(&amp;sched.safePointNote)</code></span>
<span class="codeline" id="line-2022"><code>		}</code></span>
<span class="codeline" id="line-2023"><code>	}</code></span>
<span class="codeline" id="line-2024"><code>	if sched.runqsize != 0 {</code></span>
<span class="codeline" id="line-2025"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2026"><code>		startm(_p_, false)</code></span>
<span class="codeline" id="line-2027"><code>		return</code></span>
<span class="codeline" id="line-2028"><code>	}</code></span>
<span class="codeline" id="line-2029"><code>	// If this is the last running P and nobody is polling network,</code></span>
<span class="codeline" id="line-2030"><code>	// need to wakeup another M to poll network.</code></span>
<span class="codeline" id="line-2031"><code>	if sched.npidle == uint32(gomaxprocs-1) &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != 0 {</code></span>
<span class="codeline" id="line-2032"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2033"><code>		startm(_p_, false)</code></span>
<span class="codeline" id="line-2034"><code>		return</code></span>
<span class="codeline" id="line-2035"><code>	}</code></span>
<span class="codeline" id="line-2036"><code>	if when := nobarrierWakeTime(_p_); when != 0 {</code></span>
<span class="codeline" id="line-2037"><code>		wakeNetPoller(when)</code></span>
<span class="codeline" id="line-2038"><code>	}</code></span>
<span class="codeline" id="line-2039"><code>	pidleput(_p_)</code></span>
<span class="codeline" id="line-2040"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2041"><code>}</code></span>
<span class="codeline" id="line-2042"><code></code></span>
<span class="codeline" id="line-2043"><code>// Tries to add one more P to execute G's.</code></span>
<span class="codeline" id="line-2044"><code>// Called when a G is made runnable (newproc, ready).</code></span>
<span class="codeline" id="line-2045"><code>func wakep() {</code></span>
<span class="codeline" id="line-2046"><code>	if atomic.Load(&amp;sched.npidle) == 0 {</code></span>
<span class="codeline" id="line-2047"><code>		return</code></span>
<span class="codeline" id="line-2048"><code>	}</code></span>
<span class="codeline" id="line-2049"><code>	// be conservative about spinning threads</code></span>
<span class="codeline" id="line-2050"><code>	if atomic.Load(&amp;sched.nmspinning) != 0 || !atomic.Cas(&amp;sched.nmspinning, 0, 1) {</code></span>
<span class="codeline" id="line-2051"><code>		return</code></span>
<span class="codeline" id="line-2052"><code>	}</code></span>
<span class="codeline" id="line-2053"><code>	startm(nil, true)</code></span>
<span class="codeline" id="line-2054"><code>}</code></span>
<span class="codeline" id="line-2055"><code></code></span>
<span class="codeline" id="line-2056"><code>// Stops execution of the current m that is locked to a g until the g is runnable again.</code></span>
<span class="codeline" id="line-2057"><code>// Returns with acquired P.</code></span>
<span class="codeline" id="line-2058"><code>func stoplockedm() {</code></span>
<span class="codeline" id="line-2059"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-2060"><code></code></span>
<span class="codeline" id="line-2061"><code>	if _g_.m.lockedg == 0 || _g_.m.lockedg.ptr().lockedm.ptr() != _g_.m {</code></span>
<span class="codeline" id="line-2062"><code>		throw("stoplockedm: inconsistent locking")</code></span>
<span class="codeline" id="line-2063"><code>	}</code></span>
<span class="codeline" id="line-2064"><code>	if _g_.m.p != 0 {</code></span>
<span class="codeline" id="line-2065"><code>		// Schedule another M to run this p.</code></span>
<span class="codeline" id="line-2066"><code>		_p_ := releasep()</code></span>
<span class="codeline" id="line-2067"><code>		handoffp(_p_)</code></span>
<span class="codeline" id="line-2068"><code>	}</code></span>
<span class="codeline" id="line-2069"><code>	incidlelocked(1)</code></span>
<span class="codeline" id="line-2070"><code>	// Wait until another thread schedules lockedg again.</code></span>
<span class="codeline" id="line-2071"><code>	notesleep(&amp;_g_.m.park)</code></span>
<span class="codeline" id="line-2072"><code>	noteclear(&amp;_g_.m.park)</code></span>
<span class="codeline" id="line-2073"><code>	status := readgstatus(_g_.m.lockedg.ptr())</code></span>
<span class="codeline" id="line-2074"><code>	if status&amp;^_Gscan != _Grunnable {</code></span>
<span class="codeline" id="line-2075"><code>		print("runtime:stoplockedm: g is not Grunnable or Gscanrunnable\n")</code></span>
<span class="codeline" id="line-2076"><code>		dumpgstatus(_g_)</code></span>
<span class="codeline" id="line-2077"><code>		throw("stoplockedm: not runnable")</code></span>
<span class="codeline" id="line-2078"><code>	}</code></span>
<span class="codeline" id="line-2079"><code>	acquirep(_g_.m.nextp.ptr())</code></span>
<span class="codeline" id="line-2080"><code>	_g_.m.nextp = 0</code></span>
<span class="codeline" id="line-2081"><code>}</code></span>
<span class="codeline" id="line-2082"><code></code></span>
<span class="codeline" id="line-2083"><code>// Schedules the locked m to run the locked gp.</code></span>
<span class="codeline" id="line-2084"><code>// May run during STW, so write barriers are not allowed.</code></span>
<span class="codeline" id="line-2085"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-2086"><code>func startlockedm(gp *g) {</code></span>
<span class="codeline" id="line-2087"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-2088"><code></code></span>
<span class="codeline" id="line-2089"><code>	mp := gp.lockedm.ptr()</code></span>
<span class="codeline" id="line-2090"><code>	if mp == _g_.m {</code></span>
<span class="codeline" id="line-2091"><code>		throw("startlockedm: locked to me")</code></span>
<span class="codeline" id="line-2092"><code>	}</code></span>
<span class="codeline" id="line-2093"><code>	if mp.nextp != 0 {</code></span>
<span class="codeline" id="line-2094"><code>		throw("startlockedm: m has p")</code></span>
<span class="codeline" id="line-2095"><code>	}</code></span>
<span class="codeline" id="line-2096"><code>	// directly handoff current P to the locked m</code></span>
<span class="codeline" id="line-2097"><code>	incidlelocked(-1)</code></span>
<span class="codeline" id="line-2098"><code>	_p_ := releasep()</code></span>
<span class="codeline" id="line-2099"><code>	mp.nextp.set(_p_)</code></span>
<span class="codeline" id="line-2100"><code>	notewakeup(&amp;mp.park)</code></span>
<span class="codeline" id="line-2101"><code>	stopm()</code></span>
<span class="codeline" id="line-2102"><code>}</code></span>
<span class="codeline" id="line-2103"><code></code></span>
<span class="codeline" id="line-2104"><code>// Stops the current m for stopTheWorld.</code></span>
<span class="codeline" id="line-2105"><code>// Returns when the world is restarted.</code></span>
<span class="codeline" id="line-2106"><code>func gcstopm() {</code></span>
<span class="codeline" id="line-2107"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-2108"><code></code></span>
<span class="codeline" id="line-2109"><code>	if sched.gcwaiting == 0 {</code></span>
<span class="codeline" id="line-2110"><code>		throw("gcstopm: not waiting for gc")</code></span>
<span class="codeline" id="line-2111"><code>	}</code></span>
<span class="codeline" id="line-2112"><code>	if _g_.m.spinning {</code></span>
<span class="codeline" id="line-2113"><code>		_g_.m.spinning = false</code></span>
<span class="codeline" id="line-2114"><code>		// OK to just drop nmspinning here,</code></span>
<span class="codeline" id="line-2115"><code>		// startTheWorld will unpark threads as necessary.</code></span>
<span class="codeline" id="line-2116"><code>		if int32(atomic.Xadd(&amp;sched.nmspinning, -1)) &lt; 0 {</code></span>
<span class="codeline" id="line-2117"><code>			throw("gcstopm: negative nmspinning")</code></span>
<span class="codeline" id="line-2118"><code>		}</code></span>
<span class="codeline" id="line-2119"><code>	}</code></span>
<span class="codeline" id="line-2120"><code>	_p_ := releasep()</code></span>
<span class="codeline" id="line-2121"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2122"><code>	_p_.status = _Pgcstop</code></span>
<span class="codeline" id="line-2123"><code>	sched.stopwait--</code></span>
<span class="codeline" id="line-2124"><code>	if sched.stopwait == 0 {</code></span>
<span class="codeline" id="line-2125"><code>		notewakeup(&amp;sched.stopnote)</code></span>
<span class="codeline" id="line-2126"><code>	}</code></span>
<span class="codeline" id="line-2127"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2128"><code>	stopm()</code></span>
<span class="codeline" id="line-2129"><code>}</code></span>
<span class="codeline" id="line-2130"><code></code></span>
<span class="codeline" id="line-2131"><code>// Schedules gp to run on the current M.</code></span>
<span class="codeline" id="line-2132"><code>// If inheritTime is true, gp inherits the remaining time in the</code></span>
<span class="codeline" id="line-2133"><code>// current time slice. Otherwise, it starts a new time slice.</code></span>
<span class="codeline" id="line-2134"><code>// Never returns.</code></span>
<span class="codeline" id="line-2135"><code>//</code></span>
<span class="codeline" id="line-2136"><code>// Write barriers are allowed because this is called immediately after</code></span>
<span class="codeline" id="line-2137"><code>// acquiring a P in several places.</code></span>
<span class="codeline" id="line-2138"><code>//</code></span>
<span class="codeline" id="line-2139"><code>//go:yeswritebarrierrec</code></span>
<span class="codeline" id="line-2140"><code>func execute(gp *g, inheritTime bool) {</code></span>
<span class="codeline" id="line-2141"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-2142"><code></code></span>
<span class="codeline" id="line-2143"><code>	// Assign gp.m before entering _Grunning so running Gs have an</code></span>
<span class="codeline" id="line-2144"><code>	// M.</code></span>
<span class="codeline" id="line-2145"><code>	_g_.m.curg = gp</code></span>
<span class="codeline" id="line-2146"><code>	gp.m = _g_.m</code></span>
<span class="codeline" id="line-2147"><code>	casgstatus(gp, _Grunnable, _Grunning)</code></span>
<span class="codeline" id="line-2148"><code>	gp.waitsince = 0</code></span>
<span class="codeline" id="line-2149"><code>	gp.preempt = false</code></span>
<span class="codeline" id="line-2150"><code>	gp.stackguard0 = gp.stack.lo + _StackGuard</code></span>
<span class="codeline" id="line-2151"><code>	if !inheritTime {</code></span>
<span class="codeline" id="line-2152"><code>		_g_.m.p.ptr().schedtick++</code></span>
<span class="codeline" id="line-2153"><code>	}</code></span>
<span class="codeline" id="line-2154"><code></code></span>
<span class="codeline" id="line-2155"><code>	// Check whether the profiler needs to be turned on or off.</code></span>
<span class="codeline" id="line-2156"><code>	hz := sched.profilehz</code></span>
<span class="codeline" id="line-2157"><code>	if _g_.m.profilehz != hz {</code></span>
<span class="codeline" id="line-2158"><code>		setThreadCPUProfiler(hz)</code></span>
<span class="codeline" id="line-2159"><code>	}</code></span>
<span class="codeline" id="line-2160"><code></code></span>
<span class="codeline" id="line-2161"><code>	if trace.enabled {</code></span>
<span class="codeline" id="line-2162"><code>		// GoSysExit has to happen when we have a P, but before GoStart.</code></span>
<span class="codeline" id="line-2163"><code>		// So we emit it here.</code></span>
<span class="codeline" id="line-2164"><code>		if gp.syscallsp != 0 &amp;&amp; gp.sysblocktraced {</code></span>
<span class="codeline" id="line-2165"><code>			traceGoSysExit(gp.sysexitticks)</code></span>
<span class="codeline" id="line-2166"><code>		}</code></span>
<span class="codeline" id="line-2167"><code>		traceGoStart()</code></span>
<span class="codeline" id="line-2168"><code>	}</code></span>
<span class="codeline" id="line-2169"><code></code></span>
<span class="codeline" id="line-2170"><code>	gogo(&amp;gp.sched)</code></span>
<span class="codeline" id="line-2171"><code>}</code></span>
<span class="codeline" id="line-2172"><code></code></span>
<span class="codeline" id="line-2173"><code>// Finds a runnable goroutine to execute.</code></span>
<span class="codeline" id="line-2174"><code>// Tries to steal from other P's, get g from local or global queue, poll network.</code></span>
<span class="codeline" id="line-2175"><code>func findrunnable() (gp *g, inheritTime bool) {</code></span>
<span class="codeline" id="line-2176"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-2177"><code></code></span>
<span class="codeline" id="line-2178"><code>	// The conditions here and in handoffp must agree: if</code></span>
<span class="codeline" id="line-2179"><code>	// findrunnable would return a G to run, handoffp must start</code></span>
<span class="codeline" id="line-2180"><code>	// an M.</code></span>
<span class="codeline" id="line-2181"><code></code></span>
<span class="codeline" id="line-2182"><code>top:</code></span>
<span class="codeline" id="line-2183"><code>	_p_ := _g_.m.p.ptr()</code></span>
<span class="codeline" id="line-2184"><code>	if sched.gcwaiting != 0 {</code></span>
<span class="codeline" id="line-2185"><code>		gcstopm()</code></span>
<span class="codeline" id="line-2186"><code>		goto top</code></span>
<span class="codeline" id="line-2187"><code>	}</code></span>
<span class="codeline" id="line-2188"><code>	if _p_.runSafePointFn != 0 {</code></span>
<span class="codeline" id="line-2189"><code>		runSafePointFn()</code></span>
<span class="codeline" id="line-2190"><code>	}</code></span>
<span class="codeline" id="line-2191"><code></code></span>
<span class="codeline" id="line-2192"><code>	now, pollUntil, _ := checkTimers(_p_, 0)</code></span>
<span class="codeline" id="line-2193"><code></code></span>
<span class="codeline" id="line-2194"><code>	if fingwait &amp;&amp; fingwake {</code></span>
<span class="codeline" id="line-2195"><code>		if gp := wakefing(); gp != nil {</code></span>
<span class="codeline" id="line-2196"><code>			ready(gp, 0, true)</code></span>
<span class="codeline" id="line-2197"><code>		}</code></span>
<span class="codeline" id="line-2198"><code>	}</code></span>
<span class="codeline" id="line-2199"><code>	if *cgo_yield != nil {</code></span>
<span class="codeline" id="line-2200"><code>		asmcgocall(*cgo_yield, nil)</code></span>
<span class="codeline" id="line-2201"><code>	}</code></span>
<span class="codeline" id="line-2202"><code></code></span>
<span class="codeline" id="line-2203"><code>	// local runq</code></span>
<span class="codeline" id="line-2204"><code>	if gp, inheritTime := runqget(_p_); gp != nil {</code></span>
<span class="codeline" id="line-2205"><code>		return gp, inheritTime</code></span>
<span class="codeline" id="line-2206"><code>	}</code></span>
<span class="codeline" id="line-2207"><code></code></span>
<span class="codeline" id="line-2208"><code>	// global runq</code></span>
<span class="codeline" id="line-2209"><code>	if sched.runqsize != 0 {</code></span>
<span class="codeline" id="line-2210"><code>		lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2211"><code>		gp := globrunqget(_p_, 0)</code></span>
<span class="codeline" id="line-2212"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2213"><code>		if gp != nil {</code></span>
<span class="codeline" id="line-2214"><code>			return gp, false</code></span>
<span class="codeline" id="line-2215"><code>		}</code></span>
<span class="codeline" id="line-2216"><code>	}</code></span>
<span class="codeline" id="line-2217"><code></code></span>
<span class="codeline" id="line-2218"><code>	// Poll network.</code></span>
<span class="codeline" id="line-2219"><code>	// This netpoll is only an optimization before we resort to stealing.</code></span>
<span class="codeline" id="line-2220"><code>	// We can safely skip it if there are no waiters or a thread is blocked</code></span>
<span class="codeline" id="line-2221"><code>	// in netpoll already. If there is any kind of logical race with that</code></span>
<span class="codeline" id="line-2222"><code>	// blocked thread (e.g. it has already returned from netpoll, but does</code></span>
<span class="codeline" id="line-2223"><code>	// not set lastpoll yet), this thread will do blocking netpoll below</code></span>
<span class="codeline" id="line-2224"><code>	// anyway.</code></span>
<span class="codeline" id="line-2225"><code>	if netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; 0 &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != 0 {</code></span>
<span class="codeline" id="line-2226"><code>		if list := netpoll(0); !list.empty() { // non-blocking</code></span>
<span class="codeline" id="line-2227"><code>			gp := list.pop()</code></span>
<span class="codeline" id="line-2228"><code>			injectglist(&amp;list)</code></span>
<span class="codeline" id="line-2229"><code>			casgstatus(gp, _Gwaiting, _Grunnable)</code></span>
<span class="codeline" id="line-2230"><code>			if trace.enabled {</code></span>
<span class="codeline" id="line-2231"><code>				traceGoUnpark(gp, 0)</code></span>
<span class="codeline" id="line-2232"><code>			}</code></span>
<span class="codeline" id="line-2233"><code>			return gp, false</code></span>
<span class="codeline" id="line-2234"><code>		}</code></span>
<span class="codeline" id="line-2235"><code>	}</code></span>
<span class="codeline" id="line-2236"><code></code></span>
<span class="codeline" id="line-2237"><code>	// Steal work from other P's.</code></span>
<span class="codeline" id="line-2238"><code>	procs := uint32(gomaxprocs)</code></span>
<span class="codeline" id="line-2239"><code>	ranTimer := false</code></span>
<span class="codeline" id="line-2240"><code>	// If number of spinning M's &gt;= number of busy P's, block.</code></span>
<span class="codeline" id="line-2241"><code>	// This is necessary to prevent excessive CPU consumption</code></span>
<span class="codeline" id="line-2242"><code>	// when GOMAXPROCS&gt;&gt;1 but the program parallelism is low.</code></span>
<span class="codeline" id="line-2243"><code>	if !_g_.m.spinning &amp;&amp; 2*atomic.Load(&amp;sched.nmspinning) &gt;= procs-atomic.Load(&amp;sched.npidle) {</code></span>
<span class="codeline" id="line-2244"><code>		goto stop</code></span>
<span class="codeline" id="line-2245"><code>	}</code></span>
<span class="codeline" id="line-2246"><code>	if !_g_.m.spinning {</code></span>
<span class="codeline" id="line-2247"><code>		_g_.m.spinning = true</code></span>
<span class="codeline" id="line-2248"><code>		atomic.Xadd(&amp;sched.nmspinning, 1)</code></span>
<span class="codeline" id="line-2249"><code>	}</code></span>
<span class="codeline" id="line-2250"><code>	for i := 0; i &lt; 4; i++ {</code></span>
<span class="codeline" id="line-2251"><code>		for enum := stealOrder.start(fastrand()); !enum.done(); enum.next() {</code></span>
<span class="codeline" id="line-2252"><code>			if sched.gcwaiting != 0 {</code></span>
<span class="codeline" id="line-2253"><code>				goto top</code></span>
<span class="codeline" id="line-2254"><code>			}</code></span>
<span class="codeline" id="line-2255"><code>			stealRunNextG := i &gt; 2 // first look for ready queues with more than 1 g</code></span>
<span class="codeline" id="line-2256"><code>			p2 := allp[enum.position()]</code></span>
<span class="codeline" id="line-2257"><code>			if _p_ == p2 {</code></span>
<span class="codeline" id="line-2258"><code>				continue</code></span>
<span class="codeline" id="line-2259"><code>			}</code></span>
<span class="codeline" id="line-2260"><code>			if gp := runqsteal(_p_, p2, stealRunNextG); gp != nil {</code></span>
<span class="codeline" id="line-2261"><code>				return gp, false</code></span>
<span class="codeline" id="line-2262"><code>			}</code></span>
<span class="codeline" id="line-2263"><code></code></span>
<span class="codeline" id="line-2264"><code>			// Consider stealing timers from p2.</code></span>
<span class="codeline" id="line-2265"><code>			// This call to checkTimers is the only place where</code></span>
<span class="codeline" id="line-2266"><code>			// we hold a lock on a different P's timers.</code></span>
<span class="codeline" id="line-2267"><code>			// Lock contention can be a problem here, so</code></span>
<span class="codeline" id="line-2268"><code>			// initially avoid grabbing the lock if p2 is running</code></span>
<span class="codeline" id="line-2269"><code>			// and is not marked for preemption. If p2 is running</code></span>
<span class="codeline" id="line-2270"><code>			// and not being preempted we assume it will handle its</code></span>
<span class="codeline" id="line-2271"><code>			// own timers.</code></span>
<span class="codeline" id="line-2272"><code>			// If we're still looking for work after checking all</code></span>
<span class="codeline" id="line-2273"><code>			// the P's, then go ahead and steal from an active P.</code></span>
<span class="codeline" id="line-2274"><code>			if i &gt; 2 || (i &gt; 1 &amp;&amp; shouldStealTimers(p2)) {</code></span>
<span class="codeline" id="line-2275"><code>				tnow, w, ran := checkTimers(p2, now)</code></span>
<span class="codeline" id="line-2276"><code>				now = tnow</code></span>
<span class="codeline" id="line-2277"><code>				if w != 0 &amp;&amp; (pollUntil == 0 || w &lt; pollUntil) {</code></span>
<span class="codeline" id="line-2278"><code>					pollUntil = w</code></span>
<span class="codeline" id="line-2279"><code>				}</code></span>
<span class="codeline" id="line-2280"><code>				if ran {</code></span>
<span class="codeline" id="line-2281"><code>					// Running the timers may have</code></span>
<span class="codeline" id="line-2282"><code>					// made an arbitrary number of G's</code></span>
<span class="codeline" id="line-2283"><code>					// ready and added them to this P's</code></span>
<span class="codeline" id="line-2284"><code>					// local run queue. That invalidates</code></span>
<span class="codeline" id="line-2285"><code>					// the assumption of runqsteal</code></span>
<span class="codeline" id="line-2286"><code>					// that is always has room to add</code></span>
<span class="codeline" id="line-2287"><code>					// stolen G's. So check now if there</code></span>
<span class="codeline" id="line-2288"><code>					// is a local G to run.</code></span>
<span class="codeline" id="line-2289"><code>					if gp, inheritTime := runqget(_p_); gp != nil {</code></span>
<span class="codeline" id="line-2290"><code>						return gp, inheritTime</code></span>
<span class="codeline" id="line-2291"><code>					}</code></span>
<span class="codeline" id="line-2292"><code>					ranTimer = true</code></span>
<span class="codeline" id="line-2293"><code>				}</code></span>
<span class="codeline" id="line-2294"><code>			}</code></span>
<span class="codeline" id="line-2295"><code>		}</code></span>
<span class="codeline" id="line-2296"><code>	}</code></span>
<span class="codeline" id="line-2297"><code>	if ranTimer {</code></span>
<span class="codeline" id="line-2298"><code>		// Running a timer may have made some goroutine ready.</code></span>
<span class="codeline" id="line-2299"><code>		goto top</code></span>
<span class="codeline" id="line-2300"><code>	}</code></span>
<span class="codeline" id="line-2301"><code></code></span>
<span class="codeline" id="line-2302"><code>stop:</code></span>
<span class="codeline" id="line-2303"><code></code></span>
<span class="codeline" id="line-2304"><code>	// We have nothing to do. If we're in the GC mark phase, can</code></span>
<span class="codeline" id="line-2305"><code>	// safely scan and blacken objects, and have work to do, run</code></span>
<span class="codeline" id="line-2306"><code>	// idle-time marking rather than give up the P.</code></span>
<span class="codeline" id="line-2307"><code>	if gcBlackenEnabled != 0 &amp;&amp; _p_.gcBgMarkWorker != 0 &amp;&amp; gcMarkWorkAvailable(_p_) {</code></span>
<span class="codeline" id="line-2308"><code>		_p_.gcMarkWorkerMode = gcMarkWorkerIdleMode</code></span>
<span class="codeline" id="line-2309"><code>		gp := _p_.gcBgMarkWorker.ptr()</code></span>
<span class="codeline" id="line-2310"><code>		casgstatus(gp, _Gwaiting, _Grunnable)</code></span>
<span class="codeline" id="line-2311"><code>		if trace.enabled {</code></span>
<span class="codeline" id="line-2312"><code>			traceGoUnpark(gp, 0)</code></span>
<span class="codeline" id="line-2313"><code>		}</code></span>
<span class="codeline" id="line-2314"><code>		return gp, false</code></span>
<span class="codeline" id="line-2315"><code>	}</code></span>
<span class="codeline" id="line-2316"><code></code></span>
<span class="codeline" id="line-2317"><code>	delta := int64(-1)</code></span>
<span class="codeline" id="line-2318"><code>	if pollUntil != 0 {</code></span>
<span class="codeline" id="line-2319"><code>		// checkTimers ensures that polluntil &gt; now.</code></span>
<span class="codeline" id="line-2320"><code>		delta = pollUntil - now</code></span>
<span class="codeline" id="line-2321"><code>	}</code></span>
<span class="codeline" id="line-2322"><code></code></span>
<span class="codeline" id="line-2323"><code>	// wasm only:</code></span>
<span class="codeline" id="line-2324"><code>	// If a callback returned and no other goroutine is awake,</code></span>
<span class="codeline" id="line-2325"><code>	// then wake event handler goroutine which pauses execution</code></span>
<span class="codeline" id="line-2326"><code>	// until a callback was triggered.</code></span>
<span class="codeline" id="line-2327"><code>	gp, otherReady := beforeIdle(delta)</code></span>
<span class="codeline" id="line-2328"><code>	if gp != nil {</code></span>
<span class="codeline" id="line-2329"><code>		casgstatus(gp, _Gwaiting, _Grunnable)</code></span>
<span class="codeline" id="line-2330"><code>		if trace.enabled {</code></span>
<span class="codeline" id="line-2331"><code>			traceGoUnpark(gp, 0)</code></span>
<span class="codeline" id="line-2332"><code>		}</code></span>
<span class="codeline" id="line-2333"><code>		return gp, false</code></span>
<span class="codeline" id="line-2334"><code>	}</code></span>
<span class="codeline" id="line-2335"><code>	if otherReady {</code></span>
<span class="codeline" id="line-2336"><code>		goto top</code></span>
<span class="codeline" id="line-2337"><code>	}</code></span>
<span class="codeline" id="line-2338"><code></code></span>
<span class="codeline" id="line-2339"><code>	// Before we drop our P, make a snapshot of the allp slice,</code></span>
<span class="codeline" id="line-2340"><code>	// which can change underfoot once we no longer block</code></span>
<span class="codeline" id="line-2341"><code>	// safe-points. We don't need to snapshot the contents because</code></span>
<span class="codeline" id="line-2342"><code>	// everything up to cap(allp) is immutable.</code></span>
<span class="codeline" id="line-2343"><code>	allpSnapshot := allp</code></span>
<span class="codeline" id="line-2344"><code></code></span>
<span class="codeline" id="line-2345"><code>	// return P and block</code></span>
<span class="codeline" id="line-2346"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2347"><code>	if sched.gcwaiting != 0 || _p_.runSafePointFn != 0 {</code></span>
<span class="codeline" id="line-2348"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2349"><code>		goto top</code></span>
<span class="codeline" id="line-2350"><code>	}</code></span>
<span class="codeline" id="line-2351"><code>	if sched.runqsize != 0 {</code></span>
<span class="codeline" id="line-2352"><code>		gp := globrunqget(_p_, 0)</code></span>
<span class="codeline" id="line-2353"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2354"><code>		return gp, false</code></span>
<span class="codeline" id="line-2355"><code>	}</code></span>
<span class="codeline" id="line-2356"><code>	if releasep() != _p_ {</code></span>
<span class="codeline" id="line-2357"><code>		throw("findrunnable: wrong p")</code></span>
<span class="codeline" id="line-2358"><code>	}</code></span>
<span class="codeline" id="line-2359"><code>	pidleput(_p_)</code></span>
<span class="codeline" id="line-2360"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2361"><code></code></span>
<span class="codeline" id="line-2362"><code>	// Delicate dance: thread transitions from spinning to non-spinning state,</code></span>
<span class="codeline" id="line-2363"><code>	// potentially concurrently with submission of new goroutines. We must</code></span>
<span class="codeline" id="line-2364"><code>	// drop nmspinning first and then check all per-P queues again (with</code></span>
<span class="codeline" id="line-2365"><code>	// #StoreLoad memory barrier in between). If we do it the other way around,</code></span>
<span class="codeline" id="line-2366"><code>	// another thread can submit a goroutine after we've checked all run queues</code></span>
<span class="codeline" id="line-2367"><code>	// but before we drop nmspinning; as the result nobody will unpark a thread</code></span>
<span class="codeline" id="line-2368"><code>	// to run the goroutine.</code></span>
<span class="codeline" id="line-2369"><code>	// If we discover new work below, we need to restore m.spinning as a signal</code></span>
<span class="codeline" id="line-2370"><code>	// for resetspinning to unpark a new worker thread (because there can be more</code></span>
<span class="codeline" id="line-2371"><code>	// than one starving goroutine). However, if after discovering new work</code></span>
<span class="codeline" id="line-2372"><code>	// we also observe no idle Ps, it is OK to just park the current thread:</code></span>
<span class="codeline" id="line-2373"><code>	// the system is fully loaded so no spinning threads are required.</code></span>
<span class="codeline" id="line-2374"><code>	// Also see "Worker thread parking/unparking" comment at the top of the file.</code></span>
<span class="codeline" id="line-2375"><code>	wasSpinning := _g_.m.spinning</code></span>
<span class="codeline" id="line-2376"><code>	if _g_.m.spinning {</code></span>
<span class="codeline" id="line-2377"><code>		_g_.m.spinning = false</code></span>
<span class="codeline" id="line-2378"><code>		if int32(atomic.Xadd(&amp;sched.nmspinning, -1)) &lt; 0 {</code></span>
<span class="codeline" id="line-2379"><code>			throw("findrunnable: negative nmspinning")</code></span>
<span class="codeline" id="line-2380"><code>		}</code></span>
<span class="codeline" id="line-2381"><code>	}</code></span>
<span class="codeline" id="line-2382"><code></code></span>
<span class="codeline" id="line-2383"><code>	// check all runqueues once again</code></span>
<span class="codeline" id="line-2384"><code>	for _, _p_ := range allpSnapshot {</code></span>
<span class="codeline" id="line-2385"><code>		if !runqempty(_p_) {</code></span>
<span class="codeline" id="line-2386"><code>			lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2387"><code>			_p_ = pidleget()</code></span>
<span class="codeline" id="line-2388"><code>			unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2389"><code>			if _p_ != nil {</code></span>
<span class="codeline" id="line-2390"><code>				acquirep(_p_)</code></span>
<span class="codeline" id="line-2391"><code>				if wasSpinning {</code></span>
<span class="codeline" id="line-2392"><code>					_g_.m.spinning = true</code></span>
<span class="codeline" id="line-2393"><code>					atomic.Xadd(&amp;sched.nmspinning, 1)</code></span>
<span class="codeline" id="line-2394"><code>				}</code></span>
<span class="codeline" id="line-2395"><code>				goto top</code></span>
<span class="codeline" id="line-2396"><code>			}</code></span>
<span class="codeline" id="line-2397"><code>			break</code></span>
<span class="codeline" id="line-2398"><code>		}</code></span>
<span class="codeline" id="line-2399"><code>	}</code></span>
<span class="codeline" id="line-2400"><code></code></span>
<span class="codeline" id="line-2401"><code>	// Check for idle-priority GC work again.</code></span>
<span class="codeline" id="line-2402"><code>	if gcBlackenEnabled != 0 &amp;&amp; gcMarkWorkAvailable(nil) {</code></span>
<span class="codeline" id="line-2403"><code>		lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2404"><code>		_p_ = pidleget()</code></span>
<span class="codeline" id="line-2405"><code>		if _p_ != nil &amp;&amp; _p_.gcBgMarkWorker == 0 {</code></span>
<span class="codeline" id="line-2406"><code>			pidleput(_p_)</code></span>
<span class="codeline" id="line-2407"><code>			_p_ = nil</code></span>
<span class="codeline" id="line-2408"><code>		}</code></span>
<span class="codeline" id="line-2409"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2410"><code>		if _p_ != nil {</code></span>
<span class="codeline" id="line-2411"><code>			acquirep(_p_)</code></span>
<span class="codeline" id="line-2412"><code>			if wasSpinning {</code></span>
<span class="codeline" id="line-2413"><code>				_g_.m.spinning = true</code></span>
<span class="codeline" id="line-2414"><code>				atomic.Xadd(&amp;sched.nmspinning, 1)</code></span>
<span class="codeline" id="line-2415"><code>			}</code></span>
<span class="codeline" id="line-2416"><code>			// Go back to idle GC check.</code></span>
<span class="codeline" id="line-2417"><code>			goto stop</code></span>
<span class="codeline" id="line-2418"><code>		}</code></span>
<span class="codeline" id="line-2419"><code>	}</code></span>
<span class="codeline" id="line-2420"><code></code></span>
<span class="codeline" id="line-2421"><code>	// poll network</code></span>
<span class="codeline" id="line-2422"><code>	if netpollinited() &amp;&amp; (atomic.Load(&amp;netpollWaiters) &gt; 0 || pollUntil != 0) &amp;&amp; atomic.Xchg64(&amp;sched.lastpoll, 0) != 0 {</code></span>
<span class="codeline" id="line-2423"><code>		atomic.Store64(&amp;sched.pollUntil, uint64(pollUntil))</code></span>
<span class="codeline" id="line-2424"><code>		if _g_.m.p != 0 {</code></span>
<span class="codeline" id="line-2425"><code>			throw("findrunnable: netpoll with p")</code></span>
<span class="codeline" id="line-2426"><code>		}</code></span>
<span class="codeline" id="line-2427"><code>		if _g_.m.spinning {</code></span>
<span class="codeline" id="line-2428"><code>			throw("findrunnable: netpoll with spinning")</code></span>
<span class="codeline" id="line-2429"><code>		}</code></span>
<span class="codeline" id="line-2430"><code>		if faketime != 0 {</code></span>
<span class="codeline" id="line-2431"><code>			// When using fake time, just poll.</code></span>
<span class="codeline" id="line-2432"><code>			delta = 0</code></span>
<span class="codeline" id="line-2433"><code>		}</code></span>
<span class="codeline" id="line-2434"><code>		list := netpoll(delta) // block until new work is available</code></span>
<span class="codeline" id="line-2435"><code>		atomic.Store64(&amp;sched.pollUntil, 0)</code></span>
<span class="codeline" id="line-2436"><code>		atomic.Store64(&amp;sched.lastpoll, uint64(nanotime()))</code></span>
<span class="codeline" id="line-2437"><code>		if faketime != 0 &amp;&amp; list.empty() {</code></span>
<span class="codeline" id="line-2438"><code>			// Using fake time and nothing is ready; stop M.</code></span>
<span class="codeline" id="line-2439"><code>			// When all M's stop, checkdead will call timejump.</code></span>
<span class="codeline" id="line-2440"><code>			stopm()</code></span>
<span class="codeline" id="line-2441"><code>			goto top</code></span>
<span class="codeline" id="line-2442"><code>		}</code></span>
<span class="codeline" id="line-2443"><code>		lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2444"><code>		_p_ = pidleget()</code></span>
<span class="codeline" id="line-2445"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2446"><code>		if _p_ == nil {</code></span>
<span class="codeline" id="line-2447"><code>			injectglist(&amp;list)</code></span>
<span class="codeline" id="line-2448"><code>		} else {</code></span>
<span class="codeline" id="line-2449"><code>			acquirep(_p_)</code></span>
<span class="codeline" id="line-2450"><code>			if !list.empty() {</code></span>
<span class="codeline" id="line-2451"><code>				gp := list.pop()</code></span>
<span class="codeline" id="line-2452"><code>				injectglist(&amp;list)</code></span>
<span class="codeline" id="line-2453"><code>				casgstatus(gp, _Gwaiting, _Grunnable)</code></span>
<span class="codeline" id="line-2454"><code>				if trace.enabled {</code></span>
<span class="codeline" id="line-2455"><code>					traceGoUnpark(gp, 0)</code></span>
<span class="codeline" id="line-2456"><code>				}</code></span>
<span class="codeline" id="line-2457"><code>				return gp, false</code></span>
<span class="codeline" id="line-2458"><code>			}</code></span>
<span class="codeline" id="line-2459"><code>			if wasSpinning {</code></span>
<span class="codeline" id="line-2460"><code>				_g_.m.spinning = true</code></span>
<span class="codeline" id="line-2461"><code>				atomic.Xadd(&amp;sched.nmspinning, 1)</code></span>
<span class="codeline" id="line-2462"><code>			}</code></span>
<span class="codeline" id="line-2463"><code>			goto top</code></span>
<span class="codeline" id="line-2464"><code>		}</code></span>
<span class="codeline" id="line-2465"><code>	} else if pollUntil != 0 &amp;&amp; netpollinited() {</code></span>
<span class="codeline" id="line-2466"><code>		pollerPollUntil := int64(atomic.Load64(&amp;sched.pollUntil))</code></span>
<span class="codeline" id="line-2467"><code>		if pollerPollUntil == 0 || pollerPollUntil &gt; pollUntil {</code></span>
<span class="codeline" id="line-2468"><code>			netpollBreak()</code></span>
<span class="codeline" id="line-2469"><code>		}</code></span>
<span class="codeline" id="line-2470"><code>	}</code></span>
<span class="codeline" id="line-2471"><code>	stopm()</code></span>
<span class="codeline" id="line-2472"><code>	goto top</code></span>
<span class="codeline" id="line-2473"><code>}</code></span>
<span class="codeline" id="line-2474"><code></code></span>
<span class="codeline" id="line-2475"><code>// pollWork reports whether there is non-background work this P could</code></span>
<span class="codeline" id="line-2476"><code>// be doing. This is a fairly lightweight check to be used for</code></span>
<span class="codeline" id="line-2477"><code>// background work loops, like idle GC. It checks a subset of the</code></span>
<span class="codeline" id="line-2478"><code>// conditions checked by the actual scheduler.</code></span>
<span class="codeline" id="line-2479"><code>func pollWork() bool {</code></span>
<span class="codeline" id="line-2480"><code>	if sched.runqsize != 0 {</code></span>
<span class="codeline" id="line-2481"><code>		return true</code></span>
<span class="codeline" id="line-2482"><code>	}</code></span>
<span class="codeline" id="line-2483"><code>	p := getg().m.p.ptr()</code></span>
<span class="codeline" id="line-2484"><code>	if !runqempty(p) {</code></span>
<span class="codeline" id="line-2485"><code>		return true</code></span>
<span class="codeline" id="line-2486"><code>	}</code></span>
<span class="codeline" id="line-2487"><code>	if netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; 0 &amp;&amp; sched.lastpoll != 0 {</code></span>
<span class="codeline" id="line-2488"><code>		if list := netpoll(0); !list.empty() {</code></span>
<span class="codeline" id="line-2489"><code>			injectglist(&amp;list)</code></span>
<span class="codeline" id="line-2490"><code>			return true</code></span>
<span class="codeline" id="line-2491"><code>		}</code></span>
<span class="codeline" id="line-2492"><code>	}</code></span>
<span class="codeline" id="line-2493"><code>	return false</code></span>
<span class="codeline" id="line-2494"><code>}</code></span>
<span class="codeline" id="line-2495"><code></code></span>
<span class="codeline" id="line-2496"><code>// wakeNetPoller wakes up the thread sleeping in the network poller,</code></span>
<span class="codeline" id="line-2497"><code>// if there is one, and if it isn't going to wake up anyhow before</code></span>
<span class="codeline" id="line-2498"><code>// the when argument.</code></span>
<span class="codeline" id="line-2499"><code>func wakeNetPoller(when int64) {</code></span>
<span class="codeline" id="line-2500"><code>	if atomic.Load64(&amp;sched.lastpoll) == 0 {</code></span>
<span class="codeline" id="line-2501"><code>		// In findrunnable we ensure that when polling the pollUntil</code></span>
<span class="codeline" id="line-2502"><code>		// field is either zero or the time to which the current</code></span>
<span class="codeline" id="line-2503"><code>		// poll is expected to run. This can have a spurious wakeup</code></span>
<span class="codeline" id="line-2504"><code>		// but should never miss a wakeup.</code></span>
<span class="codeline" id="line-2505"><code>		pollerPollUntil := int64(atomic.Load64(&amp;sched.pollUntil))</code></span>
<span class="codeline" id="line-2506"><code>		if pollerPollUntil == 0 || pollerPollUntil &gt; when {</code></span>
<span class="codeline" id="line-2507"><code>			netpollBreak()</code></span>
<span class="codeline" id="line-2508"><code>		}</code></span>
<span class="codeline" id="line-2509"><code>	}</code></span>
<span class="codeline" id="line-2510"><code>}</code></span>
<span class="codeline" id="line-2511"><code></code></span>
<span class="codeline" id="line-2512"><code>func resetspinning() {</code></span>
<span class="codeline" id="line-2513"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-2514"><code>	if !_g_.m.spinning {</code></span>
<span class="codeline" id="line-2515"><code>		throw("resetspinning: not a spinning m")</code></span>
<span class="codeline" id="line-2516"><code>	}</code></span>
<span class="codeline" id="line-2517"><code>	_g_.m.spinning = false</code></span>
<span class="codeline" id="line-2518"><code>	nmspinning := atomic.Xadd(&amp;sched.nmspinning, -1)</code></span>
<span class="codeline" id="line-2519"><code>	if int32(nmspinning) &lt; 0 {</code></span>
<span class="codeline" id="line-2520"><code>		throw("findrunnable: negative nmspinning")</code></span>
<span class="codeline" id="line-2521"><code>	}</code></span>
<span class="codeline" id="line-2522"><code>	// M wakeup policy is deliberately somewhat conservative, so check if we</code></span>
<span class="codeline" id="line-2523"><code>	// need to wakeup another P here. See "Worker thread parking/unparking"</code></span>
<span class="codeline" id="line-2524"><code>	// comment at the top of the file for details.</code></span>
<span class="codeline" id="line-2525"><code>	wakep()</code></span>
<span class="codeline" id="line-2526"><code>}</code></span>
<span class="codeline" id="line-2527"><code></code></span>
<span class="codeline" id="line-2528"><code>// injectglist adds each runnable G on the list to some run queue,</code></span>
<span class="codeline" id="line-2529"><code>// and clears glist. If there is no current P, they are added to the</code></span>
<span class="codeline" id="line-2530"><code>// global queue, and up to npidle M's are started to run them.</code></span>
<span class="codeline" id="line-2531"><code>// Otherwise, for each idle P, this adds a G to the global queue</code></span>
<span class="codeline" id="line-2532"><code>// and starts an M. Any remaining G's are added to the current P's</code></span>
<span class="codeline" id="line-2533"><code>// local run queue.</code></span>
<span class="codeline" id="line-2534"><code>// This may temporarily acquire the scheduler lock.</code></span>
<span class="codeline" id="line-2535"><code>// Can run concurrently with GC.</code></span>
<span class="codeline" id="line-2536"><code>func injectglist(glist *gList) {</code></span>
<span class="codeline" id="line-2537"><code>	if glist.empty() {</code></span>
<span class="codeline" id="line-2538"><code>		return</code></span>
<span class="codeline" id="line-2539"><code>	}</code></span>
<span class="codeline" id="line-2540"><code>	if trace.enabled {</code></span>
<span class="codeline" id="line-2541"><code>		for gp := glist.head.ptr(); gp != nil; gp = gp.schedlink.ptr() {</code></span>
<span class="codeline" id="line-2542"><code>			traceGoUnpark(gp, 0)</code></span>
<span class="codeline" id="line-2543"><code>		}</code></span>
<span class="codeline" id="line-2544"><code>	}</code></span>
<span class="codeline" id="line-2545"><code></code></span>
<span class="codeline" id="line-2546"><code>	// Mark all the goroutines as runnable before we put them</code></span>
<span class="codeline" id="line-2547"><code>	// on the run queues.</code></span>
<span class="codeline" id="line-2548"><code>	head := glist.head.ptr()</code></span>
<span class="codeline" id="line-2549"><code>	var tail *g</code></span>
<span class="codeline" id="line-2550"><code>	qsize := 0</code></span>
<span class="codeline" id="line-2551"><code>	for gp := head; gp != nil; gp = gp.schedlink.ptr() {</code></span>
<span class="codeline" id="line-2552"><code>		tail = gp</code></span>
<span class="codeline" id="line-2553"><code>		qsize++</code></span>
<span class="codeline" id="line-2554"><code>		casgstatus(gp, _Gwaiting, _Grunnable)</code></span>
<span class="codeline" id="line-2555"><code>	}</code></span>
<span class="codeline" id="line-2556"><code></code></span>
<span class="codeline" id="line-2557"><code>	// Turn the gList into a gQueue.</code></span>
<span class="codeline" id="line-2558"><code>	var q gQueue</code></span>
<span class="codeline" id="line-2559"><code>	q.head.set(head)</code></span>
<span class="codeline" id="line-2560"><code>	q.tail.set(tail)</code></span>
<span class="codeline" id="line-2561"><code>	*glist = gList{}</code></span>
<span class="codeline" id="line-2562"><code></code></span>
<span class="codeline" id="line-2563"><code>	startIdle := func(n int) {</code></span>
<span class="codeline" id="line-2564"><code>		for ; n != 0 &amp;&amp; sched.npidle != 0; n-- {</code></span>
<span class="codeline" id="line-2565"><code>			startm(nil, false)</code></span>
<span class="codeline" id="line-2566"><code>		}</code></span>
<span class="codeline" id="line-2567"><code>	}</code></span>
<span class="codeline" id="line-2568"><code></code></span>
<span class="codeline" id="line-2569"><code>	pp := getg().m.p.ptr()</code></span>
<span class="codeline" id="line-2570"><code>	if pp == nil {</code></span>
<span class="codeline" id="line-2571"><code>		lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2572"><code>		globrunqputbatch(&amp;q, int32(qsize))</code></span>
<span class="codeline" id="line-2573"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2574"><code>		startIdle(qsize)</code></span>
<span class="codeline" id="line-2575"><code>		return</code></span>
<span class="codeline" id="line-2576"><code>	}</code></span>
<span class="codeline" id="line-2577"><code></code></span>
<span class="codeline" id="line-2578"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2579"><code>	npidle := int(sched.npidle)</code></span>
<span class="codeline" id="line-2580"><code>	var n int</code></span>
<span class="codeline" id="line-2581"><code>	for n = 0; n &lt; npidle &amp;&amp; !q.empty(); n++ {</code></span>
<span class="codeline" id="line-2582"><code>		globrunqput(q.pop())</code></span>
<span class="codeline" id="line-2583"><code>	}</code></span>
<span class="codeline" id="line-2584"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2585"><code>	startIdle(n)</code></span>
<span class="codeline" id="line-2586"><code>	qsize -= n</code></span>
<span class="codeline" id="line-2587"><code></code></span>
<span class="codeline" id="line-2588"><code>	if !q.empty() {</code></span>
<span class="codeline" id="line-2589"><code>		runqputbatch(pp, &amp;q, qsize)</code></span>
<span class="codeline" id="line-2590"><code>	}</code></span>
<span class="codeline" id="line-2591"><code>}</code></span>
<span class="codeline" id="line-2592"><code></code></span>
<span class="codeline" id="line-2593"><code>// One round of scheduler: find a runnable goroutine and execute it.</code></span>
<span class="codeline" id="line-2594"><code>// Never returns.</code></span>
<span class="codeline" id="line-2595"><code>func schedule() {</code></span>
<span class="codeline" id="line-2596"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-2597"><code></code></span>
<span class="codeline" id="line-2598"><code>	if _g_.m.locks != 0 {</code></span>
<span class="codeline" id="line-2599"><code>		throw("schedule: holding locks")</code></span>
<span class="codeline" id="line-2600"><code>	}</code></span>
<span class="codeline" id="line-2601"><code></code></span>
<span class="codeline" id="line-2602"><code>	if _g_.m.lockedg != 0 {</code></span>
<span class="codeline" id="line-2603"><code>		stoplockedm()</code></span>
<span class="codeline" id="line-2604"><code>		execute(_g_.m.lockedg.ptr(), false) // Never returns.</code></span>
<span class="codeline" id="line-2605"><code>	}</code></span>
<span class="codeline" id="line-2606"><code></code></span>
<span class="codeline" id="line-2607"><code>	// We should not schedule away from a g that is executing a cgo call,</code></span>
<span class="codeline" id="line-2608"><code>	// since the cgo call is using the m's g0 stack.</code></span>
<span class="codeline" id="line-2609"><code>	if _g_.m.incgo {</code></span>
<span class="codeline" id="line-2610"><code>		throw("schedule: in cgo")</code></span>
<span class="codeline" id="line-2611"><code>	}</code></span>
<span class="codeline" id="line-2612"><code></code></span>
<span class="codeline" id="line-2613"><code>top:</code></span>
<span class="codeline" id="line-2614"><code>	pp := _g_.m.p.ptr()</code></span>
<span class="codeline" id="line-2615"><code>	pp.preempt = false</code></span>
<span class="codeline" id="line-2616"><code></code></span>
<span class="codeline" id="line-2617"><code>	if sched.gcwaiting != 0 {</code></span>
<span class="codeline" id="line-2618"><code>		gcstopm()</code></span>
<span class="codeline" id="line-2619"><code>		goto top</code></span>
<span class="codeline" id="line-2620"><code>	}</code></span>
<span class="codeline" id="line-2621"><code>	if pp.runSafePointFn != 0 {</code></span>
<span class="codeline" id="line-2622"><code>		runSafePointFn()</code></span>
<span class="codeline" id="line-2623"><code>	}</code></span>
<span class="codeline" id="line-2624"><code></code></span>
<span class="codeline" id="line-2625"><code>	// Sanity check: if we are spinning, the run queue should be empty.</code></span>
<span class="codeline" id="line-2626"><code>	// Check this before calling checkTimers, as that might call</code></span>
<span class="codeline" id="line-2627"><code>	// goready to put a ready goroutine on the local run queue.</code></span>
<span class="codeline" id="line-2628"><code>	if _g_.m.spinning &amp;&amp; (pp.runnext != 0 || pp.runqhead != pp.runqtail) {</code></span>
<span class="codeline" id="line-2629"><code>		throw("schedule: spinning with local work")</code></span>
<span class="codeline" id="line-2630"><code>	}</code></span>
<span class="codeline" id="line-2631"><code></code></span>
<span class="codeline" id="line-2632"><code>	checkTimers(pp, 0)</code></span>
<span class="codeline" id="line-2633"><code></code></span>
<span class="codeline" id="line-2634"><code>	var gp *g</code></span>
<span class="codeline" id="line-2635"><code>	var inheritTime bool</code></span>
<span class="codeline" id="line-2636"><code></code></span>
<span class="codeline" id="line-2637"><code>	// Normal goroutines will check for need to wakeP in ready,</code></span>
<span class="codeline" id="line-2638"><code>	// but GCworkers and tracereaders will not, so the check must</code></span>
<span class="codeline" id="line-2639"><code>	// be done here instead.</code></span>
<span class="codeline" id="line-2640"><code>	tryWakeP := false</code></span>
<span class="codeline" id="line-2641"><code>	if trace.enabled || trace.shutdown {</code></span>
<span class="codeline" id="line-2642"><code>		gp = traceReader()</code></span>
<span class="codeline" id="line-2643"><code>		if gp != nil {</code></span>
<span class="codeline" id="line-2644"><code>			casgstatus(gp, _Gwaiting, _Grunnable)</code></span>
<span class="codeline" id="line-2645"><code>			traceGoUnpark(gp, 0)</code></span>
<span class="codeline" id="line-2646"><code>			tryWakeP = true</code></span>
<span class="codeline" id="line-2647"><code>		}</code></span>
<span class="codeline" id="line-2648"><code>	}</code></span>
<span class="codeline" id="line-2649"><code>	if gp == nil &amp;&amp; gcBlackenEnabled != 0 {</code></span>
<span class="codeline" id="line-2650"><code>		gp = gcController.findRunnableGCWorker(_g_.m.p.ptr())</code></span>
<span class="codeline" id="line-2651"><code>		tryWakeP = tryWakeP || gp != nil</code></span>
<span class="codeline" id="line-2652"><code>	}</code></span>
<span class="codeline" id="line-2653"><code>	if gp == nil {</code></span>
<span class="codeline" id="line-2654"><code>		// Check the global runnable queue once in a while to ensure fairness.</code></span>
<span class="codeline" id="line-2655"><code>		// Otherwise two goroutines can completely occupy the local runqueue</code></span>
<span class="codeline" id="line-2656"><code>		// by constantly respawning each other.</code></span>
<span class="codeline" id="line-2657"><code>		if _g_.m.p.ptr().schedtick%61 == 0 &amp;&amp; sched.runqsize &gt; 0 {</code></span>
<span class="codeline" id="line-2658"><code>			lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2659"><code>			gp = globrunqget(_g_.m.p.ptr(), 1)</code></span>
<span class="codeline" id="line-2660"><code>			unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2661"><code>		}</code></span>
<span class="codeline" id="line-2662"><code>	}</code></span>
<span class="codeline" id="line-2663"><code>	if gp == nil {</code></span>
<span class="codeline" id="line-2664"><code>		gp, inheritTime = runqget(_g_.m.p.ptr())</code></span>
<span class="codeline" id="line-2665"><code>		// We can see gp != nil here even if the M is spinning,</code></span>
<span class="codeline" id="line-2666"><code>		// if checkTimers added a local goroutine via goready.</code></span>
<span class="codeline" id="line-2667"><code>	}</code></span>
<span class="codeline" id="line-2668"><code>	if gp == nil {</code></span>
<span class="codeline" id="line-2669"><code>		gp, inheritTime = findrunnable() // blocks until work is available</code></span>
<span class="codeline" id="line-2670"><code>	}</code></span>
<span class="codeline" id="line-2671"><code></code></span>
<span class="codeline" id="line-2672"><code>	// This thread is going to run a goroutine and is not spinning anymore,</code></span>
<span class="codeline" id="line-2673"><code>	// so if it was marked as spinning we need to reset it now and potentially</code></span>
<span class="codeline" id="line-2674"><code>	// start a new spinning M.</code></span>
<span class="codeline" id="line-2675"><code>	if _g_.m.spinning {</code></span>
<span class="codeline" id="line-2676"><code>		resetspinning()</code></span>
<span class="codeline" id="line-2677"><code>	}</code></span>
<span class="codeline" id="line-2678"><code></code></span>
<span class="codeline" id="line-2679"><code>	if sched.disable.user &amp;&amp; !schedEnabled(gp) {</code></span>
<span class="codeline" id="line-2680"><code>		// Scheduling of this goroutine is disabled. Put it on</code></span>
<span class="codeline" id="line-2681"><code>		// the list of pending runnable goroutines for when we</code></span>
<span class="codeline" id="line-2682"><code>		// re-enable user scheduling and look again.</code></span>
<span class="codeline" id="line-2683"><code>		lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2684"><code>		if schedEnabled(gp) {</code></span>
<span class="codeline" id="line-2685"><code>			// Something re-enabled scheduling while we</code></span>
<span class="codeline" id="line-2686"><code>			// were acquiring the lock.</code></span>
<span class="codeline" id="line-2687"><code>			unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2688"><code>		} else {</code></span>
<span class="codeline" id="line-2689"><code>			sched.disable.runnable.pushBack(gp)</code></span>
<span class="codeline" id="line-2690"><code>			sched.disable.n++</code></span>
<span class="codeline" id="line-2691"><code>			unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2692"><code>			goto top</code></span>
<span class="codeline" id="line-2693"><code>		}</code></span>
<span class="codeline" id="line-2694"><code>	}</code></span>
<span class="codeline" id="line-2695"><code></code></span>
<span class="codeline" id="line-2696"><code>	// If about to schedule a not-normal goroutine (a GCworker or tracereader),</code></span>
<span class="codeline" id="line-2697"><code>	// wake a P if there is one.</code></span>
<span class="codeline" id="line-2698"><code>	if tryWakeP {</code></span>
<span class="codeline" id="line-2699"><code>		wakep()</code></span>
<span class="codeline" id="line-2700"><code>	}</code></span>
<span class="codeline" id="line-2701"><code>	if gp.lockedm != 0 {</code></span>
<span class="codeline" id="line-2702"><code>		// Hands off own p to the locked m,</code></span>
<span class="codeline" id="line-2703"><code>		// then blocks waiting for a new p.</code></span>
<span class="codeline" id="line-2704"><code>		startlockedm(gp)</code></span>
<span class="codeline" id="line-2705"><code>		goto top</code></span>
<span class="codeline" id="line-2706"><code>	}</code></span>
<span class="codeline" id="line-2707"><code></code></span>
<span class="codeline" id="line-2708"><code>	execute(gp, inheritTime)</code></span>
<span class="codeline" id="line-2709"><code>}</code></span>
<span class="codeline" id="line-2710"><code></code></span>
<span class="codeline" id="line-2711"><code>// dropg removes the association between m and the current goroutine m-&gt;curg (gp for short).</code></span>
<span class="codeline" id="line-2712"><code>// Typically a caller sets gp's status away from Grunning and then</code></span>
<span class="codeline" id="line-2713"><code>// immediately calls dropg to finish the job. The caller is also responsible</code></span>
<span class="codeline" id="line-2714"><code>// for arranging that gp will be restarted using ready at an</code></span>
<span class="codeline" id="line-2715"><code>// appropriate time. After calling dropg and arranging for gp to be</code></span>
<span class="codeline" id="line-2716"><code>// readied later, the caller can do other work but eventually should</code></span>
<span class="codeline" id="line-2717"><code>// call schedule to restart the scheduling of goroutines on this m.</code></span>
<span class="codeline" id="line-2718"><code>func dropg() {</code></span>
<span class="codeline" id="line-2719"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-2720"><code></code></span>
<span class="codeline" id="line-2721"><code>	setMNoWB(&amp;_g_.m.curg.m, nil)</code></span>
<span class="codeline" id="line-2722"><code>	setGNoWB(&amp;_g_.m.curg, nil)</code></span>
<span class="codeline" id="line-2723"><code>}</code></span>
<span class="codeline" id="line-2724"><code></code></span>
<span class="codeline" id="line-2725"><code>// checkTimers runs any timers for the P that are ready.</code></span>
<span class="codeline" id="line-2726"><code>// If now is not 0 it is the current time.</code></span>
<span class="codeline" id="line-2727"><code>// It returns the current time or 0 if it is not known,</code></span>
<span class="codeline" id="line-2728"><code>// and the time when the next timer should run or 0 if there is no next timer,</code></span>
<span class="codeline" id="line-2729"><code>// and reports whether it ran any timers.</code></span>
<span class="codeline" id="line-2730"><code>// If the time when the next timer should run is not 0,</code></span>
<span class="codeline" id="line-2731"><code>// it is always larger than the returned time.</code></span>
<span class="codeline" id="line-2732"><code>// We pass now in and out to avoid extra calls of nanotime.</code></span>
<span class="codeline" id="line-2733"><code>//go:yeswritebarrierrec</code></span>
<span class="codeline" id="line-2734"><code>func checkTimers(pp *p, now int64) (rnow, pollUntil int64, ran bool) {</code></span>
<span class="codeline" id="line-2735"><code>	// If there are no timers to adjust, and the first timer on</code></span>
<span class="codeline" id="line-2736"><code>	// the heap is not yet ready to run, then there is nothing to do.</code></span>
<span class="codeline" id="line-2737"><code>	if atomic.Load(&amp;pp.adjustTimers) == 0 {</code></span>
<span class="codeline" id="line-2738"><code>		next := int64(atomic.Load64(&amp;pp.timer0When))</code></span>
<span class="codeline" id="line-2739"><code>		if next == 0 {</code></span>
<span class="codeline" id="line-2740"><code>			return now, 0, false</code></span>
<span class="codeline" id="line-2741"><code>		}</code></span>
<span class="codeline" id="line-2742"><code>		if now == 0 {</code></span>
<span class="codeline" id="line-2743"><code>			now = nanotime()</code></span>
<span class="codeline" id="line-2744"><code>		}</code></span>
<span class="codeline" id="line-2745"><code>		if now &lt; next {</code></span>
<span class="codeline" id="line-2746"><code>			// Next timer is not ready to run.</code></span>
<span class="codeline" id="line-2747"><code>			// But keep going if we would clear deleted timers.</code></span>
<span class="codeline" id="line-2748"><code>			// This corresponds to the condition below where</code></span>
<span class="codeline" id="line-2749"><code>			// we decide whether to call clearDeletedTimers.</code></span>
<span class="codeline" id="line-2750"><code>			if pp != getg().m.p.ptr() || int(atomic.Load(&amp;pp.deletedTimers)) &lt;= int(atomic.Load(&amp;pp.numTimers)/4) {</code></span>
<span class="codeline" id="line-2751"><code>				return now, next, false</code></span>
<span class="codeline" id="line-2752"><code>			}</code></span>
<span class="codeline" id="line-2753"><code>		}</code></span>
<span class="codeline" id="line-2754"><code>	}</code></span>
<span class="codeline" id="line-2755"><code></code></span>
<span class="codeline" id="line-2756"><code>	lock(&amp;pp.timersLock)</code></span>
<span class="codeline" id="line-2757"><code></code></span>
<span class="codeline" id="line-2758"><code>	adjusttimers(pp)</code></span>
<span class="codeline" id="line-2759"><code></code></span>
<span class="codeline" id="line-2760"><code>	rnow = now</code></span>
<span class="codeline" id="line-2761"><code>	if len(pp.timers) &gt; 0 {</code></span>
<span class="codeline" id="line-2762"><code>		if rnow == 0 {</code></span>
<span class="codeline" id="line-2763"><code>			rnow = nanotime()</code></span>
<span class="codeline" id="line-2764"><code>		}</code></span>
<span class="codeline" id="line-2765"><code>		for len(pp.timers) &gt; 0 {</code></span>
<span class="codeline" id="line-2766"><code>			// Note that runtimer may temporarily unlock</code></span>
<span class="codeline" id="line-2767"><code>			// pp.timersLock.</code></span>
<span class="codeline" id="line-2768"><code>			if tw := runtimer(pp, rnow); tw != 0 {</code></span>
<span class="codeline" id="line-2769"><code>				if tw &gt; 0 {</code></span>
<span class="codeline" id="line-2770"><code>					pollUntil = tw</code></span>
<span class="codeline" id="line-2771"><code>				}</code></span>
<span class="codeline" id="line-2772"><code>				break</code></span>
<span class="codeline" id="line-2773"><code>			}</code></span>
<span class="codeline" id="line-2774"><code>			ran = true</code></span>
<span class="codeline" id="line-2775"><code>		}</code></span>
<span class="codeline" id="line-2776"><code>	}</code></span>
<span class="codeline" id="line-2777"><code></code></span>
<span class="codeline" id="line-2778"><code>	// If this is the local P, and there are a lot of deleted timers,</code></span>
<span class="codeline" id="line-2779"><code>	// clear them out. We only do this for the local P to reduce</code></span>
<span class="codeline" id="line-2780"><code>	// lock contention on timersLock.</code></span>
<span class="codeline" id="line-2781"><code>	if pp == getg().m.p.ptr() &amp;&amp; int(atomic.Load(&amp;pp.deletedTimers)) &gt; len(pp.timers)/4 {</code></span>
<span class="codeline" id="line-2782"><code>		clearDeletedTimers(pp)</code></span>
<span class="codeline" id="line-2783"><code>	}</code></span>
<span class="codeline" id="line-2784"><code></code></span>
<span class="codeline" id="line-2785"><code>	unlock(&amp;pp.timersLock)</code></span>
<span class="codeline" id="line-2786"><code></code></span>
<span class="codeline" id="line-2787"><code>	return rnow, pollUntil, ran</code></span>
<span class="codeline" id="line-2788"><code>}</code></span>
<span class="codeline" id="line-2789"><code></code></span>
<span class="codeline" id="line-2790"><code>// shouldStealTimers reports whether we should try stealing the timers from p2.</code></span>
<span class="codeline" id="line-2791"><code>// We don't steal timers from a running P that is not marked for preemption,</code></span>
<span class="codeline" id="line-2792"><code>// on the assumption that it will run its own timers. This reduces</code></span>
<span class="codeline" id="line-2793"><code>// contention on the timers lock.</code></span>
<span class="codeline" id="line-2794"><code>func shouldStealTimers(p2 *p) bool {</code></span>
<span class="codeline" id="line-2795"><code>	if p2.status != _Prunning {</code></span>
<span class="codeline" id="line-2796"><code>		return true</code></span>
<span class="codeline" id="line-2797"><code>	}</code></span>
<span class="codeline" id="line-2798"><code>	mp := p2.m.ptr()</code></span>
<span class="codeline" id="line-2799"><code>	if mp == nil || mp.locks &gt; 0 {</code></span>
<span class="codeline" id="line-2800"><code>		return false</code></span>
<span class="codeline" id="line-2801"><code>	}</code></span>
<span class="codeline" id="line-2802"><code>	gp := mp.curg</code></span>
<span class="codeline" id="line-2803"><code>	if gp == nil || gp.atomicstatus != _Grunning || !gp.preempt {</code></span>
<span class="codeline" id="line-2804"><code>		return false</code></span>
<span class="codeline" id="line-2805"><code>	}</code></span>
<span class="codeline" id="line-2806"><code>	return true</code></span>
<span class="codeline" id="line-2807"><code>}</code></span>
<span class="codeline" id="line-2808"><code></code></span>
<span class="codeline" id="line-2809"><code>func parkunlock_c(gp *g, lock unsafe.Pointer) bool {</code></span>
<span class="codeline" id="line-2810"><code>	unlock((*mutex)(lock))</code></span>
<span class="codeline" id="line-2811"><code>	return true</code></span>
<span class="codeline" id="line-2812"><code>}</code></span>
<span class="codeline" id="line-2813"><code></code></span>
<span class="codeline" id="line-2814"><code>// park continuation on g0.</code></span>
<span class="codeline" id="line-2815"><code>func park_m(gp *g) {</code></span>
<span class="codeline" id="line-2816"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-2817"><code></code></span>
<span class="codeline" id="line-2818"><code>	if trace.enabled {</code></span>
<span class="codeline" id="line-2819"><code>		traceGoPark(_g_.m.waittraceev, _g_.m.waittraceskip)</code></span>
<span class="codeline" id="line-2820"><code>	}</code></span>
<span class="codeline" id="line-2821"><code></code></span>
<span class="codeline" id="line-2822"><code>	casgstatus(gp, _Grunning, _Gwaiting)</code></span>
<span class="codeline" id="line-2823"><code>	dropg()</code></span>
<span class="codeline" id="line-2824"><code></code></span>
<span class="codeline" id="line-2825"><code>	if fn := _g_.m.waitunlockf; fn != nil {</code></span>
<span class="codeline" id="line-2826"><code>		ok := fn(gp, _g_.m.waitlock)</code></span>
<span class="codeline" id="line-2827"><code>		_g_.m.waitunlockf = nil</code></span>
<span class="codeline" id="line-2828"><code>		_g_.m.waitlock = nil</code></span>
<span class="codeline" id="line-2829"><code>		if !ok {</code></span>
<span class="codeline" id="line-2830"><code>			if trace.enabled {</code></span>
<span class="codeline" id="line-2831"><code>				traceGoUnpark(gp, 2)</code></span>
<span class="codeline" id="line-2832"><code>			}</code></span>
<span class="codeline" id="line-2833"><code>			casgstatus(gp, _Gwaiting, _Grunnable)</code></span>
<span class="codeline" id="line-2834"><code>			execute(gp, true) // Schedule it back, never returns.</code></span>
<span class="codeline" id="line-2835"><code>		}</code></span>
<span class="codeline" id="line-2836"><code>	}</code></span>
<span class="codeline" id="line-2837"><code>	schedule()</code></span>
<span class="codeline" id="line-2838"><code>}</code></span>
<span class="codeline" id="line-2839"><code></code></span>
<span class="codeline" id="line-2840"><code>func goschedImpl(gp *g) {</code></span>
<span class="codeline" id="line-2841"><code>	status := readgstatus(gp)</code></span>
<span class="codeline" id="line-2842"><code>	if status&amp;^_Gscan != _Grunning {</code></span>
<span class="codeline" id="line-2843"><code>		dumpgstatus(gp)</code></span>
<span class="codeline" id="line-2844"><code>		throw("bad g status")</code></span>
<span class="codeline" id="line-2845"><code>	}</code></span>
<span class="codeline" id="line-2846"><code>	casgstatus(gp, _Grunning, _Grunnable)</code></span>
<span class="codeline" id="line-2847"><code>	dropg()</code></span>
<span class="codeline" id="line-2848"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2849"><code>	globrunqput(gp)</code></span>
<span class="codeline" id="line-2850"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2851"><code></code></span>
<span class="codeline" id="line-2852"><code>	schedule()</code></span>
<span class="codeline" id="line-2853"><code>}</code></span>
<span class="codeline" id="line-2854"><code></code></span>
<span class="codeline" id="line-2855"><code>// Gosched continuation on g0.</code></span>
<span class="codeline" id="line-2856"><code>func gosched_m(gp *g) {</code></span>
<span class="codeline" id="line-2857"><code>	if trace.enabled {</code></span>
<span class="codeline" id="line-2858"><code>		traceGoSched()</code></span>
<span class="codeline" id="line-2859"><code>	}</code></span>
<span class="codeline" id="line-2860"><code>	goschedImpl(gp)</code></span>
<span class="codeline" id="line-2861"><code>}</code></span>
<span class="codeline" id="line-2862"><code></code></span>
<span class="codeline" id="line-2863"><code>// goschedguarded is a forbidden-states-avoided version of gosched_m</code></span>
<span class="codeline" id="line-2864"><code>func goschedguarded_m(gp *g) {</code></span>
<span class="codeline" id="line-2865"><code></code></span>
<span class="codeline" id="line-2866"><code>	if !canPreemptM(gp.m) {</code></span>
<span class="codeline" id="line-2867"><code>		gogo(&amp;gp.sched) // never return</code></span>
<span class="codeline" id="line-2868"><code>	}</code></span>
<span class="codeline" id="line-2869"><code></code></span>
<span class="codeline" id="line-2870"><code>	if trace.enabled {</code></span>
<span class="codeline" id="line-2871"><code>		traceGoSched()</code></span>
<span class="codeline" id="line-2872"><code>	}</code></span>
<span class="codeline" id="line-2873"><code>	goschedImpl(gp)</code></span>
<span class="codeline" id="line-2874"><code>}</code></span>
<span class="codeline" id="line-2875"><code></code></span>
<span class="codeline" id="line-2876"><code>func gopreempt_m(gp *g) {</code></span>
<span class="codeline" id="line-2877"><code>	if trace.enabled {</code></span>
<span class="codeline" id="line-2878"><code>		traceGoPreempt()</code></span>
<span class="codeline" id="line-2879"><code>	}</code></span>
<span class="codeline" id="line-2880"><code>	goschedImpl(gp)</code></span>
<span class="codeline" id="line-2881"><code>}</code></span>
<span class="codeline" id="line-2882"><code></code></span>
<span class="codeline" id="line-2883"><code>// preemptPark parks gp and puts it in _Gpreempted.</code></span>
<span class="codeline" id="line-2884"><code>//</code></span>
<span class="codeline" id="line-2885"><code>//go:systemstack</code></span>
<span class="codeline" id="line-2886"><code>func preemptPark(gp *g) {</code></span>
<span class="codeline" id="line-2887"><code>	if trace.enabled {</code></span>
<span class="codeline" id="line-2888"><code>		traceGoPark(traceEvGoBlock, 0)</code></span>
<span class="codeline" id="line-2889"><code>	}</code></span>
<span class="codeline" id="line-2890"><code>	status := readgstatus(gp)</code></span>
<span class="codeline" id="line-2891"><code>	if status&amp;^_Gscan != _Grunning {</code></span>
<span class="codeline" id="line-2892"><code>		dumpgstatus(gp)</code></span>
<span class="codeline" id="line-2893"><code>		throw("bad g status")</code></span>
<span class="codeline" id="line-2894"><code>	}</code></span>
<span class="codeline" id="line-2895"><code>	gp.waitreason = waitReasonPreempted</code></span>
<span class="codeline" id="line-2896"><code>	// Transition from _Grunning to _Gscan|_Gpreempted. We can't</code></span>
<span class="codeline" id="line-2897"><code>	// be in _Grunning when we dropg because then we'd be running</code></span>
<span class="codeline" id="line-2898"><code>	// without an M, but the moment we're in _Gpreempted,</code></span>
<span class="codeline" id="line-2899"><code>	// something could claim this G before we've fully cleaned it</code></span>
<span class="codeline" id="line-2900"><code>	// up. Hence, we set the scan bit to lock down further</code></span>
<span class="codeline" id="line-2901"><code>	// transitions until we can dropg.</code></span>
<span class="codeline" id="line-2902"><code>	casGToPreemptScan(gp, _Grunning, _Gscan|_Gpreempted)</code></span>
<span class="codeline" id="line-2903"><code>	dropg()</code></span>
<span class="codeline" id="line-2904"><code>	casfrom_Gscanstatus(gp, _Gscan|_Gpreempted, _Gpreempted)</code></span>
<span class="codeline" id="line-2905"><code>	schedule()</code></span>
<span class="codeline" id="line-2906"><code>}</code></span>
<span class="codeline" id="line-2907"><code></code></span>
<span class="codeline" id="line-2908"><code>// goyield is like Gosched, but it:</code></span>
<span class="codeline" id="line-2909"><code>// - emits a GoPreempt trace event instead of a GoSched trace event</code></span>
<span class="codeline" id="line-2910"><code>// - puts the current G on the runq of the current P instead of the globrunq</code></span>
<span class="codeline" id="line-2911"><code>func goyield() {</code></span>
<span class="codeline" id="line-2912"><code>	checkTimeouts()</code></span>
<span class="codeline" id="line-2913"><code>	mcall(goyield_m)</code></span>
<span class="codeline" id="line-2914"><code>}</code></span>
<span class="codeline" id="line-2915"><code></code></span>
<span class="codeline" id="line-2916"><code>func goyield_m(gp *g) {</code></span>
<span class="codeline" id="line-2917"><code>	if trace.enabled {</code></span>
<span class="codeline" id="line-2918"><code>		traceGoPreempt()</code></span>
<span class="codeline" id="line-2919"><code>	}</code></span>
<span class="codeline" id="line-2920"><code>	pp := gp.m.p.ptr()</code></span>
<span class="codeline" id="line-2921"><code>	casgstatus(gp, _Grunning, _Grunnable)</code></span>
<span class="codeline" id="line-2922"><code>	dropg()</code></span>
<span class="codeline" id="line-2923"><code>	runqput(pp, gp, false)</code></span>
<span class="codeline" id="line-2924"><code>	schedule()</code></span>
<span class="codeline" id="line-2925"><code>}</code></span>
<span class="codeline" id="line-2926"><code></code></span>
<span class="codeline" id="line-2927"><code>// Finishes execution of the current goroutine.</code></span>
<span class="codeline" id="line-2928"><code>func goexit1() {</code></span>
<span class="codeline" id="line-2929"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-2930"><code>		racegoend()</code></span>
<span class="codeline" id="line-2931"><code>	}</code></span>
<span class="codeline" id="line-2932"><code>	if trace.enabled {</code></span>
<span class="codeline" id="line-2933"><code>		traceGoEnd()</code></span>
<span class="codeline" id="line-2934"><code>	}</code></span>
<span class="codeline" id="line-2935"><code>	mcall(goexit0)</code></span>
<span class="codeline" id="line-2936"><code>}</code></span>
<span class="codeline" id="line-2937"><code></code></span>
<span class="codeline" id="line-2938"><code>// goexit continuation on g0.</code></span>
<span class="codeline" id="line-2939"><code>func goexit0(gp *g) {</code></span>
<span class="codeline" id="line-2940"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-2941"><code></code></span>
<span class="codeline" id="line-2942"><code>	casgstatus(gp, _Grunning, _Gdead)</code></span>
<span class="codeline" id="line-2943"><code>	if isSystemGoroutine(gp, false) {</code></span>
<span class="codeline" id="line-2944"><code>		atomic.Xadd(&amp;sched.ngsys, -1)</code></span>
<span class="codeline" id="line-2945"><code>	}</code></span>
<span class="codeline" id="line-2946"><code>	gp.m = nil</code></span>
<span class="codeline" id="line-2947"><code>	locked := gp.lockedm != 0</code></span>
<span class="codeline" id="line-2948"><code>	gp.lockedm = 0</code></span>
<span class="codeline" id="line-2949"><code>	_g_.m.lockedg = 0</code></span>
<span class="codeline" id="line-2950"><code>	gp.preemptStop = false</code></span>
<span class="codeline" id="line-2951"><code>	gp.paniconfault = false</code></span>
<span class="codeline" id="line-2952"><code>	gp._defer = nil // should be true already but just in case.</code></span>
<span class="codeline" id="line-2953"><code>	gp._panic = nil // non-nil for Goexit during panic. points at stack-allocated data.</code></span>
<span class="codeline" id="line-2954"><code>	gp.writebuf = nil</code></span>
<span class="codeline" id="line-2955"><code>	gp.waitreason = 0</code></span>
<span class="codeline" id="line-2956"><code>	gp.param = nil</code></span>
<span class="codeline" id="line-2957"><code>	gp.labels = nil</code></span>
<span class="codeline" id="line-2958"><code>	gp.timer = nil</code></span>
<span class="codeline" id="line-2959"><code></code></span>
<span class="codeline" id="line-2960"><code>	if gcBlackenEnabled != 0 &amp;&amp; gp.gcAssistBytes &gt; 0 {</code></span>
<span class="codeline" id="line-2961"><code>		// Flush assist credit to the global pool. This gives</code></span>
<span class="codeline" id="line-2962"><code>		// better information to pacing if the application is</code></span>
<span class="codeline" id="line-2963"><code>		// rapidly creating an exiting goroutines.</code></span>
<span class="codeline" id="line-2964"><code>		scanCredit := int64(gcController.assistWorkPerByte * float64(gp.gcAssistBytes))</code></span>
<span class="codeline" id="line-2965"><code>		atomic.Xaddint64(&amp;gcController.bgScanCredit, scanCredit)</code></span>
<span class="codeline" id="line-2966"><code>		gp.gcAssistBytes = 0</code></span>
<span class="codeline" id="line-2967"><code>	}</code></span>
<span class="codeline" id="line-2968"><code></code></span>
<span class="codeline" id="line-2969"><code>	dropg()</code></span>
<span class="codeline" id="line-2970"><code></code></span>
<span class="codeline" id="line-2971"><code>	if GOARCH == "wasm" { // no threads yet on wasm</code></span>
<span class="codeline" id="line-2972"><code>		gfput(_g_.m.p.ptr(), gp)</code></span>
<span class="codeline" id="line-2973"><code>		schedule() // never returns</code></span>
<span class="codeline" id="line-2974"><code>	}</code></span>
<span class="codeline" id="line-2975"><code></code></span>
<span class="codeline" id="line-2976"><code>	if _g_.m.lockedInt != 0 {</code></span>
<span class="codeline" id="line-2977"><code>		print("invalid m-&gt;lockedInt = ", _g_.m.lockedInt, "\n")</code></span>
<span class="codeline" id="line-2978"><code>		throw("internal lockOSThread error")</code></span>
<span class="codeline" id="line-2979"><code>	}</code></span>
<span class="codeline" id="line-2980"><code>	gfput(_g_.m.p.ptr(), gp)</code></span>
<span class="codeline" id="line-2981"><code>	if locked {</code></span>
<span class="codeline" id="line-2982"><code>		// The goroutine may have locked this thread because</code></span>
<span class="codeline" id="line-2983"><code>		// it put it in an unusual kernel state. Kill it</code></span>
<span class="codeline" id="line-2984"><code>		// rather than returning it to the thread pool.</code></span>
<span class="codeline" id="line-2985"><code></code></span>
<span class="codeline" id="line-2986"><code>		// Return to mstart, which will release the P and exit</code></span>
<span class="codeline" id="line-2987"><code>		// the thread.</code></span>
<span class="codeline" id="line-2988"><code>		if GOOS != "plan9" { // See golang.org/issue/22227.</code></span>
<span class="codeline" id="line-2989"><code>			gogo(&amp;_g_.m.g0.sched)</code></span>
<span class="codeline" id="line-2990"><code>		} else {</code></span>
<span class="codeline" id="line-2991"><code>			// Clear lockedExt on plan9 since we may end up re-using</code></span>
<span class="codeline" id="line-2992"><code>			// this thread.</code></span>
<span class="codeline" id="line-2993"><code>			_g_.m.lockedExt = 0</code></span>
<span class="codeline" id="line-2994"><code>		}</code></span>
<span class="codeline" id="line-2995"><code>	}</code></span>
<span class="codeline" id="line-2996"><code>	schedule()</code></span>
<span class="codeline" id="line-2997"><code>}</code></span>
<span class="codeline" id="line-2998"><code></code></span>
<span class="codeline" id="line-2999"><code>// save updates getg().sched to refer to pc and sp so that a following</code></span>
<span class="codeline" id="line-3000"><code>// gogo will restore pc and sp.</code></span>
<span class="codeline" id="line-3001"><code>//</code></span>
<span class="codeline" id="line-3002"><code>// save must not have write barriers because invoking a write barrier</code></span>
<span class="codeline" id="line-3003"><code>// can clobber getg().sched.</code></span>
<span class="codeline" id="line-3004"><code>//</code></span>
<span class="codeline" id="line-3005"><code>//go:nosplit</code></span>
<span class="codeline" id="line-3006"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-3007"><code>func save(pc, sp uintptr) {</code></span>
<span class="codeline" id="line-3008"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-3009"><code></code></span>
<span class="codeline" id="line-3010"><code>	_g_.sched.pc = pc</code></span>
<span class="codeline" id="line-3011"><code>	_g_.sched.sp = sp</code></span>
<span class="codeline" id="line-3012"><code>	_g_.sched.lr = 0</code></span>
<span class="codeline" id="line-3013"><code>	_g_.sched.ret = 0</code></span>
<span class="codeline" id="line-3014"><code>	_g_.sched.g = guintptr(unsafe.Pointer(_g_))</code></span>
<span class="codeline" id="line-3015"><code>	// We need to ensure ctxt is zero, but can't have a write</code></span>
<span class="codeline" id="line-3016"><code>	// barrier here. However, it should always already be zero.</code></span>
<span class="codeline" id="line-3017"><code>	// Assert that.</code></span>
<span class="codeline" id="line-3018"><code>	if _g_.sched.ctxt != nil {</code></span>
<span class="codeline" id="line-3019"><code>		badctxt()</code></span>
<span class="codeline" id="line-3020"><code>	}</code></span>
<span class="codeline" id="line-3021"><code>}</code></span>
<span class="codeline" id="line-3022"><code></code></span>
<span class="codeline" id="line-3023"><code>// The goroutine g is about to enter a system call.</code></span>
<span class="codeline" id="line-3024"><code>// Record that it's not using the cpu anymore.</code></span>
<span class="codeline" id="line-3025"><code>// This is called only from the go syscall library and cgocall,</code></span>
<span class="codeline" id="line-3026"><code>// not from the low-level system calls used by the runtime.</code></span>
<span class="codeline" id="line-3027"><code>//</code></span>
<span class="codeline" id="line-3028"><code>// Entersyscall cannot split the stack: the gosave must</code></span>
<span class="codeline" id="line-3029"><code>// make g-&gt;sched refer to the caller's stack segment, because</code></span>
<span class="codeline" id="line-3030"><code>// entersyscall is going to return immediately after.</code></span>
<span class="codeline" id="line-3031"><code>//</code></span>
<span class="codeline" id="line-3032"><code>// Nothing entersyscall calls can split the stack either.</code></span>
<span class="codeline" id="line-3033"><code>// We cannot safely move the stack during an active call to syscall,</code></span>
<span class="codeline" id="line-3034"><code>// because we do not know which of the uintptr arguments are</code></span>
<span class="codeline" id="line-3035"><code>// really pointers (back into the stack).</code></span>
<span class="codeline" id="line-3036"><code>// In practice, this means that we make the fast path run through</code></span>
<span class="codeline" id="line-3037"><code>// entersyscall doing no-split things, and the slow path has to use systemstack</code></span>
<span class="codeline" id="line-3038"><code>// to run bigger things on the system stack.</code></span>
<span class="codeline" id="line-3039"><code>//</code></span>
<span class="codeline" id="line-3040"><code>// reentersyscall is the entry point used by cgo callbacks, where explicitly</code></span>
<span class="codeline" id="line-3041"><code>// saved SP and PC are restored. This is needed when exitsyscall will be called</code></span>
<span class="codeline" id="line-3042"><code>// from a function further up in the call stack than the parent, as g-&gt;syscallsp</code></span>
<span class="codeline" id="line-3043"><code>// must always point to a valid stack frame. entersyscall below is the normal</code></span>
<span class="codeline" id="line-3044"><code>// entry point for syscalls, which obtains the SP and PC from the caller.</code></span>
<span class="codeline" id="line-3045"><code>//</code></span>
<span class="codeline" id="line-3046"><code>// Syscall tracing:</code></span>
<span class="codeline" id="line-3047"><code>// At the start of a syscall we emit traceGoSysCall to capture the stack trace.</code></span>
<span class="codeline" id="line-3048"><code>// If the syscall does not block, that is it, we do not emit any other events.</code></span>
<span class="codeline" id="line-3049"><code>// If the syscall blocks (that is, P is retaken), retaker emits traceGoSysBlock;</code></span>
<span class="codeline" id="line-3050"><code>// when syscall returns we emit traceGoSysExit and when the goroutine starts running</code></span>
<span class="codeline" id="line-3051"><code>// (potentially instantly, if exitsyscallfast returns true) we emit traceGoStart.</code></span>
<span class="codeline" id="line-3052"><code>// To ensure that traceGoSysExit is emitted strictly after traceGoSysBlock,</code></span>
<span class="codeline" id="line-3053"><code>// we remember current value of syscalltick in m (_g_.m.syscalltick = _g_.m.p.ptr().syscalltick),</code></span>
<span class="codeline" id="line-3054"><code>// whoever emits traceGoSysBlock increments p.syscalltick afterwards;</code></span>
<span class="codeline" id="line-3055"><code>// and we wait for the increment before emitting traceGoSysExit.</code></span>
<span class="codeline" id="line-3056"><code>// Note that the increment is done even if tracing is not enabled,</code></span>
<span class="codeline" id="line-3057"><code>// because tracing can be enabled in the middle of syscall. We don't want the wait to hang.</code></span>
<span class="codeline" id="line-3058"><code>//</code></span>
<span class="codeline" id="line-3059"><code>//go:nosplit</code></span>
<span class="codeline" id="line-3060"><code>func reentersyscall(pc, sp uintptr) {</code></span>
<span class="codeline" id="line-3061"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-3062"><code></code></span>
<span class="codeline" id="line-3063"><code>	// Disable preemption because during this function g is in Gsyscall status,</code></span>
<span class="codeline" id="line-3064"><code>	// but can have inconsistent g-&gt;sched, do not let GC observe it.</code></span>
<span class="codeline" id="line-3065"><code>	_g_.m.locks++</code></span>
<span class="codeline" id="line-3066"><code></code></span>
<span class="codeline" id="line-3067"><code>	// Entersyscall must not call any function that might split/grow the stack.</code></span>
<span class="codeline" id="line-3068"><code>	// (See details in comment above.)</code></span>
<span class="codeline" id="line-3069"><code>	// Catch calls that might, by replacing the stack guard with something that</code></span>
<span class="codeline" id="line-3070"><code>	// will trip any stack check and leaving a flag to tell newstack to die.</code></span>
<span class="codeline" id="line-3071"><code>	_g_.stackguard0 = stackPreempt</code></span>
<span class="codeline" id="line-3072"><code>	_g_.throwsplit = true</code></span>
<span class="codeline" id="line-3073"><code></code></span>
<span class="codeline" id="line-3074"><code>	// Leave SP around for GC and traceback.</code></span>
<span class="codeline" id="line-3075"><code>	save(pc, sp)</code></span>
<span class="codeline" id="line-3076"><code>	_g_.syscallsp = sp</code></span>
<span class="codeline" id="line-3077"><code>	_g_.syscallpc = pc</code></span>
<span class="codeline" id="line-3078"><code>	casgstatus(_g_, _Grunning, _Gsyscall)</code></span>
<span class="codeline" id="line-3079"><code>	if _g_.syscallsp &lt; _g_.stack.lo || _g_.stack.hi &lt; _g_.syscallsp {</code></span>
<span class="codeline" id="line-3080"><code>		systemstack(func() {</code></span>
<span class="codeline" id="line-3081"><code>			print("entersyscall inconsistent ", hex(_g_.syscallsp), " [", hex(_g_.stack.lo), ",", hex(_g_.stack.hi), "]\n")</code></span>
<span class="codeline" id="line-3082"><code>			throw("entersyscall")</code></span>
<span class="codeline" id="line-3083"><code>		})</code></span>
<span class="codeline" id="line-3084"><code>	}</code></span>
<span class="codeline" id="line-3085"><code></code></span>
<span class="codeline" id="line-3086"><code>	if trace.enabled {</code></span>
<span class="codeline" id="line-3087"><code>		systemstack(traceGoSysCall)</code></span>
<span class="codeline" id="line-3088"><code>		// systemstack itself clobbers g.sched.{pc,sp} and we might</code></span>
<span class="codeline" id="line-3089"><code>		// need them later when the G is genuinely blocked in a</code></span>
<span class="codeline" id="line-3090"><code>		// syscall</code></span>
<span class="codeline" id="line-3091"><code>		save(pc, sp)</code></span>
<span class="codeline" id="line-3092"><code>	}</code></span>
<span class="codeline" id="line-3093"><code></code></span>
<span class="codeline" id="line-3094"><code>	if atomic.Load(&amp;sched.sysmonwait) != 0 {</code></span>
<span class="codeline" id="line-3095"><code>		systemstack(entersyscall_sysmon)</code></span>
<span class="codeline" id="line-3096"><code>		save(pc, sp)</code></span>
<span class="codeline" id="line-3097"><code>	}</code></span>
<span class="codeline" id="line-3098"><code></code></span>
<span class="codeline" id="line-3099"><code>	if _g_.m.p.ptr().runSafePointFn != 0 {</code></span>
<span class="codeline" id="line-3100"><code>		// runSafePointFn may stack split if run on this stack</code></span>
<span class="codeline" id="line-3101"><code>		systemstack(runSafePointFn)</code></span>
<span class="codeline" id="line-3102"><code>		save(pc, sp)</code></span>
<span class="codeline" id="line-3103"><code>	}</code></span>
<span class="codeline" id="line-3104"><code></code></span>
<span class="codeline" id="line-3105"><code>	_g_.m.syscalltick = _g_.m.p.ptr().syscalltick</code></span>
<span class="codeline" id="line-3106"><code>	_g_.sysblocktraced = true</code></span>
<span class="codeline" id="line-3107"><code>	pp := _g_.m.p.ptr()</code></span>
<span class="codeline" id="line-3108"><code>	pp.m = 0</code></span>
<span class="codeline" id="line-3109"><code>	_g_.m.oldp.set(pp)</code></span>
<span class="codeline" id="line-3110"><code>	_g_.m.p = 0</code></span>
<span class="codeline" id="line-3111"><code>	atomic.Store(&amp;pp.status, _Psyscall)</code></span>
<span class="codeline" id="line-3112"><code>	if sched.gcwaiting != 0 {</code></span>
<span class="codeline" id="line-3113"><code>		systemstack(entersyscall_gcwait)</code></span>
<span class="codeline" id="line-3114"><code>		save(pc, sp)</code></span>
<span class="codeline" id="line-3115"><code>	}</code></span>
<span class="codeline" id="line-3116"><code></code></span>
<span class="codeline" id="line-3117"><code>	_g_.m.locks--</code></span>
<span class="codeline" id="line-3118"><code>}</code></span>
<span class="codeline" id="line-3119"><code></code></span>
<span class="codeline" id="line-3120"><code>// Standard syscall entry used by the go syscall library and normal cgo calls.</code></span>
<span class="codeline" id="line-3121"><code>//</code></span>
<span class="codeline" id="line-3122"><code>// This is exported via linkname to assembly in the syscall package.</code></span>
<span class="codeline" id="line-3123"><code>//</code></span>
<span class="codeline" id="line-3124"><code>//go:nosplit</code></span>
<span class="codeline" id="line-3125"><code>//go:linkname entersyscall</code></span>
<span class="codeline" id="line-3126"><code>func entersyscall() {</code></span>
<span class="codeline" id="line-3127"><code>	reentersyscall(getcallerpc(), getcallersp())</code></span>
<span class="codeline" id="line-3128"><code>}</code></span>
<span class="codeline" id="line-3129"><code></code></span>
<span class="codeline" id="line-3130"><code>func entersyscall_sysmon() {</code></span>
<span class="codeline" id="line-3131"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3132"><code>	if atomic.Load(&amp;sched.sysmonwait) != 0 {</code></span>
<span class="codeline" id="line-3133"><code>		atomic.Store(&amp;sched.sysmonwait, 0)</code></span>
<span class="codeline" id="line-3134"><code>		notewakeup(&amp;sched.sysmonnote)</code></span>
<span class="codeline" id="line-3135"><code>	}</code></span>
<span class="codeline" id="line-3136"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3137"><code>}</code></span>
<span class="codeline" id="line-3138"><code></code></span>
<span class="codeline" id="line-3139"><code>func entersyscall_gcwait() {</code></span>
<span class="codeline" id="line-3140"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-3141"><code>	_p_ := _g_.m.oldp.ptr()</code></span>
<span class="codeline" id="line-3142"><code></code></span>
<span class="codeline" id="line-3143"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3144"><code>	if sched.stopwait &gt; 0 &amp;&amp; atomic.Cas(&amp;_p_.status, _Psyscall, _Pgcstop) {</code></span>
<span class="codeline" id="line-3145"><code>		if trace.enabled {</code></span>
<span class="codeline" id="line-3146"><code>			traceGoSysBlock(_p_)</code></span>
<span class="codeline" id="line-3147"><code>			traceProcStop(_p_)</code></span>
<span class="codeline" id="line-3148"><code>		}</code></span>
<span class="codeline" id="line-3149"><code>		_p_.syscalltick++</code></span>
<span class="codeline" id="line-3150"><code>		if sched.stopwait--; sched.stopwait == 0 {</code></span>
<span class="codeline" id="line-3151"><code>			notewakeup(&amp;sched.stopnote)</code></span>
<span class="codeline" id="line-3152"><code>		}</code></span>
<span class="codeline" id="line-3153"><code>	}</code></span>
<span class="codeline" id="line-3154"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3155"><code>}</code></span>
<span class="codeline" id="line-3156"><code></code></span>
<span class="codeline" id="line-3157"><code>// The same as entersyscall(), but with a hint that the syscall is blocking.</code></span>
<span class="codeline" id="line-3158"><code>//go:nosplit</code></span>
<span class="codeline" id="line-3159"><code>func entersyscallblock() {</code></span>
<span class="codeline" id="line-3160"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-3161"><code></code></span>
<span class="codeline" id="line-3162"><code>	_g_.m.locks++ // see comment in entersyscall</code></span>
<span class="codeline" id="line-3163"><code>	_g_.throwsplit = true</code></span>
<span class="codeline" id="line-3164"><code>	_g_.stackguard0 = stackPreempt // see comment in entersyscall</code></span>
<span class="codeline" id="line-3165"><code>	_g_.m.syscalltick = _g_.m.p.ptr().syscalltick</code></span>
<span class="codeline" id="line-3166"><code>	_g_.sysblocktraced = true</code></span>
<span class="codeline" id="line-3167"><code>	_g_.m.p.ptr().syscalltick++</code></span>
<span class="codeline" id="line-3168"><code></code></span>
<span class="codeline" id="line-3169"><code>	// Leave SP around for GC and traceback.</code></span>
<span class="codeline" id="line-3170"><code>	pc := getcallerpc()</code></span>
<span class="codeline" id="line-3171"><code>	sp := getcallersp()</code></span>
<span class="codeline" id="line-3172"><code>	save(pc, sp)</code></span>
<span class="codeline" id="line-3173"><code>	_g_.syscallsp = _g_.sched.sp</code></span>
<span class="codeline" id="line-3174"><code>	_g_.syscallpc = _g_.sched.pc</code></span>
<span class="codeline" id="line-3175"><code>	if _g_.syscallsp &lt; _g_.stack.lo || _g_.stack.hi &lt; _g_.syscallsp {</code></span>
<span class="codeline" id="line-3176"><code>		sp1 := sp</code></span>
<span class="codeline" id="line-3177"><code>		sp2 := _g_.sched.sp</code></span>
<span class="codeline" id="line-3178"><code>		sp3 := _g_.syscallsp</code></span>
<span class="codeline" id="line-3179"><code>		systemstack(func() {</code></span>
<span class="codeline" id="line-3180"><code>			print("entersyscallblock inconsistent ", hex(sp1), " ", hex(sp2), " ", hex(sp3), " [", hex(_g_.stack.lo), ",", hex(_g_.stack.hi), "]\n")</code></span>
<span class="codeline" id="line-3181"><code>			throw("entersyscallblock")</code></span>
<span class="codeline" id="line-3182"><code>		})</code></span>
<span class="codeline" id="line-3183"><code>	}</code></span>
<span class="codeline" id="line-3184"><code>	casgstatus(_g_, _Grunning, _Gsyscall)</code></span>
<span class="codeline" id="line-3185"><code>	if _g_.syscallsp &lt; _g_.stack.lo || _g_.stack.hi &lt; _g_.syscallsp {</code></span>
<span class="codeline" id="line-3186"><code>		systemstack(func() {</code></span>
<span class="codeline" id="line-3187"><code>			print("entersyscallblock inconsistent ", hex(sp), " ", hex(_g_.sched.sp), " ", hex(_g_.syscallsp), " [", hex(_g_.stack.lo), ",", hex(_g_.stack.hi), "]\n")</code></span>
<span class="codeline" id="line-3188"><code>			throw("entersyscallblock")</code></span>
<span class="codeline" id="line-3189"><code>		})</code></span>
<span class="codeline" id="line-3190"><code>	}</code></span>
<span class="codeline" id="line-3191"><code></code></span>
<span class="codeline" id="line-3192"><code>	systemstack(entersyscallblock_handoff)</code></span>
<span class="codeline" id="line-3193"><code></code></span>
<span class="codeline" id="line-3194"><code>	// Resave for traceback during blocked call.</code></span>
<span class="codeline" id="line-3195"><code>	save(getcallerpc(), getcallersp())</code></span>
<span class="codeline" id="line-3196"><code></code></span>
<span class="codeline" id="line-3197"><code>	_g_.m.locks--</code></span>
<span class="codeline" id="line-3198"><code>}</code></span>
<span class="codeline" id="line-3199"><code></code></span>
<span class="codeline" id="line-3200"><code>func entersyscallblock_handoff() {</code></span>
<span class="codeline" id="line-3201"><code>	if trace.enabled {</code></span>
<span class="codeline" id="line-3202"><code>		traceGoSysCall()</code></span>
<span class="codeline" id="line-3203"><code>		traceGoSysBlock(getg().m.p.ptr())</code></span>
<span class="codeline" id="line-3204"><code>	}</code></span>
<span class="codeline" id="line-3205"><code>	handoffp(releasep())</code></span>
<span class="codeline" id="line-3206"><code>}</code></span>
<span class="codeline" id="line-3207"><code></code></span>
<span class="codeline" id="line-3208"><code>// The goroutine g exited its system call.</code></span>
<span class="codeline" id="line-3209"><code>// Arrange for it to run on a cpu again.</code></span>
<span class="codeline" id="line-3210"><code>// This is called only from the go syscall library, not</code></span>
<span class="codeline" id="line-3211"><code>// from the low-level system calls used by the runtime.</code></span>
<span class="codeline" id="line-3212"><code>//</code></span>
<span class="codeline" id="line-3213"><code>// Write barriers are not allowed because our P may have been stolen.</code></span>
<span class="codeline" id="line-3214"><code>//</code></span>
<span class="codeline" id="line-3215"><code>// This is exported via linkname to assembly in the syscall package.</code></span>
<span class="codeline" id="line-3216"><code>//</code></span>
<span class="codeline" id="line-3217"><code>//go:nosplit</code></span>
<span class="codeline" id="line-3218"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-3219"><code>//go:linkname exitsyscall</code></span>
<span class="codeline" id="line-3220"><code>func exitsyscall() {</code></span>
<span class="codeline" id="line-3221"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-3222"><code></code></span>
<span class="codeline" id="line-3223"><code>	_g_.m.locks++ // see comment in entersyscall</code></span>
<span class="codeline" id="line-3224"><code>	if getcallersp() &gt; _g_.syscallsp {</code></span>
<span class="codeline" id="line-3225"><code>		throw("exitsyscall: syscall frame is no longer valid")</code></span>
<span class="codeline" id="line-3226"><code>	}</code></span>
<span class="codeline" id="line-3227"><code></code></span>
<span class="codeline" id="line-3228"><code>	_g_.waitsince = 0</code></span>
<span class="codeline" id="line-3229"><code>	oldp := _g_.m.oldp.ptr()</code></span>
<span class="codeline" id="line-3230"><code>	_g_.m.oldp = 0</code></span>
<span class="codeline" id="line-3231"><code>	if exitsyscallfast(oldp) {</code></span>
<span class="codeline" id="line-3232"><code>		if trace.enabled {</code></span>
<span class="codeline" id="line-3233"><code>			if oldp != _g_.m.p.ptr() || _g_.m.syscalltick != _g_.m.p.ptr().syscalltick {</code></span>
<span class="codeline" id="line-3234"><code>				systemstack(traceGoStart)</code></span>
<span class="codeline" id="line-3235"><code>			}</code></span>
<span class="codeline" id="line-3236"><code>		}</code></span>
<span class="codeline" id="line-3237"><code>		// There's a cpu for us, so we can run.</code></span>
<span class="codeline" id="line-3238"><code>		_g_.m.p.ptr().syscalltick++</code></span>
<span class="codeline" id="line-3239"><code>		// We need to cas the status and scan before resuming...</code></span>
<span class="codeline" id="line-3240"><code>		casgstatus(_g_, _Gsyscall, _Grunning)</code></span>
<span class="codeline" id="line-3241"><code></code></span>
<span class="codeline" id="line-3242"><code>		// Garbage collector isn't running (since we are),</code></span>
<span class="codeline" id="line-3243"><code>		// so okay to clear syscallsp.</code></span>
<span class="codeline" id="line-3244"><code>		_g_.syscallsp = 0</code></span>
<span class="codeline" id="line-3245"><code>		_g_.m.locks--</code></span>
<span class="codeline" id="line-3246"><code>		if _g_.preempt {</code></span>
<span class="codeline" id="line-3247"><code>			// restore the preemption request in case we've cleared it in newstack</code></span>
<span class="codeline" id="line-3248"><code>			_g_.stackguard0 = stackPreempt</code></span>
<span class="codeline" id="line-3249"><code>		} else {</code></span>
<span class="codeline" id="line-3250"><code>			// otherwise restore the real _StackGuard, we've spoiled it in entersyscall/entersyscallblock</code></span>
<span class="codeline" id="line-3251"><code>			_g_.stackguard0 = _g_.stack.lo + _StackGuard</code></span>
<span class="codeline" id="line-3252"><code>		}</code></span>
<span class="codeline" id="line-3253"><code>		_g_.throwsplit = false</code></span>
<span class="codeline" id="line-3254"><code></code></span>
<span class="codeline" id="line-3255"><code>		if sched.disable.user &amp;&amp; !schedEnabled(_g_) {</code></span>
<span class="codeline" id="line-3256"><code>			// Scheduling of this goroutine is disabled.</code></span>
<span class="codeline" id="line-3257"><code>			Gosched()</code></span>
<span class="codeline" id="line-3258"><code>		}</code></span>
<span class="codeline" id="line-3259"><code></code></span>
<span class="codeline" id="line-3260"><code>		return</code></span>
<span class="codeline" id="line-3261"><code>	}</code></span>
<span class="codeline" id="line-3262"><code></code></span>
<span class="codeline" id="line-3263"><code>	_g_.sysexitticks = 0</code></span>
<span class="codeline" id="line-3264"><code>	if trace.enabled {</code></span>
<span class="codeline" id="line-3265"><code>		// Wait till traceGoSysBlock event is emitted.</code></span>
<span class="codeline" id="line-3266"><code>		// This ensures consistency of the trace (the goroutine is started after it is blocked).</code></span>
<span class="codeline" id="line-3267"><code>		for oldp != nil &amp;&amp; oldp.syscalltick == _g_.m.syscalltick {</code></span>
<span class="codeline" id="line-3268"><code>			osyield()</code></span>
<span class="codeline" id="line-3269"><code>		}</code></span>
<span class="codeline" id="line-3270"><code>		// We can't trace syscall exit right now because we don't have a P.</code></span>
<span class="codeline" id="line-3271"><code>		// Tracing code can invoke write barriers that cannot run without a P.</code></span>
<span class="codeline" id="line-3272"><code>		// So instead we remember the syscall exit time and emit the event</code></span>
<span class="codeline" id="line-3273"><code>		// in execute when we have a P.</code></span>
<span class="codeline" id="line-3274"><code>		_g_.sysexitticks = cputicks()</code></span>
<span class="codeline" id="line-3275"><code>	}</code></span>
<span class="codeline" id="line-3276"><code></code></span>
<span class="codeline" id="line-3277"><code>	_g_.m.locks--</code></span>
<span class="codeline" id="line-3278"><code></code></span>
<span class="codeline" id="line-3279"><code>	// Call the scheduler.</code></span>
<span class="codeline" id="line-3280"><code>	mcall(exitsyscall0)</code></span>
<span class="codeline" id="line-3281"><code></code></span>
<span class="codeline" id="line-3282"><code>	// Scheduler returned, so we're allowed to run now.</code></span>
<span class="codeline" id="line-3283"><code>	// Delete the syscallsp information that we left for</code></span>
<span class="codeline" id="line-3284"><code>	// the garbage collector during the system call.</code></span>
<span class="codeline" id="line-3285"><code>	// Must wait until now because until gosched returns</code></span>
<span class="codeline" id="line-3286"><code>	// we don't know for sure that the garbage collector</code></span>
<span class="codeline" id="line-3287"><code>	// is not running.</code></span>
<span class="codeline" id="line-3288"><code>	_g_.syscallsp = 0</code></span>
<span class="codeline" id="line-3289"><code>	_g_.m.p.ptr().syscalltick++</code></span>
<span class="codeline" id="line-3290"><code>	_g_.throwsplit = false</code></span>
<span class="codeline" id="line-3291"><code>}</code></span>
<span class="codeline" id="line-3292"><code></code></span>
<span class="codeline" id="line-3293"><code>//go:nosplit</code></span>
<span class="codeline" id="line-3294"><code>func exitsyscallfast(oldp *p) bool {</code></span>
<span class="codeline" id="line-3295"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-3296"><code></code></span>
<span class="codeline" id="line-3297"><code>	// Freezetheworld sets stopwait but does not retake P's.</code></span>
<span class="codeline" id="line-3298"><code>	if sched.stopwait == freezeStopWait {</code></span>
<span class="codeline" id="line-3299"><code>		return false</code></span>
<span class="codeline" id="line-3300"><code>	}</code></span>
<span class="codeline" id="line-3301"><code></code></span>
<span class="codeline" id="line-3302"><code>	// Try to re-acquire the last P.</code></span>
<span class="codeline" id="line-3303"><code>	if oldp != nil &amp;&amp; oldp.status == _Psyscall &amp;&amp; atomic.Cas(&amp;oldp.status, _Psyscall, _Pidle) {</code></span>
<span class="codeline" id="line-3304"><code>		// There's a cpu for us, so we can run.</code></span>
<span class="codeline" id="line-3305"><code>		wirep(oldp)</code></span>
<span class="codeline" id="line-3306"><code>		exitsyscallfast_reacquired()</code></span>
<span class="codeline" id="line-3307"><code>		return true</code></span>
<span class="codeline" id="line-3308"><code>	}</code></span>
<span class="codeline" id="line-3309"><code></code></span>
<span class="codeline" id="line-3310"><code>	// Try to get any other idle P.</code></span>
<span class="codeline" id="line-3311"><code>	if sched.pidle != 0 {</code></span>
<span class="codeline" id="line-3312"><code>		var ok bool</code></span>
<span class="codeline" id="line-3313"><code>		systemstack(func() {</code></span>
<span class="codeline" id="line-3314"><code>			ok = exitsyscallfast_pidle()</code></span>
<span class="codeline" id="line-3315"><code>			if ok &amp;&amp; trace.enabled {</code></span>
<span class="codeline" id="line-3316"><code>				if oldp != nil {</code></span>
<span class="codeline" id="line-3317"><code>					// Wait till traceGoSysBlock event is emitted.</code></span>
<span class="codeline" id="line-3318"><code>					// This ensures consistency of the trace (the goroutine is started after it is blocked).</code></span>
<span class="codeline" id="line-3319"><code>					for oldp.syscalltick == _g_.m.syscalltick {</code></span>
<span class="codeline" id="line-3320"><code>						osyield()</code></span>
<span class="codeline" id="line-3321"><code>					}</code></span>
<span class="codeline" id="line-3322"><code>				}</code></span>
<span class="codeline" id="line-3323"><code>				traceGoSysExit(0)</code></span>
<span class="codeline" id="line-3324"><code>			}</code></span>
<span class="codeline" id="line-3325"><code>		})</code></span>
<span class="codeline" id="line-3326"><code>		if ok {</code></span>
<span class="codeline" id="line-3327"><code>			return true</code></span>
<span class="codeline" id="line-3328"><code>		}</code></span>
<span class="codeline" id="line-3329"><code>	}</code></span>
<span class="codeline" id="line-3330"><code>	return false</code></span>
<span class="codeline" id="line-3331"><code>}</code></span>
<span class="codeline" id="line-3332"><code></code></span>
<span class="codeline" id="line-3333"><code>// exitsyscallfast_reacquired is the exitsyscall path on which this G</code></span>
<span class="codeline" id="line-3334"><code>// has successfully reacquired the P it was running on before the</code></span>
<span class="codeline" id="line-3335"><code>// syscall.</code></span>
<span class="codeline" id="line-3336"><code>//</code></span>
<span class="codeline" id="line-3337"><code>//go:nosplit</code></span>
<span class="codeline" id="line-3338"><code>func exitsyscallfast_reacquired() {</code></span>
<span class="codeline" id="line-3339"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-3340"><code>	if _g_.m.syscalltick != _g_.m.p.ptr().syscalltick {</code></span>
<span class="codeline" id="line-3341"><code>		if trace.enabled {</code></span>
<span class="codeline" id="line-3342"><code>			// The p was retaken and then enter into syscall again (since _g_.m.syscalltick has changed).</code></span>
<span class="codeline" id="line-3343"><code>			// traceGoSysBlock for this syscall was already emitted,</code></span>
<span class="codeline" id="line-3344"><code>			// but here we effectively retake the p from the new syscall running on the same p.</code></span>
<span class="codeline" id="line-3345"><code>			systemstack(func() {</code></span>
<span class="codeline" id="line-3346"><code>				// Denote blocking of the new syscall.</code></span>
<span class="codeline" id="line-3347"><code>				traceGoSysBlock(_g_.m.p.ptr())</code></span>
<span class="codeline" id="line-3348"><code>				// Denote completion of the current syscall.</code></span>
<span class="codeline" id="line-3349"><code>				traceGoSysExit(0)</code></span>
<span class="codeline" id="line-3350"><code>			})</code></span>
<span class="codeline" id="line-3351"><code>		}</code></span>
<span class="codeline" id="line-3352"><code>		_g_.m.p.ptr().syscalltick++</code></span>
<span class="codeline" id="line-3353"><code>	}</code></span>
<span class="codeline" id="line-3354"><code>}</code></span>
<span class="codeline" id="line-3355"><code></code></span>
<span class="codeline" id="line-3356"><code>func exitsyscallfast_pidle() bool {</code></span>
<span class="codeline" id="line-3357"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3358"><code>	_p_ := pidleget()</code></span>
<span class="codeline" id="line-3359"><code>	if _p_ != nil &amp;&amp; atomic.Load(&amp;sched.sysmonwait) != 0 {</code></span>
<span class="codeline" id="line-3360"><code>		atomic.Store(&amp;sched.sysmonwait, 0)</code></span>
<span class="codeline" id="line-3361"><code>		notewakeup(&amp;sched.sysmonnote)</code></span>
<span class="codeline" id="line-3362"><code>	}</code></span>
<span class="codeline" id="line-3363"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3364"><code>	if _p_ != nil {</code></span>
<span class="codeline" id="line-3365"><code>		acquirep(_p_)</code></span>
<span class="codeline" id="line-3366"><code>		return true</code></span>
<span class="codeline" id="line-3367"><code>	}</code></span>
<span class="codeline" id="line-3368"><code>	return false</code></span>
<span class="codeline" id="line-3369"><code>}</code></span>
<span class="codeline" id="line-3370"><code></code></span>
<span class="codeline" id="line-3371"><code>// exitsyscall slow path on g0.</code></span>
<span class="codeline" id="line-3372"><code>// Failed to acquire P, enqueue gp as runnable.</code></span>
<span class="codeline" id="line-3373"><code>//</code></span>
<span class="codeline" id="line-3374"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-3375"><code>func exitsyscall0(gp *g) {</code></span>
<span class="codeline" id="line-3376"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-3377"><code></code></span>
<span class="codeline" id="line-3378"><code>	casgstatus(gp, _Gsyscall, _Grunnable)</code></span>
<span class="codeline" id="line-3379"><code>	dropg()</code></span>
<span class="codeline" id="line-3380"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3381"><code>	var _p_ *p</code></span>
<span class="codeline" id="line-3382"><code>	if schedEnabled(_g_) {</code></span>
<span class="codeline" id="line-3383"><code>		_p_ = pidleget()</code></span>
<span class="codeline" id="line-3384"><code>	}</code></span>
<span class="codeline" id="line-3385"><code>	if _p_ == nil {</code></span>
<span class="codeline" id="line-3386"><code>		globrunqput(gp)</code></span>
<span class="codeline" id="line-3387"><code>	} else if atomic.Load(&amp;sched.sysmonwait) != 0 {</code></span>
<span class="codeline" id="line-3388"><code>		atomic.Store(&amp;sched.sysmonwait, 0)</code></span>
<span class="codeline" id="line-3389"><code>		notewakeup(&amp;sched.sysmonnote)</code></span>
<span class="codeline" id="line-3390"><code>	}</code></span>
<span class="codeline" id="line-3391"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3392"><code>	if _p_ != nil {</code></span>
<span class="codeline" id="line-3393"><code>		acquirep(_p_)</code></span>
<span class="codeline" id="line-3394"><code>		execute(gp, false) // Never returns.</code></span>
<span class="codeline" id="line-3395"><code>	}</code></span>
<span class="codeline" id="line-3396"><code>	if _g_.m.lockedg != 0 {</code></span>
<span class="codeline" id="line-3397"><code>		// Wait until another thread schedules gp and so m again.</code></span>
<span class="codeline" id="line-3398"><code>		stoplockedm()</code></span>
<span class="codeline" id="line-3399"><code>		execute(gp, false) // Never returns.</code></span>
<span class="codeline" id="line-3400"><code>	}</code></span>
<span class="codeline" id="line-3401"><code>	stopm()</code></span>
<span class="codeline" id="line-3402"><code>	schedule() // Never returns.</code></span>
<span class="codeline" id="line-3403"><code>}</code></span>
<span class="codeline" id="line-3404"><code></code></span>
<span class="codeline" id="line-3405"><code>func beforefork() {</code></span>
<span class="codeline" id="line-3406"><code>	gp := getg().m.curg</code></span>
<span class="codeline" id="line-3407"><code></code></span>
<span class="codeline" id="line-3408"><code>	// Block signals during a fork, so that the child does not run</code></span>
<span class="codeline" id="line-3409"><code>	// a signal handler before exec if a signal is sent to the process</code></span>
<span class="codeline" id="line-3410"><code>	// group. See issue #18600.</code></span>
<span class="codeline" id="line-3411"><code>	gp.m.locks++</code></span>
<span class="codeline" id="line-3412"><code>	msigsave(gp.m)</code></span>
<span class="codeline" id="line-3413"><code>	sigblock()</code></span>
<span class="codeline" id="line-3414"><code></code></span>
<span class="codeline" id="line-3415"><code>	// This function is called before fork in syscall package.</code></span>
<span class="codeline" id="line-3416"><code>	// Code between fork and exec must not allocate memory nor even try to grow stack.</code></span>
<span class="codeline" id="line-3417"><code>	// Here we spoil g-&gt;_StackGuard to reliably detect any attempts to grow stack.</code></span>
<span class="codeline" id="line-3418"><code>	// runtime_AfterFork will undo this in parent process, but not in child.</code></span>
<span class="codeline" id="line-3419"><code>	gp.stackguard0 = stackFork</code></span>
<span class="codeline" id="line-3420"><code>}</code></span>
<span class="codeline" id="line-3421"><code></code></span>
<span class="codeline" id="line-3422"><code>// Called from syscall package before fork.</code></span>
<span class="codeline" id="line-3423"><code>//go:linkname syscall_runtime_BeforeFork syscall.runtime_BeforeFork</code></span>
<span class="codeline" id="line-3424"><code>//go:nosplit</code></span>
<span class="codeline" id="line-3425"><code>func syscall_runtime_BeforeFork() {</code></span>
<span class="codeline" id="line-3426"><code>	systemstack(beforefork)</code></span>
<span class="codeline" id="line-3427"><code>}</code></span>
<span class="codeline" id="line-3428"><code></code></span>
<span class="codeline" id="line-3429"><code>func afterfork() {</code></span>
<span class="codeline" id="line-3430"><code>	gp := getg().m.curg</code></span>
<span class="codeline" id="line-3431"><code></code></span>
<span class="codeline" id="line-3432"><code>	// See the comments in beforefork.</code></span>
<span class="codeline" id="line-3433"><code>	gp.stackguard0 = gp.stack.lo + _StackGuard</code></span>
<span class="codeline" id="line-3434"><code></code></span>
<span class="codeline" id="line-3435"><code>	msigrestore(gp.m.sigmask)</code></span>
<span class="codeline" id="line-3436"><code></code></span>
<span class="codeline" id="line-3437"><code>	gp.m.locks--</code></span>
<span class="codeline" id="line-3438"><code>}</code></span>
<span class="codeline" id="line-3439"><code></code></span>
<span class="codeline" id="line-3440"><code>// Called from syscall package after fork in parent.</code></span>
<span class="codeline" id="line-3441"><code>//go:linkname syscall_runtime_AfterFork syscall.runtime_AfterFork</code></span>
<span class="codeline" id="line-3442"><code>//go:nosplit</code></span>
<span class="codeline" id="line-3443"><code>func syscall_runtime_AfterFork() {</code></span>
<span class="codeline" id="line-3444"><code>	systemstack(afterfork)</code></span>
<span class="codeline" id="line-3445"><code>}</code></span>
<span class="codeline" id="line-3446"><code></code></span>
<span class="codeline" id="line-3447"><code>// inForkedChild is true while manipulating signals in the child process.</code></span>
<span class="codeline" id="line-3448"><code>// This is used to avoid calling libc functions in case we are using vfork.</code></span>
<span class="codeline" id="line-3449"><code>var inForkedChild bool</code></span>
<span class="codeline" id="line-3450"><code></code></span>
<span class="codeline" id="line-3451"><code>// Called from syscall package after fork in child.</code></span>
<span class="codeline" id="line-3452"><code>// It resets non-sigignored signals to the default handler, and</code></span>
<span class="codeline" id="line-3453"><code>// restores the signal mask in preparation for the exec.</code></span>
<span class="codeline" id="line-3454"><code>//</code></span>
<span class="codeline" id="line-3455"><code>// Because this might be called during a vfork, and therefore may be</code></span>
<span class="codeline" id="line-3456"><code>// temporarily sharing address space with the parent process, this must</code></span>
<span class="codeline" id="line-3457"><code>// not change any global variables or calling into C code that may do so.</code></span>
<span class="codeline" id="line-3458"><code>//</code></span>
<span class="codeline" id="line-3459"><code>//go:linkname syscall_runtime_AfterForkInChild syscall.runtime_AfterForkInChild</code></span>
<span class="codeline" id="line-3460"><code>//go:nosplit</code></span>
<span class="codeline" id="line-3461"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-3462"><code>func syscall_runtime_AfterForkInChild() {</code></span>
<span class="codeline" id="line-3463"><code>	// It's OK to change the global variable inForkedChild here</code></span>
<span class="codeline" id="line-3464"><code>	// because we are going to change it back. There is no race here,</code></span>
<span class="codeline" id="line-3465"><code>	// because if we are sharing address space with the parent process,</code></span>
<span class="codeline" id="line-3466"><code>	// then the parent process can not be running concurrently.</code></span>
<span class="codeline" id="line-3467"><code>	inForkedChild = true</code></span>
<span class="codeline" id="line-3468"><code></code></span>
<span class="codeline" id="line-3469"><code>	clearSignalHandlers()</code></span>
<span class="codeline" id="line-3470"><code></code></span>
<span class="codeline" id="line-3471"><code>	// When we are the child we are the only thread running,</code></span>
<span class="codeline" id="line-3472"><code>	// so we know that nothing else has changed gp.m.sigmask.</code></span>
<span class="codeline" id="line-3473"><code>	msigrestore(getg().m.sigmask)</code></span>
<span class="codeline" id="line-3474"><code></code></span>
<span class="codeline" id="line-3475"><code>	inForkedChild = false</code></span>
<span class="codeline" id="line-3476"><code>}</code></span>
<span class="codeline" id="line-3477"><code></code></span>
<span class="codeline" id="line-3478"><code>// Called from syscall package before Exec.</code></span>
<span class="codeline" id="line-3479"><code>//go:linkname syscall_runtime_BeforeExec syscall.runtime_BeforeExec</code></span>
<span class="codeline" id="line-3480"><code>func syscall_runtime_BeforeExec() {</code></span>
<span class="codeline" id="line-3481"><code>	// Prevent thread creation during exec.</code></span>
<span class="codeline" id="line-3482"><code>	execLock.lock()</code></span>
<span class="codeline" id="line-3483"><code>}</code></span>
<span class="codeline" id="line-3484"><code></code></span>
<span class="codeline" id="line-3485"><code>// Called from syscall package after Exec.</code></span>
<span class="codeline" id="line-3486"><code>//go:linkname syscall_runtime_AfterExec syscall.runtime_AfterExec</code></span>
<span class="codeline" id="line-3487"><code>func syscall_runtime_AfterExec() {</code></span>
<span class="codeline" id="line-3488"><code>	execLock.unlock()</code></span>
<span class="codeline" id="line-3489"><code>}</code></span>
<span class="codeline" id="line-3490"><code></code></span>
<span class="codeline" id="line-3491"><code>// Allocate a new g, with a stack big enough for stacksize bytes.</code></span>
<span class="codeline" id="line-3492"><code>func malg(stacksize int32) *g {</code></span>
<span class="codeline" id="line-3493"><code>	newg := new(g)</code></span>
<span class="codeline" id="line-3494"><code>	if stacksize &gt;= 0 {</code></span>
<span class="codeline" id="line-3495"><code>		stacksize = round2(_StackSystem + stacksize)</code></span>
<span class="codeline" id="line-3496"><code>		systemstack(func() {</code></span>
<span class="codeline" id="line-3497"><code>			newg.stack = stackalloc(uint32(stacksize))</code></span>
<span class="codeline" id="line-3498"><code>		})</code></span>
<span class="codeline" id="line-3499"><code>		newg.stackguard0 = newg.stack.lo + _StackGuard</code></span>
<span class="codeline" id="line-3500"><code>		newg.stackguard1 = ^uintptr(0)</code></span>
<span class="codeline" id="line-3501"><code>		// Clear the bottom word of the stack. We record g</code></span>
<span class="codeline" id="line-3502"><code>		// there on gsignal stack during VDSO on ARM and ARM64.</code></span>
<span class="codeline" id="line-3503"><code>		*(*uintptr)(unsafe.Pointer(newg.stack.lo)) = 0</code></span>
<span class="codeline" id="line-3504"><code>	}</code></span>
<span class="codeline" id="line-3505"><code>	return newg</code></span>
<span class="codeline" id="line-3506"><code>}</code></span>
<span class="codeline" id="line-3507"><code></code></span>
<span class="codeline" id="line-3508"><code>// Create a new g running fn with siz bytes of arguments.</code></span>
<span class="codeline" id="line-3509"><code>// Put it on the queue of g's waiting to run.</code></span>
<span class="codeline" id="line-3510"><code>// The compiler turns a go statement into a call to this.</code></span>
<span class="codeline" id="line-3511"><code>//</code></span>
<span class="codeline" id="line-3512"><code>// The stack layout of this call is unusual: it assumes that the</code></span>
<span class="codeline" id="line-3513"><code>// arguments to pass to fn are on the stack sequentially immediately</code></span>
<span class="codeline" id="line-3514"><code>// after &amp;fn. Hence, they are logically part of newproc's argument</code></span>
<span class="codeline" id="line-3515"><code>// frame, even though they don't appear in its signature (and can't</code></span>
<span class="codeline" id="line-3516"><code>// because their types differ between call sites).</code></span>
<span class="codeline" id="line-3517"><code>//</code></span>
<span class="codeline" id="line-3518"><code>// This must be nosplit because this stack layout means there are</code></span>
<span class="codeline" id="line-3519"><code>// untyped arguments in newproc's argument frame. Stack copies won't</code></span>
<span class="codeline" id="line-3520"><code>// be able to adjust them and stack splits won't be able to copy them.</code></span>
<span class="codeline" id="line-3521"><code>//</code></span>
<span class="codeline" id="line-3522"><code>//go:nosplit</code></span>
<span class="codeline" id="line-3523"><code>func newproc(siz int32, fn *funcval) {</code></span>
<span class="codeline" id="line-3524"><code>	argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</code></span>
<span class="codeline" id="line-3525"><code>	gp := getg()</code></span>
<span class="codeline" id="line-3526"><code>	pc := getcallerpc()</code></span>
<span class="codeline" id="line-3527"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-3528"><code>		newg := newproc1(fn, argp, siz, gp, pc)</code></span>
<span class="codeline" id="line-3529"><code></code></span>
<span class="codeline" id="line-3530"><code>		_p_ := getg().m.p.ptr()</code></span>
<span class="codeline" id="line-3531"><code>		runqput(_p_, newg, true)</code></span>
<span class="codeline" id="line-3532"><code></code></span>
<span class="codeline" id="line-3533"><code>		if mainStarted {</code></span>
<span class="codeline" id="line-3534"><code>			wakep()</code></span>
<span class="codeline" id="line-3535"><code>		}</code></span>
<span class="codeline" id="line-3536"><code>	})</code></span>
<span class="codeline" id="line-3537"><code>}</code></span>
<span class="codeline" id="line-3538"><code></code></span>
<span class="codeline" id="line-3539"><code>// Create a new g in state _Grunnable, starting at fn, with narg bytes</code></span>
<span class="codeline" id="line-3540"><code>// of arguments starting at argp. callerpc is the address of the go</code></span>
<span class="codeline" id="line-3541"><code>// statement that created this. The caller is responsible for adding</code></span>
<span class="codeline" id="line-3542"><code>// the new g to the scheduler.</code></span>
<span class="codeline" id="line-3543"><code>//</code></span>
<span class="codeline" id="line-3544"><code>// This must run on the system stack because it's the continuation of</code></span>
<span class="codeline" id="line-3545"><code>// newproc, which cannot split the stack.</code></span>
<span class="codeline" id="line-3546"><code>//</code></span>
<span class="codeline" id="line-3547"><code>//go:systemstack</code></span>
<span class="codeline" id="line-3548"><code>func newproc1(fn *funcval, argp unsafe.Pointer, narg int32, callergp *g, callerpc uintptr) *g {</code></span>
<span class="codeline" id="line-3549"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-3550"><code></code></span>
<span class="codeline" id="line-3551"><code>	if fn == nil {</code></span>
<span class="codeline" id="line-3552"><code>		_g_.m.throwing = -1 // do not dump full stacks</code></span>
<span class="codeline" id="line-3553"><code>		throw("go of nil func value")</code></span>
<span class="codeline" id="line-3554"><code>	}</code></span>
<span class="codeline" id="line-3555"><code>	acquirem() // disable preemption because it can be holding p in a local var</code></span>
<span class="codeline" id="line-3556"><code>	siz := narg</code></span>
<span class="codeline" id="line-3557"><code>	siz = (siz + 7) &amp;^ 7</code></span>
<span class="codeline" id="line-3558"><code></code></span>
<span class="codeline" id="line-3559"><code>	// We could allocate a larger initial stack if necessary.</code></span>
<span class="codeline" id="line-3560"><code>	// Not worth it: this is almost always an error.</code></span>
<span class="codeline" id="line-3561"><code>	// 4*sizeof(uintreg): extra space added below</code></span>
<span class="codeline" id="line-3562"><code>	// sizeof(uintreg): caller's LR (arm) or return address (x86, in gostartcall).</code></span>
<span class="codeline" id="line-3563"><code>	if siz &gt;= _StackMin-4*sys.RegSize-sys.RegSize {</code></span>
<span class="codeline" id="line-3564"><code>		throw("newproc: function arguments too large for new goroutine")</code></span>
<span class="codeline" id="line-3565"><code>	}</code></span>
<span class="codeline" id="line-3566"><code></code></span>
<span class="codeline" id="line-3567"><code>	_p_ := _g_.m.p.ptr()</code></span>
<span class="codeline" id="line-3568"><code>	newg := gfget(_p_)</code></span>
<span class="codeline" id="line-3569"><code>	if newg == nil {</code></span>
<span class="codeline" id="line-3570"><code>		newg = malg(_StackMin)</code></span>
<span class="codeline" id="line-3571"><code>		casgstatus(newg, _Gidle, _Gdead)</code></span>
<span class="codeline" id="line-3572"><code>		allgadd(newg) // publishes with a g-&gt;status of Gdead so GC scanner doesn't look at uninitialized stack.</code></span>
<span class="codeline" id="line-3573"><code>	}</code></span>
<span class="codeline" id="line-3574"><code>	if newg.stack.hi == 0 {</code></span>
<span class="codeline" id="line-3575"><code>		throw("newproc1: newg missing stack")</code></span>
<span class="codeline" id="line-3576"><code>	}</code></span>
<span class="codeline" id="line-3577"><code></code></span>
<span class="codeline" id="line-3578"><code>	if readgstatus(newg) != _Gdead {</code></span>
<span class="codeline" id="line-3579"><code>		throw("newproc1: new g is not Gdead")</code></span>
<span class="codeline" id="line-3580"><code>	}</code></span>
<span class="codeline" id="line-3581"><code></code></span>
<span class="codeline" id="line-3582"><code>	totalSize := 4*sys.RegSize + uintptr(siz) + sys.MinFrameSize // extra space in case of reads slightly beyond frame</code></span>
<span class="codeline" id="line-3583"><code>	totalSize += -totalSize &amp; (sys.SpAlign - 1)                  // align to spAlign</code></span>
<span class="codeline" id="line-3584"><code>	sp := newg.stack.hi - totalSize</code></span>
<span class="codeline" id="line-3585"><code>	spArg := sp</code></span>
<span class="codeline" id="line-3586"><code>	if usesLR {</code></span>
<span class="codeline" id="line-3587"><code>		// caller's LR</code></span>
<span class="codeline" id="line-3588"><code>		*(*uintptr)(unsafe.Pointer(sp)) = 0</code></span>
<span class="codeline" id="line-3589"><code>		prepGoExitFrame(sp)</code></span>
<span class="codeline" id="line-3590"><code>		spArg += sys.MinFrameSize</code></span>
<span class="codeline" id="line-3591"><code>	}</code></span>
<span class="codeline" id="line-3592"><code>	if narg &gt; 0 {</code></span>
<span class="codeline" id="line-3593"><code>		memmove(unsafe.Pointer(spArg), argp, uintptr(narg))</code></span>
<span class="codeline" id="line-3594"><code>		// This is a stack-to-stack copy. If write barriers</code></span>
<span class="codeline" id="line-3595"><code>		// are enabled and the source stack is grey (the</code></span>
<span class="codeline" id="line-3596"><code>		// destination is always black), then perform a</code></span>
<span class="codeline" id="line-3597"><code>		// barrier copy. We do this *after* the memmove</code></span>
<span class="codeline" id="line-3598"><code>		// because the destination stack may have garbage on</code></span>
<span class="codeline" id="line-3599"><code>		// it.</code></span>
<span class="codeline" id="line-3600"><code>		if writeBarrier.needed &amp;&amp; !_g_.m.curg.gcscandone {</code></span>
<span class="codeline" id="line-3601"><code>			f := findfunc(fn.fn)</code></span>
<span class="codeline" id="line-3602"><code>			stkmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))</code></span>
<span class="codeline" id="line-3603"><code>			if stkmap.nbit &gt; 0 {</code></span>
<span class="codeline" id="line-3604"><code>				// We're in the prologue, so it's always stack map index 0.</code></span>
<span class="codeline" id="line-3605"><code>				bv := stackmapdata(stkmap, 0)</code></span>
<span class="codeline" id="line-3606"><code>				bulkBarrierBitmap(spArg, spArg, uintptr(bv.n)*sys.PtrSize, 0, bv.bytedata)</code></span>
<span class="codeline" id="line-3607"><code>			}</code></span>
<span class="codeline" id="line-3608"><code>		}</code></span>
<span class="codeline" id="line-3609"><code>	}</code></span>
<span class="codeline" id="line-3610"><code></code></span>
<span class="codeline" id="line-3611"><code>	memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))</code></span>
<span class="codeline" id="line-3612"><code>	newg.sched.sp = sp</code></span>
<span class="codeline" id="line-3613"><code>	newg.stktopsp = sp</code></span>
<span class="codeline" id="line-3614"><code>	newg.sched.pc = funcPC(goexit) + sys.PCQuantum // +PCQuantum so that previous instruction is in same function</code></span>
<span class="codeline" id="line-3615"><code>	newg.sched.g = guintptr(unsafe.Pointer(newg))</code></span>
<span class="codeline" id="line-3616"><code>	gostartcallfn(&amp;newg.sched, fn)</code></span>
<span class="codeline" id="line-3617"><code>	newg.gopc = callerpc</code></span>
<span class="codeline" id="line-3618"><code>	newg.ancestors = saveAncestors(callergp)</code></span>
<span class="codeline" id="line-3619"><code>	newg.startpc = fn.fn</code></span>
<span class="codeline" id="line-3620"><code>	if _g_.m.curg != nil {</code></span>
<span class="codeline" id="line-3621"><code>		newg.labels = _g_.m.curg.labels</code></span>
<span class="codeline" id="line-3622"><code>	}</code></span>
<span class="codeline" id="line-3623"><code>	if isSystemGoroutine(newg, false) {</code></span>
<span class="codeline" id="line-3624"><code>		atomic.Xadd(&amp;sched.ngsys, +1)</code></span>
<span class="codeline" id="line-3625"><code>	}</code></span>
<span class="codeline" id="line-3626"><code>	casgstatus(newg, _Gdead, _Grunnable)</code></span>
<span class="codeline" id="line-3627"><code></code></span>
<span class="codeline" id="line-3628"><code>	if _p_.goidcache == _p_.goidcacheend {</code></span>
<span class="codeline" id="line-3629"><code>		// Sched.goidgen is the last allocated id,</code></span>
<span class="codeline" id="line-3630"><code>		// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].</code></span>
<span class="codeline" id="line-3631"><code>		// At startup sched.goidgen=0, so main goroutine receives goid=1.</code></span>
<span class="codeline" id="line-3632"><code>		_p_.goidcache = atomic.Xadd64(&amp;sched.goidgen, _GoidCacheBatch)</code></span>
<span class="codeline" id="line-3633"><code>		_p_.goidcache -= _GoidCacheBatch - 1</code></span>
<span class="codeline" id="line-3634"><code>		_p_.goidcacheend = _p_.goidcache + _GoidCacheBatch</code></span>
<span class="codeline" id="line-3635"><code>	}</code></span>
<span class="codeline" id="line-3636"><code>	newg.goid = int64(_p_.goidcache)</code></span>
<span class="codeline" id="line-3637"><code>	_p_.goidcache++</code></span>
<span class="codeline" id="line-3638"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-3639"><code>		newg.racectx = racegostart(callerpc)</code></span>
<span class="codeline" id="line-3640"><code>	}</code></span>
<span class="codeline" id="line-3641"><code>	if trace.enabled {</code></span>
<span class="codeline" id="line-3642"><code>		traceGoCreate(newg, newg.startpc)</code></span>
<span class="codeline" id="line-3643"><code>	}</code></span>
<span class="codeline" id="line-3644"><code>	releasem(_g_.m)</code></span>
<span class="codeline" id="line-3645"><code></code></span>
<span class="codeline" id="line-3646"><code>	return newg</code></span>
<span class="codeline" id="line-3647"><code>}</code></span>
<span class="codeline" id="line-3648"><code></code></span>
<span class="codeline" id="line-3649"><code>// saveAncestors copies previous ancestors of the given caller g and</code></span>
<span class="codeline" id="line-3650"><code>// includes infor for the current caller into a new set of tracebacks for</code></span>
<span class="codeline" id="line-3651"><code>// a g being created.</code></span>
<span class="codeline" id="line-3652"><code>func saveAncestors(callergp *g) *[]ancestorInfo {</code></span>
<span class="codeline" id="line-3653"><code>	// Copy all prior info, except for the root goroutine (goid 0).</code></span>
<span class="codeline" id="line-3654"><code>	if debug.tracebackancestors &lt;= 0 || callergp.goid == 0 {</code></span>
<span class="codeline" id="line-3655"><code>		return nil</code></span>
<span class="codeline" id="line-3656"><code>	}</code></span>
<span class="codeline" id="line-3657"><code>	var callerAncestors []ancestorInfo</code></span>
<span class="codeline" id="line-3658"><code>	if callergp.ancestors != nil {</code></span>
<span class="codeline" id="line-3659"><code>		callerAncestors = *callergp.ancestors</code></span>
<span class="codeline" id="line-3660"><code>	}</code></span>
<span class="codeline" id="line-3661"><code>	n := int32(len(callerAncestors)) + 1</code></span>
<span class="codeline" id="line-3662"><code>	if n &gt; debug.tracebackancestors {</code></span>
<span class="codeline" id="line-3663"><code>		n = debug.tracebackancestors</code></span>
<span class="codeline" id="line-3664"><code>	}</code></span>
<span class="codeline" id="line-3665"><code>	ancestors := make([]ancestorInfo, n)</code></span>
<span class="codeline" id="line-3666"><code>	copy(ancestors[1:], callerAncestors)</code></span>
<span class="codeline" id="line-3667"><code></code></span>
<span class="codeline" id="line-3668"><code>	var pcs [_TracebackMaxFrames]uintptr</code></span>
<span class="codeline" id="line-3669"><code>	npcs := gcallers(callergp, 0, pcs[:])</code></span>
<span class="codeline" id="line-3670"><code>	ipcs := make([]uintptr, npcs)</code></span>
<span class="codeline" id="line-3671"><code>	copy(ipcs, pcs[:])</code></span>
<span class="codeline" id="line-3672"><code>	ancestors[0] = ancestorInfo{</code></span>
<span class="codeline" id="line-3673"><code>		pcs:  ipcs,</code></span>
<span class="codeline" id="line-3674"><code>		goid: callergp.goid,</code></span>
<span class="codeline" id="line-3675"><code>		gopc: callergp.gopc,</code></span>
<span class="codeline" id="line-3676"><code>	}</code></span>
<span class="codeline" id="line-3677"><code></code></span>
<span class="codeline" id="line-3678"><code>	ancestorsp := new([]ancestorInfo)</code></span>
<span class="codeline" id="line-3679"><code>	*ancestorsp = ancestors</code></span>
<span class="codeline" id="line-3680"><code>	return ancestorsp</code></span>
<span class="codeline" id="line-3681"><code>}</code></span>
<span class="codeline" id="line-3682"><code></code></span>
<span class="codeline" id="line-3683"><code>// Put on gfree list.</code></span>
<span class="codeline" id="line-3684"><code>// If local list is too long, transfer a batch to the global list.</code></span>
<span class="codeline" id="line-3685"><code>func gfput(_p_ *p, gp *g) {</code></span>
<span class="codeline" id="line-3686"><code>	if readgstatus(gp) != _Gdead {</code></span>
<span class="codeline" id="line-3687"><code>		throw("gfput: bad status (not Gdead)")</code></span>
<span class="codeline" id="line-3688"><code>	}</code></span>
<span class="codeline" id="line-3689"><code></code></span>
<span class="codeline" id="line-3690"><code>	stksize := gp.stack.hi - gp.stack.lo</code></span>
<span class="codeline" id="line-3691"><code></code></span>
<span class="codeline" id="line-3692"><code>	if stksize != _FixedStack {</code></span>
<span class="codeline" id="line-3693"><code>		// non-standard stack size - free it.</code></span>
<span class="codeline" id="line-3694"><code>		stackfree(gp.stack)</code></span>
<span class="codeline" id="line-3695"><code>		gp.stack.lo = 0</code></span>
<span class="codeline" id="line-3696"><code>		gp.stack.hi = 0</code></span>
<span class="codeline" id="line-3697"><code>		gp.stackguard0 = 0</code></span>
<span class="codeline" id="line-3698"><code>	}</code></span>
<span class="codeline" id="line-3699"><code></code></span>
<span class="codeline" id="line-3700"><code>	_p_.gFree.push(gp)</code></span>
<span class="codeline" id="line-3701"><code>	_p_.gFree.n++</code></span>
<span class="codeline" id="line-3702"><code>	if _p_.gFree.n &gt;= 64 {</code></span>
<span class="codeline" id="line-3703"><code>		lock(&amp;sched.gFree.lock)</code></span>
<span class="codeline" id="line-3704"><code>		for _p_.gFree.n &gt;= 32 {</code></span>
<span class="codeline" id="line-3705"><code>			_p_.gFree.n--</code></span>
<span class="codeline" id="line-3706"><code>			gp = _p_.gFree.pop()</code></span>
<span class="codeline" id="line-3707"><code>			if gp.stack.lo == 0 {</code></span>
<span class="codeline" id="line-3708"><code>				sched.gFree.noStack.push(gp)</code></span>
<span class="codeline" id="line-3709"><code>			} else {</code></span>
<span class="codeline" id="line-3710"><code>				sched.gFree.stack.push(gp)</code></span>
<span class="codeline" id="line-3711"><code>			}</code></span>
<span class="codeline" id="line-3712"><code>			sched.gFree.n++</code></span>
<span class="codeline" id="line-3713"><code>		}</code></span>
<span class="codeline" id="line-3714"><code>		unlock(&amp;sched.gFree.lock)</code></span>
<span class="codeline" id="line-3715"><code>	}</code></span>
<span class="codeline" id="line-3716"><code>}</code></span>
<span class="codeline" id="line-3717"><code></code></span>
<span class="codeline" id="line-3718"><code>// Get from gfree list.</code></span>
<span class="codeline" id="line-3719"><code>// If local list is empty, grab a batch from global list.</code></span>
<span class="codeline" id="line-3720"><code>func gfget(_p_ *p) *g {</code></span>
<span class="codeline" id="line-3721"><code>retry:</code></span>
<span class="codeline" id="line-3722"><code>	if _p_.gFree.empty() &amp;&amp; (!sched.gFree.stack.empty() || !sched.gFree.noStack.empty()) {</code></span>
<span class="codeline" id="line-3723"><code>		lock(&amp;sched.gFree.lock)</code></span>
<span class="codeline" id="line-3724"><code>		// Move a batch of free Gs to the P.</code></span>
<span class="codeline" id="line-3725"><code>		for _p_.gFree.n &lt; 32 {</code></span>
<span class="codeline" id="line-3726"><code>			// Prefer Gs with stacks.</code></span>
<span class="codeline" id="line-3727"><code>			gp := sched.gFree.stack.pop()</code></span>
<span class="codeline" id="line-3728"><code>			if gp == nil {</code></span>
<span class="codeline" id="line-3729"><code>				gp = sched.gFree.noStack.pop()</code></span>
<span class="codeline" id="line-3730"><code>				if gp == nil {</code></span>
<span class="codeline" id="line-3731"><code>					break</code></span>
<span class="codeline" id="line-3732"><code>				}</code></span>
<span class="codeline" id="line-3733"><code>			}</code></span>
<span class="codeline" id="line-3734"><code>			sched.gFree.n--</code></span>
<span class="codeline" id="line-3735"><code>			_p_.gFree.push(gp)</code></span>
<span class="codeline" id="line-3736"><code>			_p_.gFree.n++</code></span>
<span class="codeline" id="line-3737"><code>		}</code></span>
<span class="codeline" id="line-3738"><code>		unlock(&amp;sched.gFree.lock)</code></span>
<span class="codeline" id="line-3739"><code>		goto retry</code></span>
<span class="codeline" id="line-3740"><code>	}</code></span>
<span class="codeline" id="line-3741"><code>	gp := _p_.gFree.pop()</code></span>
<span class="codeline" id="line-3742"><code>	if gp == nil {</code></span>
<span class="codeline" id="line-3743"><code>		return nil</code></span>
<span class="codeline" id="line-3744"><code>	}</code></span>
<span class="codeline" id="line-3745"><code>	_p_.gFree.n--</code></span>
<span class="codeline" id="line-3746"><code>	if gp.stack.lo == 0 {</code></span>
<span class="codeline" id="line-3747"><code>		// Stack was deallocated in gfput. Allocate a new one.</code></span>
<span class="codeline" id="line-3748"><code>		systemstack(func() {</code></span>
<span class="codeline" id="line-3749"><code>			gp.stack = stackalloc(_FixedStack)</code></span>
<span class="codeline" id="line-3750"><code>		})</code></span>
<span class="codeline" id="line-3751"><code>		gp.stackguard0 = gp.stack.lo + _StackGuard</code></span>
<span class="codeline" id="line-3752"><code>	} else {</code></span>
<span class="codeline" id="line-3753"><code>		if raceenabled {</code></span>
<span class="codeline" id="line-3754"><code>			racemalloc(unsafe.Pointer(gp.stack.lo), gp.stack.hi-gp.stack.lo)</code></span>
<span class="codeline" id="line-3755"><code>		}</code></span>
<span class="codeline" id="line-3756"><code>		if msanenabled {</code></span>
<span class="codeline" id="line-3757"><code>			msanmalloc(unsafe.Pointer(gp.stack.lo), gp.stack.hi-gp.stack.lo)</code></span>
<span class="codeline" id="line-3758"><code>		}</code></span>
<span class="codeline" id="line-3759"><code>	}</code></span>
<span class="codeline" id="line-3760"><code>	return gp</code></span>
<span class="codeline" id="line-3761"><code>}</code></span>
<span class="codeline" id="line-3762"><code></code></span>
<span class="codeline" id="line-3763"><code>// Purge all cached G's from gfree list to the global list.</code></span>
<span class="codeline" id="line-3764"><code>func gfpurge(_p_ *p) {</code></span>
<span class="codeline" id="line-3765"><code>	lock(&amp;sched.gFree.lock)</code></span>
<span class="codeline" id="line-3766"><code>	for !_p_.gFree.empty() {</code></span>
<span class="codeline" id="line-3767"><code>		gp := _p_.gFree.pop()</code></span>
<span class="codeline" id="line-3768"><code>		_p_.gFree.n--</code></span>
<span class="codeline" id="line-3769"><code>		if gp.stack.lo == 0 {</code></span>
<span class="codeline" id="line-3770"><code>			sched.gFree.noStack.push(gp)</code></span>
<span class="codeline" id="line-3771"><code>		} else {</code></span>
<span class="codeline" id="line-3772"><code>			sched.gFree.stack.push(gp)</code></span>
<span class="codeline" id="line-3773"><code>		}</code></span>
<span class="codeline" id="line-3774"><code>		sched.gFree.n++</code></span>
<span class="codeline" id="line-3775"><code>	}</code></span>
<span class="codeline" id="line-3776"><code>	unlock(&amp;sched.gFree.lock)</code></span>
<span class="codeline" id="line-3777"><code>}</code></span>
<span class="codeline" id="line-3778"><code></code></span>
<span class="codeline" id="line-3779"><code>// Breakpoint executes a breakpoint trap.</code></span>
<span class="codeline" id="line-3780"><code>func Breakpoint() {</code></span>
<span class="codeline" id="line-3781"><code>	breakpoint()</code></span>
<span class="codeline" id="line-3782"><code>}</code></span>
<span class="codeline" id="line-3783"><code></code></span>
<span class="codeline" id="line-3784"><code>// dolockOSThread is called by LockOSThread and lockOSThread below</code></span>
<span class="codeline" id="line-3785"><code>// after they modify m.locked. Do not allow preemption during this call,</code></span>
<span class="codeline" id="line-3786"><code>// or else the m might be different in this function than in the caller.</code></span>
<span class="codeline" id="line-3787"><code>//go:nosplit</code></span>
<span class="codeline" id="line-3788"><code>func dolockOSThread() {</code></span>
<span class="codeline" id="line-3789"><code>	if GOARCH == "wasm" {</code></span>
<span class="codeline" id="line-3790"><code>		return // no threads on wasm yet</code></span>
<span class="codeline" id="line-3791"><code>	}</code></span>
<span class="codeline" id="line-3792"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-3793"><code>	_g_.m.lockedg.set(_g_)</code></span>
<span class="codeline" id="line-3794"><code>	_g_.lockedm.set(_g_.m)</code></span>
<span class="codeline" id="line-3795"><code>}</code></span>
<span class="codeline" id="line-3796"><code></code></span>
<span class="codeline" id="line-3797"><code>//go:nosplit</code></span>
<span class="codeline" id="line-3798"><code></code></span>
<span class="codeline" id="line-3799"><code>// LockOSThread wires the calling goroutine to its current operating system thread.</code></span>
<span class="codeline" id="line-3800"><code>// The calling goroutine will always execute in that thread,</code></span>
<span class="codeline" id="line-3801"><code>// and no other goroutine will execute in it,</code></span>
<span class="codeline" id="line-3802"><code>// until the calling goroutine has made as many calls to</code></span>
<span class="codeline" id="line-3803"><code>// UnlockOSThread as to LockOSThread.</code></span>
<span class="codeline" id="line-3804"><code>// If the calling goroutine exits without unlocking the thread,</code></span>
<span class="codeline" id="line-3805"><code>// the thread will be terminated.</code></span>
<span class="codeline" id="line-3806"><code>//</code></span>
<span class="codeline" id="line-3807"><code>// All init functions are run on the startup thread. Calling LockOSThread</code></span>
<span class="codeline" id="line-3808"><code>// from an init function will cause the main function to be invoked on</code></span>
<span class="codeline" id="line-3809"><code>// that thread.</code></span>
<span class="codeline" id="line-3810"><code>//</code></span>
<span class="codeline" id="line-3811"><code>// A goroutine should call LockOSThread before calling OS services or</code></span>
<span class="codeline" id="line-3812"><code>// non-Go library functions that depend on per-thread state.</code></span>
<span class="codeline" id="line-3813"><code>func LockOSThread() {</code></span>
<span class="codeline" id="line-3814"><code>	if atomic.Load(&amp;newmHandoff.haveTemplateThread) == 0 &amp;&amp; GOOS != "plan9" {</code></span>
<span class="codeline" id="line-3815"><code>		// If we need to start a new thread from the locked</code></span>
<span class="codeline" id="line-3816"><code>		// thread, we need the template thread. Start it now</code></span>
<span class="codeline" id="line-3817"><code>		// while we're in a known-good state.</code></span>
<span class="codeline" id="line-3818"><code>		startTemplateThread()</code></span>
<span class="codeline" id="line-3819"><code>	}</code></span>
<span class="codeline" id="line-3820"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-3821"><code>	_g_.m.lockedExt++</code></span>
<span class="codeline" id="line-3822"><code>	if _g_.m.lockedExt == 0 {</code></span>
<span class="codeline" id="line-3823"><code>		_g_.m.lockedExt--</code></span>
<span class="codeline" id="line-3824"><code>		panic("LockOSThread nesting overflow")</code></span>
<span class="codeline" id="line-3825"><code>	}</code></span>
<span class="codeline" id="line-3826"><code>	dolockOSThread()</code></span>
<span class="codeline" id="line-3827"><code>}</code></span>
<span class="codeline" id="line-3828"><code></code></span>
<span class="codeline" id="line-3829"><code>//go:nosplit</code></span>
<span class="codeline" id="line-3830"><code>func lockOSThread() {</code></span>
<span class="codeline" id="line-3831"><code>	getg().m.lockedInt++</code></span>
<span class="codeline" id="line-3832"><code>	dolockOSThread()</code></span>
<span class="codeline" id="line-3833"><code>}</code></span>
<span class="codeline" id="line-3834"><code></code></span>
<span class="codeline" id="line-3835"><code>// dounlockOSThread is called by UnlockOSThread and unlockOSThread below</code></span>
<span class="codeline" id="line-3836"><code>// after they update m-&gt;locked. Do not allow preemption during this call,</code></span>
<span class="codeline" id="line-3837"><code>// or else the m might be in different in this function than in the caller.</code></span>
<span class="codeline" id="line-3838"><code>//go:nosplit</code></span>
<span class="codeline" id="line-3839"><code>func dounlockOSThread() {</code></span>
<span class="codeline" id="line-3840"><code>	if GOARCH == "wasm" {</code></span>
<span class="codeline" id="line-3841"><code>		return // no threads on wasm yet</code></span>
<span class="codeline" id="line-3842"><code>	}</code></span>
<span class="codeline" id="line-3843"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-3844"><code>	if _g_.m.lockedInt != 0 || _g_.m.lockedExt != 0 {</code></span>
<span class="codeline" id="line-3845"><code>		return</code></span>
<span class="codeline" id="line-3846"><code>	}</code></span>
<span class="codeline" id="line-3847"><code>	_g_.m.lockedg = 0</code></span>
<span class="codeline" id="line-3848"><code>	_g_.lockedm = 0</code></span>
<span class="codeline" id="line-3849"><code>}</code></span>
<span class="codeline" id="line-3850"><code></code></span>
<span class="codeline" id="line-3851"><code>//go:nosplit</code></span>
<span class="codeline" id="line-3852"><code></code></span>
<span class="codeline" id="line-3853"><code>// UnlockOSThread undoes an earlier call to LockOSThread.</code></span>
<span class="codeline" id="line-3854"><code>// If this drops the number of active LockOSThread calls on the</code></span>
<span class="codeline" id="line-3855"><code>// calling goroutine to zero, it unwires the calling goroutine from</code></span>
<span class="codeline" id="line-3856"><code>// its fixed operating system thread.</code></span>
<span class="codeline" id="line-3857"><code>// If there are no active LockOSThread calls, this is a no-op.</code></span>
<span class="codeline" id="line-3858"><code>//</code></span>
<span class="codeline" id="line-3859"><code>// Before calling UnlockOSThread, the caller must ensure that the OS</code></span>
<span class="codeline" id="line-3860"><code>// thread is suitable for running other goroutines. If the caller made</code></span>
<span class="codeline" id="line-3861"><code>// any permanent changes to the state of the thread that would affect</code></span>
<span class="codeline" id="line-3862"><code>// other goroutines, it should not call this function and thus leave</code></span>
<span class="codeline" id="line-3863"><code>// the goroutine locked to the OS thread until the goroutine (and</code></span>
<span class="codeline" id="line-3864"><code>// hence the thread) exits.</code></span>
<span class="codeline" id="line-3865"><code>func UnlockOSThread() {</code></span>
<span class="codeline" id="line-3866"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-3867"><code>	if _g_.m.lockedExt == 0 {</code></span>
<span class="codeline" id="line-3868"><code>		return</code></span>
<span class="codeline" id="line-3869"><code>	}</code></span>
<span class="codeline" id="line-3870"><code>	_g_.m.lockedExt--</code></span>
<span class="codeline" id="line-3871"><code>	dounlockOSThread()</code></span>
<span class="codeline" id="line-3872"><code>}</code></span>
<span class="codeline" id="line-3873"><code></code></span>
<span class="codeline" id="line-3874"><code>//go:nosplit</code></span>
<span class="codeline" id="line-3875"><code>func unlockOSThread() {</code></span>
<span class="codeline" id="line-3876"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-3877"><code>	if _g_.m.lockedInt == 0 {</code></span>
<span class="codeline" id="line-3878"><code>		systemstack(badunlockosthread)</code></span>
<span class="codeline" id="line-3879"><code>	}</code></span>
<span class="codeline" id="line-3880"><code>	_g_.m.lockedInt--</code></span>
<span class="codeline" id="line-3881"><code>	dounlockOSThread()</code></span>
<span class="codeline" id="line-3882"><code>}</code></span>
<span class="codeline" id="line-3883"><code></code></span>
<span class="codeline" id="line-3884"><code>func badunlockosthread() {</code></span>
<span class="codeline" id="line-3885"><code>	throw("runtime: internal error: misuse of lockOSThread/unlockOSThread")</code></span>
<span class="codeline" id="line-3886"><code>}</code></span>
<span class="codeline" id="line-3887"><code></code></span>
<span class="codeline" id="line-3888"><code>func gcount() int32 {</code></span>
<span class="codeline" id="line-3889"><code>	n := int32(allglen) - sched.gFree.n - int32(atomic.Load(&amp;sched.ngsys))</code></span>
<span class="codeline" id="line-3890"><code>	for _, _p_ := range allp {</code></span>
<span class="codeline" id="line-3891"><code>		n -= _p_.gFree.n</code></span>
<span class="codeline" id="line-3892"><code>	}</code></span>
<span class="codeline" id="line-3893"><code></code></span>
<span class="codeline" id="line-3894"><code>	// All these variables can be changed concurrently, so the result can be inconsistent.</code></span>
<span class="codeline" id="line-3895"><code>	// But at least the current goroutine is running.</code></span>
<span class="codeline" id="line-3896"><code>	if n &lt; 1 {</code></span>
<span class="codeline" id="line-3897"><code>		n = 1</code></span>
<span class="codeline" id="line-3898"><code>	}</code></span>
<span class="codeline" id="line-3899"><code>	return n</code></span>
<span class="codeline" id="line-3900"><code>}</code></span>
<span class="codeline" id="line-3901"><code></code></span>
<span class="codeline" id="line-3902"><code>func mcount() int32 {</code></span>
<span class="codeline" id="line-3903"><code>	return int32(sched.mnext - sched.nmfreed)</code></span>
<span class="codeline" id="line-3904"><code>}</code></span>
<span class="codeline" id="line-3905"><code></code></span>
<span class="codeline" id="line-3906"><code>var prof struct {</code></span>
<span class="codeline" id="line-3907"><code>	signalLock uint32</code></span>
<span class="codeline" id="line-3908"><code>	hz         int32</code></span>
<span class="codeline" id="line-3909"><code>}</code></span>
<span class="codeline" id="line-3910"><code></code></span>
<span class="codeline" id="line-3911"><code>func _System()                    { _System() }</code></span>
<span class="codeline" id="line-3912"><code>func _ExternalCode()              { _ExternalCode() }</code></span>
<span class="codeline" id="line-3913"><code>func _LostExternalCode()          { _LostExternalCode() }</code></span>
<span class="codeline" id="line-3914"><code>func _GC()                        { _GC() }</code></span>
<span class="codeline" id="line-3915"><code>func _LostSIGPROFDuringAtomic64() { _LostSIGPROFDuringAtomic64() }</code></span>
<span class="codeline" id="line-3916"><code>func _VDSO()                      { _VDSO() }</code></span>
<span class="codeline" id="line-3917"><code></code></span>
<span class="codeline" id="line-3918"><code>// Called if we receive a SIGPROF signal.</code></span>
<span class="codeline" id="line-3919"><code>// Called by the signal handler, may run during STW.</code></span>
<span class="codeline" id="line-3920"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-3921"><code>func sigprof(pc, sp, lr uintptr, gp *g, mp *m) {</code></span>
<span class="codeline" id="line-3922"><code>	if prof.hz == 0 {</code></span>
<span class="codeline" id="line-3923"><code>		return</code></span>
<span class="codeline" id="line-3924"><code>	}</code></span>
<span class="codeline" id="line-3925"><code></code></span>
<span class="codeline" id="line-3926"><code>	// On mips{,le}, 64bit atomics are emulated with spinlocks, in</code></span>
<span class="codeline" id="line-3927"><code>	// runtime/internal/atomic. If SIGPROF arrives while the program is inside</code></span>
<span class="codeline" id="line-3928"><code>	// the critical section, it creates a deadlock (when writing the sample).</code></span>
<span class="codeline" id="line-3929"><code>	// As a workaround, create a counter of SIGPROFs while in critical section</code></span>
<span class="codeline" id="line-3930"><code>	// to store the count, and pass it to sigprof.add() later when SIGPROF is</code></span>
<span class="codeline" id="line-3931"><code>	// received from somewhere else (with _LostSIGPROFDuringAtomic64 as pc).</code></span>
<span class="codeline" id="line-3932"><code>	if GOARCH == "mips" || GOARCH == "mipsle" || GOARCH == "arm" {</code></span>
<span class="codeline" id="line-3933"><code>		if f := findfunc(pc); f.valid() {</code></span>
<span class="codeline" id="line-3934"><code>			if hasPrefix(funcname(f), "runtime/internal/atomic") {</code></span>
<span class="codeline" id="line-3935"><code>				cpuprof.lostAtomic++</code></span>
<span class="codeline" id="line-3936"><code>				return</code></span>
<span class="codeline" id="line-3937"><code>			}</code></span>
<span class="codeline" id="line-3938"><code>		}</code></span>
<span class="codeline" id="line-3939"><code>	}</code></span>
<span class="codeline" id="line-3940"><code></code></span>
<span class="codeline" id="line-3941"><code>	// Profiling runs concurrently with GC, so it must not allocate.</code></span>
<span class="codeline" id="line-3942"><code>	// Set a trap in case the code does allocate.</code></span>
<span class="codeline" id="line-3943"><code>	// Note that on windows, one thread takes profiles of all the</code></span>
<span class="codeline" id="line-3944"><code>	// other threads, so mp is usually not getg().m.</code></span>
<span class="codeline" id="line-3945"><code>	// In fact mp may not even be stopped.</code></span>
<span class="codeline" id="line-3946"><code>	// See golang.org/issue/17165.</code></span>
<span class="codeline" id="line-3947"><code>	getg().m.mallocing++</code></span>
<span class="codeline" id="line-3948"><code></code></span>
<span class="codeline" id="line-3949"><code>	// Define that a "user g" is a user-created goroutine, and a "system g"</code></span>
<span class="codeline" id="line-3950"><code>	// is one that is m-&gt;g0 or m-&gt;gsignal.</code></span>
<span class="codeline" id="line-3951"><code>	//</code></span>
<span class="codeline" id="line-3952"><code>	// We might be interrupted for profiling halfway through a</code></span>
<span class="codeline" id="line-3953"><code>	// goroutine switch. The switch involves updating three (or four) values:</code></span>
<span class="codeline" id="line-3954"><code>	// g, PC, SP, and (on arm) LR. The PC must be the last to be updated,</code></span>
<span class="codeline" id="line-3955"><code>	// because once it gets updated the new g is running.</code></span>
<span class="codeline" id="line-3956"><code>	//</code></span>
<span class="codeline" id="line-3957"><code>	// When switching from a user g to a system g, LR is not considered live,</code></span>
<span class="codeline" id="line-3958"><code>	// so the update only affects g, SP, and PC. Since PC must be last, there</code></span>
<span class="codeline" id="line-3959"><code>	// the possible partial transitions in ordinary execution are (1) g alone is updated,</code></span>
<span class="codeline" id="line-3960"><code>	// (2) both g and SP are updated, and (3) SP alone is updated.</code></span>
<span class="codeline" id="line-3961"><code>	// If SP or g alone is updated, we can detect the partial transition by checking</code></span>
<span class="codeline" id="line-3962"><code>	// whether the SP is within g's stack bounds. (We could also require that SP</code></span>
<span class="codeline" id="line-3963"><code>	// be changed only after g, but the stack bounds check is needed by other</code></span>
<span class="codeline" id="line-3964"><code>	// cases, so there is no need to impose an additional requirement.)</code></span>
<span class="codeline" id="line-3965"><code>	//</code></span>
<span class="codeline" id="line-3966"><code>	// There is one exceptional transition to a system g, not in ordinary execution.</code></span>
<span class="codeline" id="line-3967"><code>	// When a signal arrives, the operating system starts the signal handler running</code></span>
<span class="codeline" id="line-3968"><code>	// with an updated PC and SP. The g is updated last, at the beginning of the</code></span>
<span class="codeline" id="line-3969"><code>	// handler. There are two reasons this is okay. First, until g is updated the</code></span>
<span class="codeline" id="line-3970"><code>	// g and SP do not match, so the stack bounds check detects the partial transition.</code></span>
<span class="codeline" id="line-3971"><code>	// Second, signal handlers currently run with signals disabled, so a profiling</code></span>
<span class="codeline" id="line-3972"><code>	// signal cannot arrive during the handler.</code></span>
<span class="codeline" id="line-3973"><code>	//</code></span>
<span class="codeline" id="line-3974"><code>	// When switching from a system g to a user g, there are three possibilities.</code></span>
<span class="codeline" id="line-3975"><code>	//</code></span>
<span class="codeline" id="line-3976"><code>	// First, it may be that the g switch has no PC update, because the SP</code></span>
<span class="codeline" id="line-3977"><code>	// either corresponds to a user g throughout (as in asmcgocall)</code></span>
<span class="codeline" id="line-3978"><code>	// or because it has been arranged to look like a user g frame</code></span>
<span class="codeline" id="line-3979"><code>	// (as in cgocallback_gofunc). In this case, since the entire</code></span>
<span class="codeline" id="line-3980"><code>	// transition is a g+SP update, a partial transition updating just one of</code></span>
<span class="codeline" id="line-3981"><code>	// those will be detected by the stack bounds check.</code></span>
<span class="codeline" id="line-3982"><code>	//</code></span>
<span class="codeline" id="line-3983"><code>	// Second, when returning from a signal handler, the PC and SP updates</code></span>
<span class="codeline" id="line-3984"><code>	// are performed by the operating system in an atomic update, so the g</code></span>
<span class="codeline" id="line-3985"><code>	// update must be done before them. The stack bounds check detects</code></span>
<span class="codeline" id="line-3986"><code>	// the partial transition here, and (again) signal handlers run with signals</code></span>
<span class="codeline" id="line-3987"><code>	// disabled, so a profiling signal cannot arrive then anyway.</code></span>
<span class="codeline" id="line-3988"><code>	//</code></span>
<span class="codeline" id="line-3989"><code>	// Third, the common case: it may be that the switch updates g, SP, and PC</code></span>
<span class="codeline" id="line-3990"><code>	// separately. If the PC is within any of the functions that does this,</code></span>
<span class="codeline" id="line-3991"><code>	// we don't ask for a traceback. C.F. the function setsSP for more about this.</code></span>
<span class="codeline" id="line-3992"><code>	//</code></span>
<span class="codeline" id="line-3993"><code>	// There is another apparently viable approach, recorded here in case</code></span>
<span class="codeline" id="line-3994"><code>	// the "PC within setsSP function" check turns out not to be usable.</code></span>
<span class="codeline" id="line-3995"><code>	// It would be possible to delay the update of either g or SP until immediately</code></span>
<span class="codeline" id="line-3996"><code>	// before the PC update instruction. Then, because of the stack bounds check,</code></span>
<span class="codeline" id="line-3997"><code>	// the only problematic interrupt point is just before that PC update instruction,</code></span>
<span class="codeline" id="line-3998"><code>	// and the sigprof handler can detect that instruction and simulate stepping past</code></span>
<span class="codeline" id="line-3999"><code>	// it in order to reach a consistent state. On ARM, the update of g must be made</code></span>
<span class="codeline" id="line-4000"><code>	// in two places (in R10 and also in a TLS slot), so the delayed update would</code></span>
<span class="codeline" id="line-4001"><code>	// need to be the SP update. The sigprof handler must read the instruction at</code></span>
<span class="codeline" id="line-4002"><code>	// the current PC and if it was the known instruction (for example, JMP BX or</code></span>
<span class="codeline" id="line-4003"><code>	// MOV R2, PC), use that other register in place of the PC value.</code></span>
<span class="codeline" id="line-4004"><code>	// The biggest drawback to this solution is that it requires that we can tell</code></span>
<span class="codeline" id="line-4005"><code>	// whether it's safe to read from the memory pointed at by PC.</code></span>
<span class="codeline" id="line-4006"><code>	// In a correct program, we can test PC == nil and otherwise read,</code></span>
<span class="codeline" id="line-4007"><code>	// but if a profiling signal happens at the instant that a program executes</code></span>
<span class="codeline" id="line-4008"><code>	// a bad jump (before the program manages to handle the resulting fault)</code></span>
<span class="codeline" id="line-4009"><code>	// the profiling handler could fault trying to read nonexistent memory.</code></span>
<span class="codeline" id="line-4010"><code>	//</code></span>
<span class="codeline" id="line-4011"><code>	// To recap, there are no constraints on the assembly being used for the</code></span>
<span class="codeline" id="line-4012"><code>	// transition. We simply require that g and SP match and that the PC is not</code></span>
<span class="codeline" id="line-4013"><code>	// in gogo.</code></span>
<span class="codeline" id="line-4014"><code>	traceback := true</code></span>
<span class="codeline" id="line-4015"><code>	if gp == nil || sp &lt; gp.stack.lo || gp.stack.hi &lt; sp || setsSP(pc) || (mp != nil &amp;&amp; mp.vdsoSP != 0) {</code></span>
<span class="codeline" id="line-4016"><code>		traceback = false</code></span>
<span class="codeline" id="line-4017"><code>	}</code></span>
<span class="codeline" id="line-4018"><code>	var stk [maxCPUProfStack]uintptr</code></span>
<span class="codeline" id="line-4019"><code>	n := 0</code></span>
<span class="codeline" id="line-4020"><code>	if mp.ncgo &gt; 0 &amp;&amp; mp.curg != nil &amp;&amp; mp.curg.syscallpc != 0 &amp;&amp; mp.curg.syscallsp != 0 {</code></span>
<span class="codeline" id="line-4021"><code>		cgoOff := 0</code></span>
<span class="codeline" id="line-4022"><code>		// Check cgoCallersUse to make sure that we are not</code></span>
<span class="codeline" id="line-4023"><code>		// interrupting other code that is fiddling with</code></span>
<span class="codeline" id="line-4024"><code>		// cgoCallers.  We are running in a signal handler</code></span>
<span class="codeline" id="line-4025"><code>		// with all signals blocked, so we don't have to worry</code></span>
<span class="codeline" id="line-4026"><code>		// about any other code interrupting us.</code></span>
<span class="codeline" id="line-4027"><code>		if atomic.Load(&amp;mp.cgoCallersUse) == 0 &amp;&amp; mp.cgoCallers != nil &amp;&amp; mp.cgoCallers[0] != 0 {</code></span>
<span class="codeline" id="line-4028"><code>			for cgoOff &lt; len(mp.cgoCallers) &amp;&amp; mp.cgoCallers[cgoOff] != 0 {</code></span>
<span class="codeline" id="line-4029"><code>				cgoOff++</code></span>
<span class="codeline" id="line-4030"><code>			}</code></span>
<span class="codeline" id="line-4031"><code>			copy(stk[:], mp.cgoCallers[:cgoOff])</code></span>
<span class="codeline" id="line-4032"><code>			mp.cgoCallers[0] = 0</code></span>
<span class="codeline" id="line-4033"><code>		}</code></span>
<span class="codeline" id="line-4034"><code></code></span>
<span class="codeline" id="line-4035"><code>		// Collect Go stack that leads to the cgo call.</code></span>
<span class="codeline" id="line-4036"><code>		n = gentraceback(mp.curg.syscallpc, mp.curg.syscallsp, 0, mp.curg, 0, &amp;stk[cgoOff], len(stk)-cgoOff, nil, nil, 0)</code></span>
<span class="codeline" id="line-4037"><code>		if n &gt; 0 {</code></span>
<span class="codeline" id="line-4038"><code>			n += cgoOff</code></span>
<span class="codeline" id="line-4039"><code>		}</code></span>
<span class="codeline" id="line-4040"><code>	} else if traceback {</code></span>
<span class="codeline" id="line-4041"><code>		n = gentraceback(pc, sp, lr, gp, 0, &amp;stk[0], len(stk), nil, nil, _TraceTrap|_TraceJumpStack)</code></span>
<span class="codeline" id="line-4042"><code>	}</code></span>
<span class="codeline" id="line-4043"><code></code></span>
<span class="codeline" id="line-4044"><code>	if n &lt;= 0 {</code></span>
<span class="codeline" id="line-4045"><code>		// Normal traceback is impossible or has failed.</code></span>
<span class="codeline" id="line-4046"><code>		// See if it falls into several common cases.</code></span>
<span class="codeline" id="line-4047"><code>		n = 0</code></span>
<span class="codeline" id="line-4048"><code>		if (GOOS == "windows" || GOOS == "solaris" || GOOS == "illumos" || GOOS == "darwin" || GOOS == "aix") &amp;&amp; mp.libcallg != 0 &amp;&amp; mp.libcallpc != 0 &amp;&amp; mp.libcallsp != 0 {</code></span>
<span class="codeline" id="line-4049"><code>			// Libcall, i.e. runtime syscall on windows.</code></span>
<span class="codeline" id="line-4050"><code>			// Collect Go stack that leads to the call.</code></span>
<span class="codeline" id="line-4051"><code>			n = gentraceback(mp.libcallpc, mp.libcallsp, 0, mp.libcallg.ptr(), 0, &amp;stk[0], len(stk), nil, nil, 0)</code></span>
<span class="codeline" id="line-4052"><code>		}</code></span>
<span class="codeline" id="line-4053"><code>		if n == 0 &amp;&amp; mp != nil &amp;&amp; mp.vdsoSP != 0 {</code></span>
<span class="codeline" id="line-4054"><code>			n = gentraceback(mp.vdsoPC, mp.vdsoSP, 0, gp, 0, &amp;stk[0], len(stk), nil, nil, _TraceTrap|_TraceJumpStack)</code></span>
<span class="codeline" id="line-4055"><code>		}</code></span>
<span class="codeline" id="line-4056"><code>		if n == 0 {</code></span>
<span class="codeline" id="line-4057"><code>			// If all of the above has failed, account it against abstract "System" or "GC".</code></span>
<span class="codeline" id="line-4058"><code>			n = 2</code></span>
<span class="codeline" id="line-4059"><code>			if inVDSOPage(pc) {</code></span>
<span class="codeline" id="line-4060"><code>				pc = funcPC(_VDSO) + sys.PCQuantum</code></span>
<span class="codeline" id="line-4061"><code>			} else if pc &gt; firstmoduledata.etext {</code></span>
<span class="codeline" id="line-4062"><code>				// "ExternalCode" is better than "etext".</code></span>
<span class="codeline" id="line-4063"><code>				pc = funcPC(_ExternalCode) + sys.PCQuantum</code></span>
<span class="codeline" id="line-4064"><code>			}</code></span>
<span class="codeline" id="line-4065"><code>			stk[0] = pc</code></span>
<span class="codeline" id="line-4066"><code>			if mp.preemptoff != "" {</code></span>
<span class="codeline" id="line-4067"><code>				stk[1] = funcPC(_GC) + sys.PCQuantum</code></span>
<span class="codeline" id="line-4068"><code>			} else {</code></span>
<span class="codeline" id="line-4069"><code>				stk[1] = funcPC(_System) + sys.PCQuantum</code></span>
<span class="codeline" id="line-4070"><code>			}</code></span>
<span class="codeline" id="line-4071"><code>		}</code></span>
<span class="codeline" id="line-4072"><code>	}</code></span>
<span class="codeline" id="line-4073"><code></code></span>
<span class="codeline" id="line-4074"><code>	if prof.hz != 0 {</code></span>
<span class="codeline" id="line-4075"><code>		cpuprof.add(gp, stk[:n])</code></span>
<span class="codeline" id="line-4076"><code>	}</code></span>
<span class="codeline" id="line-4077"><code>	getg().m.mallocing--</code></span>
<span class="codeline" id="line-4078"><code>}</code></span>
<span class="codeline" id="line-4079"><code></code></span>
<span class="codeline" id="line-4080"><code>// If the signal handler receives a SIGPROF signal on a non-Go thread,</code></span>
<span class="codeline" id="line-4081"><code>// it tries to collect a traceback into sigprofCallers.</code></span>
<span class="codeline" id="line-4082"><code>// sigprofCallersUse is set to non-zero while sigprofCallers holds a traceback.</code></span>
<span class="codeline" id="line-4083"><code>var sigprofCallers cgoCallers</code></span>
<span class="codeline" id="line-4084"><code>var sigprofCallersUse uint32</code></span>
<span class="codeline" id="line-4085"><code></code></span>
<span class="codeline" id="line-4086"><code>// sigprofNonGo is called if we receive a SIGPROF signal on a non-Go thread,</code></span>
<span class="codeline" id="line-4087"><code>// and the signal handler collected a stack trace in sigprofCallers.</code></span>
<span class="codeline" id="line-4088"><code>// When this is called, sigprofCallersUse will be non-zero.</code></span>
<span class="codeline" id="line-4089"><code>// g is nil, and what we can do is very limited.</code></span>
<span class="codeline" id="line-4090"><code>//go:nosplit</code></span>
<span class="codeline" id="line-4091"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-4092"><code>func sigprofNonGo() {</code></span>
<span class="codeline" id="line-4093"><code>	if prof.hz != 0 {</code></span>
<span class="codeline" id="line-4094"><code>		n := 0</code></span>
<span class="codeline" id="line-4095"><code>		for n &lt; len(sigprofCallers) &amp;&amp; sigprofCallers[n] != 0 {</code></span>
<span class="codeline" id="line-4096"><code>			n++</code></span>
<span class="codeline" id="line-4097"><code>		}</code></span>
<span class="codeline" id="line-4098"><code>		cpuprof.addNonGo(sigprofCallers[:n])</code></span>
<span class="codeline" id="line-4099"><code>	}</code></span>
<span class="codeline" id="line-4100"><code></code></span>
<span class="codeline" id="line-4101"><code>	atomic.Store(&amp;sigprofCallersUse, 0)</code></span>
<span class="codeline" id="line-4102"><code>}</code></span>
<span class="codeline" id="line-4103"><code></code></span>
<span class="codeline" id="line-4104"><code>// sigprofNonGoPC is called when a profiling signal arrived on a</code></span>
<span class="codeline" id="line-4105"><code>// non-Go thread and we have a single PC value, not a stack trace.</code></span>
<span class="codeline" id="line-4106"><code>// g is nil, and what we can do is very limited.</code></span>
<span class="codeline" id="line-4107"><code>//go:nosplit</code></span>
<span class="codeline" id="line-4108"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-4109"><code>func sigprofNonGoPC(pc uintptr) {</code></span>
<span class="codeline" id="line-4110"><code>	if prof.hz != 0 {</code></span>
<span class="codeline" id="line-4111"><code>		stk := []uintptr{</code></span>
<span class="codeline" id="line-4112"><code>			pc,</code></span>
<span class="codeline" id="line-4113"><code>			funcPC(_ExternalCode) + sys.PCQuantum,</code></span>
<span class="codeline" id="line-4114"><code>		}</code></span>
<span class="codeline" id="line-4115"><code>		cpuprof.addNonGo(stk)</code></span>
<span class="codeline" id="line-4116"><code>	}</code></span>
<span class="codeline" id="line-4117"><code>}</code></span>
<span class="codeline" id="line-4118"><code></code></span>
<span class="codeline" id="line-4119"><code>// Reports whether a function will set the SP</code></span>
<span class="codeline" id="line-4120"><code>// to an absolute value. Important that</code></span>
<span class="codeline" id="line-4121"><code>// we don't traceback when these are at the bottom</code></span>
<span class="codeline" id="line-4122"><code>// of the stack since we can't be sure that we will</code></span>
<span class="codeline" id="line-4123"><code>// find the caller.</code></span>
<span class="codeline" id="line-4124"><code>//</code></span>
<span class="codeline" id="line-4125"><code>// If the function is not on the bottom of the stack</code></span>
<span class="codeline" id="line-4126"><code>// we assume that it will have set it up so that traceback will be consistent,</code></span>
<span class="codeline" id="line-4127"><code>// either by being a traceback terminating function</code></span>
<span class="codeline" id="line-4128"><code>// or putting one on the stack at the right offset.</code></span>
<span class="codeline" id="line-4129"><code>func setsSP(pc uintptr) bool {</code></span>
<span class="codeline" id="line-4130"><code>	f := findfunc(pc)</code></span>
<span class="codeline" id="line-4131"><code>	if !f.valid() {</code></span>
<span class="codeline" id="line-4132"><code>		// couldn't find the function for this PC,</code></span>
<span class="codeline" id="line-4133"><code>		// so assume the worst and stop traceback</code></span>
<span class="codeline" id="line-4134"><code>		return true</code></span>
<span class="codeline" id="line-4135"><code>	}</code></span>
<span class="codeline" id="line-4136"><code>	switch f.funcID {</code></span>
<span class="codeline" id="line-4137"><code>	case funcID_gogo, funcID_systemstack, funcID_mcall, funcID_morestack:</code></span>
<span class="codeline" id="line-4138"><code>		return true</code></span>
<span class="codeline" id="line-4139"><code>	}</code></span>
<span class="codeline" id="line-4140"><code>	return false</code></span>
<span class="codeline" id="line-4141"><code>}</code></span>
<span class="codeline" id="line-4142"><code></code></span>
<span class="codeline" id="line-4143"><code>// setcpuprofilerate sets the CPU profiling rate to hz times per second.</code></span>
<span class="codeline" id="line-4144"><code>// If hz &lt;= 0, setcpuprofilerate turns off CPU profiling.</code></span>
<span class="codeline" id="line-4145"><code>func setcpuprofilerate(hz int32) {</code></span>
<span class="codeline" id="line-4146"><code>	// Force sane arguments.</code></span>
<span class="codeline" id="line-4147"><code>	if hz &lt; 0 {</code></span>
<span class="codeline" id="line-4148"><code>		hz = 0</code></span>
<span class="codeline" id="line-4149"><code>	}</code></span>
<span class="codeline" id="line-4150"><code></code></span>
<span class="codeline" id="line-4151"><code>	// Disable preemption, otherwise we can be rescheduled to another thread</code></span>
<span class="codeline" id="line-4152"><code>	// that has profiling enabled.</code></span>
<span class="codeline" id="line-4153"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-4154"><code>	_g_.m.locks++</code></span>
<span class="codeline" id="line-4155"><code></code></span>
<span class="codeline" id="line-4156"><code>	// Stop profiler on this thread so that it is safe to lock prof.</code></span>
<span class="codeline" id="line-4157"><code>	// if a profiling signal came in while we had prof locked,</code></span>
<span class="codeline" id="line-4158"><code>	// it would deadlock.</code></span>
<span class="codeline" id="line-4159"><code>	setThreadCPUProfiler(0)</code></span>
<span class="codeline" id="line-4160"><code></code></span>
<span class="codeline" id="line-4161"><code>	for !atomic.Cas(&amp;prof.signalLock, 0, 1) {</code></span>
<span class="codeline" id="line-4162"><code>		osyield()</code></span>
<span class="codeline" id="line-4163"><code>	}</code></span>
<span class="codeline" id="line-4164"><code>	if prof.hz != hz {</code></span>
<span class="codeline" id="line-4165"><code>		setProcessCPUProfiler(hz)</code></span>
<span class="codeline" id="line-4166"><code>		prof.hz = hz</code></span>
<span class="codeline" id="line-4167"><code>	}</code></span>
<span class="codeline" id="line-4168"><code>	atomic.Store(&amp;prof.signalLock, 0)</code></span>
<span class="codeline" id="line-4169"><code></code></span>
<span class="codeline" id="line-4170"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-4171"><code>	sched.profilehz = hz</code></span>
<span class="codeline" id="line-4172"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-4173"><code></code></span>
<span class="codeline" id="line-4174"><code>	if hz != 0 {</code></span>
<span class="codeline" id="line-4175"><code>		setThreadCPUProfiler(hz)</code></span>
<span class="codeline" id="line-4176"><code>	}</code></span>
<span class="codeline" id="line-4177"><code></code></span>
<span class="codeline" id="line-4178"><code>	_g_.m.locks--</code></span>
<span class="codeline" id="line-4179"><code>}</code></span>
<span class="codeline" id="line-4180"><code></code></span>
<span class="codeline" id="line-4181"><code>// init initializes pp, which may be a freshly allocated p or a</code></span>
<span class="codeline" id="line-4182"><code>// previously destroyed p, and transitions it to status _Pgcstop.</code></span>
<span class="codeline" id="line-4183"><code>func (pp *p) init(id int32) {</code></span>
<span class="codeline" id="line-4184"><code>	pp.id = id</code></span>
<span class="codeline" id="line-4185"><code>	pp.status = _Pgcstop</code></span>
<span class="codeline" id="line-4186"><code>	pp.sudogcache = pp.sudogbuf[:0]</code></span>
<span class="codeline" id="line-4187"><code>	for i := range pp.deferpool {</code></span>
<span class="codeline" id="line-4188"><code>		pp.deferpool[i] = pp.deferpoolbuf[i][:0]</code></span>
<span class="codeline" id="line-4189"><code>	}</code></span>
<span class="codeline" id="line-4190"><code>	pp.wbBuf.reset()</code></span>
<span class="codeline" id="line-4191"><code>	if pp.mcache == nil {</code></span>
<span class="codeline" id="line-4192"><code>		if id == 0 {</code></span>
<span class="codeline" id="line-4193"><code>			if mcache0 == nil {</code></span>
<span class="codeline" id="line-4194"><code>				throw("missing mcache?")</code></span>
<span class="codeline" id="line-4195"><code>			}</code></span>
<span class="codeline" id="line-4196"><code>			// Use the bootstrap mcache0. Only one P will get</code></span>
<span class="codeline" id="line-4197"><code>			// mcache0: the one with ID 0.</code></span>
<span class="codeline" id="line-4198"><code>			pp.mcache = mcache0</code></span>
<span class="codeline" id="line-4199"><code>		} else {</code></span>
<span class="codeline" id="line-4200"><code>			pp.mcache = allocmcache()</code></span>
<span class="codeline" id="line-4201"><code>		}</code></span>
<span class="codeline" id="line-4202"><code>	}</code></span>
<span class="codeline" id="line-4203"><code>	if raceenabled &amp;&amp; pp.raceprocctx == 0 {</code></span>
<span class="codeline" id="line-4204"><code>		if id == 0 {</code></span>
<span class="codeline" id="line-4205"><code>			pp.raceprocctx = raceprocctx0</code></span>
<span class="codeline" id="line-4206"><code>			raceprocctx0 = 0 // bootstrap</code></span>
<span class="codeline" id="line-4207"><code>		} else {</code></span>
<span class="codeline" id="line-4208"><code>			pp.raceprocctx = raceproccreate()</code></span>
<span class="codeline" id="line-4209"><code>		}</code></span>
<span class="codeline" id="line-4210"><code>	}</code></span>
<span class="codeline" id="line-4211"><code>	lockInit(&amp;pp.timersLock, lockRankTimers)</code></span>
<span class="codeline" id="line-4212"><code>}</code></span>
<span class="codeline" id="line-4213"><code></code></span>
<span class="codeline" id="line-4214"><code>// destroy releases all of the resources associated with pp and</code></span>
<span class="codeline" id="line-4215"><code>// transitions it to status _Pdead.</code></span>
<span class="codeline" id="line-4216"><code>//</code></span>
<span class="codeline" id="line-4217"><code>// sched.lock must be held and the world must be stopped.</code></span>
<span class="codeline" id="line-4218"><code>func (pp *p) destroy() {</code></span>
<span class="codeline" id="line-4219"><code>	// Move all runnable goroutines to the global queue</code></span>
<span class="codeline" id="line-4220"><code>	for pp.runqhead != pp.runqtail {</code></span>
<span class="codeline" id="line-4221"><code>		// Pop from tail of local queue</code></span>
<span class="codeline" id="line-4222"><code>		pp.runqtail--</code></span>
<span class="codeline" id="line-4223"><code>		gp := pp.runq[pp.runqtail%uint32(len(pp.runq))].ptr()</code></span>
<span class="codeline" id="line-4224"><code>		// Push onto head of global queue</code></span>
<span class="codeline" id="line-4225"><code>		globrunqputhead(gp)</code></span>
<span class="codeline" id="line-4226"><code>	}</code></span>
<span class="codeline" id="line-4227"><code>	if pp.runnext != 0 {</code></span>
<span class="codeline" id="line-4228"><code>		globrunqputhead(pp.runnext.ptr())</code></span>
<span class="codeline" id="line-4229"><code>		pp.runnext = 0</code></span>
<span class="codeline" id="line-4230"><code>	}</code></span>
<span class="codeline" id="line-4231"><code>	if len(pp.timers) &gt; 0 {</code></span>
<span class="codeline" id="line-4232"><code>		plocal := getg().m.p.ptr()</code></span>
<span class="codeline" id="line-4233"><code>		// The world is stopped, but we acquire timersLock to</code></span>
<span class="codeline" id="line-4234"><code>		// protect against sysmon calling timeSleepUntil.</code></span>
<span class="codeline" id="line-4235"><code>		// This is the only case where we hold the timersLock of</code></span>
<span class="codeline" id="line-4236"><code>		// more than one P, so there are no deadlock concerns.</code></span>
<span class="codeline" id="line-4237"><code>		lock(&amp;plocal.timersLock)</code></span>
<span class="codeline" id="line-4238"><code>		lock(&amp;pp.timersLock)</code></span>
<span class="codeline" id="line-4239"><code>		moveTimers(plocal, pp.timers)</code></span>
<span class="codeline" id="line-4240"><code>		pp.timers = nil</code></span>
<span class="codeline" id="line-4241"><code>		pp.numTimers = 0</code></span>
<span class="codeline" id="line-4242"><code>		pp.adjustTimers = 0</code></span>
<span class="codeline" id="line-4243"><code>		pp.deletedTimers = 0</code></span>
<span class="codeline" id="line-4244"><code>		atomic.Store64(&amp;pp.timer0When, 0)</code></span>
<span class="codeline" id="line-4245"><code>		unlock(&amp;pp.timersLock)</code></span>
<span class="codeline" id="line-4246"><code>		unlock(&amp;plocal.timersLock)</code></span>
<span class="codeline" id="line-4247"><code>	}</code></span>
<span class="codeline" id="line-4248"><code>	// If there's a background worker, make it runnable and put</code></span>
<span class="codeline" id="line-4249"><code>	// it on the global queue so it can clean itself up.</code></span>
<span class="codeline" id="line-4250"><code>	if gp := pp.gcBgMarkWorker.ptr(); gp != nil {</code></span>
<span class="codeline" id="line-4251"><code>		casgstatus(gp, _Gwaiting, _Grunnable)</code></span>
<span class="codeline" id="line-4252"><code>		if trace.enabled {</code></span>
<span class="codeline" id="line-4253"><code>			traceGoUnpark(gp, 0)</code></span>
<span class="codeline" id="line-4254"><code>		}</code></span>
<span class="codeline" id="line-4255"><code>		globrunqput(gp)</code></span>
<span class="codeline" id="line-4256"><code>		// This assignment doesn't race because the</code></span>
<span class="codeline" id="line-4257"><code>		// world is stopped.</code></span>
<span class="codeline" id="line-4258"><code>		pp.gcBgMarkWorker.set(nil)</code></span>
<span class="codeline" id="line-4259"><code>	}</code></span>
<span class="codeline" id="line-4260"><code>	// Flush p's write barrier buffer.</code></span>
<span class="codeline" id="line-4261"><code>	if gcphase != _GCoff {</code></span>
<span class="codeline" id="line-4262"><code>		wbBufFlush1(pp)</code></span>
<span class="codeline" id="line-4263"><code>		pp.gcw.dispose()</code></span>
<span class="codeline" id="line-4264"><code>	}</code></span>
<span class="codeline" id="line-4265"><code>	for i := range pp.sudogbuf {</code></span>
<span class="codeline" id="line-4266"><code>		pp.sudogbuf[i] = nil</code></span>
<span class="codeline" id="line-4267"><code>	}</code></span>
<span class="codeline" id="line-4268"><code>	pp.sudogcache = pp.sudogbuf[:0]</code></span>
<span class="codeline" id="line-4269"><code>	for i := range pp.deferpool {</code></span>
<span class="codeline" id="line-4270"><code>		for j := range pp.deferpoolbuf[i] {</code></span>
<span class="codeline" id="line-4271"><code>			pp.deferpoolbuf[i][j] = nil</code></span>
<span class="codeline" id="line-4272"><code>		}</code></span>
<span class="codeline" id="line-4273"><code>		pp.deferpool[i] = pp.deferpoolbuf[i][:0]</code></span>
<span class="codeline" id="line-4274"><code>	}</code></span>
<span class="codeline" id="line-4275"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-4276"><code>		for i := 0; i &lt; pp.mspancache.len; i++ {</code></span>
<span class="codeline" id="line-4277"><code>			// Safe to call since the world is stopped.</code></span>
<span class="codeline" id="line-4278"><code>			mheap_.spanalloc.free(unsafe.Pointer(pp.mspancache.buf[i]))</code></span>
<span class="codeline" id="line-4279"><code>		}</code></span>
<span class="codeline" id="line-4280"><code>		pp.mspancache.len = 0</code></span>
<span class="codeline" id="line-4281"><code>		pp.pcache.flush(&amp;mheap_.pages)</code></span>
<span class="codeline" id="line-4282"><code>	})</code></span>
<span class="codeline" id="line-4283"><code>	freemcache(pp.mcache)</code></span>
<span class="codeline" id="line-4284"><code>	pp.mcache = nil</code></span>
<span class="codeline" id="line-4285"><code>	gfpurge(pp)</code></span>
<span class="codeline" id="line-4286"><code>	traceProcFree(pp)</code></span>
<span class="codeline" id="line-4287"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-4288"><code>		if pp.timerRaceCtx != 0 {</code></span>
<span class="codeline" id="line-4289"><code>			// The race detector code uses a callback to fetch</code></span>
<span class="codeline" id="line-4290"><code>			// the proc context, so arrange for that callback</code></span>
<span class="codeline" id="line-4291"><code>			// to see the right thing.</code></span>
<span class="codeline" id="line-4292"><code>			// This hack only works because we are the only</code></span>
<span class="codeline" id="line-4293"><code>			// thread running.</code></span>
<span class="codeline" id="line-4294"><code>			mp := getg().m</code></span>
<span class="codeline" id="line-4295"><code>			phold := mp.p.ptr()</code></span>
<span class="codeline" id="line-4296"><code>			mp.p.set(pp)</code></span>
<span class="codeline" id="line-4297"><code></code></span>
<span class="codeline" id="line-4298"><code>			racectxend(pp.timerRaceCtx)</code></span>
<span class="codeline" id="line-4299"><code>			pp.timerRaceCtx = 0</code></span>
<span class="codeline" id="line-4300"><code></code></span>
<span class="codeline" id="line-4301"><code>			mp.p.set(phold)</code></span>
<span class="codeline" id="line-4302"><code>		}</code></span>
<span class="codeline" id="line-4303"><code>		raceprocdestroy(pp.raceprocctx)</code></span>
<span class="codeline" id="line-4304"><code>		pp.raceprocctx = 0</code></span>
<span class="codeline" id="line-4305"><code>	}</code></span>
<span class="codeline" id="line-4306"><code>	pp.gcAssistTime = 0</code></span>
<span class="codeline" id="line-4307"><code>	pp.status = _Pdead</code></span>
<span class="codeline" id="line-4308"><code>}</code></span>
<span class="codeline" id="line-4309"><code></code></span>
<span class="codeline" id="line-4310"><code>// Change number of processors. The world is stopped, sched is locked.</code></span>
<span class="codeline" id="line-4311"><code>// gcworkbufs are not being modified by either the GC or</code></span>
<span class="codeline" id="line-4312"><code>// the write barrier code.</code></span>
<span class="codeline" id="line-4313"><code>// Returns list of Ps with local work, they need to be scheduled by the caller.</code></span>
<span class="codeline" id="line-4314"><code>func procresize(nprocs int32) *p {</code></span>
<span class="codeline" id="line-4315"><code>	old := gomaxprocs</code></span>
<span class="codeline" id="line-4316"><code>	if old &lt; 0 || nprocs &lt;= 0 {</code></span>
<span class="codeline" id="line-4317"><code>		throw("procresize: invalid arg")</code></span>
<span class="codeline" id="line-4318"><code>	}</code></span>
<span class="codeline" id="line-4319"><code>	if trace.enabled {</code></span>
<span class="codeline" id="line-4320"><code>		traceGomaxprocs(nprocs)</code></span>
<span class="codeline" id="line-4321"><code>	}</code></span>
<span class="codeline" id="line-4322"><code></code></span>
<span class="codeline" id="line-4323"><code>	// update statistics</code></span>
<span class="codeline" id="line-4324"><code>	now := nanotime()</code></span>
<span class="codeline" id="line-4325"><code>	if sched.procresizetime != 0 {</code></span>
<span class="codeline" id="line-4326"><code>		sched.totaltime += int64(old) * (now - sched.procresizetime)</code></span>
<span class="codeline" id="line-4327"><code>	}</code></span>
<span class="codeline" id="line-4328"><code>	sched.procresizetime = now</code></span>
<span class="codeline" id="line-4329"><code></code></span>
<span class="codeline" id="line-4330"><code>	// Grow allp if necessary.</code></span>
<span class="codeline" id="line-4331"><code>	if nprocs &gt; int32(len(allp)) {</code></span>
<span class="codeline" id="line-4332"><code>		// Synchronize with retake, which could be running</code></span>
<span class="codeline" id="line-4333"><code>		// concurrently since it doesn't run on a P.</code></span>
<span class="codeline" id="line-4334"><code>		lock(&amp;allpLock)</code></span>
<span class="codeline" id="line-4335"><code>		if nprocs &lt;= int32(cap(allp)) {</code></span>
<span class="codeline" id="line-4336"><code>			allp = allp[:nprocs]</code></span>
<span class="codeline" id="line-4337"><code>		} else {</code></span>
<span class="codeline" id="line-4338"><code>			nallp := make([]*p, nprocs)</code></span>
<span class="codeline" id="line-4339"><code>			// Copy everything up to allp's cap so we</code></span>
<span class="codeline" id="line-4340"><code>			// never lose old allocated Ps.</code></span>
<span class="codeline" id="line-4341"><code>			copy(nallp, allp[:cap(allp)])</code></span>
<span class="codeline" id="line-4342"><code>			allp = nallp</code></span>
<span class="codeline" id="line-4343"><code>		}</code></span>
<span class="codeline" id="line-4344"><code>		unlock(&amp;allpLock)</code></span>
<span class="codeline" id="line-4345"><code>	}</code></span>
<span class="codeline" id="line-4346"><code></code></span>
<span class="codeline" id="line-4347"><code>	// initialize new P's</code></span>
<span class="codeline" id="line-4348"><code>	for i := old; i &lt; nprocs; i++ {</code></span>
<span class="codeline" id="line-4349"><code>		pp := allp[i]</code></span>
<span class="codeline" id="line-4350"><code>		if pp == nil {</code></span>
<span class="codeline" id="line-4351"><code>			pp = new(p)</code></span>
<span class="codeline" id="line-4352"><code>		}</code></span>
<span class="codeline" id="line-4353"><code>		pp.init(i)</code></span>
<span class="codeline" id="line-4354"><code>		atomicstorep(unsafe.Pointer(&amp;allp[i]), unsafe.Pointer(pp))</code></span>
<span class="codeline" id="line-4355"><code>	}</code></span>
<span class="codeline" id="line-4356"><code></code></span>
<span class="codeline" id="line-4357"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-4358"><code>	if _g_.m.p != 0 &amp;&amp; _g_.m.p.ptr().id &lt; nprocs {</code></span>
<span class="codeline" id="line-4359"><code>		// continue to use the current P</code></span>
<span class="codeline" id="line-4360"><code>		_g_.m.p.ptr().status = _Prunning</code></span>
<span class="codeline" id="line-4361"><code>		_g_.m.p.ptr().mcache.prepareForSweep()</code></span>
<span class="codeline" id="line-4362"><code>	} else {</code></span>
<span class="codeline" id="line-4363"><code>		// release the current P and acquire allp[0].</code></span>
<span class="codeline" id="line-4364"><code>		//</code></span>
<span class="codeline" id="line-4365"><code>		// We must do this before destroying our current P</code></span>
<span class="codeline" id="line-4366"><code>		// because p.destroy itself has write barriers, so we</code></span>
<span class="codeline" id="line-4367"><code>		// need to do that from a valid P.</code></span>
<span class="codeline" id="line-4368"><code>		if _g_.m.p != 0 {</code></span>
<span class="codeline" id="line-4369"><code>			if trace.enabled {</code></span>
<span class="codeline" id="line-4370"><code>				// Pretend that we were descheduled</code></span>
<span class="codeline" id="line-4371"><code>				// and then scheduled again to keep</code></span>
<span class="codeline" id="line-4372"><code>				// the trace sane.</code></span>
<span class="codeline" id="line-4373"><code>				traceGoSched()</code></span>
<span class="codeline" id="line-4374"><code>				traceProcStop(_g_.m.p.ptr())</code></span>
<span class="codeline" id="line-4375"><code>			}</code></span>
<span class="codeline" id="line-4376"><code>			_g_.m.p.ptr().m = 0</code></span>
<span class="codeline" id="line-4377"><code>		}</code></span>
<span class="codeline" id="line-4378"><code>		_g_.m.p = 0</code></span>
<span class="codeline" id="line-4379"><code>		p := allp[0]</code></span>
<span class="codeline" id="line-4380"><code>		p.m = 0</code></span>
<span class="codeline" id="line-4381"><code>		p.status = _Pidle</code></span>
<span class="codeline" id="line-4382"><code>		acquirep(p)</code></span>
<span class="codeline" id="line-4383"><code>		if trace.enabled {</code></span>
<span class="codeline" id="line-4384"><code>			traceGoStart()</code></span>
<span class="codeline" id="line-4385"><code>		}</code></span>
<span class="codeline" id="line-4386"><code>	}</code></span>
<span class="codeline" id="line-4387"><code></code></span>
<span class="codeline" id="line-4388"><code>	// g.m.p is now set, so we no longer need mcache0 for bootstrapping.</code></span>
<span class="codeline" id="line-4389"><code>	mcache0 = nil</code></span>
<span class="codeline" id="line-4390"><code></code></span>
<span class="codeline" id="line-4391"><code>	// release resources from unused P's</code></span>
<span class="codeline" id="line-4392"><code>	for i := nprocs; i &lt; old; i++ {</code></span>
<span class="codeline" id="line-4393"><code>		p := allp[i]</code></span>
<span class="codeline" id="line-4394"><code>		p.destroy()</code></span>
<span class="codeline" id="line-4395"><code>		// can't free P itself because it can be referenced by an M in syscall</code></span>
<span class="codeline" id="line-4396"><code>	}</code></span>
<span class="codeline" id="line-4397"><code></code></span>
<span class="codeline" id="line-4398"><code>	// Trim allp.</code></span>
<span class="codeline" id="line-4399"><code>	if int32(len(allp)) != nprocs {</code></span>
<span class="codeline" id="line-4400"><code>		lock(&amp;allpLock)</code></span>
<span class="codeline" id="line-4401"><code>		allp = allp[:nprocs]</code></span>
<span class="codeline" id="line-4402"><code>		unlock(&amp;allpLock)</code></span>
<span class="codeline" id="line-4403"><code>	}</code></span>
<span class="codeline" id="line-4404"><code></code></span>
<span class="codeline" id="line-4405"><code>	var runnablePs *p</code></span>
<span class="codeline" id="line-4406"><code>	for i := nprocs - 1; i &gt;= 0; i-- {</code></span>
<span class="codeline" id="line-4407"><code>		p := allp[i]</code></span>
<span class="codeline" id="line-4408"><code>		if _g_.m.p.ptr() == p {</code></span>
<span class="codeline" id="line-4409"><code>			continue</code></span>
<span class="codeline" id="line-4410"><code>		}</code></span>
<span class="codeline" id="line-4411"><code>		p.status = _Pidle</code></span>
<span class="codeline" id="line-4412"><code>		if runqempty(p) {</code></span>
<span class="codeline" id="line-4413"><code>			pidleput(p)</code></span>
<span class="codeline" id="line-4414"><code>		} else {</code></span>
<span class="codeline" id="line-4415"><code>			p.m.set(mget())</code></span>
<span class="codeline" id="line-4416"><code>			p.link.set(runnablePs)</code></span>
<span class="codeline" id="line-4417"><code>			runnablePs = p</code></span>
<span class="codeline" id="line-4418"><code>		}</code></span>
<span class="codeline" id="line-4419"><code>	}</code></span>
<span class="codeline" id="line-4420"><code>	stealOrder.reset(uint32(nprocs))</code></span>
<span class="codeline" id="line-4421"><code>	var int32p *int32 = &amp;gomaxprocs // make compiler check that gomaxprocs is an int32</code></span>
<span class="codeline" id="line-4422"><code>	atomic.Store((*uint32)(unsafe.Pointer(int32p)), uint32(nprocs))</code></span>
<span class="codeline" id="line-4423"><code>	return runnablePs</code></span>
<span class="codeline" id="line-4424"><code>}</code></span>
<span class="codeline" id="line-4425"><code></code></span>
<span class="codeline" id="line-4426"><code>// Associate p and the current m.</code></span>
<span class="codeline" id="line-4427"><code>//</code></span>
<span class="codeline" id="line-4428"><code>// This function is allowed to have write barriers even if the caller</code></span>
<span class="codeline" id="line-4429"><code>// isn't because it immediately acquires _p_.</code></span>
<span class="codeline" id="line-4430"><code>//</code></span>
<span class="codeline" id="line-4431"><code>//go:yeswritebarrierrec</code></span>
<span class="codeline" id="line-4432"><code>func acquirep(_p_ *p) {</code></span>
<span class="codeline" id="line-4433"><code>	// Do the part that isn't allowed to have write barriers.</code></span>
<span class="codeline" id="line-4434"><code>	wirep(_p_)</code></span>
<span class="codeline" id="line-4435"><code></code></span>
<span class="codeline" id="line-4436"><code>	// Have p; write barriers now allowed.</code></span>
<span class="codeline" id="line-4437"><code></code></span>
<span class="codeline" id="line-4438"><code>	// Perform deferred mcache flush before this P can allocate</code></span>
<span class="codeline" id="line-4439"><code>	// from a potentially stale mcache.</code></span>
<span class="codeline" id="line-4440"><code>	_p_.mcache.prepareForSweep()</code></span>
<span class="codeline" id="line-4441"><code></code></span>
<span class="codeline" id="line-4442"><code>	if trace.enabled {</code></span>
<span class="codeline" id="line-4443"><code>		traceProcStart()</code></span>
<span class="codeline" id="line-4444"><code>	}</code></span>
<span class="codeline" id="line-4445"><code>}</code></span>
<span class="codeline" id="line-4446"><code></code></span>
<span class="codeline" id="line-4447"><code>// wirep is the first step of acquirep, which actually associates the</code></span>
<span class="codeline" id="line-4448"><code>// current M to _p_. This is broken out so we can disallow write</code></span>
<span class="codeline" id="line-4449"><code>// barriers for this part, since we don't yet have a P.</code></span>
<span class="codeline" id="line-4450"><code>//</code></span>
<span class="codeline" id="line-4451"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-4452"><code>//go:nosplit</code></span>
<span class="codeline" id="line-4453"><code>func wirep(_p_ *p) {</code></span>
<span class="codeline" id="line-4454"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-4455"><code></code></span>
<span class="codeline" id="line-4456"><code>	if _g_.m.p != 0 {</code></span>
<span class="codeline" id="line-4457"><code>		throw("wirep: already in go")</code></span>
<span class="codeline" id="line-4458"><code>	}</code></span>
<span class="codeline" id="line-4459"><code>	if _p_.m != 0 || _p_.status != _Pidle {</code></span>
<span class="codeline" id="line-4460"><code>		id := int64(0)</code></span>
<span class="codeline" id="line-4461"><code>		if _p_.m != 0 {</code></span>
<span class="codeline" id="line-4462"><code>			id = _p_.m.ptr().id</code></span>
<span class="codeline" id="line-4463"><code>		}</code></span>
<span class="codeline" id="line-4464"><code>		print("wirep: p-&gt;m=", _p_.m, "(", id, ") p-&gt;status=", _p_.status, "\n")</code></span>
<span class="codeline" id="line-4465"><code>		throw("wirep: invalid p state")</code></span>
<span class="codeline" id="line-4466"><code>	}</code></span>
<span class="codeline" id="line-4467"><code>	_g_.m.p.set(_p_)</code></span>
<span class="codeline" id="line-4468"><code>	_p_.m.set(_g_.m)</code></span>
<span class="codeline" id="line-4469"><code>	_p_.status = _Prunning</code></span>
<span class="codeline" id="line-4470"><code>}</code></span>
<span class="codeline" id="line-4471"><code></code></span>
<span class="codeline" id="line-4472"><code>// Disassociate p and the current m.</code></span>
<span class="codeline" id="line-4473"><code>func releasep() *p {</code></span>
<span class="codeline" id="line-4474"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-4475"><code></code></span>
<span class="codeline" id="line-4476"><code>	if _g_.m.p == 0 {</code></span>
<span class="codeline" id="line-4477"><code>		throw("releasep: invalid arg")</code></span>
<span class="codeline" id="line-4478"><code>	}</code></span>
<span class="codeline" id="line-4479"><code>	_p_ := _g_.m.p.ptr()</code></span>
<span class="codeline" id="line-4480"><code>	if _p_.m.ptr() != _g_.m || _p_.status != _Prunning {</code></span>
<span class="codeline" id="line-4481"><code>		print("releasep: m=", _g_.m, " m-&gt;p=", _g_.m.p.ptr(), " p-&gt;m=", hex(_p_.m), " p-&gt;status=", _p_.status, "\n")</code></span>
<span class="codeline" id="line-4482"><code>		throw("releasep: invalid p state")</code></span>
<span class="codeline" id="line-4483"><code>	}</code></span>
<span class="codeline" id="line-4484"><code>	if trace.enabled {</code></span>
<span class="codeline" id="line-4485"><code>		traceProcStop(_g_.m.p.ptr())</code></span>
<span class="codeline" id="line-4486"><code>	}</code></span>
<span class="codeline" id="line-4487"><code>	_g_.m.p = 0</code></span>
<span class="codeline" id="line-4488"><code>	_p_.m = 0</code></span>
<span class="codeline" id="line-4489"><code>	_p_.status = _Pidle</code></span>
<span class="codeline" id="line-4490"><code>	return _p_</code></span>
<span class="codeline" id="line-4491"><code>}</code></span>
<span class="codeline" id="line-4492"><code></code></span>
<span class="codeline" id="line-4493"><code>func incidlelocked(v int32) {</code></span>
<span class="codeline" id="line-4494"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-4495"><code>	sched.nmidlelocked += v</code></span>
<span class="codeline" id="line-4496"><code>	if v &gt; 0 {</code></span>
<span class="codeline" id="line-4497"><code>		checkdead()</code></span>
<span class="codeline" id="line-4498"><code>	}</code></span>
<span class="codeline" id="line-4499"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-4500"><code>}</code></span>
<span class="codeline" id="line-4501"><code></code></span>
<span class="codeline" id="line-4502"><code>// Check for deadlock situation.</code></span>
<span class="codeline" id="line-4503"><code>// The check is based on number of running M's, if 0 -&gt; deadlock.</code></span>
<span class="codeline" id="line-4504"><code>// sched.lock must be held.</code></span>
<span class="codeline" id="line-4505"><code>func checkdead() {</code></span>
<span class="codeline" id="line-4506"><code>	// For -buildmode=c-shared or -buildmode=c-archive it's OK if</code></span>
<span class="codeline" id="line-4507"><code>	// there are no running goroutines. The calling program is</code></span>
<span class="codeline" id="line-4508"><code>	// assumed to be running.</code></span>
<span class="codeline" id="line-4509"><code>	if islibrary || isarchive {</code></span>
<span class="codeline" id="line-4510"><code>		return</code></span>
<span class="codeline" id="line-4511"><code>	}</code></span>
<span class="codeline" id="line-4512"><code></code></span>
<span class="codeline" id="line-4513"><code>	// If we are dying because of a signal caught on an already idle thread,</code></span>
<span class="codeline" id="line-4514"><code>	// freezetheworld will cause all running threads to block.</code></span>
<span class="codeline" id="line-4515"><code>	// And runtime will essentially enter into deadlock state,</code></span>
<span class="codeline" id="line-4516"><code>	// except that there is a thread that will call exit soon.</code></span>
<span class="codeline" id="line-4517"><code>	if panicking &gt; 0 {</code></span>
<span class="codeline" id="line-4518"><code>		return</code></span>
<span class="codeline" id="line-4519"><code>	}</code></span>
<span class="codeline" id="line-4520"><code></code></span>
<span class="codeline" id="line-4521"><code>	// If we are not running under cgo, but we have an extra M then account</code></span>
<span class="codeline" id="line-4522"><code>	// for it. (It is possible to have an extra M on Windows without cgo to</code></span>
<span class="codeline" id="line-4523"><code>	// accommodate callbacks created by syscall.NewCallback. See issue #6751</code></span>
<span class="codeline" id="line-4524"><code>	// for details.)</code></span>
<span class="codeline" id="line-4525"><code>	var run0 int32</code></span>
<span class="codeline" id="line-4526"><code>	if !iscgo &amp;&amp; cgoHasExtraM {</code></span>
<span class="codeline" id="line-4527"><code>		mp := lockextra(true)</code></span>
<span class="codeline" id="line-4528"><code>		haveExtraM := extraMCount &gt; 0</code></span>
<span class="codeline" id="line-4529"><code>		unlockextra(mp)</code></span>
<span class="codeline" id="line-4530"><code>		if haveExtraM {</code></span>
<span class="codeline" id="line-4531"><code>			run0 = 1</code></span>
<span class="codeline" id="line-4532"><code>		}</code></span>
<span class="codeline" id="line-4533"><code>	}</code></span>
<span class="codeline" id="line-4534"><code></code></span>
<span class="codeline" id="line-4535"><code>	run := mcount() - sched.nmidle - sched.nmidlelocked - sched.nmsys</code></span>
<span class="codeline" id="line-4536"><code>	if run &gt; run0 {</code></span>
<span class="codeline" id="line-4537"><code>		return</code></span>
<span class="codeline" id="line-4538"><code>	}</code></span>
<span class="codeline" id="line-4539"><code>	if run &lt; 0 {</code></span>
<span class="codeline" id="line-4540"><code>		print("runtime: checkdead: nmidle=", sched.nmidle, " nmidlelocked=", sched.nmidlelocked, " mcount=", mcount(), " nmsys=", sched.nmsys, "\n")</code></span>
<span class="codeline" id="line-4541"><code>		throw("checkdead: inconsistent counts")</code></span>
<span class="codeline" id="line-4542"><code>	}</code></span>
<span class="codeline" id="line-4543"><code></code></span>
<span class="codeline" id="line-4544"><code>	grunning := 0</code></span>
<span class="codeline" id="line-4545"><code>	lock(&amp;allglock)</code></span>
<span class="codeline" id="line-4546"><code>	for i := 0; i &lt; len(allgs); i++ {</code></span>
<span class="codeline" id="line-4547"><code>		gp := allgs[i]</code></span>
<span class="codeline" id="line-4548"><code>		if isSystemGoroutine(gp, false) {</code></span>
<span class="codeline" id="line-4549"><code>			continue</code></span>
<span class="codeline" id="line-4550"><code>		}</code></span>
<span class="codeline" id="line-4551"><code>		s := readgstatus(gp)</code></span>
<span class="codeline" id="line-4552"><code>		switch s &amp;^ _Gscan {</code></span>
<span class="codeline" id="line-4553"><code>		case _Gwaiting,</code></span>
<span class="codeline" id="line-4554"><code>			_Gpreempted:</code></span>
<span class="codeline" id="line-4555"><code>			grunning++</code></span>
<span class="codeline" id="line-4556"><code>		case _Grunnable,</code></span>
<span class="codeline" id="line-4557"><code>			_Grunning,</code></span>
<span class="codeline" id="line-4558"><code>			_Gsyscall:</code></span>
<span class="codeline" id="line-4559"><code>			unlock(&amp;allglock)</code></span>
<span class="codeline" id="line-4560"><code>			print("runtime: checkdead: find g ", gp.goid, " in status ", s, "\n")</code></span>
<span class="codeline" id="line-4561"><code>			throw("checkdead: runnable g")</code></span>
<span class="codeline" id="line-4562"><code>		}</code></span>
<span class="codeline" id="line-4563"><code>	}</code></span>
<span class="codeline" id="line-4564"><code>	unlock(&amp;allglock)</code></span>
<span class="codeline" id="line-4565"><code>	if grunning == 0 { // possible if main goroutine calls runtime·Goexit()</code></span>
<span class="codeline" id="line-4566"><code>		unlock(&amp;sched.lock) // unlock so that GODEBUG=scheddetail=1 doesn't hang</code></span>
<span class="codeline" id="line-4567"><code>		throw("no goroutines (main called runtime.Goexit) - deadlock!")</code></span>
<span class="codeline" id="line-4568"><code>	}</code></span>
<span class="codeline" id="line-4569"><code></code></span>
<span class="codeline" id="line-4570"><code>	// Maybe jump time forward for playground.</code></span>
<span class="codeline" id="line-4571"><code>	if faketime != 0 {</code></span>
<span class="codeline" id="line-4572"><code>		when, _p_ := timeSleepUntil()</code></span>
<span class="codeline" id="line-4573"><code>		if _p_ != nil {</code></span>
<span class="codeline" id="line-4574"><code>			faketime = when</code></span>
<span class="codeline" id="line-4575"><code>			for pp := &amp;sched.pidle; *pp != 0; pp = &amp;(*pp).ptr().link {</code></span>
<span class="codeline" id="line-4576"><code>				if (*pp).ptr() == _p_ {</code></span>
<span class="codeline" id="line-4577"><code>					*pp = _p_.link</code></span>
<span class="codeline" id="line-4578"><code>					break</code></span>
<span class="codeline" id="line-4579"><code>				}</code></span>
<span class="codeline" id="line-4580"><code>			}</code></span>
<span class="codeline" id="line-4581"><code>			mp := mget()</code></span>
<span class="codeline" id="line-4582"><code>			if mp == nil {</code></span>
<span class="codeline" id="line-4583"><code>				// There should always be a free M since</code></span>
<span class="codeline" id="line-4584"><code>				// nothing is running.</code></span>
<span class="codeline" id="line-4585"><code>				throw("checkdead: no m for timer")</code></span>
<span class="codeline" id="line-4586"><code>			}</code></span>
<span class="codeline" id="line-4587"><code>			mp.nextp.set(_p_)</code></span>
<span class="codeline" id="line-4588"><code>			notewakeup(&amp;mp.park)</code></span>
<span class="codeline" id="line-4589"><code>			return</code></span>
<span class="codeline" id="line-4590"><code>		}</code></span>
<span class="codeline" id="line-4591"><code>	}</code></span>
<span class="codeline" id="line-4592"><code></code></span>
<span class="codeline" id="line-4593"><code>	// There are no goroutines running, so we can look at the P's.</code></span>
<span class="codeline" id="line-4594"><code>	for _, _p_ := range allp {</code></span>
<span class="codeline" id="line-4595"><code>		if len(_p_.timers) &gt; 0 {</code></span>
<span class="codeline" id="line-4596"><code>			return</code></span>
<span class="codeline" id="line-4597"><code>		}</code></span>
<span class="codeline" id="line-4598"><code>	}</code></span>
<span class="codeline" id="line-4599"><code></code></span>
<span class="codeline" id="line-4600"><code>	getg().m.throwing = -1 // do not dump full stacks</code></span>
<span class="codeline" id="line-4601"><code>	unlock(&amp;sched.lock)    // unlock so that GODEBUG=scheddetail=1 doesn't hang</code></span>
<span class="codeline" id="line-4602"><code>	throw("all goroutines are asleep - deadlock!")</code></span>
<span class="codeline" id="line-4603"><code>}</code></span>
<span class="codeline" id="line-4604"><code></code></span>
<span class="codeline" id="line-4605"><code>// forcegcperiod is the maximum time in nanoseconds between garbage</code></span>
<span class="codeline" id="line-4606"><code>// collections. If we go this long without a garbage collection, one</code></span>
<span class="codeline" id="line-4607"><code>// is forced to run.</code></span>
<span class="codeline" id="line-4608"><code>//</code></span>
<span class="codeline" id="line-4609"><code>// This is a variable for testing purposes. It normally doesn't change.</code></span>
<span class="codeline" id="line-4610"><code>var forcegcperiod int64 = 2 * 60 * 1e9</code></span>
<span class="codeline" id="line-4611"><code></code></span>
<span class="codeline" id="line-4612"><code>// Always runs without a P, so write barriers are not allowed.</code></span>
<span class="codeline" id="line-4613"><code>//</code></span>
<span class="codeline" id="line-4614"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-4615"><code>func sysmon() {</code></span>
<span class="codeline" id="line-4616"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-4617"><code>	sched.nmsys++</code></span>
<span class="codeline" id="line-4618"><code>	checkdead()</code></span>
<span class="codeline" id="line-4619"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-4620"><code></code></span>
<span class="codeline" id="line-4621"><code>	lasttrace := int64(0)</code></span>
<span class="codeline" id="line-4622"><code>	idle := 0 // how many cycles in succession we had not wokeup somebody</code></span>
<span class="codeline" id="line-4623"><code>	delay := uint32(0)</code></span>
<span class="codeline" id="line-4624"><code>	for {</code></span>
<span class="codeline" id="line-4625"><code>		if idle == 0 { // start with 20us sleep...</code></span>
<span class="codeline" id="line-4626"><code>			delay = 20</code></span>
<span class="codeline" id="line-4627"><code>		} else if idle &gt; 50 { // start doubling the sleep after 1ms...</code></span>
<span class="codeline" id="line-4628"><code>			delay *= 2</code></span>
<span class="codeline" id="line-4629"><code>		}</code></span>
<span class="codeline" id="line-4630"><code>		if delay &gt; 10*1000 { // up to 10ms</code></span>
<span class="codeline" id="line-4631"><code>			delay = 10 * 1000</code></span>
<span class="codeline" id="line-4632"><code>		}</code></span>
<span class="codeline" id="line-4633"><code>		usleep(delay)</code></span>
<span class="codeline" id="line-4634"><code>		now := nanotime()</code></span>
<span class="codeline" id="line-4635"><code>		next, _ := timeSleepUntil()</code></span>
<span class="codeline" id="line-4636"><code>		if debug.schedtrace &lt;= 0 &amp;&amp; (sched.gcwaiting != 0 || atomic.Load(&amp;sched.npidle) == uint32(gomaxprocs)) {</code></span>
<span class="codeline" id="line-4637"><code>			lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-4638"><code>			if atomic.Load(&amp;sched.gcwaiting) != 0 || atomic.Load(&amp;sched.npidle) == uint32(gomaxprocs) {</code></span>
<span class="codeline" id="line-4639"><code>				if next &gt; now {</code></span>
<span class="codeline" id="line-4640"><code>					atomic.Store(&amp;sched.sysmonwait, 1)</code></span>
<span class="codeline" id="line-4641"><code>					unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-4642"><code>					// Make wake-up period small enough</code></span>
<span class="codeline" id="line-4643"><code>					// for the sampling to be correct.</code></span>
<span class="codeline" id="line-4644"><code>					sleep := forcegcperiod / 2</code></span>
<span class="codeline" id="line-4645"><code>					if next-now &lt; sleep {</code></span>
<span class="codeline" id="line-4646"><code>						sleep = next - now</code></span>
<span class="codeline" id="line-4647"><code>					}</code></span>
<span class="codeline" id="line-4648"><code>					shouldRelax := sleep &gt;= osRelaxMinNS</code></span>
<span class="codeline" id="line-4649"><code>					if shouldRelax {</code></span>
<span class="codeline" id="line-4650"><code>						osRelax(true)</code></span>
<span class="codeline" id="line-4651"><code>					}</code></span>
<span class="codeline" id="line-4652"><code>					notetsleep(&amp;sched.sysmonnote, sleep)</code></span>
<span class="codeline" id="line-4653"><code>					if shouldRelax {</code></span>
<span class="codeline" id="line-4654"><code>						osRelax(false)</code></span>
<span class="codeline" id="line-4655"><code>					}</code></span>
<span class="codeline" id="line-4656"><code>					now = nanotime()</code></span>
<span class="codeline" id="line-4657"><code>					next, _ = timeSleepUntil()</code></span>
<span class="codeline" id="line-4658"><code>					lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-4659"><code>					atomic.Store(&amp;sched.sysmonwait, 0)</code></span>
<span class="codeline" id="line-4660"><code>					noteclear(&amp;sched.sysmonnote)</code></span>
<span class="codeline" id="line-4661"><code>				}</code></span>
<span class="codeline" id="line-4662"><code>				idle = 0</code></span>
<span class="codeline" id="line-4663"><code>				delay = 20</code></span>
<span class="codeline" id="line-4664"><code>			}</code></span>
<span class="codeline" id="line-4665"><code>			unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-4666"><code>		}</code></span>
<span class="codeline" id="line-4667"><code>		lock(&amp;sched.sysmonlock)</code></span>
<span class="codeline" id="line-4668"><code>		{</code></span>
<span class="codeline" id="line-4669"><code>			// If we spent a long time blocked on sysmonlock</code></span>
<span class="codeline" id="line-4670"><code>			// then we want to update now and next since it's</code></span>
<span class="codeline" id="line-4671"><code>			// likely stale.</code></span>
<span class="codeline" id="line-4672"><code>			now1 := nanotime()</code></span>
<span class="codeline" id="line-4673"><code>			if now1-now &gt; 50*1000 /* 50µs */ {</code></span>
<span class="codeline" id="line-4674"><code>				next, _ = timeSleepUntil()</code></span>
<span class="codeline" id="line-4675"><code>			}</code></span>
<span class="codeline" id="line-4676"><code>			now = now1</code></span>
<span class="codeline" id="line-4677"><code>		}</code></span>
<span class="codeline" id="line-4678"><code></code></span>
<span class="codeline" id="line-4679"><code>		// trigger libc interceptors if needed</code></span>
<span class="codeline" id="line-4680"><code>		if *cgo_yield != nil {</code></span>
<span class="codeline" id="line-4681"><code>			asmcgocall(*cgo_yield, nil)</code></span>
<span class="codeline" id="line-4682"><code>		}</code></span>
<span class="codeline" id="line-4683"><code>		// poll network if not polled for more than 10ms</code></span>
<span class="codeline" id="line-4684"><code>		lastpoll := int64(atomic.Load64(&amp;sched.lastpoll))</code></span>
<span class="codeline" id="line-4685"><code>		if netpollinited() &amp;&amp; lastpoll != 0 &amp;&amp; lastpoll+10*1000*1000 &lt; now {</code></span>
<span class="codeline" id="line-4686"><code>			atomic.Cas64(&amp;sched.lastpoll, uint64(lastpoll), uint64(now))</code></span>
<span class="codeline" id="line-4687"><code>			list := netpoll(0) // non-blocking - returns list of goroutines</code></span>
<span class="codeline" id="line-4688"><code>			if !list.empty() {</code></span>
<span class="codeline" id="line-4689"><code>				// Need to decrement number of idle locked M's</code></span>
<span class="codeline" id="line-4690"><code>				// (pretending that one more is running) before injectglist.</code></span>
<span class="codeline" id="line-4691"><code>				// Otherwise it can lead to the following situation:</code></span>
<span class="codeline" id="line-4692"><code>				// injectglist grabs all P's but before it starts M's to run the P's,</code></span>
<span class="codeline" id="line-4693"><code>				// another M returns from syscall, finishes running its G,</code></span>
<span class="codeline" id="line-4694"><code>				// observes that there is no work to do and no other running M's</code></span>
<span class="codeline" id="line-4695"><code>				// and reports deadlock.</code></span>
<span class="codeline" id="line-4696"><code>				incidlelocked(-1)</code></span>
<span class="codeline" id="line-4697"><code>				injectglist(&amp;list)</code></span>
<span class="codeline" id="line-4698"><code>				incidlelocked(1)</code></span>
<span class="codeline" id="line-4699"><code>			}</code></span>
<span class="codeline" id="line-4700"><code>		}</code></span>
<span class="codeline" id="line-4701"><code>		if next &lt; now {</code></span>
<span class="codeline" id="line-4702"><code>			// There are timers that should have already run,</code></span>
<span class="codeline" id="line-4703"><code>			// perhaps because there is an unpreemptible P.</code></span>
<span class="codeline" id="line-4704"><code>			// Try to start an M to run them.</code></span>
<span class="codeline" id="line-4705"><code>			startm(nil, false)</code></span>
<span class="codeline" id="line-4706"><code>		}</code></span>
<span class="codeline" id="line-4707"><code>		if atomic.Load(&amp;scavenge.sysmonWake) != 0 {</code></span>
<span class="codeline" id="line-4708"><code>			// Kick the scavenger awake if someone requested it.</code></span>
<span class="codeline" id="line-4709"><code>			wakeScavenger()</code></span>
<span class="codeline" id="line-4710"><code>		}</code></span>
<span class="codeline" id="line-4711"><code>		// retake P's blocked in syscalls</code></span>
<span class="codeline" id="line-4712"><code>		// and preempt long running G's</code></span>
<span class="codeline" id="line-4713"><code>		if retake(now) != 0 {</code></span>
<span class="codeline" id="line-4714"><code>			idle = 0</code></span>
<span class="codeline" id="line-4715"><code>		} else {</code></span>
<span class="codeline" id="line-4716"><code>			idle++</code></span>
<span class="codeline" id="line-4717"><code>		}</code></span>
<span class="codeline" id="line-4718"><code>		// check if we need to force a GC</code></span>
<span class="codeline" id="line-4719"><code>		if t := (gcTrigger{kind: gcTriggerTime, now: now}); t.test() &amp;&amp; atomic.Load(&amp;forcegc.idle) != 0 {</code></span>
<span class="codeline" id="line-4720"><code>			lock(&amp;forcegc.lock)</code></span>
<span class="codeline" id="line-4721"><code>			forcegc.idle = 0</code></span>
<span class="codeline" id="line-4722"><code>			var list gList</code></span>
<span class="codeline" id="line-4723"><code>			list.push(forcegc.g)</code></span>
<span class="codeline" id="line-4724"><code>			injectglist(&amp;list)</code></span>
<span class="codeline" id="line-4725"><code>			unlock(&amp;forcegc.lock)</code></span>
<span class="codeline" id="line-4726"><code>		}</code></span>
<span class="codeline" id="line-4727"><code>		if debug.schedtrace &gt; 0 &amp;&amp; lasttrace+int64(debug.schedtrace)*1000000 &lt;= now {</code></span>
<span class="codeline" id="line-4728"><code>			lasttrace = now</code></span>
<span class="codeline" id="line-4729"><code>			schedtrace(debug.scheddetail &gt; 0)</code></span>
<span class="codeline" id="line-4730"><code>		}</code></span>
<span class="codeline" id="line-4731"><code>		unlock(&amp;sched.sysmonlock)</code></span>
<span class="codeline" id="line-4732"><code>	}</code></span>
<span class="codeline" id="line-4733"><code>}</code></span>
<span class="codeline" id="line-4734"><code></code></span>
<span class="codeline" id="line-4735"><code>type sysmontick struct {</code></span>
<span class="codeline" id="line-4736"><code>	schedtick   uint32</code></span>
<span class="codeline" id="line-4737"><code>	schedwhen   int64</code></span>
<span class="codeline" id="line-4738"><code>	syscalltick uint32</code></span>
<span class="codeline" id="line-4739"><code>	syscallwhen int64</code></span>
<span class="codeline" id="line-4740"><code>}</code></span>
<span class="codeline" id="line-4741"><code></code></span>
<span class="codeline" id="line-4742"><code>// forcePreemptNS is the time slice given to a G before it is</code></span>
<span class="codeline" id="line-4743"><code>// preempted.</code></span>
<span class="codeline" id="line-4744"><code>const forcePreemptNS = 10 * 1000 * 1000 // 10ms</code></span>
<span class="codeline" id="line-4745"><code></code></span>
<span class="codeline" id="line-4746"><code>func retake(now int64) uint32 {</code></span>
<span class="codeline" id="line-4747"><code>	n := 0</code></span>
<span class="codeline" id="line-4748"><code>	// Prevent allp slice changes. This lock will be completely</code></span>
<span class="codeline" id="line-4749"><code>	// uncontended unless we're already stopping the world.</code></span>
<span class="codeline" id="line-4750"><code>	lock(&amp;allpLock)</code></span>
<span class="codeline" id="line-4751"><code>	// We can't use a range loop over allp because we may</code></span>
<span class="codeline" id="line-4752"><code>	// temporarily drop the allpLock. Hence, we need to re-fetch</code></span>
<span class="codeline" id="line-4753"><code>	// allp each time around the loop.</code></span>
<span class="codeline" id="line-4754"><code>	for i := 0; i &lt; len(allp); i++ {</code></span>
<span class="codeline" id="line-4755"><code>		_p_ := allp[i]</code></span>
<span class="codeline" id="line-4756"><code>		if _p_ == nil {</code></span>
<span class="codeline" id="line-4757"><code>			// This can happen if procresize has grown</code></span>
<span class="codeline" id="line-4758"><code>			// allp but not yet created new Ps.</code></span>
<span class="codeline" id="line-4759"><code>			continue</code></span>
<span class="codeline" id="line-4760"><code>		}</code></span>
<span class="codeline" id="line-4761"><code>		pd := &amp;_p_.sysmontick</code></span>
<span class="codeline" id="line-4762"><code>		s := _p_.status</code></span>
<span class="codeline" id="line-4763"><code>		sysretake := false</code></span>
<span class="codeline" id="line-4764"><code>		if s == _Prunning || s == _Psyscall {</code></span>
<span class="codeline" id="line-4765"><code>			// Preempt G if it's running for too long.</code></span>
<span class="codeline" id="line-4766"><code>			t := int64(_p_.schedtick)</code></span>
<span class="codeline" id="line-4767"><code>			if int64(pd.schedtick) != t {</code></span>
<span class="codeline" id="line-4768"><code>				pd.schedtick = uint32(t)</code></span>
<span class="codeline" id="line-4769"><code>				pd.schedwhen = now</code></span>
<span class="codeline" id="line-4770"><code>			} else if pd.schedwhen+forcePreemptNS &lt;= now {</code></span>
<span class="codeline" id="line-4771"><code>				preemptone(_p_)</code></span>
<span class="codeline" id="line-4772"><code>				// In case of syscall, preemptone() doesn't</code></span>
<span class="codeline" id="line-4773"><code>				// work, because there is no M wired to P.</code></span>
<span class="codeline" id="line-4774"><code>				sysretake = true</code></span>
<span class="codeline" id="line-4775"><code>			}</code></span>
<span class="codeline" id="line-4776"><code>		}</code></span>
<span class="codeline" id="line-4777"><code>		if s == _Psyscall {</code></span>
<span class="codeline" id="line-4778"><code>			// Retake P from syscall if it's there for more than 1 sysmon tick (at least 20us).</code></span>
<span class="codeline" id="line-4779"><code>			t := int64(_p_.syscalltick)</code></span>
<span class="codeline" id="line-4780"><code>			if !sysretake &amp;&amp; int64(pd.syscalltick) != t {</code></span>
<span class="codeline" id="line-4781"><code>				pd.syscalltick = uint32(t)</code></span>
<span class="codeline" id="line-4782"><code>				pd.syscallwhen = now</code></span>
<span class="codeline" id="line-4783"><code>				continue</code></span>
<span class="codeline" id="line-4784"><code>			}</code></span>
<span class="codeline" id="line-4785"><code>			// On the one hand we don't want to retake Ps if there is no other work to do,</code></span>
<span class="codeline" id="line-4786"><code>			// but on the other hand we want to retake them eventually</code></span>
<span class="codeline" id="line-4787"><code>			// because they can prevent the sysmon thread from deep sleep.</code></span>
<span class="codeline" id="line-4788"><code>			if runqempty(_p_) &amp;&amp; atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) &gt; 0 &amp;&amp; pd.syscallwhen+10*1000*1000 &gt; now {</code></span>
<span class="codeline" id="line-4789"><code>				continue</code></span>
<span class="codeline" id="line-4790"><code>			}</code></span>
<span class="codeline" id="line-4791"><code>			// Drop allpLock so we can take sched.lock.</code></span>
<span class="codeline" id="line-4792"><code>			unlock(&amp;allpLock)</code></span>
<span class="codeline" id="line-4793"><code>			// Need to decrement number of idle locked M's</code></span>
<span class="codeline" id="line-4794"><code>			// (pretending that one more is running) before the CAS.</code></span>
<span class="codeline" id="line-4795"><code>			// Otherwise the M from which we retake can exit the syscall,</code></span>
<span class="codeline" id="line-4796"><code>			// increment nmidle and report deadlock.</code></span>
<span class="codeline" id="line-4797"><code>			incidlelocked(-1)</code></span>
<span class="codeline" id="line-4798"><code>			if atomic.Cas(&amp;_p_.status, s, _Pidle) {</code></span>
<span class="codeline" id="line-4799"><code>				if trace.enabled {</code></span>
<span class="codeline" id="line-4800"><code>					traceGoSysBlock(_p_)</code></span>
<span class="codeline" id="line-4801"><code>					traceProcStop(_p_)</code></span>
<span class="codeline" id="line-4802"><code>				}</code></span>
<span class="codeline" id="line-4803"><code>				n++</code></span>
<span class="codeline" id="line-4804"><code>				_p_.syscalltick++</code></span>
<span class="codeline" id="line-4805"><code>				handoffp(_p_)</code></span>
<span class="codeline" id="line-4806"><code>			}</code></span>
<span class="codeline" id="line-4807"><code>			incidlelocked(1)</code></span>
<span class="codeline" id="line-4808"><code>			lock(&amp;allpLock)</code></span>
<span class="codeline" id="line-4809"><code>		}</code></span>
<span class="codeline" id="line-4810"><code>	}</code></span>
<span class="codeline" id="line-4811"><code>	unlock(&amp;allpLock)</code></span>
<span class="codeline" id="line-4812"><code>	return uint32(n)</code></span>
<span class="codeline" id="line-4813"><code>}</code></span>
<span class="codeline" id="line-4814"><code></code></span>
<span class="codeline" id="line-4815"><code>// Tell all goroutines that they have been preempted and they should stop.</code></span>
<span class="codeline" id="line-4816"><code>// This function is purely best-effort. It can fail to inform a goroutine if a</code></span>
<span class="codeline" id="line-4817"><code>// processor just started running it.</code></span>
<span class="codeline" id="line-4818"><code>// No locks need to be held.</code></span>
<span class="codeline" id="line-4819"><code>// Returns true if preemption request was issued to at least one goroutine.</code></span>
<span class="codeline" id="line-4820"><code>func preemptall() bool {</code></span>
<span class="codeline" id="line-4821"><code>	res := false</code></span>
<span class="codeline" id="line-4822"><code>	for _, _p_ := range allp {</code></span>
<span class="codeline" id="line-4823"><code>		if _p_.status != _Prunning {</code></span>
<span class="codeline" id="line-4824"><code>			continue</code></span>
<span class="codeline" id="line-4825"><code>		}</code></span>
<span class="codeline" id="line-4826"><code>		if preemptone(_p_) {</code></span>
<span class="codeline" id="line-4827"><code>			res = true</code></span>
<span class="codeline" id="line-4828"><code>		}</code></span>
<span class="codeline" id="line-4829"><code>	}</code></span>
<span class="codeline" id="line-4830"><code>	return res</code></span>
<span class="codeline" id="line-4831"><code>}</code></span>
<span class="codeline" id="line-4832"><code></code></span>
<span class="codeline" id="line-4833"><code>// Tell the goroutine running on processor P to stop.</code></span>
<span class="codeline" id="line-4834"><code>// This function is purely best-effort. It can incorrectly fail to inform the</code></span>
<span class="codeline" id="line-4835"><code>// goroutine. It can send inform the wrong goroutine. Even if it informs the</code></span>
<span class="codeline" id="line-4836"><code>// correct goroutine, that goroutine might ignore the request if it is</code></span>
<span class="codeline" id="line-4837"><code>// simultaneously executing newstack.</code></span>
<span class="codeline" id="line-4838"><code>// No lock needs to be held.</code></span>
<span class="codeline" id="line-4839"><code>// Returns true if preemption request was issued.</code></span>
<span class="codeline" id="line-4840"><code>// The actual preemption will happen at some point in the future</code></span>
<span class="codeline" id="line-4841"><code>// and will be indicated by the gp-&gt;status no longer being</code></span>
<span class="codeline" id="line-4842"><code>// Grunning</code></span>
<span class="codeline" id="line-4843"><code>func preemptone(_p_ *p) bool {</code></span>
<span class="codeline" id="line-4844"><code>	mp := _p_.m.ptr()</code></span>
<span class="codeline" id="line-4845"><code>	if mp == nil || mp == getg().m {</code></span>
<span class="codeline" id="line-4846"><code>		return false</code></span>
<span class="codeline" id="line-4847"><code>	}</code></span>
<span class="codeline" id="line-4848"><code>	gp := mp.curg</code></span>
<span class="codeline" id="line-4849"><code>	if gp == nil || gp == mp.g0 {</code></span>
<span class="codeline" id="line-4850"><code>		return false</code></span>
<span class="codeline" id="line-4851"><code>	}</code></span>
<span class="codeline" id="line-4852"><code></code></span>
<span class="codeline" id="line-4853"><code>	gp.preempt = true</code></span>
<span class="codeline" id="line-4854"><code></code></span>
<span class="codeline" id="line-4855"><code>	// Every call in a go routine checks for stack overflow by</code></span>
<span class="codeline" id="line-4856"><code>	// comparing the current stack pointer to gp-&gt;stackguard0.</code></span>
<span class="codeline" id="line-4857"><code>	// Setting gp-&gt;stackguard0 to StackPreempt folds</code></span>
<span class="codeline" id="line-4858"><code>	// preemption into the normal stack overflow check.</code></span>
<span class="codeline" id="line-4859"><code>	gp.stackguard0 = stackPreempt</code></span>
<span class="codeline" id="line-4860"><code></code></span>
<span class="codeline" id="line-4861"><code>	// Request an async preemption of this P.</code></span>
<span class="codeline" id="line-4862"><code>	if preemptMSupported &amp;&amp; debug.asyncpreemptoff == 0 {</code></span>
<span class="codeline" id="line-4863"><code>		_p_.preempt = true</code></span>
<span class="codeline" id="line-4864"><code>		preemptM(mp)</code></span>
<span class="codeline" id="line-4865"><code>	}</code></span>
<span class="codeline" id="line-4866"><code></code></span>
<span class="codeline" id="line-4867"><code>	return true</code></span>
<span class="codeline" id="line-4868"><code>}</code></span>
<span class="codeline" id="line-4869"><code></code></span>
<span class="codeline" id="line-4870"><code>var starttime int64</code></span>
<span class="codeline" id="line-4871"><code></code></span>
<span class="codeline" id="line-4872"><code>func schedtrace(detailed bool) {</code></span>
<span class="codeline" id="line-4873"><code>	now := nanotime()</code></span>
<span class="codeline" id="line-4874"><code>	if starttime == 0 {</code></span>
<span class="codeline" id="line-4875"><code>		starttime = now</code></span>
<span class="codeline" id="line-4876"><code>	}</code></span>
<span class="codeline" id="line-4877"><code></code></span>
<span class="codeline" id="line-4878"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-4879"><code>	print("SCHED ", (now-starttime)/1e6, "ms: gomaxprocs=", gomaxprocs, " idleprocs=", sched.npidle, " threads=", mcount(), " spinningthreads=", sched.nmspinning, " idlethreads=", sched.nmidle, " runqueue=", sched.runqsize)</code></span>
<span class="codeline" id="line-4880"><code>	if detailed {</code></span>
<span class="codeline" id="line-4881"><code>		print(" gcwaiting=", sched.gcwaiting, " nmidlelocked=", sched.nmidlelocked, " stopwait=", sched.stopwait, " sysmonwait=", sched.sysmonwait, "\n")</code></span>
<span class="codeline" id="line-4882"><code>	}</code></span>
<span class="codeline" id="line-4883"><code>	// We must be careful while reading data from P's, M's and G's.</code></span>
<span class="codeline" id="line-4884"><code>	// Even if we hold schedlock, most data can be changed concurrently.</code></span>
<span class="codeline" id="line-4885"><code>	// E.g. (p-&gt;m ? p-&gt;m-&gt;id : -1) can crash if p-&gt;m changes from non-nil to nil.</code></span>
<span class="codeline" id="line-4886"><code>	for i, _p_ := range allp {</code></span>
<span class="codeline" id="line-4887"><code>		mp := _p_.m.ptr()</code></span>
<span class="codeline" id="line-4888"><code>		h := atomic.Load(&amp;_p_.runqhead)</code></span>
<span class="codeline" id="line-4889"><code>		t := atomic.Load(&amp;_p_.runqtail)</code></span>
<span class="codeline" id="line-4890"><code>		if detailed {</code></span>
<span class="codeline" id="line-4891"><code>			id := int64(-1)</code></span>
<span class="codeline" id="line-4892"><code>			if mp != nil {</code></span>
<span class="codeline" id="line-4893"><code>				id = mp.id</code></span>
<span class="codeline" id="line-4894"><code>			}</code></span>
<span class="codeline" id="line-4895"><code>			print("  P", i, ": status=", _p_.status, " schedtick=", _p_.schedtick, " syscalltick=", _p_.syscalltick, " m=", id, " runqsize=", t-h, " gfreecnt=", _p_.gFree.n, " timerslen=", len(_p_.timers), "\n")</code></span>
<span class="codeline" id="line-4896"><code>		} else {</code></span>
<span class="codeline" id="line-4897"><code>			// In non-detailed mode format lengths of per-P run queues as:</code></span>
<span class="codeline" id="line-4898"><code>			// [len1 len2 len3 len4]</code></span>
<span class="codeline" id="line-4899"><code>			print(" ")</code></span>
<span class="codeline" id="line-4900"><code>			if i == 0 {</code></span>
<span class="codeline" id="line-4901"><code>				print("[")</code></span>
<span class="codeline" id="line-4902"><code>			}</code></span>
<span class="codeline" id="line-4903"><code>			print(t - h)</code></span>
<span class="codeline" id="line-4904"><code>			if i == len(allp)-1 {</code></span>
<span class="codeline" id="line-4905"><code>				print("]\n")</code></span>
<span class="codeline" id="line-4906"><code>			}</code></span>
<span class="codeline" id="line-4907"><code>		}</code></span>
<span class="codeline" id="line-4908"><code>	}</code></span>
<span class="codeline" id="line-4909"><code></code></span>
<span class="codeline" id="line-4910"><code>	if !detailed {</code></span>
<span class="codeline" id="line-4911"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-4912"><code>		return</code></span>
<span class="codeline" id="line-4913"><code>	}</code></span>
<span class="codeline" id="line-4914"><code></code></span>
<span class="codeline" id="line-4915"><code>	for mp := allm; mp != nil; mp = mp.alllink {</code></span>
<span class="codeline" id="line-4916"><code>		_p_ := mp.p.ptr()</code></span>
<span class="codeline" id="line-4917"><code>		gp := mp.curg</code></span>
<span class="codeline" id="line-4918"><code>		lockedg := mp.lockedg.ptr()</code></span>
<span class="codeline" id="line-4919"><code>		id1 := int32(-1)</code></span>
<span class="codeline" id="line-4920"><code>		if _p_ != nil {</code></span>
<span class="codeline" id="line-4921"><code>			id1 = _p_.id</code></span>
<span class="codeline" id="line-4922"><code>		}</code></span>
<span class="codeline" id="line-4923"><code>		id2 := int64(-1)</code></span>
<span class="codeline" id="line-4924"><code>		if gp != nil {</code></span>
<span class="codeline" id="line-4925"><code>			id2 = gp.goid</code></span>
<span class="codeline" id="line-4926"><code>		}</code></span>
<span class="codeline" id="line-4927"><code>		id3 := int64(-1)</code></span>
<span class="codeline" id="line-4928"><code>		if lockedg != nil {</code></span>
<span class="codeline" id="line-4929"><code>			id3 = lockedg.goid</code></span>
<span class="codeline" id="line-4930"><code>		}</code></span>
<span class="codeline" id="line-4931"><code>		print("  M", mp.id, ": p=", id1, " curg=", id2, " mallocing=", mp.mallocing, " throwing=", mp.throwing, " preemptoff=", mp.preemptoff, ""+" locks=", mp.locks, " dying=", mp.dying, " spinning=", mp.spinning, " blocked=", mp.blocked, " lockedg=", id3, "\n")</code></span>
<span class="codeline" id="line-4932"><code>	}</code></span>
<span class="codeline" id="line-4933"><code></code></span>
<span class="codeline" id="line-4934"><code>	lock(&amp;allglock)</code></span>
<span class="codeline" id="line-4935"><code>	for gi := 0; gi &lt; len(allgs); gi++ {</code></span>
<span class="codeline" id="line-4936"><code>		gp := allgs[gi]</code></span>
<span class="codeline" id="line-4937"><code>		mp := gp.m</code></span>
<span class="codeline" id="line-4938"><code>		lockedm := gp.lockedm.ptr()</code></span>
<span class="codeline" id="line-4939"><code>		id1 := int64(-1)</code></span>
<span class="codeline" id="line-4940"><code>		if mp != nil {</code></span>
<span class="codeline" id="line-4941"><code>			id1 = mp.id</code></span>
<span class="codeline" id="line-4942"><code>		}</code></span>
<span class="codeline" id="line-4943"><code>		id2 := int64(-1)</code></span>
<span class="codeline" id="line-4944"><code>		if lockedm != nil {</code></span>
<span class="codeline" id="line-4945"><code>			id2 = lockedm.id</code></span>
<span class="codeline" id="line-4946"><code>		}</code></span>
<span class="codeline" id="line-4947"><code>		print("  G", gp.goid, ": status=", readgstatus(gp), "(", gp.waitreason.String(), ") m=", id1, " lockedm=", id2, "\n")</code></span>
<span class="codeline" id="line-4948"><code>	}</code></span>
<span class="codeline" id="line-4949"><code>	unlock(&amp;allglock)</code></span>
<span class="codeline" id="line-4950"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-4951"><code>}</code></span>
<span class="codeline" id="line-4952"><code></code></span>
<span class="codeline" id="line-4953"><code>// schedEnableUser enables or disables the scheduling of user</code></span>
<span class="codeline" id="line-4954"><code>// goroutines.</code></span>
<span class="codeline" id="line-4955"><code>//</code></span>
<span class="codeline" id="line-4956"><code>// This does not stop already running user goroutines, so the caller</code></span>
<span class="codeline" id="line-4957"><code>// should first stop the world when disabling user goroutines.</code></span>
<span class="codeline" id="line-4958"><code>func schedEnableUser(enable bool) {</code></span>
<span class="codeline" id="line-4959"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-4960"><code>	if sched.disable.user == !enable {</code></span>
<span class="codeline" id="line-4961"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-4962"><code>		return</code></span>
<span class="codeline" id="line-4963"><code>	}</code></span>
<span class="codeline" id="line-4964"><code>	sched.disable.user = !enable</code></span>
<span class="codeline" id="line-4965"><code>	if enable {</code></span>
<span class="codeline" id="line-4966"><code>		n := sched.disable.n</code></span>
<span class="codeline" id="line-4967"><code>		sched.disable.n = 0</code></span>
<span class="codeline" id="line-4968"><code>		globrunqputbatch(&amp;sched.disable.runnable, n)</code></span>
<span class="codeline" id="line-4969"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-4970"><code>		for ; n != 0 &amp;&amp; sched.npidle != 0; n-- {</code></span>
<span class="codeline" id="line-4971"><code>			startm(nil, false)</code></span>
<span class="codeline" id="line-4972"><code>		}</code></span>
<span class="codeline" id="line-4973"><code>	} else {</code></span>
<span class="codeline" id="line-4974"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-4975"><code>	}</code></span>
<span class="codeline" id="line-4976"><code>}</code></span>
<span class="codeline" id="line-4977"><code></code></span>
<span class="codeline" id="line-4978"><code>// schedEnabled reports whether gp should be scheduled. It returns</code></span>
<span class="codeline" id="line-4979"><code>// false is scheduling of gp is disabled.</code></span>
<span class="codeline" id="line-4980"><code>func schedEnabled(gp *g) bool {</code></span>
<span class="codeline" id="line-4981"><code>	if sched.disable.user {</code></span>
<span class="codeline" id="line-4982"><code>		return isSystemGoroutine(gp, true)</code></span>
<span class="codeline" id="line-4983"><code>	}</code></span>
<span class="codeline" id="line-4984"><code>	return true</code></span>
<span class="codeline" id="line-4985"><code>}</code></span>
<span class="codeline" id="line-4986"><code></code></span>
<span class="codeline" id="line-4987"><code>// Put mp on midle list.</code></span>
<span class="codeline" id="line-4988"><code>// Sched must be locked.</code></span>
<span class="codeline" id="line-4989"><code>// May run during STW, so write barriers are not allowed.</code></span>
<span class="codeline" id="line-4990"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-4991"><code>func mput(mp *m) {</code></span>
<span class="codeline" id="line-4992"><code>	mp.schedlink = sched.midle</code></span>
<span class="codeline" id="line-4993"><code>	sched.midle.set(mp)</code></span>
<span class="codeline" id="line-4994"><code>	sched.nmidle++</code></span>
<span class="codeline" id="line-4995"><code>	checkdead()</code></span>
<span class="codeline" id="line-4996"><code>}</code></span>
<span class="codeline" id="line-4997"><code></code></span>
<span class="codeline" id="line-4998"><code>// Try to get an m from midle list.</code></span>
<span class="codeline" id="line-4999"><code>// Sched must be locked.</code></span>
<span class="codeline" id="line-5000"><code>// May run during STW, so write barriers are not allowed.</code></span>
<span class="codeline" id="line-5001"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-5002"><code>func mget() *m {</code></span>
<span class="codeline" id="line-5003"><code>	mp := sched.midle.ptr()</code></span>
<span class="codeline" id="line-5004"><code>	if mp != nil {</code></span>
<span class="codeline" id="line-5005"><code>		sched.midle = mp.schedlink</code></span>
<span class="codeline" id="line-5006"><code>		sched.nmidle--</code></span>
<span class="codeline" id="line-5007"><code>	}</code></span>
<span class="codeline" id="line-5008"><code>	return mp</code></span>
<span class="codeline" id="line-5009"><code>}</code></span>
<span class="codeline" id="line-5010"><code></code></span>
<span class="codeline" id="line-5011"><code>// Put gp on the global runnable queue.</code></span>
<span class="codeline" id="line-5012"><code>// Sched must be locked.</code></span>
<span class="codeline" id="line-5013"><code>// May run during STW, so write barriers are not allowed.</code></span>
<span class="codeline" id="line-5014"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-5015"><code>func globrunqput(gp *g) {</code></span>
<span class="codeline" id="line-5016"><code>	sched.runq.pushBack(gp)</code></span>
<span class="codeline" id="line-5017"><code>	sched.runqsize++</code></span>
<span class="codeline" id="line-5018"><code>}</code></span>
<span class="codeline" id="line-5019"><code></code></span>
<span class="codeline" id="line-5020"><code>// Put gp at the head of the global runnable queue.</code></span>
<span class="codeline" id="line-5021"><code>// Sched must be locked.</code></span>
<span class="codeline" id="line-5022"><code>// May run during STW, so write barriers are not allowed.</code></span>
<span class="codeline" id="line-5023"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-5024"><code>func globrunqputhead(gp *g) {</code></span>
<span class="codeline" id="line-5025"><code>	sched.runq.push(gp)</code></span>
<span class="codeline" id="line-5026"><code>	sched.runqsize++</code></span>
<span class="codeline" id="line-5027"><code>}</code></span>
<span class="codeline" id="line-5028"><code></code></span>
<span class="codeline" id="line-5029"><code>// Put a batch of runnable goroutines on the global runnable queue.</code></span>
<span class="codeline" id="line-5030"><code>// This clears *batch.</code></span>
<span class="codeline" id="line-5031"><code>// Sched must be locked.</code></span>
<span class="codeline" id="line-5032"><code>func globrunqputbatch(batch *gQueue, n int32) {</code></span>
<span class="codeline" id="line-5033"><code>	sched.runq.pushBackAll(*batch)</code></span>
<span class="codeline" id="line-5034"><code>	sched.runqsize += n</code></span>
<span class="codeline" id="line-5035"><code>	*batch = gQueue{}</code></span>
<span class="codeline" id="line-5036"><code>}</code></span>
<span class="codeline" id="line-5037"><code></code></span>
<span class="codeline" id="line-5038"><code>// Try get a batch of G's from the global runnable queue.</code></span>
<span class="codeline" id="line-5039"><code>// Sched must be locked.</code></span>
<span class="codeline" id="line-5040"><code>func globrunqget(_p_ *p, max int32) *g {</code></span>
<span class="codeline" id="line-5041"><code>	if sched.runqsize == 0 {</code></span>
<span class="codeline" id="line-5042"><code>		return nil</code></span>
<span class="codeline" id="line-5043"><code>	}</code></span>
<span class="codeline" id="line-5044"><code></code></span>
<span class="codeline" id="line-5045"><code>	n := sched.runqsize/gomaxprocs + 1</code></span>
<span class="codeline" id="line-5046"><code>	if n &gt; sched.runqsize {</code></span>
<span class="codeline" id="line-5047"><code>		n = sched.runqsize</code></span>
<span class="codeline" id="line-5048"><code>	}</code></span>
<span class="codeline" id="line-5049"><code>	if max &gt; 0 &amp;&amp; n &gt; max {</code></span>
<span class="codeline" id="line-5050"><code>		n = max</code></span>
<span class="codeline" id="line-5051"><code>	}</code></span>
<span class="codeline" id="line-5052"><code>	if n &gt; int32(len(_p_.runq))/2 {</code></span>
<span class="codeline" id="line-5053"><code>		n = int32(len(_p_.runq)) / 2</code></span>
<span class="codeline" id="line-5054"><code>	}</code></span>
<span class="codeline" id="line-5055"><code></code></span>
<span class="codeline" id="line-5056"><code>	sched.runqsize -= n</code></span>
<span class="codeline" id="line-5057"><code></code></span>
<span class="codeline" id="line-5058"><code>	gp := sched.runq.pop()</code></span>
<span class="codeline" id="line-5059"><code>	n--</code></span>
<span class="codeline" id="line-5060"><code>	for ; n &gt; 0; n-- {</code></span>
<span class="codeline" id="line-5061"><code>		gp1 := sched.runq.pop()</code></span>
<span class="codeline" id="line-5062"><code>		runqput(_p_, gp1, false)</code></span>
<span class="codeline" id="line-5063"><code>	}</code></span>
<span class="codeline" id="line-5064"><code>	return gp</code></span>
<span class="codeline" id="line-5065"><code>}</code></span>
<span class="codeline" id="line-5066"><code></code></span>
<span class="codeline" id="line-5067"><code>// Put p to on _Pidle list.</code></span>
<span class="codeline" id="line-5068"><code>// Sched must be locked.</code></span>
<span class="codeline" id="line-5069"><code>// May run during STW, so write barriers are not allowed.</code></span>
<span class="codeline" id="line-5070"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-5071"><code>func pidleput(_p_ *p) {</code></span>
<span class="codeline" id="line-5072"><code>	if !runqempty(_p_) {</code></span>
<span class="codeline" id="line-5073"><code>		throw("pidleput: P has non-empty run queue")</code></span>
<span class="codeline" id="line-5074"><code>	}</code></span>
<span class="codeline" id="line-5075"><code>	_p_.link = sched.pidle</code></span>
<span class="codeline" id="line-5076"><code>	sched.pidle.set(_p_)</code></span>
<span class="codeline" id="line-5077"><code>	atomic.Xadd(&amp;sched.npidle, 1) // TODO: fast atomic</code></span>
<span class="codeline" id="line-5078"><code>}</code></span>
<span class="codeline" id="line-5079"><code></code></span>
<span class="codeline" id="line-5080"><code>// Try get a p from _Pidle list.</code></span>
<span class="codeline" id="line-5081"><code>// Sched must be locked.</code></span>
<span class="codeline" id="line-5082"><code>// May run during STW, so write barriers are not allowed.</code></span>
<span class="codeline" id="line-5083"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-5084"><code>func pidleget() *p {</code></span>
<span class="codeline" id="line-5085"><code>	_p_ := sched.pidle.ptr()</code></span>
<span class="codeline" id="line-5086"><code>	if _p_ != nil {</code></span>
<span class="codeline" id="line-5087"><code>		sched.pidle = _p_.link</code></span>
<span class="codeline" id="line-5088"><code>		atomic.Xadd(&amp;sched.npidle, -1) // TODO: fast atomic</code></span>
<span class="codeline" id="line-5089"><code>	}</code></span>
<span class="codeline" id="line-5090"><code>	return _p_</code></span>
<span class="codeline" id="line-5091"><code>}</code></span>
<span class="codeline" id="line-5092"><code></code></span>
<span class="codeline" id="line-5093"><code>// runqempty reports whether _p_ has no Gs on its local run queue.</code></span>
<span class="codeline" id="line-5094"><code>// It never returns true spuriously.</code></span>
<span class="codeline" id="line-5095"><code>func runqempty(_p_ *p) bool {</code></span>
<span class="codeline" id="line-5096"><code>	// Defend against a race where 1) _p_ has G1 in runqnext but runqhead == runqtail,</code></span>
<span class="codeline" id="line-5097"><code>	// 2) runqput on _p_ kicks G1 to the runq, 3) runqget on _p_ empties runqnext.</code></span>
<span class="codeline" id="line-5098"><code>	// Simply observing that runqhead == runqtail and then observing that runqnext == nil</code></span>
<span class="codeline" id="line-5099"><code>	// does not mean the queue is empty.</code></span>
<span class="codeline" id="line-5100"><code>	for {</code></span>
<span class="codeline" id="line-5101"><code>		head := atomic.Load(&amp;_p_.runqhead)</code></span>
<span class="codeline" id="line-5102"><code>		tail := atomic.Load(&amp;_p_.runqtail)</code></span>
<span class="codeline" id="line-5103"><code>		runnext := atomic.Loaduintptr((*uintptr)(unsafe.Pointer(&amp;_p_.runnext)))</code></span>
<span class="codeline" id="line-5104"><code>		if tail == atomic.Load(&amp;_p_.runqtail) {</code></span>
<span class="codeline" id="line-5105"><code>			return head == tail &amp;&amp; runnext == 0</code></span>
<span class="codeline" id="line-5106"><code>		}</code></span>
<span class="codeline" id="line-5107"><code>	}</code></span>
<span class="codeline" id="line-5108"><code>}</code></span>
<span class="codeline" id="line-5109"><code></code></span>
<span class="codeline" id="line-5110"><code>// To shake out latent assumptions about scheduling order,</code></span>
<span class="codeline" id="line-5111"><code>// we introduce some randomness into scheduling decisions</code></span>
<span class="codeline" id="line-5112"><code>// when running with the race detector.</code></span>
<span class="codeline" id="line-5113"><code>// The need for this was made obvious by changing the</code></span>
<span class="codeline" id="line-5114"><code>// (deterministic) scheduling order in Go 1.5 and breaking</code></span>
<span class="codeline" id="line-5115"><code>// many poorly-written tests.</code></span>
<span class="codeline" id="line-5116"><code>// With the randomness here, as long as the tests pass</code></span>
<span class="codeline" id="line-5117"><code>// consistently with -race, they shouldn't have latent scheduling</code></span>
<span class="codeline" id="line-5118"><code>// assumptions.</code></span>
<span class="codeline" id="line-5119"><code>const randomizeScheduler = raceenabled</code></span>
<span class="codeline" id="line-5120"><code></code></span>
<span class="codeline" id="line-5121"><code>// runqput tries to put g on the local runnable queue.</code></span>
<span class="codeline" id="line-5122"><code>// If next is false, runqput adds g to the tail of the runnable queue.</code></span>
<span class="codeline" id="line-5123"><code>// If next is true, runqput puts g in the _p_.runnext slot.</code></span>
<span class="codeline" id="line-5124"><code>// If the run queue is full, runnext puts g on the global queue.</code></span>
<span class="codeline" id="line-5125"><code>// Executed only by the owner P.</code></span>
<span class="codeline" id="line-5126"><code>func runqput(_p_ *p, gp *g, next bool) {</code></span>
<span class="codeline" id="line-5127"><code>	if randomizeScheduler &amp;&amp; next &amp;&amp; fastrand()%2 == 0 {</code></span>
<span class="codeline" id="line-5128"><code>		next = false</code></span>
<span class="codeline" id="line-5129"><code>	}</code></span>
<span class="codeline" id="line-5130"><code></code></span>
<span class="codeline" id="line-5131"><code>	if next {</code></span>
<span class="codeline" id="line-5132"><code>	retryNext:</code></span>
<span class="codeline" id="line-5133"><code>		oldnext := _p_.runnext</code></span>
<span class="codeline" id="line-5134"><code>		if !_p_.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) {</code></span>
<span class="codeline" id="line-5135"><code>			goto retryNext</code></span>
<span class="codeline" id="line-5136"><code>		}</code></span>
<span class="codeline" id="line-5137"><code>		if oldnext == 0 {</code></span>
<span class="codeline" id="line-5138"><code>			return</code></span>
<span class="codeline" id="line-5139"><code>		}</code></span>
<span class="codeline" id="line-5140"><code>		// Kick the old runnext out to the regular run queue.</code></span>
<span class="codeline" id="line-5141"><code>		gp = oldnext.ptr()</code></span>
<span class="codeline" id="line-5142"><code>	}</code></span>
<span class="codeline" id="line-5143"><code></code></span>
<span class="codeline" id="line-5144"><code>retry:</code></span>
<span class="codeline" id="line-5145"><code>	h := atomic.LoadAcq(&amp;_p_.runqhead) // load-acquire, synchronize with consumers</code></span>
<span class="codeline" id="line-5146"><code>	t := _p_.runqtail</code></span>
<span class="codeline" id="line-5147"><code>	if t-h &lt; uint32(len(_p_.runq)) {</code></span>
<span class="codeline" id="line-5148"><code>		_p_.runq[t%uint32(len(_p_.runq))].set(gp)</code></span>
<span class="codeline" id="line-5149"><code>		atomic.StoreRel(&amp;_p_.runqtail, t+1) // store-release, makes the item available for consumption</code></span>
<span class="codeline" id="line-5150"><code>		return</code></span>
<span class="codeline" id="line-5151"><code>	}</code></span>
<span class="codeline" id="line-5152"><code>	if runqputslow(_p_, gp, h, t) {</code></span>
<span class="codeline" id="line-5153"><code>		return</code></span>
<span class="codeline" id="line-5154"><code>	}</code></span>
<span class="codeline" id="line-5155"><code>	// the queue is not full, now the put above must succeed</code></span>
<span class="codeline" id="line-5156"><code>	goto retry</code></span>
<span class="codeline" id="line-5157"><code>}</code></span>
<span class="codeline" id="line-5158"><code></code></span>
<span class="codeline" id="line-5159"><code>// Put g and a batch of work from local runnable queue on global queue.</code></span>
<span class="codeline" id="line-5160"><code>// Executed only by the owner P.</code></span>
<span class="codeline" id="line-5161"><code>func runqputslow(_p_ *p, gp *g, h, t uint32) bool {</code></span>
<span class="codeline" id="line-5162"><code>	var batch [len(_p_.runq)/2 + 1]*g</code></span>
<span class="codeline" id="line-5163"><code></code></span>
<span class="codeline" id="line-5164"><code>	// First, grab a batch from local queue.</code></span>
<span class="codeline" id="line-5165"><code>	n := t - h</code></span>
<span class="codeline" id="line-5166"><code>	n = n / 2</code></span>
<span class="codeline" id="line-5167"><code>	if n != uint32(len(_p_.runq)/2) {</code></span>
<span class="codeline" id="line-5168"><code>		throw("runqputslow: queue is not full")</code></span>
<span class="codeline" id="line-5169"><code>	}</code></span>
<span class="codeline" id="line-5170"><code>	for i := uint32(0); i &lt; n; i++ {</code></span>
<span class="codeline" id="line-5171"><code>		batch[i] = _p_.runq[(h+i)%uint32(len(_p_.runq))].ptr()</code></span>
<span class="codeline" id="line-5172"><code>	}</code></span>
<span class="codeline" id="line-5173"><code>	if !atomic.CasRel(&amp;_p_.runqhead, h, h+n) { // cas-release, commits consume</code></span>
<span class="codeline" id="line-5174"><code>		return false</code></span>
<span class="codeline" id="line-5175"><code>	}</code></span>
<span class="codeline" id="line-5176"><code>	batch[n] = gp</code></span>
<span class="codeline" id="line-5177"><code></code></span>
<span class="codeline" id="line-5178"><code>	if randomizeScheduler {</code></span>
<span class="codeline" id="line-5179"><code>		for i := uint32(1); i &lt;= n; i++ {</code></span>
<span class="codeline" id="line-5180"><code>			j := fastrandn(i + 1)</code></span>
<span class="codeline" id="line-5181"><code>			batch[i], batch[j] = batch[j], batch[i]</code></span>
<span class="codeline" id="line-5182"><code>		}</code></span>
<span class="codeline" id="line-5183"><code>	}</code></span>
<span class="codeline" id="line-5184"><code></code></span>
<span class="codeline" id="line-5185"><code>	// Link the goroutines.</code></span>
<span class="codeline" id="line-5186"><code>	for i := uint32(0); i &lt; n; i++ {</code></span>
<span class="codeline" id="line-5187"><code>		batch[i].schedlink.set(batch[i+1])</code></span>
<span class="codeline" id="line-5188"><code>	}</code></span>
<span class="codeline" id="line-5189"><code>	var q gQueue</code></span>
<span class="codeline" id="line-5190"><code>	q.head.set(batch[0])</code></span>
<span class="codeline" id="line-5191"><code>	q.tail.set(batch[n])</code></span>
<span class="codeline" id="line-5192"><code></code></span>
<span class="codeline" id="line-5193"><code>	// Now put the batch on global queue.</code></span>
<span class="codeline" id="line-5194"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-5195"><code>	globrunqputbatch(&amp;q, int32(n+1))</code></span>
<span class="codeline" id="line-5196"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-5197"><code>	return true</code></span>
<span class="codeline" id="line-5198"><code>}</code></span>
<span class="codeline" id="line-5199"><code></code></span>
<span class="codeline" id="line-5200"><code>// runqputbatch tries to put all the G's on q on the local runnable queue.</code></span>
<span class="codeline" id="line-5201"><code>// If the queue is full, they are put on the global queue; in that case</code></span>
<span class="codeline" id="line-5202"><code>// this will temporarily acquire the scheduler lock.</code></span>
<span class="codeline" id="line-5203"><code>// Executed only by the owner P.</code></span>
<span class="codeline" id="line-5204"><code>func runqputbatch(pp *p, q *gQueue, qsize int) {</code></span>
<span class="codeline" id="line-5205"><code>	h := atomic.LoadAcq(&amp;pp.runqhead)</code></span>
<span class="codeline" id="line-5206"><code>	t := pp.runqtail</code></span>
<span class="codeline" id="line-5207"><code>	n := uint32(0)</code></span>
<span class="codeline" id="line-5208"><code>	for !q.empty() &amp;&amp; t-h &lt; uint32(len(pp.runq)) {</code></span>
<span class="codeline" id="line-5209"><code>		gp := q.pop()</code></span>
<span class="codeline" id="line-5210"><code>		pp.runq[t%uint32(len(pp.runq))].set(gp)</code></span>
<span class="codeline" id="line-5211"><code>		t++</code></span>
<span class="codeline" id="line-5212"><code>		n++</code></span>
<span class="codeline" id="line-5213"><code>	}</code></span>
<span class="codeline" id="line-5214"><code>	qsize -= int(n)</code></span>
<span class="codeline" id="line-5215"><code></code></span>
<span class="codeline" id="line-5216"><code>	if randomizeScheduler {</code></span>
<span class="codeline" id="line-5217"><code>		off := func(o uint32) uint32 {</code></span>
<span class="codeline" id="line-5218"><code>			return (pp.runqtail + o) % uint32(len(pp.runq))</code></span>
<span class="codeline" id="line-5219"><code>		}</code></span>
<span class="codeline" id="line-5220"><code>		for i := uint32(1); i &lt; n; i++ {</code></span>
<span class="codeline" id="line-5221"><code>			j := fastrandn(i + 1)</code></span>
<span class="codeline" id="line-5222"><code>			pp.runq[off(i)], pp.runq[off(j)] = pp.runq[off(j)], pp.runq[off(i)]</code></span>
<span class="codeline" id="line-5223"><code>		}</code></span>
<span class="codeline" id="line-5224"><code>	}</code></span>
<span class="codeline" id="line-5225"><code></code></span>
<span class="codeline" id="line-5226"><code>	atomic.StoreRel(&amp;pp.runqtail, t)</code></span>
<span class="codeline" id="line-5227"><code>	if !q.empty() {</code></span>
<span class="codeline" id="line-5228"><code>		lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-5229"><code>		globrunqputbatch(q, int32(qsize))</code></span>
<span class="codeline" id="line-5230"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-5231"><code>	}</code></span>
<span class="codeline" id="line-5232"><code>}</code></span>
<span class="codeline" id="line-5233"><code></code></span>
<span class="codeline" id="line-5234"><code>// Get g from local runnable queue.</code></span>
<span class="codeline" id="line-5235"><code>// If inheritTime is true, gp should inherit the remaining time in the</code></span>
<span class="codeline" id="line-5236"><code>// current time slice. Otherwise, it should start a new time slice.</code></span>
<span class="codeline" id="line-5237"><code>// Executed only by the owner P.</code></span>
<span class="codeline" id="line-5238"><code>func runqget(_p_ *p) (gp *g, inheritTime bool) {</code></span>
<span class="codeline" id="line-5239"><code>	// If there's a runnext, it's the next G to run.</code></span>
<span class="codeline" id="line-5240"><code>	for {</code></span>
<span class="codeline" id="line-5241"><code>		next := _p_.runnext</code></span>
<span class="codeline" id="line-5242"><code>		if next == 0 {</code></span>
<span class="codeline" id="line-5243"><code>			break</code></span>
<span class="codeline" id="line-5244"><code>		}</code></span>
<span class="codeline" id="line-5245"><code>		if _p_.runnext.cas(next, 0) {</code></span>
<span class="codeline" id="line-5246"><code>			return next.ptr(), true</code></span>
<span class="codeline" id="line-5247"><code>		}</code></span>
<span class="codeline" id="line-5248"><code>	}</code></span>
<span class="codeline" id="line-5249"><code></code></span>
<span class="codeline" id="line-5250"><code>	for {</code></span>
<span class="codeline" id="line-5251"><code>		h := atomic.LoadAcq(&amp;_p_.runqhead) // load-acquire, synchronize with other consumers</code></span>
<span class="codeline" id="line-5252"><code>		t := _p_.runqtail</code></span>
<span class="codeline" id="line-5253"><code>		if t == h {</code></span>
<span class="codeline" id="line-5254"><code>			return nil, false</code></span>
<span class="codeline" id="line-5255"><code>		}</code></span>
<span class="codeline" id="line-5256"><code>		gp := _p_.runq[h%uint32(len(_p_.runq))].ptr()</code></span>
<span class="codeline" id="line-5257"><code>		if atomic.CasRel(&amp;_p_.runqhead, h, h+1) { // cas-release, commits consume</code></span>
<span class="codeline" id="line-5258"><code>			return gp, false</code></span>
<span class="codeline" id="line-5259"><code>		}</code></span>
<span class="codeline" id="line-5260"><code>	}</code></span>
<span class="codeline" id="line-5261"><code>}</code></span>
<span class="codeline" id="line-5262"><code></code></span>
<span class="codeline" id="line-5263"><code>// Grabs a batch of goroutines from _p_'s runnable queue into batch.</code></span>
<span class="codeline" id="line-5264"><code>// Batch is a ring buffer starting at batchHead.</code></span>
<span class="codeline" id="line-5265"><code>// Returns number of grabbed goroutines.</code></span>
<span class="codeline" id="line-5266"><code>// Can be executed by any P.</code></span>
<span class="codeline" id="line-5267"><code>func runqgrab(_p_ *p, batch *[256]guintptr, batchHead uint32, stealRunNextG bool) uint32 {</code></span>
<span class="codeline" id="line-5268"><code>	for {</code></span>
<span class="codeline" id="line-5269"><code>		h := atomic.LoadAcq(&amp;_p_.runqhead) // load-acquire, synchronize with other consumers</code></span>
<span class="codeline" id="line-5270"><code>		t := atomic.LoadAcq(&amp;_p_.runqtail) // load-acquire, synchronize with the producer</code></span>
<span class="codeline" id="line-5271"><code>		n := t - h</code></span>
<span class="codeline" id="line-5272"><code>		n = n - n/2</code></span>
<span class="codeline" id="line-5273"><code>		if n == 0 {</code></span>
<span class="codeline" id="line-5274"><code>			if stealRunNextG {</code></span>
<span class="codeline" id="line-5275"><code>				// Try to steal from _p_.runnext.</code></span>
<span class="codeline" id="line-5276"><code>				if next := _p_.runnext; next != 0 {</code></span>
<span class="codeline" id="line-5277"><code>					if _p_.status == _Prunning {</code></span>
<span class="codeline" id="line-5278"><code>						// Sleep to ensure that _p_ isn't about to run the g</code></span>
<span class="codeline" id="line-5279"><code>						// we are about to steal.</code></span>
<span class="codeline" id="line-5280"><code>						// The important use case here is when the g running</code></span>
<span class="codeline" id="line-5281"><code>						// on _p_ ready()s another g and then almost</code></span>
<span class="codeline" id="line-5282"><code>						// immediately blocks. Instead of stealing runnext</code></span>
<span class="codeline" id="line-5283"><code>						// in this window, back off to give _p_ a chance to</code></span>
<span class="codeline" id="line-5284"><code>						// schedule runnext. This will avoid thrashing gs</code></span>
<span class="codeline" id="line-5285"><code>						// between different Ps.</code></span>
<span class="codeline" id="line-5286"><code>						// A sync chan send/recv takes ~50ns as of time of</code></span>
<span class="codeline" id="line-5287"><code>						// writing, so 3us gives ~50x overshoot.</code></span>
<span class="codeline" id="line-5288"><code>						if GOOS != "windows" {</code></span>
<span class="codeline" id="line-5289"><code>							usleep(3)</code></span>
<span class="codeline" id="line-5290"><code>						} else {</code></span>
<span class="codeline" id="line-5291"><code>							// On windows system timer granularity is</code></span>
<span class="codeline" id="line-5292"><code>							// 1-15ms, which is way too much for this</code></span>
<span class="codeline" id="line-5293"><code>							// optimization. So just yield.</code></span>
<span class="codeline" id="line-5294"><code>							osyield()</code></span>
<span class="codeline" id="line-5295"><code>						}</code></span>
<span class="codeline" id="line-5296"><code>					}</code></span>
<span class="codeline" id="line-5297"><code>					if !_p_.runnext.cas(next, 0) {</code></span>
<span class="codeline" id="line-5298"><code>						continue</code></span>
<span class="codeline" id="line-5299"><code>					}</code></span>
<span class="codeline" id="line-5300"><code>					batch[batchHead%uint32(len(batch))] = next</code></span>
<span class="codeline" id="line-5301"><code>					return 1</code></span>
<span class="codeline" id="line-5302"><code>				}</code></span>
<span class="codeline" id="line-5303"><code>			}</code></span>
<span class="codeline" id="line-5304"><code>			return 0</code></span>
<span class="codeline" id="line-5305"><code>		}</code></span>
<span class="codeline" id="line-5306"><code>		if n &gt; uint32(len(_p_.runq)/2) { // read inconsistent h and t</code></span>
<span class="codeline" id="line-5307"><code>			continue</code></span>
<span class="codeline" id="line-5308"><code>		}</code></span>
<span class="codeline" id="line-5309"><code>		for i := uint32(0); i &lt; n; i++ {</code></span>
<span class="codeline" id="line-5310"><code>			g := _p_.runq[(h+i)%uint32(len(_p_.runq))]</code></span>
<span class="codeline" id="line-5311"><code>			batch[(batchHead+i)%uint32(len(batch))] = g</code></span>
<span class="codeline" id="line-5312"><code>		}</code></span>
<span class="codeline" id="line-5313"><code>		if atomic.CasRel(&amp;_p_.runqhead, h, h+n) { // cas-release, commits consume</code></span>
<span class="codeline" id="line-5314"><code>			return n</code></span>
<span class="codeline" id="line-5315"><code>		}</code></span>
<span class="codeline" id="line-5316"><code>	}</code></span>
<span class="codeline" id="line-5317"><code>}</code></span>
<span class="codeline" id="line-5318"><code></code></span>
<span class="codeline" id="line-5319"><code>// Steal half of elements from local runnable queue of p2</code></span>
<span class="codeline" id="line-5320"><code>// and put onto local runnable queue of p.</code></span>
<span class="codeline" id="line-5321"><code>// Returns one of the stolen elements (or nil if failed).</code></span>
<span class="codeline" id="line-5322"><code>func runqsteal(_p_, p2 *p, stealRunNextG bool) *g {</code></span>
<span class="codeline" id="line-5323"><code>	t := _p_.runqtail</code></span>
<span class="codeline" id="line-5324"><code>	n := runqgrab(p2, &amp;_p_.runq, t, stealRunNextG)</code></span>
<span class="codeline" id="line-5325"><code>	if n == 0 {</code></span>
<span class="codeline" id="line-5326"><code>		return nil</code></span>
<span class="codeline" id="line-5327"><code>	}</code></span>
<span class="codeline" id="line-5328"><code>	n--</code></span>
<span class="codeline" id="line-5329"><code>	gp := _p_.runq[(t+n)%uint32(len(_p_.runq))].ptr()</code></span>
<span class="codeline" id="line-5330"><code>	if n == 0 {</code></span>
<span class="codeline" id="line-5331"><code>		return gp</code></span>
<span class="codeline" id="line-5332"><code>	}</code></span>
<span class="codeline" id="line-5333"><code>	h := atomic.LoadAcq(&amp;_p_.runqhead) // load-acquire, synchronize with consumers</code></span>
<span class="codeline" id="line-5334"><code>	if t-h+n &gt;= uint32(len(_p_.runq)) {</code></span>
<span class="codeline" id="line-5335"><code>		throw("runqsteal: runq overflow")</code></span>
<span class="codeline" id="line-5336"><code>	}</code></span>
<span class="codeline" id="line-5337"><code>	atomic.StoreRel(&amp;_p_.runqtail, t+n) // store-release, makes the item available for consumption</code></span>
<span class="codeline" id="line-5338"><code>	return gp</code></span>
<span class="codeline" id="line-5339"><code>}</code></span>
<span class="codeline" id="line-5340"><code></code></span>
<span class="codeline" id="line-5341"><code>// A gQueue is a dequeue of Gs linked through g.schedlink. A G can only</code></span>
<span class="codeline" id="line-5342"><code>// be on one gQueue or gList at a time.</code></span>
<span class="codeline" id="line-5343"><code>type gQueue struct {</code></span>
<span class="codeline" id="line-5344"><code>	head guintptr</code></span>
<span class="codeline" id="line-5345"><code>	tail guintptr</code></span>
<span class="codeline" id="line-5346"><code>}</code></span>
<span class="codeline" id="line-5347"><code></code></span>
<span class="codeline" id="line-5348"><code>// empty reports whether q is empty.</code></span>
<span class="codeline" id="line-5349"><code>func (q *gQueue) empty() bool {</code></span>
<span class="codeline" id="line-5350"><code>	return q.head == 0</code></span>
<span class="codeline" id="line-5351"><code>}</code></span>
<span class="codeline" id="line-5352"><code></code></span>
<span class="codeline" id="line-5353"><code>// push adds gp to the head of q.</code></span>
<span class="codeline" id="line-5354"><code>func (q *gQueue) push(gp *g) {</code></span>
<span class="codeline" id="line-5355"><code>	gp.schedlink = q.head</code></span>
<span class="codeline" id="line-5356"><code>	q.head.set(gp)</code></span>
<span class="codeline" id="line-5357"><code>	if q.tail == 0 {</code></span>
<span class="codeline" id="line-5358"><code>		q.tail.set(gp)</code></span>
<span class="codeline" id="line-5359"><code>	}</code></span>
<span class="codeline" id="line-5360"><code>}</code></span>
<span class="codeline" id="line-5361"><code></code></span>
<span class="codeline" id="line-5362"><code>// pushBack adds gp to the tail of q.</code></span>
<span class="codeline" id="line-5363"><code>func (q *gQueue) pushBack(gp *g) {</code></span>
<span class="codeline" id="line-5364"><code>	gp.schedlink = 0</code></span>
<span class="codeline" id="line-5365"><code>	if q.tail != 0 {</code></span>
<span class="codeline" id="line-5366"><code>		q.tail.ptr().schedlink.set(gp)</code></span>
<span class="codeline" id="line-5367"><code>	} else {</code></span>
<span class="codeline" id="line-5368"><code>		q.head.set(gp)</code></span>
<span class="codeline" id="line-5369"><code>	}</code></span>
<span class="codeline" id="line-5370"><code>	q.tail.set(gp)</code></span>
<span class="codeline" id="line-5371"><code>}</code></span>
<span class="codeline" id="line-5372"><code></code></span>
<span class="codeline" id="line-5373"><code>// pushBackAll adds all Gs in l2 to the tail of q. After this q2 must</code></span>
<span class="codeline" id="line-5374"><code>// not be used.</code></span>
<span class="codeline" id="line-5375"><code>func (q *gQueue) pushBackAll(q2 gQueue) {</code></span>
<span class="codeline" id="line-5376"><code>	if q2.tail == 0 {</code></span>
<span class="codeline" id="line-5377"><code>		return</code></span>
<span class="codeline" id="line-5378"><code>	}</code></span>
<span class="codeline" id="line-5379"><code>	q2.tail.ptr().schedlink = 0</code></span>
<span class="codeline" id="line-5380"><code>	if q.tail != 0 {</code></span>
<span class="codeline" id="line-5381"><code>		q.tail.ptr().schedlink = q2.head</code></span>
<span class="codeline" id="line-5382"><code>	} else {</code></span>
<span class="codeline" id="line-5383"><code>		q.head = q2.head</code></span>
<span class="codeline" id="line-5384"><code>	}</code></span>
<span class="codeline" id="line-5385"><code>	q.tail = q2.tail</code></span>
<span class="codeline" id="line-5386"><code>}</code></span>
<span class="codeline" id="line-5387"><code></code></span>
<span class="codeline" id="line-5388"><code>// pop removes and returns the head of queue q. It returns nil if</code></span>
<span class="codeline" id="line-5389"><code>// q is empty.</code></span>
<span class="codeline" id="line-5390"><code>func (q *gQueue) pop() *g {</code></span>
<span class="codeline" id="line-5391"><code>	gp := q.head.ptr()</code></span>
<span class="codeline" id="line-5392"><code>	if gp != nil {</code></span>
<span class="codeline" id="line-5393"><code>		q.head = gp.schedlink</code></span>
<span class="codeline" id="line-5394"><code>		if q.head == 0 {</code></span>
<span class="codeline" id="line-5395"><code>			q.tail = 0</code></span>
<span class="codeline" id="line-5396"><code>		}</code></span>
<span class="codeline" id="line-5397"><code>	}</code></span>
<span class="codeline" id="line-5398"><code>	return gp</code></span>
<span class="codeline" id="line-5399"><code>}</code></span>
<span class="codeline" id="line-5400"><code></code></span>
<span class="codeline" id="line-5401"><code>// popList takes all Gs in q and returns them as a gList.</code></span>
<span class="codeline" id="line-5402"><code>func (q *gQueue) popList() gList {</code></span>
<span class="codeline" id="line-5403"><code>	stack := gList{q.head}</code></span>
<span class="codeline" id="line-5404"><code>	*q = gQueue{}</code></span>
<span class="codeline" id="line-5405"><code>	return stack</code></span>
<span class="codeline" id="line-5406"><code>}</code></span>
<span class="codeline" id="line-5407"><code></code></span>
<span class="codeline" id="line-5408"><code>// A gList is a list of Gs linked through g.schedlink. A G can only be</code></span>
<span class="codeline" id="line-5409"><code>// on one gQueue or gList at a time.</code></span>
<span class="codeline" id="line-5410"><code>type gList struct {</code></span>
<span class="codeline" id="line-5411"><code>	head guintptr</code></span>
<span class="codeline" id="line-5412"><code>}</code></span>
<span class="codeline" id="line-5413"><code></code></span>
<span class="codeline" id="line-5414"><code>// empty reports whether l is empty.</code></span>
<span class="codeline" id="line-5415"><code>func (l *gList) empty() bool {</code></span>
<span class="codeline" id="line-5416"><code>	return l.head == 0</code></span>
<span class="codeline" id="line-5417"><code>}</code></span>
<span class="codeline" id="line-5418"><code></code></span>
<span class="codeline" id="line-5419"><code>// push adds gp to the head of l.</code></span>
<span class="codeline" id="line-5420"><code>func (l *gList) push(gp *g) {</code></span>
<span class="codeline" id="line-5421"><code>	gp.schedlink = l.head</code></span>
<span class="codeline" id="line-5422"><code>	l.head.set(gp)</code></span>
<span class="codeline" id="line-5423"><code>}</code></span>
<span class="codeline" id="line-5424"><code></code></span>
<span class="codeline" id="line-5425"><code>// pushAll prepends all Gs in q to l.</code></span>
<span class="codeline" id="line-5426"><code>func (l *gList) pushAll(q gQueue) {</code></span>
<span class="codeline" id="line-5427"><code>	if !q.empty() {</code></span>
<span class="codeline" id="line-5428"><code>		q.tail.ptr().schedlink = l.head</code></span>
<span class="codeline" id="line-5429"><code>		l.head = q.head</code></span>
<span class="codeline" id="line-5430"><code>	}</code></span>
<span class="codeline" id="line-5431"><code>}</code></span>
<span class="codeline" id="line-5432"><code></code></span>
<span class="codeline" id="line-5433"><code>// pop removes and returns the head of l. If l is empty, it returns nil.</code></span>
<span class="codeline" id="line-5434"><code>func (l *gList) pop() *g {</code></span>
<span class="codeline" id="line-5435"><code>	gp := l.head.ptr()</code></span>
<span class="codeline" id="line-5436"><code>	if gp != nil {</code></span>
<span class="codeline" id="line-5437"><code>		l.head = gp.schedlink</code></span>
<span class="codeline" id="line-5438"><code>	}</code></span>
<span class="codeline" id="line-5439"><code>	return gp</code></span>
<span class="codeline" id="line-5440"><code>}</code></span>
<span class="codeline" id="line-5441"><code></code></span>
<span class="codeline" id="line-5442"><code>//go:linkname setMaxThreads runtime/debug.setMaxThreads</code></span>
<span class="codeline" id="line-5443"><code>func setMaxThreads(in int) (out int) {</code></span>
<span class="codeline" id="line-5444"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-5445"><code>	out = int(sched.maxmcount)</code></span>
<span class="codeline" id="line-5446"><code>	if in &gt; 0x7fffffff { // MaxInt32</code></span>
<span class="codeline" id="line-5447"><code>		sched.maxmcount = 0x7fffffff</code></span>
<span class="codeline" id="line-5448"><code>	} else {</code></span>
<span class="codeline" id="line-5449"><code>		sched.maxmcount = int32(in)</code></span>
<span class="codeline" id="line-5450"><code>	}</code></span>
<span class="codeline" id="line-5451"><code>	checkmcount()</code></span>
<span class="codeline" id="line-5452"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-5453"><code>	return</code></span>
<span class="codeline" id="line-5454"><code>}</code></span>
<span class="codeline" id="line-5455"><code></code></span>
<span class="codeline" id="line-5456"><code>func haveexperiment(name string) bool {</code></span>
<span class="codeline" id="line-5457"><code>	if name == "framepointer" {</code></span>
<span class="codeline" id="line-5458"><code>		return framepointer_enabled // set by linker</code></span>
<span class="codeline" id="line-5459"><code>	}</code></span>
<span class="codeline" id="line-5460"><code>	x := sys.Goexperiment</code></span>
<span class="codeline" id="line-5461"><code>	for x != "" {</code></span>
<span class="codeline" id="line-5462"><code>		xname := ""</code></span>
<span class="codeline" id="line-5463"><code>		i := index(x, ",")</code></span>
<span class="codeline" id="line-5464"><code>		if i &lt; 0 {</code></span>
<span class="codeline" id="line-5465"><code>			xname, x = x, ""</code></span>
<span class="codeline" id="line-5466"><code>		} else {</code></span>
<span class="codeline" id="line-5467"><code>			xname, x = x[:i], x[i+1:]</code></span>
<span class="codeline" id="line-5468"><code>		}</code></span>
<span class="codeline" id="line-5469"><code>		if xname == name {</code></span>
<span class="codeline" id="line-5470"><code>			return true</code></span>
<span class="codeline" id="line-5471"><code>		}</code></span>
<span class="codeline" id="line-5472"><code>		if len(xname) &gt; 2 &amp;&amp; xname[:2] == "no" &amp;&amp; xname[2:] == name {</code></span>
<span class="codeline" id="line-5473"><code>			return false</code></span>
<span class="codeline" id="line-5474"><code>		}</code></span>
<span class="codeline" id="line-5475"><code>	}</code></span>
<span class="codeline" id="line-5476"><code>	return false</code></span>
<span class="codeline" id="line-5477"><code>}</code></span>
<span class="codeline" id="line-5478"><code></code></span>
<span class="codeline" id="line-5479"><code>//go:nosplit</code></span>
<span class="codeline" id="line-5480"><code>func procPin() int {</code></span>
<span class="codeline" id="line-5481"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-5482"><code>	mp := _g_.m</code></span>
<span class="codeline" id="line-5483"><code></code></span>
<span class="codeline" id="line-5484"><code>	mp.locks++</code></span>
<span class="codeline" id="line-5485"><code>	return int(mp.p.ptr().id)</code></span>
<span class="codeline" id="line-5486"><code>}</code></span>
<span class="codeline" id="line-5487"><code></code></span>
<span class="codeline" id="line-5488"><code>//go:nosplit</code></span>
<span class="codeline" id="line-5489"><code>func procUnpin() {</code></span>
<span class="codeline" id="line-5490"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-5491"><code>	_g_.m.locks--</code></span>
<span class="codeline" id="line-5492"><code>}</code></span>
<span class="codeline" id="line-5493"><code></code></span>
<span class="codeline" id="line-5494"><code>//go:linkname sync_runtime_procPin sync.runtime_procPin</code></span>
<span class="codeline" id="line-5495"><code>//go:nosplit</code></span>
<span class="codeline" id="line-5496"><code>func sync_runtime_procPin() int {</code></span>
<span class="codeline" id="line-5497"><code>	return procPin()</code></span>
<span class="codeline" id="line-5498"><code>}</code></span>
<span class="codeline" id="line-5499"><code></code></span>
<span class="codeline" id="line-5500"><code>//go:linkname sync_runtime_procUnpin sync.runtime_procUnpin</code></span>
<span class="codeline" id="line-5501"><code>//go:nosplit</code></span>
<span class="codeline" id="line-5502"><code>func sync_runtime_procUnpin() {</code></span>
<span class="codeline" id="line-5503"><code>	procUnpin()</code></span>
<span class="codeline" id="line-5504"><code>}</code></span>
<span class="codeline" id="line-5505"><code></code></span>
<span class="codeline" id="line-5506"><code>//go:linkname sync_atomic_runtime_procPin sync/atomic.runtime_procPin</code></span>
<span class="codeline" id="line-5507"><code>//go:nosplit</code></span>
<span class="codeline" id="line-5508"><code>func sync_atomic_runtime_procPin() int {</code></span>
<span class="codeline" id="line-5509"><code>	return procPin()</code></span>
<span class="codeline" id="line-5510"><code>}</code></span>
<span class="codeline" id="line-5511"><code></code></span>
<span class="codeline" id="line-5512"><code>//go:linkname sync_atomic_runtime_procUnpin sync/atomic.runtime_procUnpin</code></span>
<span class="codeline" id="line-5513"><code>//go:nosplit</code></span>
<span class="codeline" id="line-5514"><code>func sync_atomic_runtime_procUnpin() {</code></span>
<span class="codeline" id="line-5515"><code>	procUnpin()</code></span>
<span class="codeline" id="line-5516"><code>}</code></span>
<span class="codeline" id="line-5517"><code></code></span>
<span class="codeline" id="line-5518"><code>// Active spinning for sync.Mutex.</code></span>
<span class="codeline" id="line-5519"><code>//go:linkname sync_runtime_canSpin sync.runtime_canSpin</code></span>
<span class="codeline" id="line-5520"><code>//go:nosplit</code></span>
<span class="codeline" id="line-5521"><code>func sync_runtime_canSpin(i int) bool {</code></span>
<span class="codeline" id="line-5522"><code>	// sync.Mutex is cooperative, so we are conservative with spinning.</code></span>
<span class="codeline" id="line-5523"><code>	// Spin only few times and only if running on a multicore machine and</code></span>
<span class="codeline" id="line-5524"><code>	// GOMAXPROCS&gt;1 and there is at least one other running P and local runq is empty.</code></span>
<span class="codeline" id="line-5525"><code>	// As opposed to runtime mutex we don't do passive spinning here,</code></span>
<span class="codeline" id="line-5526"><code>	// because there can be work on global runq or on other Ps.</code></span>
<span class="codeline" id="line-5527"><code>	if i &gt;= active_spin || ncpu &lt;= 1 || gomaxprocs &lt;= int32(sched.npidle+sched.nmspinning)+1 {</code></span>
<span class="codeline" id="line-5528"><code>		return false</code></span>
<span class="codeline" id="line-5529"><code>	}</code></span>
<span class="codeline" id="line-5530"><code>	if p := getg().m.p.ptr(); !runqempty(p) {</code></span>
<span class="codeline" id="line-5531"><code>		return false</code></span>
<span class="codeline" id="line-5532"><code>	}</code></span>
<span class="codeline" id="line-5533"><code>	return true</code></span>
<span class="codeline" id="line-5534"><code>}</code></span>
<span class="codeline" id="line-5535"><code></code></span>
<span class="codeline" id="line-5536"><code>//go:linkname sync_runtime_doSpin sync.runtime_doSpin</code></span>
<span class="codeline" id="line-5537"><code>//go:nosplit</code></span>
<span class="codeline" id="line-5538"><code>func sync_runtime_doSpin() {</code></span>
<span class="codeline" id="line-5539"><code>	procyield(active_spin_cnt)</code></span>
<span class="codeline" id="line-5540"><code>}</code></span>
<span class="codeline" id="line-5541"><code></code></span>
<span class="codeline" id="line-5542"><code>var stealOrder randomOrder</code></span>
<span class="codeline" id="line-5543"><code></code></span>
<span class="codeline" id="line-5544"><code>// randomOrder/randomEnum are helper types for randomized work stealing.</code></span>
<span class="codeline" id="line-5545"><code>// They allow to enumerate all Ps in different pseudo-random orders without repetitions.</code></span>
<span class="codeline" id="line-5546"><code>// The algorithm is based on the fact that if we have X such that X and GOMAXPROCS</code></span>
<span class="codeline" id="line-5547"><code>// are coprime, then a sequences of (i + X) % GOMAXPROCS gives the required enumeration.</code></span>
<span class="codeline" id="line-5548"><code>type randomOrder struct {</code></span>
<span class="codeline" id="line-5549"><code>	count    uint32</code></span>
<span class="codeline" id="line-5550"><code>	coprimes []uint32</code></span>
<span class="codeline" id="line-5551"><code>}</code></span>
<span class="codeline" id="line-5552"><code></code></span>
<span class="codeline" id="line-5553"><code>type randomEnum struct {</code></span>
<span class="codeline" id="line-5554"><code>	i     uint32</code></span>
<span class="codeline" id="line-5555"><code>	count uint32</code></span>
<span class="codeline" id="line-5556"><code>	pos   uint32</code></span>
<span class="codeline" id="line-5557"><code>	inc   uint32</code></span>
<span class="codeline" id="line-5558"><code>}</code></span>
<span class="codeline" id="line-5559"><code></code></span>
<span class="codeline" id="line-5560"><code>func (ord *randomOrder) reset(count uint32) {</code></span>
<span class="codeline" id="line-5561"><code>	ord.count = count</code></span>
<span class="codeline" id="line-5562"><code>	ord.coprimes = ord.coprimes[:0]</code></span>
<span class="codeline" id="line-5563"><code>	for i := uint32(1); i &lt;= count; i++ {</code></span>
<span class="codeline" id="line-5564"><code>		if gcd(i, count) == 1 {</code></span>
<span class="codeline" id="line-5565"><code>			ord.coprimes = append(ord.coprimes, i)</code></span>
<span class="codeline" id="line-5566"><code>		}</code></span>
<span class="codeline" id="line-5567"><code>	}</code></span>
<span class="codeline" id="line-5568"><code>}</code></span>
<span class="codeline" id="line-5569"><code></code></span>
<span class="codeline" id="line-5570"><code>func (ord *randomOrder) start(i uint32) randomEnum {</code></span>
<span class="codeline" id="line-5571"><code>	return randomEnum{</code></span>
<span class="codeline" id="line-5572"><code>		count: ord.count,</code></span>
<span class="codeline" id="line-5573"><code>		pos:   i % ord.count,</code></span>
<span class="codeline" id="line-5574"><code>		inc:   ord.coprimes[i%uint32(len(ord.coprimes))],</code></span>
<span class="codeline" id="line-5575"><code>	}</code></span>
<span class="codeline" id="line-5576"><code>}</code></span>
<span class="codeline" id="line-5577"><code></code></span>
<span class="codeline" id="line-5578"><code>func (enum *randomEnum) done() bool {</code></span>
<span class="codeline" id="line-5579"><code>	return enum.i == enum.count</code></span>
<span class="codeline" id="line-5580"><code>}</code></span>
<span class="codeline" id="line-5581"><code></code></span>
<span class="codeline" id="line-5582"><code>func (enum *randomEnum) next() {</code></span>
<span class="codeline" id="line-5583"><code>	enum.i++</code></span>
<span class="codeline" id="line-5584"><code>	enum.pos = (enum.pos + enum.inc) % enum.count</code></span>
<span class="codeline" id="line-5585"><code>}</code></span>
<span class="codeline" id="line-5586"><code></code></span>
<span class="codeline" id="line-5587"><code>func (enum *randomEnum) position() uint32 {</code></span>
<span class="codeline" id="line-5588"><code>	return enum.pos</code></span>
<span class="codeline" id="line-5589"><code>}</code></span>
<span class="codeline" id="line-5590"><code></code></span>
<span class="codeline" id="line-5591"><code>func gcd(a, b uint32) uint32 {</code></span>
<span class="codeline" id="line-5592"><code>	for b != 0 {</code></span>
<span class="codeline" id="line-5593"><code>		a, b = b, a%b</code></span>
<span class="codeline" id="line-5594"><code>	}</code></span>
<span class="codeline" id="line-5595"><code>	return a</code></span>
<span class="codeline" id="line-5596"><code>}</code></span>
<span class="codeline" id="line-5597"><code></code></span>
<span class="codeline" id="line-5598"><code>// An initTask represents the set of initializations that need to be done for a package.</code></span>
<span class="codeline" id="line-5599"><code>// Keep in sync with ../../test/initempty.go:initTask</code></span>
<span class="codeline" id="line-5600"><code>type initTask struct {</code></span>
<span class="codeline" id="line-5601"><code>	// TODO: pack the first 3 fields more tightly?</code></span>
<span class="codeline" id="line-5602"><code>	state uintptr // 0 = uninitialized, 1 = in progress, 2 = done</code></span>
<span class="codeline" id="line-5603"><code>	ndeps uintptr</code></span>
<span class="codeline" id="line-5604"><code>	nfns  uintptr</code></span>
<span class="codeline" id="line-5605"><code>	// followed by ndeps instances of an *initTask, one per package depended on</code></span>
<span class="codeline" id="line-5606"><code>	// followed by nfns pcs, one per init function to run</code></span>
<span class="codeline" id="line-5607"><code>}</code></span>
<span class="codeline" id="line-5608"><code></code></span>
<span class="codeline" id="line-5609"><code>func doInit(t *initTask) {</code></span>
<span class="codeline" id="line-5610"><code>	switch t.state {</code></span>
<span class="codeline" id="line-5611"><code>	case 2: // fully initialized</code></span>
<span class="codeline" id="line-5612"><code>		return</code></span>
<span class="codeline" id="line-5613"><code>	case 1: // initialization in progress</code></span>
<span class="codeline" id="line-5614"><code>		throw("recursive call during initialization - linker skew")</code></span>
<span class="codeline" id="line-5615"><code>	default: // not initialized yet</code></span>
<span class="codeline" id="line-5616"><code>		t.state = 1 // initialization in progress</code></span>
<span class="codeline" id="line-5617"><code>		for i := uintptr(0); i &lt; t.ndeps; i++ {</code></span>
<span class="codeline" id="line-5618"><code>			p := add(unsafe.Pointer(t), (3+i)*sys.PtrSize)</code></span>
<span class="codeline" id="line-5619"><code>			t2 := *(**initTask)(p)</code></span>
<span class="codeline" id="line-5620"><code>			doInit(t2)</code></span>
<span class="codeline" id="line-5621"><code>		}</code></span>
<span class="codeline" id="line-5622"><code>		for i := uintptr(0); i &lt; t.nfns; i++ {</code></span>
<span class="codeline" id="line-5623"><code>			p := add(unsafe.Pointer(t), (3+t.ndeps+i)*sys.PtrSize)</code></span>
<span class="codeline" id="line-5624"><code>			f := *(*func())(unsafe.Pointer(&amp;p))</code></span>
<span class="codeline" id="line-5625"><code>			f()</code></span>
<span class="codeline" id="line-5626"><code>		}</code></span>
<span class="codeline" id="line-5627"><code>		t.state = 2 // initialization done</code></span>
<span class="codeline" id="line-5628"><code>	}</code></span>
<span class="codeline" id="line-5629"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.1.6</i>. (GOOS=darwin GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project and developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table
</pre>
</div></body></html>