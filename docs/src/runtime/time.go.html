<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: time.go in package runtime</title>
<link href="../../css/light-v0.1.6.css" rel="stylesheet">
<script src="../../jvs/golds-v0.1.6.js"></script>
<body><div>

<pre id="header"><code><span class="title">Source File</span>
	time.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/runtime.html">runtime</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>// Time-related runtime and pieces of package time.</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>package runtime</code></span>
<span class="codeline" id="line-8"><code></code></span>
<span class="codeline" id="line-9"><code>import (</code></span>
<span class="codeline" id="line-10"><code>	"runtime/internal/atomic"</code></span>
<span class="codeline" id="line-11"><code>	"runtime/internal/sys"</code></span>
<span class="codeline" id="line-12"><code>	"unsafe"</code></span>
<span class="codeline" id="line-13"><code>)</code></span>
<span class="codeline" id="line-14"><code></code></span>
<span class="codeline" id="line-15"><code>// Package time knows the layout of this structure.</code></span>
<span class="codeline" id="line-16"><code>// If this struct changes, adjust ../time/sleep.go:/runtimeTimer.</code></span>
<span class="codeline" id="line-17"><code>type timer struct {</code></span>
<span class="codeline" id="line-18"><code>	// If this timer is on a heap, which P's heap it is on.</code></span>
<span class="codeline" id="line-19"><code>	// puintptr rather than *p to match uintptr in the versions</code></span>
<span class="codeline" id="line-20"><code>	// of this struct defined in other packages.</code></span>
<span class="codeline" id="line-21"><code>	pp puintptr</code></span>
<span class="codeline" id="line-22"><code></code></span>
<span class="codeline" id="line-23"><code>	// Timer wakes up at when, and then at when+period, ... (period &gt; 0 only)</code></span>
<span class="codeline" id="line-24"><code>	// each time calling f(arg, now) in the timer goroutine, so f must be</code></span>
<span class="codeline" id="line-25"><code>	// a well-behaved function and not block.</code></span>
<span class="codeline" id="line-26"><code>	when   int64</code></span>
<span class="codeline" id="line-27"><code>	period int64</code></span>
<span class="codeline" id="line-28"><code>	f      func(interface{}, uintptr)</code></span>
<span class="codeline" id="line-29"><code>	arg    interface{}</code></span>
<span class="codeline" id="line-30"><code>	seq    uintptr</code></span>
<span class="codeline" id="line-31"><code></code></span>
<span class="codeline" id="line-32"><code>	// What to set the when field to in timerModifiedXX status.</code></span>
<span class="codeline" id="line-33"><code>	nextwhen int64</code></span>
<span class="codeline" id="line-34"><code></code></span>
<span class="codeline" id="line-35"><code>	// The status field holds one of the values below.</code></span>
<span class="codeline" id="line-36"><code>	status uint32</code></span>
<span class="codeline" id="line-37"><code>}</code></span>
<span class="codeline" id="line-38"><code></code></span>
<span class="codeline" id="line-39"><code>// Code outside this file has to be careful in using a timer value.</code></span>
<span class="codeline" id="line-40"><code>//</code></span>
<span class="codeline" id="line-41"><code>// The pp, status, and nextwhen fields may only be used by code in this file.</code></span>
<span class="codeline" id="line-42"><code>//</code></span>
<span class="codeline" id="line-43"><code>// Code that creates a new timer value can set the when, period, f,</code></span>
<span class="codeline" id="line-44"><code>// arg, and seq fields.</code></span>
<span class="codeline" id="line-45"><code>// A new timer value may be passed to addtimer (called by time.startTimer).</code></span>
<span class="codeline" id="line-46"><code>// After doing that no fields may be touched.</code></span>
<span class="codeline" id="line-47"><code>//</code></span>
<span class="codeline" id="line-48"><code>// An active timer (one that has been passed to addtimer) may be</code></span>
<span class="codeline" id="line-49"><code>// passed to deltimer (time.stopTimer), after which it is no longer an</code></span>
<span class="codeline" id="line-50"><code>// active timer. It is an inactive timer.</code></span>
<span class="codeline" id="line-51"><code>// In an inactive timer the period, f, arg, and seq fields may be modified,</code></span>
<span class="codeline" id="line-52"><code>// but not the when field.</code></span>
<span class="codeline" id="line-53"><code>// It's OK to just drop an inactive timer and let the GC collect it.</code></span>
<span class="codeline" id="line-54"><code>// It's not OK to pass an inactive timer to addtimer.</code></span>
<span class="codeline" id="line-55"><code>// Only newly allocated timer values may be passed to addtimer.</code></span>
<span class="codeline" id="line-56"><code>//</code></span>
<span class="codeline" id="line-57"><code>// An active timer may be passed to modtimer. No fields may be touched.</code></span>
<span class="codeline" id="line-58"><code>// It remains an active timer.</code></span>
<span class="codeline" id="line-59"><code>//</code></span>
<span class="codeline" id="line-60"><code>// An inactive timer may be passed to resettimer to turn into an</code></span>
<span class="codeline" id="line-61"><code>// active timer with an updated when field.</code></span>
<span class="codeline" id="line-62"><code>// It's OK to pass a newly allocated timer value to resettimer.</code></span>
<span class="codeline" id="line-63"><code>//</code></span>
<span class="codeline" id="line-64"><code>// Timer operations are addtimer, deltimer, modtimer, resettimer,</code></span>
<span class="codeline" id="line-65"><code>// cleantimers, adjusttimers, and runtimer.</code></span>
<span class="codeline" id="line-66"><code>//</code></span>
<span class="codeline" id="line-67"><code>// We don't permit calling addtimer/deltimer/modtimer/resettimer simultaneously,</code></span>
<span class="codeline" id="line-68"><code>// but adjusttimers and runtimer can be called at the same time as any of those.</code></span>
<span class="codeline" id="line-69"><code>//</code></span>
<span class="codeline" id="line-70"><code>// Active timers live in heaps attached to P, in the timers field.</code></span>
<span class="codeline" id="line-71"><code>// Inactive timers live there too temporarily, until they are removed.</code></span>
<span class="codeline" id="line-72"><code>//</code></span>
<span class="codeline" id="line-73"><code>// addtimer:</code></span>
<span class="codeline" id="line-74"><code>//   timerNoStatus   -&gt; timerWaiting</code></span>
<span class="codeline" id="line-75"><code>//   anything else   -&gt; panic: invalid value</code></span>
<span class="codeline" id="line-76"><code>// deltimer:</code></span>
<span class="codeline" id="line-77"><code>//   timerWaiting         -&gt; timerModifying -&gt; timerDeleted</code></span>
<span class="codeline" id="line-78"><code>//   timerModifiedEarlier -&gt; timerModifying -&gt; timerDeleted</code></span>
<span class="codeline" id="line-79"><code>//   timerModifiedLater   -&gt; timerModifying -&gt; timerDeleted</code></span>
<span class="codeline" id="line-80"><code>//   timerNoStatus        -&gt; do nothing</code></span>
<span class="codeline" id="line-81"><code>//   timerDeleted         -&gt; do nothing</code></span>
<span class="codeline" id="line-82"><code>//   timerRemoving        -&gt; do nothing</code></span>
<span class="codeline" id="line-83"><code>//   timerRemoved         -&gt; do nothing</code></span>
<span class="codeline" id="line-84"><code>//   timerRunning         -&gt; wait until status changes</code></span>
<span class="codeline" id="line-85"><code>//   timerMoving          -&gt; wait until status changes</code></span>
<span class="codeline" id="line-86"><code>//   timerModifying       -&gt; wait until status changes</code></span>
<span class="codeline" id="line-87"><code>// modtimer:</code></span>
<span class="codeline" id="line-88"><code>//   timerWaiting    -&gt; timerModifying -&gt; timerModifiedXX</code></span>
<span class="codeline" id="line-89"><code>//   timerModifiedXX -&gt; timerModifying -&gt; timerModifiedYY</code></span>
<span class="codeline" id="line-90"><code>//   timerNoStatus   -&gt; timerModifying -&gt; timerWaiting</code></span>
<span class="codeline" id="line-91"><code>//   timerRemoved    -&gt; timerModifying -&gt; timerWaiting</code></span>
<span class="codeline" id="line-92"><code>//   timerDeleted    -&gt; timerModifying -&gt; timerModifiedXX</code></span>
<span class="codeline" id="line-93"><code>//   timerRunning    -&gt; wait until status changes</code></span>
<span class="codeline" id="line-94"><code>//   timerMoving     -&gt; wait until status changes</code></span>
<span class="codeline" id="line-95"><code>//   timerRemoving   -&gt; wait until status changes</code></span>
<span class="codeline" id="line-96"><code>//   timerModifying  -&gt; wait until status changes</code></span>
<span class="codeline" id="line-97"><code>// cleantimers (looks in P's timer heap):</code></span>
<span class="codeline" id="line-98"><code>//   timerDeleted    -&gt; timerRemoving -&gt; timerRemoved</code></span>
<span class="codeline" id="line-99"><code>//   timerModifiedXX -&gt; timerMoving -&gt; timerWaiting</code></span>
<span class="codeline" id="line-100"><code>// adjusttimers (looks in P's timer heap):</code></span>
<span class="codeline" id="line-101"><code>//   timerDeleted    -&gt; timerRemoving -&gt; timerRemoved</code></span>
<span class="codeline" id="line-102"><code>//   timerModifiedXX -&gt; timerMoving -&gt; timerWaiting</code></span>
<span class="codeline" id="line-103"><code>// runtimer (looks in P's timer heap):</code></span>
<span class="codeline" id="line-104"><code>//   timerNoStatus   -&gt; panic: uninitialized timer</code></span>
<span class="codeline" id="line-105"><code>//   timerWaiting    -&gt; timerWaiting or</code></span>
<span class="codeline" id="line-106"><code>//   timerWaiting    -&gt; timerRunning -&gt; timerNoStatus or</code></span>
<span class="codeline" id="line-107"><code>//   timerWaiting    -&gt; timerRunning -&gt; timerWaiting</code></span>
<span class="codeline" id="line-108"><code>//   timerModifying  -&gt; wait until status changes</code></span>
<span class="codeline" id="line-109"><code>//   timerModifiedXX -&gt; timerMoving -&gt; timerWaiting</code></span>
<span class="codeline" id="line-110"><code>//   timerDeleted    -&gt; timerRemoving -&gt; timerRemoved</code></span>
<span class="codeline" id="line-111"><code>//   timerRunning    -&gt; panic: concurrent runtimer calls</code></span>
<span class="codeline" id="line-112"><code>//   timerRemoved    -&gt; panic: inconsistent timer heap</code></span>
<span class="codeline" id="line-113"><code>//   timerRemoving   -&gt; panic: inconsistent timer heap</code></span>
<span class="codeline" id="line-114"><code>//   timerMoving     -&gt; panic: inconsistent timer heap</code></span>
<span class="codeline" id="line-115"><code></code></span>
<span class="codeline" id="line-116"><code>// Values for the timer status field.</code></span>
<span class="codeline" id="line-117"><code>const (</code></span>
<span class="codeline" id="line-118"><code>	// Timer has no status set yet.</code></span>
<span class="codeline" id="line-119"><code>	timerNoStatus = iota</code></span>
<span class="codeline" id="line-120"><code></code></span>
<span class="codeline" id="line-121"><code>	// Waiting for timer to fire.</code></span>
<span class="codeline" id="line-122"><code>	// The timer is in some P's heap.</code></span>
<span class="codeline" id="line-123"><code>	timerWaiting</code></span>
<span class="codeline" id="line-124"><code></code></span>
<span class="codeline" id="line-125"><code>	// Running the timer function.</code></span>
<span class="codeline" id="line-126"><code>	// A timer will only have this status briefly.</code></span>
<span class="codeline" id="line-127"><code>	timerRunning</code></span>
<span class="codeline" id="line-128"><code></code></span>
<span class="codeline" id="line-129"><code>	// The timer is deleted and should be removed.</code></span>
<span class="codeline" id="line-130"><code>	// It should not be run, but it is still in some P's heap.</code></span>
<span class="codeline" id="line-131"><code>	timerDeleted</code></span>
<span class="codeline" id="line-132"><code></code></span>
<span class="codeline" id="line-133"><code>	// The timer is being removed.</code></span>
<span class="codeline" id="line-134"><code>	// The timer will only have this status briefly.</code></span>
<span class="codeline" id="line-135"><code>	timerRemoving</code></span>
<span class="codeline" id="line-136"><code></code></span>
<span class="codeline" id="line-137"><code>	// The timer has been stopped.</code></span>
<span class="codeline" id="line-138"><code>	// It is not in any P's heap.</code></span>
<span class="codeline" id="line-139"><code>	timerRemoved</code></span>
<span class="codeline" id="line-140"><code></code></span>
<span class="codeline" id="line-141"><code>	// The timer is being modified.</code></span>
<span class="codeline" id="line-142"><code>	// The timer will only have this status briefly.</code></span>
<span class="codeline" id="line-143"><code>	timerModifying</code></span>
<span class="codeline" id="line-144"><code></code></span>
<span class="codeline" id="line-145"><code>	// The timer has been modified to an earlier time.</code></span>
<span class="codeline" id="line-146"><code>	// The new when value is in the nextwhen field.</code></span>
<span class="codeline" id="line-147"><code>	// The timer is in some P's heap, possibly in the wrong place.</code></span>
<span class="codeline" id="line-148"><code>	timerModifiedEarlier</code></span>
<span class="codeline" id="line-149"><code></code></span>
<span class="codeline" id="line-150"><code>	// The timer has been modified to the same or a later time.</code></span>
<span class="codeline" id="line-151"><code>	// The new when value is in the nextwhen field.</code></span>
<span class="codeline" id="line-152"><code>	// The timer is in some P's heap, possibly in the wrong place.</code></span>
<span class="codeline" id="line-153"><code>	timerModifiedLater</code></span>
<span class="codeline" id="line-154"><code></code></span>
<span class="codeline" id="line-155"><code>	// The timer has been modified and is being moved.</code></span>
<span class="codeline" id="line-156"><code>	// The timer will only have this status briefly.</code></span>
<span class="codeline" id="line-157"><code>	timerMoving</code></span>
<span class="codeline" id="line-158"><code>)</code></span>
<span class="codeline" id="line-159"><code></code></span>
<span class="codeline" id="line-160"><code>// maxWhen is the maximum value for timer's when field.</code></span>
<span class="codeline" id="line-161"><code>const maxWhen = 1&lt;&lt;63 - 1</code></span>
<span class="codeline" id="line-162"><code></code></span>
<span class="codeline" id="line-163"><code>// verifyTimers can be set to true to add debugging checks that the</code></span>
<span class="codeline" id="line-164"><code>// timer heaps are valid.</code></span>
<span class="codeline" id="line-165"><code>const verifyTimers = false</code></span>
<span class="codeline" id="line-166"><code></code></span>
<span class="codeline" id="line-167"><code>// Package time APIs.</code></span>
<span class="codeline" id="line-168"><code>// Godoc uses the comments in package time, not these.</code></span>
<span class="codeline" id="line-169"><code></code></span>
<span class="codeline" id="line-170"><code>// time.now is implemented in assembly.</code></span>
<span class="codeline" id="line-171"><code></code></span>
<span class="codeline" id="line-172"><code>// timeSleep puts the current goroutine to sleep for at least ns nanoseconds.</code></span>
<span class="codeline" id="line-173"><code>//go:linkname timeSleep time.Sleep</code></span>
<span class="codeline" id="line-174"><code>func timeSleep(ns int64) {</code></span>
<span class="codeline" id="line-175"><code>	if ns &lt;= 0 {</code></span>
<span class="codeline" id="line-176"><code>		return</code></span>
<span class="codeline" id="line-177"><code>	}</code></span>
<span class="codeline" id="line-178"><code></code></span>
<span class="codeline" id="line-179"><code>	gp := getg()</code></span>
<span class="codeline" id="line-180"><code>	t := gp.timer</code></span>
<span class="codeline" id="line-181"><code>	if t == nil {</code></span>
<span class="codeline" id="line-182"><code>		t = new(timer)</code></span>
<span class="codeline" id="line-183"><code>		gp.timer = t</code></span>
<span class="codeline" id="line-184"><code>	}</code></span>
<span class="codeline" id="line-185"><code>	t.f = goroutineReady</code></span>
<span class="codeline" id="line-186"><code>	t.arg = gp</code></span>
<span class="codeline" id="line-187"><code>	t.nextwhen = nanotime() + ns</code></span>
<span class="codeline" id="line-188"><code>	gopark(resetForSleep, unsafe.Pointer(t), waitReasonSleep, traceEvGoSleep, 1)</code></span>
<span class="codeline" id="line-189"><code>}</code></span>
<span class="codeline" id="line-190"><code></code></span>
<span class="codeline" id="line-191"><code>// resetForSleep is called after the goroutine is parked for timeSleep.</code></span>
<span class="codeline" id="line-192"><code>// We can't call resettimer in timeSleep itself because if this is a short</code></span>
<span class="codeline" id="line-193"><code>// sleep and there are many goroutines then the P can wind up running the</code></span>
<span class="codeline" id="line-194"><code>// timer function, goroutineReady, before the goroutine has been parked.</code></span>
<span class="codeline" id="line-195"><code>func resetForSleep(gp *g, ut unsafe.Pointer) bool {</code></span>
<span class="codeline" id="line-196"><code>	t := (*timer)(ut)</code></span>
<span class="codeline" id="line-197"><code>	resettimer(t, t.nextwhen)</code></span>
<span class="codeline" id="line-198"><code>	return true</code></span>
<span class="codeline" id="line-199"><code>}</code></span>
<span class="codeline" id="line-200"><code></code></span>
<span class="codeline" id="line-201"><code>// startTimer adds t to the timer heap.</code></span>
<span class="codeline" id="line-202"><code>//go:linkname startTimer time.startTimer</code></span>
<span class="codeline" id="line-203"><code>func startTimer(t *timer) {</code></span>
<span class="codeline" id="line-204"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-205"><code>		racerelease(unsafe.Pointer(t))</code></span>
<span class="codeline" id="line-206"><code>	}</code></span>
<span class="codeline" id="line-207"><code>	addtimer(t)</code></span>
<span class="codeline" id="line-208"><code>}</code></span>
<span class="codeline" id="line-209"><code></code></span>
<span class="codeline" id="line-210"><code>// stopTimer stops a timer.</code></span>
<span class="codeline" id="line-211"><code>// It reports whether t was stopped before being run.</code></span>
<span class="codeline" id="line-212"><code>//go:linkname stopTimer time.stopTimer</code></span>
<span class="codeline" id="line-213"><code>func stopTimer(t *timer) bool {</code></span>
<span class="codeline" id="line-214"><code>	return deltimer(t)</code></span>
<span class="codeline" id="line-215"><code>}</code></span>
<span class="codeline" id="line-216"><code></code></span>
<span class="codeline" id="line-217"><code>// resetTimer resets an inactive timer, adding it to the heap.</code></span>
<span class="codeline" id="line-218"><code>//go:linkname resetTimer time.resetTimer</code></span>
<span class="codeline" id="line-219"><code>// Reports whether the timer was modified before it was run.</code></span>
<span class="codeline" id="line-220"><code>func resetTimer(t *timer, when int64) bool {</code></span>
<span class="codeline" id="line-221"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-222"><code>		racerelease(unsafe.Pointer(t))</code></span>
<span class="codeline" id="line-223"><code>	}</code></span>
<span class="codeline" id="line-224"><code>	return resettimer(t, when)</code></span>
<span class="codeline" id="line-225"><code>}</code></span>
<span class="codeline" id="line-226"><code></code></span>
<span class="codeline" id="line-227"><code>// modTimer modifies an existing timer.</code></span>
<span class="codeline" id="line-228"><code>//go:linkname modTimer time.modTimer</code></span>
<span class="codeline" id="line-229"><code>func modTimer(t *timer, when, period int64, f func(interface{}, uintptr), arg interface{}, seq uintptr) {</code></span>
<span class="codeline" id="line-230"><code>	modtimer(t, when, period, f, arg, seq)</code></span>
<span class="codeline" id="line-231"><code>}</code></span>
<span class="codeline" id="line-232"><code></code></span>
<span class="codeline" id="line-233"><code>// Go runtime.</code></span>
<span class="codeline" id="line-234"><code></code></span>
<span class="codeline" id="line-235"><code>// Ready the goroutine arg.</code></span>
<span class="codeline" id="line-236"><code>func goroutineReady(arg interface{}, seq uintptr) {</code></span>
<span class="codeline" id="line-237"><code>	goready(arg.(*g), 0)</code></span>
<span class="codeline" id="line-238"><code>}</code></span>
<span class="codeline" id="line-239"><code></code></span>
<span class="codeline" id="line-240"><code>// addtimer adds a timer to the current P.</code></span>
<span class="codeline" id="line-241"><code>// This should only be called with a newly created timer.</code></span>
<span class="codeline" id="line-242"><code>// That avoids the risk of changing the when field of a timer in some P's heap,</code></span>
<span class="codeline" id="line-243"><code>// which could cause the heap to become unsorted.</code></span>
<span class="codeline" id="line-244"><code>func addtimer(t *timer) {</code></span>
<span class="codeline" id="line-245"><code>	// when must never be negative; otherwise runtimer will overflow</code></span>
<span class="codeline" id="line-246"><code>	// during its delta calculation and never expire other runtime timers.</code></span>
<span class="codeline" id="line-247"><code>	if t.when &lt; 0 {</code></span>
<span class="codeline" id="line-248"><code>		t.when = maxWhen</code></span>
<span class="codeline" id="line-249"><code>	}</code></span>
<span class="codeline" id="line-250"><code>	if t.status != timerNoStatus {</code></span>
<span class="codeline" id="line-251"><code>		throw("addtimer called with initialized timer")</code></span>
<span class="codeline" id="line-252"><code>	}</code></span>
<span class="codeline" id="line-253"><code>	t.status = timerWaiting</code></span>
<span class="codeline" id="line-254"><code></code></span>
<span class="codeline" id="line-255"><code>	when := t.when</code></span>
<span class="codeline" id="line-256"><code></code></span>
<span class="codeline" id="line-257"><code>	pp := getg().m.p.ptr()</code></span>
<span class="codeline" id="line-258"><code>	lock(&amp;pp.timersLock)</code></span>
<span class="codeline" id="line-259"><code>	cleantimers(pp)</code></span>
<span class="codeline" id="line-260"><code>	doaddtimer(pp, t)</code></span>
<span class="codeline" id="line-261"><code>	unlock(&amp;pp.timersLock)</code></span>
<span class="codeline" id="line-262"><code></code></span>
<span class="codeline" id="line-263"><code>	wakeNetPoller(when)</code></span>
<span class="codeline" id="line-264"><code>}</code></span>
<span class="codeline" id="line-265"><code></code></span>
<span class="codeline" id="line-266"><code>// doaddtimer adds t to the current P's heap.</code></span>
<span class="codeline" id="line-267"><code>// The caller must have locked the timers for pp.</code></span>
<span class="codeline" id="line-268"><code>func doaddtimer(pp *p, t *timer) {</code></span>
<span class="codeline" id="line-269"><code>	// Timers rely on the network poller, so make sure the poller</code></span>
<span class="codeline" id="line-270"><code>	// has started.</code></span>
<span class="codeline" id="line-271"><code>	if netpollInited == 0 {</code></span>
<span class="codeline" id="line-272"><code>		netpollGenericInit()</code></span>
<span class="codeline" id="line-273"><code>	}</code></span>
<span class="codeline" id="line-274"><code></code></span>
<span class="codeline" id="line-275"><code>	if t.pp != 0 {</code></span>
<span class="codeline" id="line-276"><code>		throw("doaddtimer: P already set in timer")</code></span>
<span class="codeline" id="line-277"><code>	}</code></span>
<span class="codeline" id="line-278"><code>	t.pp.set(pp)</code></span>
<span class="codeline" id="line-279"><code>	i := len(pp.timers)</code></span>
<span class="codeline" id="line-280"><code>	pp.timers = append(pp.timers, t)</code></span>
<span class="codeline" id="line-281"><code>	siftupTimer(pp.timers, i)</code></span>
<span class="codeline" id="line-282"><code>	if t == pp.timers[0] {</code></span>
<span class="codeline" id="line-283"><code>		atomic.Store64(&amp;pp.timer0When, uint64(t.when))</code></span>
<span class="codeline" id="line-284"><code>	}</code></span>
<span class="codeline" id="line-285"><code>	atomic.Xadd(&amp;pp.numTimers, 1)</code></span>
<span class="codeline" id="line-286"><code>}</code></span>
<span class="codeline" id="line-287"><code></code></span>
<span class="codeline" id="line-288"><code>// deltimer deletes the timer t. It may be on some other P, so we can't</code></span>
<span class="codeline" id="line-289"><code>// actually remove it from the timers heap. We can only mark it as deleted.</code></span>
<span class="codeline" id="line-290"><code>// It will be removed in due course by the P whose heap it is on.</code></span>
<span class="codeline" id="line-291"><code>// Reports whether the timer was removed before it was run.</code></span>
<span class="codeline" id="line-292"><code>func deltimer(t *timer) bool {</code></span>
<span class="codeline" id="line-293"><code>	for {</code></span>
<span class="codeline" id="line-294"><code>		switch s := atomic.Load(&amp;t.status); s {</code></span>
<span class="codeline" id="line-295"><code>		case timerWaiting, timerModifiedLater:</code></span>
<span class="codeline" id="line-296"><code>			// Prevent preemption while the timer is in timerModifying.</code></span>
<span class="codeline" id="line-297"><code>			// This could lead to a self-deadlock. See #38070.</code></span>
<span class="codeline" id="line-298"><code>			mp := acquirem()</code></span>
<span class="codeline" id="line-299"><code>			if atomic.Cas(&amp;t.status, s, timerModifying) {</code></span>
<span class="codeline" id="line-300"><code>				// Must fetch t.pp before changing status,</code></span>
<span class="codeline" id="line-301"><code>				// as cleantimers in another goroutine</code></span>
<span class="codeline" id="line-302"><code>				// can clear t.pp of a timerDeleted timer.</code></span>
<span class="codeline" id="line-303"><code>				tpp := t.pp.ptr()</code></span>
<span class="codeline" id="line-304"><code>				if !atomic.Cas(&amp;t.status, timerModifying, timerDeleted) {</code></span>
<span class="codeline" id="line-305"><code>					badTimer()</code></span>
<span class="codeline" id="line-306"><code>				}</code></span>
<span class="codeline" id="line-307"><code>				releasem(mp)</code></span>
<span class="codeline" id="line-308"><code>				atomic.Xadd(&amp;tpp.deletedTimers, 1)</code></span>
<span class="codeline" id="line-309"><code>				// Timer was not yet run.</code></span>
<span class="codeline" id="line-310"><code>				return true</code></span>
<span class="codeline" id="line-311"><code>			} else {</code></span>
<span class="codeline" id="line-312"><code>				releasem(mp)</code></span>
<span class="codeline" id="line-313"><code>			}</code></span>
<span class="codeline" id="line-314"><code>		case timerModifiedEarlier:</code></span>
<span class="codeline" id="line-315"><code>			// Prevent preemption while the timer is in timerModifying.</code></span>
<span class="codeline" id="line-316"><code>			// This could lead to a self-deadlock. See #38070.</code></span>
<span class="codeline" id="line-317"><code>			mp := acquirem()</code></span>
<span class="codeline" id="line-318"><code>			if atomic.Cas(&amp;t.status, s, timerModifying) {</code></span>
<span class="codeline" id="line-319"><code>				// Must fetch t.pp before setting status</code></span>
<span class="codeline" id="line-320"><code>				// to timerDeleted.</code></span>
<span class="codeline" id="line-321"><code>				tpp := t.pp.ptr()</code></span>
<span class="codeline" id="line-322"><code>				atomic.Xadd(&amp;tpp.adjustTimers, -1)</code></span>
<span class="codeline" id="line-323"><code>				if !atomic.Cas(&amp;t.status, timerModifying, timerDeleted) {</code></span>
<span class="codeline" id="line-324"><code>					badTimer()</code></span>
<span class="codeline" id="line-325"><code>				}</code></span>
<span class="codeline" id="line-326"><code>				releasem(mp)</code></span>
<span class="codeline" id="line-327"><code>				atomic.Xadd(&amp;tpp.deletedTimers, 1)</code></span>
<span class="codeline" id="line-328"><code>				// Timer was not yet run.</code></span>
<span class="codeline" id="line-329"><code>				return true</code></span>
<span class="codeline" id="line-330"><code>			} else {</code></span>
<span class="codeline" id="line-331"><code>				releasem(mp)</code></span>
<span class="codeline" id="line-332"><code>			}</code></span>
<span class="codeline" id="line-333"><code>		case timerDeleted, timerRemoving, timerRemoved:</code></span>
<span class="codeline" id="line-334"><code>			// Timer was already run.</code></span>
<span class="codeline" id="line-335"><code>			return false</code></span>
<span class="codeline" id="line-336"><code>		case timerRunning, timerMoving:</code></span>
<span class="codeline" id="line-337"><code>			// The timer is being run or moved, by a different P.</code></span>
<span class="codeline" id="line-338"><code>			// Wait for it to complete.</code></span>
<span class="codeline" id="line-339"><code>			osyield()</code></span>
<span class="codeline" id="line-340"><code>		case timerNoStatus:</code></span>
<span class="codeline" id="line-341"><code>			// Removing timer that was never added or</code></span>
<span class="codeline" id="line-342"><code>			// has already been run. Also see issue 21874.</code></span>
<span class="codeline" id="line-343"><code>			return false</code></span>
<span class="codeline" id="line-344"><code>		case timerModifying:</code></span>
<span class="codeline" id="line-345"><code>			// Simultaneous calls to deltimer and modtimer.</code></span>
<span class="codeline" id="line-346"><code>			// Wait for the other call to complete.</code></span>
<span class="codeline" id="line-347"><code>			osyield()</code></span>
<span class="codeline" id="line-348"><code>		default:</code></span>
<span class="codeline" id="line-349"><code>			badTimer()</code></span>
<span class="codeline" id="line-350"><code>		}</code></span>
<span class="codeline" id="line-351"><code>	}</code></span>
<span class="codeline" id="line-352"><code>}</code></span>
<span class="codeline" id="line-353"><code></code></span>
<span class="codeline" id="line-354"><code>// dodeltimer removes timer i from the current P's heap.</code></span>
<span class="codeline" id="line-355"><code>// We are locked on the P when this is called.</code></span>
<span class="codeline" id="line-356"><code>// It reports whether it saw no problems due to races.</code></span>
<span class="codeline" id="line-357"><code>// The caller must have locked the timers for pp.</code></span>
<span class="codeline" id="line-358"><code>func dodeltimer(pp *p, i int) {</code></span>
<span class="codeline" id="line-359"><code>	if t := pp.timers[i]; t.pp.ptr() != pp {</code></span>
<span class="codeline" id="line-360"><code>		throw("dodeltimer: wrong P")</code></span>
<span class="codeline" id="line-361"><code>	} else {</code></span>
<span class="codeline" id="line-362"><code>		t.pp = 0</code></span>
<span class="codeline" id="line-363"><code>	}</code></span>
<span class="codeline" id="line-364"><code>	last := len(pp.timers) - 1</code></span>
<span class="codeline" id="line-365"><code>	if i != last {</code></span>
<span class="codeline" id="line-366"><code>		pp.timers[i] = pp.timers[last]</code></span>
<span class="codeline" id="line-367"><code>	}</code></span>
<span class="codeline" id="line-368"><code>	pp.timers[last] = nil</code></span>
<span class="codeline" id="line-369"><code>	pp.timers = pp.timers[:last]</code></span>
<span class="codeline" id="line-370"><code>	if i != last {</code></span>
<span class="codeline" id="line-371"><code>		// Moving to i may have moved the last timer to a new parent,</code></span>
<span class="codeline" id="line-372"><code>		// so sift up to preserve the heap guarantee.</code></span>
<span class="codeline" id="line-373"><code>		siftupTimer(pp.timers, i)</code></span>
<span class="codeline" id="line-374"><code>		siftdownTimer(pp.timers, i)</code></span>
<span class="codeline" id="line-375"><code>	}</code></span>
<span class="codeline" id="line-376"><code>	if i == 0 {</code></span>
<span class="codeline" id="line-377"><code>		updateTimer0When(pp)</code></span>
<span class="codeline" id="line-378"><code>	}</code></span>
<span class="codeline" id="line-379"><code>	atomic.Xadd(&amp;pp.numTimers, -1)</code></span>
<span class="codeline" id="line-380"><code>}</code></span>
<span class="codeline" id="line-381"><code></code></span>
<span class="codeline" id="line-382"><code>// dodeltimer0 removes timer 0 from the current P's heap.</code></span>
<span class="codeline" id="line-383"><code>// We are locked on the P when this is called.</code></span>
<span class="codeline" id="line-384"><code>// It reports whether it saw no problems due to races.</code></span>
<span class="codeline" id="line-385"><code>// The caller must have locked the timers for pp.</code></span>
<span class="codeline" id="line-386"><code>func dodeltimer0(pp *p) {</code></span>
<span class="codeline" id="line-387"><code>	if t := pp.timers[0]; t.pp.ptr() != pp {</code></span>
<span class="codeline" id="line-388"><code>		throw("dodeltimer0: wrong P")</code></span>
<span class="codeline" id="line-389"><code>	} else {</code></span>
<span class="codeline" id="line-390"><code>		t.pp = 0</code></span>
<span class="codeline" id="line-391"><code>	}</code></span>
<span class="codeline" id="line-392"><code>	last := len(pp.timers) - 1</code></span>
<span class="codeline" id="line-393"><code>	if last &gt; 0 {</code></span>
<span class="codeline" id="line-394"><code>		pp.timers[0] = pp.timers[last]</code></span>
<span class="codeline" id="line-395"><code>	}</code></span>
<span class="codeline" id="line-396"><code>	pp.timers[last] = nil</code></span>
<span class="codeline" id="line-397"><code>	pp.timers = pp.timers[:last]</code></span>
<span class="codeline" id="line-398"><code>	if last &gt; 0 {</code></span>
<span class="codeline" id="line-399"><code>		siftdownTimer(pp.timers, 0)</code></span>
<span class="codeline" id="line-400"><code>	}</code></span>
<span class="codeline" id="line-401"><code>	updateTimer0When(pp)</code></span>
<span class="codeline" id="line-402"><code>	atomic.Xadd(&amp;pp.numTimers, -1)</code></span>
<span class="codeline" id="line-403"><code>}</code></span>
<span class="codeline" id="line-404"><code></code></span>
<span class="codeline" id="line-405"><code>// modtimer modifies an existing timer.</code></span>
<span class="codeline" id="line-406"><code>// This is called by the netpoll code or time.Ticker.Reset.</code></span>
<span class="codeline" id="line-407"><code>// Reports whether the timer was modified before it was run.</code></span>
<span class="codeline" id="line-408"><code>func modtimer(t *timer, when, period int64, f func(interface{}, uintptr), arg interface{}, seq uintptr) bool {</code></span>
<span class="codeline" id="line-409"><code>	if when &lt; 0 {</code></span>
<span class="codeline" id="line-410"><code>		when = maxWhen</code></span>
<span class="codeline" id="line-411"><code>	}</code></span>
<span class="codeline" id="line-412"><code></code></span>
<span class="codeline" id="line-413"><code>	status := uint32(timerNoStatus)</code></span>
<span class="codeline" id="line-414"><code>	wasRemoved := false</code></span>
<span class="codeline" id="line-415"><code>	var pending bool</code></span>
<span class="codeline" id="line-416"><code>	var mp *m</code></span>
<span class="codeline" id="line-417"><code>loop:</code></span>
<span class="codeline" id="line-418"><code>	for {</code></span>
<span class="codeline" id="line-419"><code>		switch status = atomic.Load(&amp;t.status); status {</code></span>
<span class="codeline" id="line-420"><code>		case timerWaiting, timerModifiedEarlier, timerModifiedLater:</code></span>
<span class="codeline" id="line-421"><code>			// Prevent preemption while the timer is in timerModifying.</code></span>
<span class="codeline" id="line-422"><code>			// This could lead to a self-deadlock. See #38070.</code></span>
<span class="codeline" id="line-423"><code>			mp = acquirem()</code></span>
<span class="codeline" id="line-424"><code>			if atomic.Cas(&amp;t.status, status, timerModifying) {</code></span>
<span class="codeline" id="line-425"><code>				pending = true // timer not yet run</code></span>
<span class="codeline" id="line-426"><code>				break loop</code></span>
<span class="codeline" id="line-427"><code>			}</code></span>
<span class="codeline" id="line-428"><code>			releasem(mp)</code></span>
<span class="codeline" id="line-429"><code>		case timerNoStatus, timerRemoved:</code></span>
<span class="codeline" id="line-430"><code>			// Prevent preemption while the timer is in timerModifying.</code></span>
<span class="codeline" id="line-431"><code>			// This could lead to a self-deadlock. See #38070.</code></span>
<span class="codeline" id="line-432"><code>			mp = acquirem()</code></span>
<span class="codeline" id="line-433"><code></code></span>
<span class="codeline" id="line-434"><code>			// Timer was already run and t is no longer in a heap.</code></span>
<span class="codeline" id="line-435"><code>			// Act like addtimer.</code></span>
<span class="codeline" id="line-436"><code>			if atomic.Cas(&amp;t.status, status, timerModifying) {</code></span>
<span class="codeline" id="line-437"><code>				wasRemoved = true</code></span>
<span class="codeline" id="line-438"><code>				pending = false // timer already run or stopped</code></span>
<span class="codeline" id="line-439"><code>				break loop</code></span>
<span class="codeline" id="line-440"><code>			}</code></span>
<span class="codeline" id="line-441"><code>			releasem(mp)</code></span>
<span class="codeline" id="line-442"><code>		case timerDeleted:</code></span>
<span class="codeline" id="line-443"><code>			// Prevent preemption while the timer is in timerModifying.</code></span>
<span class="codeline" id="line-444"><code>			// This could lead to a self-deadlock. See #38070.</code></span>
<span class="codeline" id="line-445"><code>			mp = acquirem()</code></span>
<span class="codeline" id="line-446"><code>			if atomic.Cas(&amp;t.status, status, timerModifying) {</code></span>
<span class="codeline" id="line-447"><code>				atomic.Xadd(&amp;t.pp.ptr().deletedTimers, -1)</code></span>
<span class="codeline" id="line-448"><code>				pending = false // timer already stopped</code></span>
<span class="codeline" id="line-449"><code>				break loop</code></span>
<span class="codeline" id="line-450"><code>			}</code></span>
<span class="codeline" id="line-451"><code>			releasem(mp)</code></span>
<span class="codeline" id="line-452"><code>		case timerRunning, timerRemoving, timerMoving:</code></span>
<span class="codeline" id="line-453"><code>			// The timer is being run or moved, by a different P.</code></span>
<span class="codeline" id="line-454"><code>			// Wait for it to complete.</code></span>
<span class="codeline" id="line-455"><code>			osyield()</code></span>
<span class="codeline" id="line-456"><code>		case timerModifying:</code></span>
<span class="codeline" id="line-457"><code>			// Multiple simultaneous calls to modtimer.</code></span>
<span class="codeline" id="line-458"><code>			// Wait for the other call to complete.</code></span>
<span class="codeline" id="line-459"><code>			osyield()</code></span>
<span class="codeline" id="line-460"><code>		default:</code></span>
<span class="codeline" id="line-461"><code>			badTimer()</code></span>
<span class="codeline" id="line-462"><code>		}</code></span>
<span class="codeline" id="line-463"><code>	}</code></span>
<span class="codeline" id="line-464"><code></code></span>
<span class="codeline" id="line-465"><code>	t.period = period</code></span>
<span class="codeline" id="line-466"><code>	t.f = f</code></span>
<span class="codeline" id="line-467"><code>	t.arg = arg</code></span>
<span class="codeline" id="line-468"><code>	t.seq = seq</code></span>
<span class="codeline" id="line-469"><code></code></span>
<span class="codeline" id="line-470"><code>	if wasRemoved {</code></span>
<span class="codeline" id="line-471"><code>		t.when = when</code></span>
<span class="codeline" id="line-472"><code>		pp := getg().m.p.ptr()</code></span>
<span class="codeline" id="line-473"><code>		lock(&amp;pp.timersLock)</code></span>
<span class="codeline" id="line-474"><code>		doaddtimer(pp, t)</code></span>
<span class="codeline" id="line-475"><code>		unlock(&amp;pp.timersLock)</code></span>
<span class="codeline" id="line-476"><code>		if !atomic.Cas(&amp;t.status, timerModifying, timerWaiting) {</code></span>
<span class="codeline" id="line-477"><code>			badTimer()</code></span>
<span class="codeline" id="line-478"><code>		}</code></span>
<span class="codeline" id="line-479"><code>		releasem(mp)</code></span>
<span class="codeline" id="line-480"><code>		wakeNetPoller(when)</code></span>
<span class="codeline" id="line-481"><code>	} else {</code></span>
<span class="codeline" id="line-482"><code>		// The timer is in some other P's heap, so we can't change</code></span>
<span class="codeline" id="line-483"><code>		// the when field. If we did, the other P's heap would</code></span>
<span class="codeline" id="line-484"><code>		// be out of order. So we put the new when value in the</code></span>
<span class="codeline" id="line-485"><code>		// nextwhen field, and let the other P set the when field</code></span>
<span class="codeline" id="line-486"><code>		// when it is prepared to resort the heap.</code></span>
<span class="codeline" id="line-487"><code>		t.nextwhen = when</code></span>
<span class="codeline" id="line-488"><code></code></span>
<span class="codeline" id="line-489"><code>		newStatus := uint32(timerModifiedLater)</code></span>
<span class="codeline" id="line-490"><code>		if when &lt; t.when {</code></span>
<span class="codeline" id="line-491"><code>			newStatus = timerModifiedEarlier</code></span>
<span class="codeline" id="line-492"><code>		}</code></span>
<span class="codeline" id="line-493"><code></code></span>
<span class="codeline" id="line-494"><code>		// Update the adjustTimers field.  Subtract one if we</code></span>
<span class="codeline" id="line-495"><code>		// are removing a timerModifiedEarlier, add one if we</code></span>
<span class="codeline" id="line-496"><code>		// are adding a timerModifiedEarlier.</code></span>
<span class="codeline" id="line-497"><code>		adjust := int32(0)</code></span>
<span class="codeline" id="line-498"><code>		if status == timerModifiedEarlier {</code></span>
<span class="codeline" id="line-499"><code>			adjust--</code></span>
<span class="codeline" id="line-500"><code>		}</code></span>
<span class="codeline" id="line-501"><code>		if newStatus == timerModifiedEarlier {</code></span>
<span class="codeline" id="line-502"><code>			adjust++</code></span>
<span class="codeline" id="line-503"><code>		}</code></span>
<span class="codeline" id="line-504"><code>		if adjust != 0 {</code></span>
<span class="codeline" id="line-505"><code>			atomic.Xadd(&amp;t.pp.ptr().adjustTimers, adjust)</code></span>
<span class="codeline" id="line-506"><code>		}</code></span>
<span class="codeline" id="line-507"><code></code></span>
<span class="codeline" id="line-508"><code>		// Set the new status of the timer.</code></span>
<span class="codeline" id="line-509"><code>		if !atomic.Cas(&amp;t.status, timerModifying, newStatus) {</code></span>
<span class="codeline" id="line-510"><code>			badTimer()</code></span>
<span class="codeline" id="line-511"><code>		}</code></span>
<span class="codeline" id="line-512"><code>		releasem(mp)</code></span>
<span class="codeline" id="line-513"><code></code></span>
<span class="codeline" id="line-514"><code>		// If the new status is earlier, wake up the poller.</code></span>
<span class="codeline" id="line-515"><code>		if newStatus == timerModifiedEarlier {</code></span>
<span class="codeline" id="line-516"><code>			wakeNetPoller(when)</code></span>
<span class="codeline" id="line-517"><code>		}</code></span>
<span class="codeline" id="line-518"><code>	}</code></span>
<span class="codeline" id="line-519"><code></code></span>
<span class="codeline" id="line-520"><code>	return pending</code></span>
<span class="codeline" id="line-521"><code>}</code></span>
<span class="codeline" id="line-522"><code></code></span>
<span class="codeline" id="line-523"><code>// resettimer resets the time when a timer should fire.</code></span>
<span class="codeline" id="line-524"><code>// If used for an inactive timer, the timer will become active.</code></span>
<span class="codeline" id="line-525"><code>// This should be called instead of addtimer if the timer value has been,</code></span>
<span class="codeline" id="line-526"><code>// or may have been, used previously.</code></span>
<span class="codeline" id="line-527"><code>// Reports whether the timer was modified before it was run.</code></span>
<span class="codeline" id="line-528"><code>func resettimer(t *timer, when int64) bool {</code></span>
<span class="codeline" id="line-529"><code>	return modtimer(t, when, t.period, t.f, t.arg, t.seq)</code></span>
<span class="codeline" id="line-530"><code>}</code></span>
<span class="codeline" id="line-531"><code></code></span>
<span class="codeline" id="line-532"><code>// cleantimers cleans up the head of the timer queue. This speeds up</code></span>
<span class="codeline" id="line-533"><code>// programs that create and delete timers; leaving them in the heap</code></span>
<span class="codeline" id="line-534"><code>// slows down addtimer. Reports whether no timer problems were found.</code></span>
<span class="codeline" id="line-535"><code>// The caller must have locked the timers for pp.</code></span>
<span class="codeline" id="line-536"><code>func cleantimers(pp *p) {</code></span>
<span class="codeline" id="line-537"><code>	gp := getg()</code></span>
<span class="codeline" id="line-538"><code>	for {</code></span>
<span class="codeline" id="line-539"><code>		if len(pp.timers) == 0 {</code></span>
<span class="codeline" id="line-540"><code>			return</code></span>
<span class="codeline" id="line-541"><code>		}</code></span>
<span class="codeline" id="line-542"><code></code></span>
<span class="codeline" id="line-543"><code>		// This loop can theoretically run for a while, and because</code></span>
<span class="codeline" id="line-544"><code>		// it is holding timersLock it cannot be preempted.</code></span>
<span class="codeline" id="line-545"><code>		// If someone is trying to preempt us, just return.</code></span>
<span class="codeline" id="line-546"><code>		// We can clean the timers later.</code></span>
<span class="codeline" id="line-547"><code>		if gp.preemptStop {</code></span>
<span class="codeline" id="line-548"><code>			return</code></span>
<span class="codeline" id="line-549"><code>		}</code></span>
<span class="codeline" id="line-550"><code></code></span>
<span class="codeline" id="line-551"><code>		t := pp.timers[0]</code></span>
<span class="codeline" id="line-552"><code>		if t.pp.ptr() != pp {</code></span>
<span class="codeline" id="line-553"><code>			throw("cleantimers: bad p")</code></span>
<span class="codeline" id="line-554"><code>		}</code></span>
<span class="codeline" id="line-555"><code>		switch s := atomic.Load(&amp;t.status); s {</code></span>
<span class="codeline" id="line-556"><code>		case timerDeleted:</code></span>
<span class="codeline" id="line-557"><code>			if !atomic.Cas(&amp;t.status, s, timerRemoving) {</code></span>
<span class="codeline" id="line-558"><code>				continue</code></span>
<span class="codeline" id="line-559"><code>			}</code></span>
<span class="codeline" id="line-560"><code>			dodeltimer0(pp)</code></span>
<span class="codeline" id="line-561"><code>			if !atomic.Cas(&amp;t.status, timerRemoving, timerRemoved) {</code></span>
<span class="codeline" id="line-562"><code>				badTimer()</code></span>
<span class="codeline" id="line-563"><code>			}</code></span>
<span class="codeline" id="line-564"><code>			atomic.Xadd(&amp;pp.deletedTimers, -1)</code></span>
<span class="codeline" id="line-565"><code>		case timerModifiedEarlier, timerModifiedLater:</code></span>
<span class="codeline" id="line-566"><code>			if !atomic.Cas(&amp;t.status, s, timerMoving) {</code></span>
<span class="codeline" id="line-567"><code>				continue</code></span>
<span class="codeline" id="line-568"><code>			}</code></span>
<span class="codeline" id="line-569"><code>			// Now we can change the when field.</code></span>
<span class="codeline" id="line-570"><code>			t.when = t.nextwhen</code></span>
<span class="codeline" id="line-571"><code>			// Move t to the right position.</code></span>
<span class="codeline" id="line-572"><code>			dodeltimer0(pp)</code></span>
<span class="codeline" id="line-573"><code>			doaddtimer(pp, t)</code></span>
<span class="codeline" id="line-574"><code>			if s == timerModifiedEarlier {</code></span>
<span class="codeline" id="line-575"><code>				atomic.Xadd(&amp;pp.adjustTimers, -1)</code></span>
<span class="codeline" id="line-576"><code>			}</code></span>
<span class="codeline" id="line-577"><code>			if !atomic.Cas(&amp;t.status, timerMoving, timerWaiting) {</code></span>
<span class="codeline" id="line-578"><code>				badTimer()</code></span>
<span class="codeline" id="line-579"><code>			}</code></span>
<span class="codeline" id="line-580"><code>		default:</code></span>
<span class="codeline" id="line-581"><code>			// Head of timers does not need adjustment.</code></span>
<span class="codeline" id="line-582"><code>			return</code></span>
<span class="codeline" id="line-583"><code>		}</code></span>
<span class="codeline" id="line-584"><code>	}</code></span>
<span class="codeline" id="line-585"><code>}</code></span>
<span class="codeline" id="line-586"><code></code></span>
<span class="codeline" id="line-587"><code>// moveTimers moves a slice of timers to pp. The slice has been taken</code></span>
<span class="codeline" id="line-588"><code>// from a different P.</code></span>
<span class="codeline" id="line-589"><code>// This is currently called when the world is stopped, but the caller</code></span>
<span class="codeline" id="line-590"><code>// is expected to have locked the timers for pp.</code></span>
<span class="codeline" id="line-591"><code>func moveTimers(pp *p, timers []*timer) {</code></span>
<span class="codeline" id="line-592"><code>	for _, t := range timers {</code></span>
<span class="codeline" id="line-593"><code>	loop:</code></span>
<span class="codeline" id="line-594"><code>		for {</code></span>
<span class="codeline" id="line-595"><code>			switch s := atomic.Load(&amp;t.status); s {</code></span>
<span class="codeline" id="line-596"><code>			case timerWaiting:</code></span>
<span class="codeline" id="line-597"><code>				t.pp = 0</code></span>
<span class="codeline" id="line-598"><code>				doaddtimer(pp, t)</code></span>
<span class="codeline" id="line-599"><code>				break loop</code></span>
<span class="codeline" id="line-600"><code>			case timerModifiedEarlier, timerModifiedLater:</code></span>
<span class="codeline" id="line-601"><code>				if !atomic.Cas(&amp;t.status, s, timerMoving) {</code></span>
<span class="codeline" id="line-602"><code>					continue</code></span>
<span class="codeline" id="line-603"><code>				}</code></span>
<span class="codeline" id="line-604"><code>				t.when = t.nextwhen</code></span>
<span class="codeline" id="line-605"><code>				t.pp = 0</code></span>
<span class="codeline" id="line-606"><code>				doaddtimer(pp, t)</code></span>
<span class="codeline" id="line-607"><code>				if !atomic.Cas(&amp;t.status, timerMoving, timerWaiting) {</code></span>
<span class="codeline" id="line-608"><code>					badTimer()</code></span>
<span class="codeline" id="line-609"><code>				}</code></span>
<span class="codeline" id="line-610"><code>				break loop</code></span>
<span class="codeline" id="line-611"><code>			case timerDeleted:</code></span>
<span class="codeline" id="line-612"><code>				if !atomic.Cas(&amp;t.status, s, timerRemoved) {</code></span>
<span class="codeline" id="line-613"><code>					continue</code></span>
<span class="codeline" id="line-614"><code>				}</code></span>
<span class="codeline" id="line-615"><code>				t.pp = 0</code></span>
<span class="codeline" id="line-616"><code>				// We no longer need this timer in the heap.</code></span>
<span class="codeline" id="line-617"><code>				break loop</code></span>
<span class="codeline" id="line-618"><code>			case timerModifying:</code></span>
<span class="codeline" id="line-619"><code>				// Loop until the modification is complete.</code></span>
<span class="codeline" id="line-620"><code>				osyield()</code></span>
<span class="codeline" id="line-621"><code>			case timerNoStatus, timerRemoved:</code></span>
<span class="codeline" id="line-622"><code>				// We should not see these status values in a timers heap.</code></span>
<span class="codeline" id="line-623"><code>				badTimer()</code></span>
<span class="codeline" id="line-624"><code>			case timerRunning, timerRemoving, timerMoving:</code></span>
<span class="codeline" id="line-625"><code>				// Some other P thinks it owns this timer,</code></span>
<span class="codeline" id="line-626"><code>				// which should not happen.</code></span>
<span class="codeline" id="line-627"><code>				badTimer()</code></span>
<span class="codeline" id="line-628"><code>			default:</code></span>
<span class="codeline" id="line-629"><code>				badTimer()</code></span>
<span class="codeline" id="line-630"><code>			}</code></span>
<span class="codeline" id="line-631"><code>		}</code></span>
<span class="codeline" id="line-632"><code>	}</code></span>
<span class="codeline" id="line-633"><code>}</code></span>
<span class="codeline" id="line-634"><code></code></span>
<span class="codeline" id="line-635"><code>// adjusttimers looks through the timers in the current P's heap for</code></span>
<span class="codeline" id="line-636"><code>// any timers that have been modified to run earlier, and puts them in</code></span>
<span class="codeline" id="line-637"><code>// the correct place in the heap. While looking for those timers,</code></span>
<span class="codeline" id="line-638"><code>// it also moves timers that have been modified to run later,</code></span>
<span class="codeline" id="line-639"><code>// and removes deleted timers. The caller must have locked the timers for pp.</code></span>
<span class="codeline" id="line-640"><code>func adjusttimers(pp *p) {</code></span>
<span class="codeline" id="line-641"><code>	if len(pp.timers) == 0 {</code></span>
<span class="codeline" id="line-642"><code>		return</code></span>
<span class="codeline" id="line-643"><code>	}</code></span>
<span class="codeline" id="line-644"><code>	if atomic.Load(&amp;pp.adjustTimers) == 0 {</code></span>
<span class="codeline" id="line-645"><code>		if verifyTimers {</code></span>
<span class="codeline" id="line-646"><code>			verifyTimerHeap(pp)</code></span>
<span class="codeline" id="line-647"><code>		}</code></span>
<span class="codeline" id="line-648"><code>		return</code></span>
<span class="codeline" id="line-649"><code>	}</code></span>
<span class="codeline" id="line-650"><code>	var moved []*timer</code></span>
<span class="codeline" id="line-651"><code>loop:</code></span>
<span class="codeline" id="line-652"><code>	for i := 0; i &lt; len(pp.timers); i++ {</code></span>
<span class="codeline" id="line-653"><code>		t := pp.timers[i]</code></span>
<span class="codeline" id="line-654"><code>		if t.pp.ptr() != pp {</code></span>
<span class="codeline" id="line-655"><code>			throw("adjusttimers: bad p")</code></span>
<span class="codeline" id="line-656"><code>		}</code></span>
<span class="codeline" id="line-657"><code>		switch s := atomic.Load(&amp;t.status); s {</code></span>
<span class="codeline" id="line-658"><code>		case timerDeleted:</code></span>
<span class="codeline" id="line-659"><code>			if atomic.Cas(&amp;t.status, s, timerRemoving) {</code></span>
<span class="codeline" id="line-660"><code>				dodeltimer(pp, i)</code></span>
<span class="codeline" id="line-661"><code>				if !atomic.Cas(&amp;t.status, timerRemoving, timerRemoved) {</code></span>
<span class="codeline" id="line-662"><code>					badTimer()</code></span>
<span class="codeline" id="line-663"><code>				}</code></span>
<span class="codeline" id="line-664"><code>				atomic.Xadd(&amp;pp.deletedTimers, -1)</code></span>
<span class="codeline" id="line-665"><code>				// Look at this heap position again.</code></span>
<span class="codeline" id="line-666"><code>				i--</code></span>
<span class="codeline" id="line-667"><code>			}</code></span>
<span class="codeline" id="line-668"><code>		case timerModifiedEarlier, timerModifiedLater:</code></span>
<span class="codeline" id="line-669"><code>			if atomic.Cas(&amp;t.status, s, timerMoving) {</code></span>
<span class="codeline" id="line-670"><code>				// Now we can change the when field.</code></span>
<span class="codeline" id="line-671"><code>				t.when = t.nextwhen</code></span>
<span class="codeline" id="line-672"><code>				// Take t off the heap, and hold onto it.</code></span>
<span class="codeline" id="line-673"><code>				// We don't add it back yet because the</code></span>
<span class="codeline" id="line-674"><code>				// heap manipulation could cause our</code></span>
<span class="codeline" id="line-675"><code>				// loop to skip some other timer.</code></span>
<span class="codeline" id="line-676"><code>				dodeltimer(pp, i)</code></span>
<span class="codeline" id="line-677"><code>				moved = append(moved, t)</code></span>
<span class="codeline" id="line-678"><code>				if s == timerModifiedEarlier {</code></span>
<span class="codeline" id="line-679"><code>					if n := atomic.Xadd(&amp;pp.adjustTimers, -1); int32(n) &lt;= 0 {</code></span>
<span class="codeline" id="line-680"><code>						break loop</code></span>
<span class="codeline" id="line-681"><code>					}</code></span>
<span class="codeline" id="line-682"><code>				}</code></span>
<span class="codeline" id="line-683"><code>				// Look at this heap position again.</code></span>
<span class="codeline" id="line-684"><code>				i--</code></span>
<span class="codeline" id="line-685"><code>			}</code></span>
<span class="codeline" id="line-686"><code>		case timerNoStatus, timerRunning, timerRemoving, timerRemoved, timerMoving:</code></span>
<span class="codeline" id="line-687"><code>			badTimer()</code></span>
<span class="codeline" id="line-688"><code>		case timerWaiting:</code></span>
<span class="codeline" id="line-689"><code>			// OK, nothing to do.</code></span>
<span class="codeline" id="line-690"><code>		case timerModifying:</code></span>
<span class="codeline" id="line-691"><code>			// Check again after modification is complete.</code></span>
<span class="codeline" id="line-692"><code>			osyield()</code></span>
<span class="codeline" id="line-693"><code>			i--</code></span>
<span class="codeline" id="line-694"><code>		default:</code></span>
<span class="codeline" id="line-695"><code>			badTimer()</code></span>
<span class="codeline" id="line-696"><code>		}</code></span>
<span class="codeline" id="line-697"><code>	}</code></span>
<span class="codeline" id="line-698"><code></code></span>
<span class="codeline" id="line-699"><code>	if len(moved) &gt; 0 {</code></span>
<span class="codeline" id="line-700"><code>		addAdjustedTimers(pp, moved)</code></span>
<span class="codeline" id="line-701"><code>	}</code></span>
<span class="codeline" id="line-702"><code></code></span>
<span class="codeline" id="line-703"><code>	if verifyTimers {</code></span>
<span class="codeline" id="line-704"><code>		verifyTimerHeap(pp)</code></span>
<span class="codeline" id="line-705"><code>	}</code></span>
<span class="codeline" id="line-706"><code>}</code></span>
<span class="codeline" id="line-707"><code></code></span>
<span class="codeline" id="line-708"><code>// addAdjustedTimers adds any timers we adjusted in adjusttimers</code></span>
<span class="codeline" id="line-709"><code>// back to the timer heap.</code></span>
<span class="codeline" id="line-710"><code>func addAdjustedTimers(pp *p, moved []*timer) {</code></span>
<span class="codeline" id="line-711"><code>	for _, t := range moved {</code></span>
<span class="codeline" id="line-712"><code>		doaddtimer(pp, t)</code></span>
<span class="codeline" id="line-713"><code>		if !atomic.Cas(&amp;t.status, timerMoving, timerWaiting) {</code></span>
<span class="codeline" id="line-714"><code>			badTimer()</code></span>
<span class="codeline" id="line-715"><code>		}</code></span>
<span class="codeline" id="line-716"><code>	}</code></span>
<span class="codeline" id="line-717"><code>}</code></span>
<span class="codeline" id="line-718"><code></code></span>
<span class="codeline" id="line-719"><code>// nobarrierWakeTime looks at P's timers and returns the time when we</code></span>
<span class="codeline" id="line-720"><code>// should wake up the netpoller. It returns 0 if there are no timers.</code></span>
<span class="codeline" id="line-721"><code>// This function is invoked when dropping a P, and must run without</code></span>
<span class="codeline" id="line-722"><code>// any write barriers. Therefore, if there are any timers that needs</code></span>
<span class="codeline" id="line-723"><code>// to be moved earlier, it conservatively returns the current time.</code></span>
<span class="codeline" id="line-724"><code>// The netpoller M will wake up and adjust timers before sleeping again.</code></span>
<span class="codeline" id="line-725"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-726"><code>func nobarrierWakeTime(pp *p) int64 {</code></span>
<span class="codeline" id="line-727"><code>	if atomic.Load(&amp;pp.adjustTimers) &gt; 0 {</code></span>
<span class="codeline" id="line-728"><code>		return nanotime()</code></span>
<span class="codeline" id="line-729"><code>	} else {</code></span>
<span class="codeline" id="line-730"><code>		return int64(atomic.Load64(&amp;pp.timer0When))</code></span>
<span class="codeline" id="line-731"><code>	}</code></span>
<span class="codeline" id="line-732"><code>}</code></span>
<span class="codeline" id="line-733"><code></code></span>
<span class="codeline" id="line-734"><code>// runtimer examines the first timer in timers. If it is ready based on now,</code></span>
<span class="codeline" id="line-735"><code>// it runs the timer and removes or updates it.</code></span>
<span class="codeline" id="line-736"><code>// Returns 0 if it ran a timer, -1 if there are no more timers, or the time</code></span>
<span class="codeline" id="line-737"><code>// when the first timer should run.</code></span>
<span class="codeline" id="line-738"><code>// The caller must have locked the timers for pp.</code></span>
<span class="codeline" id="line-739"><code>// If a timer is run, this will temporarily unlock the timers.</code></span>
<span class="codeline" id="line-740"><code>//go:systemstack</code></span>
<span class="codeline" id="line-741"><code>func runtimer(pp *p, now int64) int64 {</code></span>
<span class="codeline" id="line-742"><code>	for {</code></span>
<span class="codeline" id="line-743"><code>		t := pp.timers[0]</code></span>
<span class="codeline" id="line-744"><code>		if t.pp.ptr() != pp {</code></span>
<span class="codeline" id="line-745"><code>			throw("runtimer: bad p")</code></span>
<span class="codeline" id="line-746"><code>		}</code></span>
<span class="codeline" id="line-747"><code>		switch s := atomic.Load(&amp;t.status); s {</code></span>
<span class="codeline" id="line-748"><code>		case timerWaiting:</code></span>
<span class="codeline" id="line-749"><code>			if t.when &gt; now {</code></span>
<span class="codeline" id="line-750"><code>				// Not ready to run.</code></span>
<span class="codeline" id="line-751"><code>				return t.when</code></span>
<span class="codeline" id="line-752"><code>			}</code></span>
<span class="codeline" id="line-753"><code></code></span>
<span class="codeline" id="line-754"><code>			if !atomic.Cas(&amp;t.status, s, timerRunning) {</code></span>
<span class="codeline" id="line-755"><code>				continue</code></span>
<span class="codeline" id="line-756"><code>			}</code></span>
<span class="codeline" id="line-757"><code>			// Note that runOneTimer may temporarily unlock</code></span>
<span class="codeline" id="line-758"><code>			// pp.timersLock.</code></span>
<span class="codeline" id="line-759"><code>			runOneTimer(pp, t, now)</code></span>
<span class="codeline" id="line-760"><code>			return 0</code></span>
<span class="codeline" id="line-761"><code></code></span>
<span class="codeline" id="line-762"><code>		case timerDeleted:</code></span>
<span class="codeline" id="line-763"><code>			if !atomic.Cas(&amp;t.status, s, timerRemoving) {</code></span>
<span class="codeline" id="line-764"><code>				continue</code></span>
<span class="codeline" id="line-765"><code>			}</code></span>
<span class="codeline" id="line-766"><code>			dodeltimer0(pp)</code></span>
<span class="codeline" id="line-767"><code>			if !atomic.Cas(&amp;t.status, timerRemoving, timerRemoved) {</code></span>
<span class="codeline" id="line-768"><code>				badTimer()</code></span>
<span class="codeline" id="line-769"><code>			}</code></span>
<span class="codeline" id="line-770"><code>			atomic.Xadd(&amp;pp.deletedTimers, -1)</code></span>
<span class="codeline" id="line-771"><code>			if len(pp.timers) == 0 {</code></span>
<span class="codeline" id="line-772"><code>				return -1</code></span>
<span class="codeline" id="line-773"><code>			}</code></span>
<span class="codeline" id="line-774"><code></code></span>
<span class="codeline" id="line-775"><code>		case timerModifiedEarlier, timerModifiedLater:</code></span>
<span class="codeline" id="line-776"><code>			if !atomic.Cas(&amp;t.status, s, timerMoving) {</code></span>
<span class="codeline" id="line-777"><code>				continue</code></span>
<span class="codeline" id="line-778"><code>			}</code></span>
<span class="codeline" id="line-779"><code>			t.when = t.nextwhen</code></span>
<span class="codeline" id="line-780"><code>			dodeltimer0(pp)</code></span>
<span class="codeline" id="line-781"><code>			doaddtimer(pp, t)</code></span>
<span class="codeline" id="line-782"><code>			if s == timerModifiedEarlier {</code></span>
<span class="codeline" id="line-783"><code>				atomic.Xadd(&amp;pp.adjustTimers, -1)</code></span>
<span class="codeline" id="line-784"><code>			}</code></span>
<span class="codeline" id="line-785"><code>			if !atomic.Cas(&amp;t.status, timerMoving, timerWaiting) {</code></span>
<span class="codeline" id="line-786"><code>				badTimer()</code></span>
<span class="codeline" id="line-787"><code>			}</code></span>
<span class="codeline" id="line-788"><code></code></span>
<span class="codeline" id="line-789"><code>		case timerModifying:</code></span>
<span class="codeline" id="line-790"><code>			// Wait for modification to complete.</code></span>
<span class="codeline" id="line-791"><code>			osyield()</code></span>
<span class="codeline" id="line-792"><code></code></span>
<span class="codeline" id="line-793"><code>		case timerNoStatus, timerRemoved:</code></span>
<span class="codeline" id="line-794"><code>			// Should not see a new or inactive timer on the heap.</code></span>
<span class="codeline" id="line-795"><code>			badTimer()</code></span>
<span class="codeline" id="line-796"><code>		case timerRunning, timerRemoving, timerMoving:</code></span>
<span class="codeline" id="line-797"><code>			// These should only be set when timers are locked,</code></span>
<span class="codeline" id="line-798"><code>			// and we didn't do it.</code></span>
<span class="codeline" id="line-799"><code>			badTimer()</code></span>
<span class="codeline" id="line-800"><code>		default:</code></span>
<span class="codeline" id="line-801"><code>			badTimer()</code></span>
<span class="codeline" id="line-802"><code>		}</code></span>
<span class="codeline" id="line-803"><code>	}</code></span>
<span class="codeline" id="line-804"><code>}</code></span>
<span class="codeline" id="line-805"><code></code></span>
<span class="codeline" id="line-806"><code>// runOneTimer runs a single timer.</code></span>
<span class="codeline" id="line-807"><code>// The caller must have locked the timers for pp.</code></span>
<span class="codeline" id="line-808"><code>// This will temporarily unlock the timers while running the timer function.</code></span>
<span class="codeline" id="line-809"><code>//go:systemstack</code></span>
<span class="codeline" id="line-810"><code>func runOneTimer(pp *p, t *timer, now int64) {</code></span>
<span class="codeline" id="line-811"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-812"><code>		ppcur := getg().m.p.ptr()</code></span>
<span class="codeline" id="line-813"><code>		if ppcur.timerRaceCtx == 0 {</code></span>
<span class="codeline" id="line-814"><code>			ppcur.timerRaceCtx = racegostart(funcPC(runtimer) + sys.PCQuantum)</code></span>
<span class="codeline" id="line-815"><code>		}</code></span>
<span class="codeline" id="line-816"><code>		raceacquirectx(ppcur.timerRaceCtx, unsafe.Pointer(t))</code></span>
<span class="codeline" id="line-817"><code>	}</code></span>
<span class="codeline" id="line-818"><code></code></span>
<span class="codeline" id="line-819"><code>	f := t.f</code></span>
<span class="codeline" id="line-820"><code>	arg := t.arg</code></span>
<span class="codeline" id="line-821"><code>	seq := t.seq</code></span>
<span class="codeline" id="line-822"><code></code></span>
<span class="codeline" id="line-823"><code>	if t.period &gt; 0 {</code></span>
<span class="codeline" id="line-824"><code>		// Leave in heap but adjust next time to fire.</code></span>
<span class="codeline" id="line-825"><code>		delta := t.when - now</code></span>
<span class="codeline" id="line-826"><code>		t.when += t.period * (1 + -delta/t.period)</code></span>
<span class="codeline" id="line-827"><code>		siftdownTimer(pp.timers, 0)</code></span>
<span class="codeline" id="line-828"><code>		if !atomic.Cas(&amp;t.status, timerRunning, timerWaiting) {</code></span>
<span class="codeline" id="line-829"><code>			badTimer()</code></span>
<span class="codeline" id="line-830"><code>		}</code></span>
<span class="codeline" id="line-831"><code>		updateTimer0When(pp)</code></span>
<span class="codeline" id="line-832"><code>	} else {</code></span>
<span class="codeline" id="line-833"><code>		// Remove from heap.</code></span>
<span class="codeline" id="line-834"><code>		dodeltimer0(pp)</code></span>
<span class="codeline" id="line-835"><code>		if !atomic.Cas(&amp;t.status, timerRunning, timerNoStatus) {</code></span>
<span class="codeline" id="line-836"><code>			badTimer()</code></span>
<span class="codeline" id="line-837"><code>		}</code></span>
<span class="codeline" id="line-838"><code>	}</code></span>
<span class="codeline" id="line-839"><code></code></span>
<span class="codeline" id="line-840"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-841"><code>		// Temporarily use the current P's racectx for g0.</code></span>
<span class="codeline" id="line-842"><code>		gp := getg()</code></span>
<span class="codeline" id="line-843"><code>		if gp.racectx != 0 {</code></span>
<span class="codeline" id="line-844"><code>			throw("runOneTimer: unexpected racectx")</code></span>
<span class="codeline" id="line-845"><code>		}</code></span>
<span class="codeline" id="line-846"><code>		gp.racectx = gp.m.p.ptr().timerRaceCtx</code></span>
<span class="codeline" id="line-847"><code>	}</code></span>
<span class="codeline" id="line-848"><code></code></span>
<span class="codeline" id="line-849"><code>	unlock(&amp;pp.timersLock)</code></span>
<span class="codeline" id="line-850"><code></code></span>
<span class="codeline" id="line-851"><code>	f(arg, seq)</code></span>
<span class="codeline" id="line-852"><code></code></span>
<span class="codeline" id="line-853"><code>	lock(&amp;pp.timersLock)</code></span>
<span class="codeline" id="line-854"><code></code></span>
<span class="codeline" id="line-855"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-856"><code>		gp := getg()</code></span>
<span class="codeline" id="line-857"><code>		gp.racectx = 0</code></span>
<span class="codeline" id="line-858"><code>	}</code></span>
<span class="codeline" id="line-859"><code>}</code></span>
<span class="codeline" id="line-860"><code></code></span>
<span class="codeline" id="line-861"><code>// clearDeletedTimers removes all deleted timers from the P's timer heap.</code></span>
<span class="codeline" id="line-862"><code>// This is used to avoid clogging up the heap if the program</code></span>
<span class="codeline" id="line-863"><code>// starts a lot of long-running timers and then stops them.</code></span>
<span class="codeline" id="line-864"><code>// For example, this can happen via context.WithTimeout.</code></span>
<span class="codeline" id="line-865"><code>//</code></span>
<span class="codeline" id="line-866"><code>// This is the only function that walks through the entire timer heap,</code></span>
<span class="codeline" id="line-867"><code>// other than moveTimers which only runs when the world is stopped.</code></span>
<span class="codeline" id="line-868"><code>//</code></span>
<span class="codeline" id="line-869"><code>// The caller must have locked the timers for pp.</code></span>
<span class="codeline" id="line-870"><code>func clearDeletedTimers(pp *p) {</code></span>
<span class="codeline" id="line-871"><code>	cdel := int32(0)</code></span>
<span class="codeline" id="line-872"><code>	cearlier := int32(0)</code></span>
<span class="codeline" id="line-873"><code>	to := 0</code></span>
<span class="codeline" id="line-874"><code>	changedHeap := false</code></span>
<span class="codeline" id="line-875"><code>	timers := pp.timers</code></span>
<span class="codeline" id="line-876"><code>nextTimer:</code></span>
<span class="codeline" id="line-877"><code>	for _, t := range timers {</code></span>
<span class="codeline" id="line-878"><code>		for {</code></span>
<span class="codeline" id="line-879"><code>			switch s := atomic.Load(&amp;t.status); s {</code></span>
<span class="codeline" id="line-880"><code>			case timerWaiting:</code></span>
<span class="codeline" id="line-881"><code>				if changedHeap {</code></span>
<span class="codeline" id="line-882"><code>					timers[to] = t</code></span>
<span class="codeline" id="line-883"><code>					siftupTimer(timers, to)</code></span>
<span class="codeline" id="line-884"><code>				}</code></span>
<span class="codeline" id="line-885"><code>				to++</code></span>
<span class="codeline" id="line-886"><code>				continue nextTimer</code></span>
<span class="codeline" id="line-887"><code>			case timerModifiedEarlier, timerModifiedLater:</code></span>
<span class="codeline" id="line-888"><code>				if atomic.Cas(&amp;t.status, s, timerMoving) {</code></span>
<span class="codeline" id="line-889"><code>					t.when = t.nextwhen</code></span>
<span class="codeline" id="line-890"><code>					timers[to] = t</code></span>
<span class="codeline" id="line-891"><code>					siftupTimer(timers, to)</code></span>
<span class="codeline" id="line-892"><code>					to++</code></span>
<span class="codeline" id="line-893"><code>					changedHeap = true</code></span>
<span class="codeline" id="line-894"><code>					if !atomic.Cas(&amp;t.status, timerMoving, timerWaiting) {</code></span>
<span class="codeline" id="line-895"><code>						badTimer()</code></span>
<span class="codeline" id="line-896"><code>					}</code></span>
<span class="codeline" id="line-897"><code>					if s == timerModifiedEarlier {</code></span>
<span class="codeline" id="line-898"><code>						cearlier++</code></span>
<span class="codeline" id="line-899"><code>					}</code></span>
<span class="codeline" id="line-900"><code>					continue nextTimer</code></span>
<span class="codeline" id="line-901"><code>				}</code></span>
<span class="codeline" id="line-902"><code>			case timerDeleted:</code></span>
<span class="codeline" id="line-903"><code>				if atomic.Cas(&amp;t.status, s, timerRemoving) {</code></span>
<span class="codeline" id="line-904"><code>					t.pp = 0</code></span>
<span class="codeline" id="line-905"><code>					cdel++</code></span>
<span class="codeline" id="line-906"><code>					if !atomic.Cas(&amp;t.status, timerRemoving, timerRemoved) {</code></span>
<span class="codeline" id="line-907"><code>						badTimer()</code></span>
<span class="codeline" id="line-908"><code>					}</code></span>
<span class="codeline" id="line-909"><code>					changedHeap = true</code></span>
<span class="codeline" id="line-910"><code>					continue nextTimer</code></span>
<span class="codeline" id="line-911"><code>				}</code></span>
<span class="codeline" id="line-912"><code>			case timerModifying:</code></span>
<span class="codeline" id="line-913"><code>				// Loop until modification complete.</code></span>
<span class="codeline" id="line-914"><code>				osyield()</code></span>
<span class="codeline" id="line-915"><code>			case timerNoStatus, timerRemoved:</code></span>
<span class="codeline" id="line-916"><code>				// We should not see these status values in a timer heap.</code></span>
<span class="codeline" id="line-917"><code>				badTimer()</code></span>
<span class="codeline" id="line-918"><code>			case timerRunning, timerRemoving, timerMoving:</code></span>
<span class="codeline" id="line-919"><code>				// Some other P thinks it owns this timer,</code></span>
<span class="codeline" id="line-920"><code>				// which should not happen.</code></span>
<span class="codeline" id="line-921"><code>				badTimer()</code></span>
<span class="codeline" id="line-922"><code>			default:</code></span>
<span class="codeline" id="line-923"><code>				badTimer()</code></span>
<span class="codeline" id="line-924"><code>			}</code></span>
<span class="codeline" id="line-925"><code>		}</code></span>
<span class="codeline" id="line-926"><code>	}</code></span>
<span class="codeline" id="line-927"><code></code></span>
<span class="codeline" id="line-928"><code>	// Set remaining slots in timers slice to nil,</code></span>
<span class="codeline" id="line-929"><code>	// so that the timer values can be garbage collected.</code></span>
<span class="codeline" id="line-930"><code>	for i := to; i &lt; len(timers); i++ {</code></span>
<span class="codeline" id="line-931"><code>		timers[i] = nil</code></span>
<span class="codeline" id="line-932"><code>	}</code></span>
<span class="codeline" id="line-933"><code></code></span>
<span class="codeline" id="line-934"><code>	atomic.Xadd(&amp;pp.deletedTimers, -cdel)</code></span>
<span class="codeline" id="line-935"><code>	atomic.Xadd(&amp;pp.numTimers, -cdel)</code></span>
<span class="codeline" id="line-936"><code>	atomic.Xadd(&amp;pp.adjustTimers, -cearlier)</code></span>
<span class="codeline" id="line-937"><code></code></span>
<span class="codeline" id="line-938"><code>	timers = timers[:to]</code></span>
<span class="codeline" id="line-939"><code>	pp.timers = timers</code></span>
<span class="codeline" id="line-940"><code>	updateTimer0When(pp)</code></span>
<span class="codeline" id="line-941"><code></code></span>
<span class="codeline" id="line-942"><code>	if verifyTimers {</code></span>
<span class="codeline" id="line-943"><code>		verifyTimerHeap(pp)</code></span>
<span class="codeline" id="line-944"><code>	}</code></span>
<span class="codeline" id="line-945"><code>}</code></span>
<span class="codeline" id="line-946"><code></code></span>
<span class="codeline" id="line-947"><code>// verifyTimerHeap verifies that the timer heap is in a valid state.</code></span>
<span class="codeline" id="line-948"><code>// This is only for debugging, and is only called if verifyTimers is true.</code></span>
<span class="codeline" id="line-949"><code>// The caller must have locked the timers.</code></span>
<span class="codeline" id="line-950"><code>func verifyTimerHeap(pp *p) {</code></span>
<span class="codeline" id="line-951"><code>	for i, t := range pp.timers {</code></span>
<span class="codeline" id="line-952"><code>		if i == 0 {</code></span>
<span class="codeline" id="line-953"><code>			// First timer has no parent.</code></span>
<span class="codeline" id="line-954"><code>			continue</code></span>
<span class="codeline" id="line-955"><code>		}</code></span>
<span class="codeline" id="line-956"><code></code></span>
<span class="codeline" id="line-957"><code>		// The heap is 4-ary. See siftupTimer and siftdownTimer.</code></span>
<span class="codeline" id="line-958"><code>		p := (i - 1) / 4</code></span>
<span class="codeline" id="line-959"><code>		if t.when &lt; pp.timers[p].when {</code></span>
<span class="codeline" id="line-960"><code>			print("bad timer heap at ", i, ": ", p, ": ", pp.timers[p].when, ", ", i, ": ", t.when, "\n")</code></span>
<span class="codeline" id="line-961"><code>			throw("bad timer heap")</code></span>
<span class="codeline" id="line-962"><code>		}</code></span>
<span class="codeline" id="line-963"><code>	}</code></span>
<span class="codeline" id="line-964"><code>	if numTimers := int(atomic.Load(&amp;pp.numTimers)); len(pp.timers) != numTimers {</code></span>
<span class="codeline" id="line-965"><code>		println("timer heap len", len(pp.timers), "!= numTimers", numTimers)</code></span>
<span class="codeline" id="line-966"><code>		throw("bad timer heap len")</code></span>
<span class="codeline" id="line-967"><code>	}</code></span>
<span class="codeline" id="line-968"><code>}</code></span>
<span class="codeline" id="line-969"><code></code></span>
<span class="codeline" id="line-970"><code>// updateTimer0When sets the P's timer0When field.</code></span>
<span class="codeline" id="line-971"><code>// The caller must have locked the timers for pp.</code></span>
<span class="codeline" id="line-972"><code>func updateTimer0When(pp *p) {</code></span>
<span class="codeline" id="line-973"><code>	if len(pp.timers) == 0 {</code></span>
<span class="codeline" id="line-974"><code>		atomic.Store64(&amp;pp.timer0When, 0)</code></span>
<span class="codeline" id="line-975"><code>	} else {</code></span>
<span class="codeline" id="line-976"><code>		atomic.Store64(&amp;pp.timer0When, uint64(pp.timers[0].when))</code></span>
<span class="codeline" id="line-977"><code>	}</code></span>
<span class="codeline" id="line-978"><code>}</code></span>
<span class="codeline" id="line-979"><code></code></span>
<span class="codeline" id="line-980"><code>// timeSleepUntil returns the time when the next timer should fire,</code></span>
<span class="codeline" id="line-981"><code>// and the P that holds the timer heap that that timer is on.</code></span>
<span class="codeline" id="line-982"><code>// This is only called by sysmon and checkdead.</code></span>
<span class="codeline" id="line-983"><code>func timeSleepUntil() (int64, *p) {</code></span>
<span class="codeline" id="line-984"><code>	next := int64(maxWhen)</code></span>
<span class="codeline" id="line-985"><code>	var pret *p</code></span>
<span class="codeline" id="line-986"><code></code></span>
<span class="codeline" id="line-987"><code>	// Prevent allp slice changes. This is like retake.</code></span>
<span class="codeline" id="line-988"><code>	lock(&amp;allpLock)</code></span>
<span class="codeline" id="line-989"><code>	for _, pp := range allp {</code></span>
<span class="codeline" id="line-990"><code>		if pp == nil {</code></span>
<span class="codeline" id="line-991"><code>			// This can happen if procresize has grown</code></span>
<span class="codeline" id="line-992"><code>			// allp but not yet created new Ps.</code></span>
<span class="codeline" id="line-993"><code>			continue</code></span>
<span class="codeline" id="line-994"><code>		}</code></span>
<span class="codeline" id="line-995"><code></code></span>
<span class="codeline" id="line-996"><code>		c := atomic.Load(&amp;pp.adjustTimers)</code></span>
<span class="codeline" id="line-997"><code>		if c == 0 {</code></span>
<span class="codeline" id="line-998"><code>			w := int64(atomic.Load64(&amp;pp.timer0When))</code></span>
<span class="codeline" id="line-999"><code>			if w != 0 &amp;&amp; w &lt; next {</code></span>
<span class="codeline" id="line-1000"><code>				next = w</code></span>
<span class="codeline" id="line-1001"><code>				pret = pp</code></span>
<span class="codeline" id="line-1002"><code>			}</code></span>
<span class="codeline" id="line-1003"><code>			continue</code></span>
<span class="codeline" id="line-1004"><code>		}</code></span>
<span class="codeline" id="line-1005"><code></code></span>
<span class="codeline" id="line-1006"><code>		lock(&amp;pp.timersLock)</code></span>
<span class="codeline" id="line-1007"><code>		for _, t := range pp.timers {</code></span>
<span class="codeline" id="line-1008"><code>			switch s := atomic.Load(&amp;t.status); s {</code></span>
<span class="codeline" id="line-1009"><code>			case timerWaiting:</code></span>
<span class="codeline" id="line-1010"><code>				if t.when &lt; next {</code></span>
<span class="codeline" id="line-1011"><code>					next = t.when</code></span>
<span class="codeline" id="line-1012"><code>				}</code></span>
<span class="codeline" id="line-1013"><code>			case timerModifiedEarlier, timerModifiedLater:</code></span>
<span class="codeline" id="line-1014"><code>				if t.nextwhen &lt; next {</code></span>
<span class="codeline" id="line-1015"><code>					next = t.nextwhen</code></span>
<span class="codeline" id="line-1016"><code>				}</code></span>
<span class="codeline" id="line-1017"><code>				if s == timerModifiedEarlier {</code></span>
<span class="codeline" id="line-1018"><code>					c--</code></span>
<span class="codeline" id="line-1019"><code>				}</code></span>
<span class="codeline" id="line-1020"><code>			}</code></span>
<span class="codeline" id="line-1021"><code>			// The timers are sorted, so we only have to check</code></span>
<span class="codeline" id="line-1022"><code>			// the first timer for each P, unless there are</code></span>
<span class="codeline" id="line-1023"><code>			// some timerModifiedEarlier timers. The number</code></span>
<span class="codeline" id="line-1024"><code>			// of timerModifiedEarlier timers is in the adjustTimers</code></span>
<span class="codeline" id="line-1025"><code>			// field, used to initialize c, above.</code></span>
<span class="codeline" id="line-1026"><code>			//</code></span>
<span class="codeline" id="line-1027"><code>			// We don't worry about cases like timerModifying.</code></span>
<span class="codeline" id="line-1028"><code>			// New timers can show up at any time,</code></span>
<span class="codeline" id="line-1029"><code>			// so this function is necessarily imprecise.</code></span>
<span class="codeline" id="line-1030"><code>			// Do a signed check here since we aren't</code></span>
<span class="codeline" id="line-1031"><code>			// synchronizing the read of pp.adjustTimers</code></span>
<span class="codeline" id="line-1032"><code>			// with the check of a timer status.</code></span>
<span class="codeline" id="line-1033"><code>			if int32(c) &lt;= 0 {</code></span>
<span class="codeline" id="line-1034"><code>				break</code></span>
<span class="codeline" id="line-1035"><code>			}</code></span>
<span class="codeline" id="line-1036"><code>		}</code></span>
<span class="codeline" id="line-1037"><code>		unlock(&amp;pp.timersLock)</code></span>
<span class="codeline" id="line-1038"><code>	}</code></span>
<span class="codeline" id="line-1039"><code>	unlock(&amp;allpLock)</code></span>
<span class="codeline" id="line-1040"><code></code></span>
<span class="codeline" id="line-1041"><code>	return next, pret</code></span>
<span class="codeline" id="line-1042"><code>}</code></span>
<span class="codeline" id="line-1043"><code></code></span>
<span class="codeline" id="line-1044"><code>// Heap maintenance algorithms.</code></span>
<span class="codeline" id="line-1045"><code>// These algorithms check for slice index errors manually.</code></span>
<span class="codeline" id="line-1046"><code>// Slice index error can happen if the program is using racy</code></span>
<span class="codeline" id="line-1047"><code>// access to timers. We don't want to panic here, because</code></span>
<span class="codeline" id="line-1048"><code>// it will cause the program to crash with a mysterious</code></span>
<span class="codeline" id="line-1049"><code>// "panic holding locks" message. Instead, we panic while not</code></span>
<span class="codeline" id="line-1050"><code>// holding a lock.</code></span>
<span class="codeline" id="line-1051"><code></code></span>
<span class="codeline" id="line-1052"><code>func siftupTimer(t []*timer, i int) {</code></span>
<span class="codeline" id="line-1053"><code>	if i &gt;= len(t) {</code></span>
<span class="codeline" id="line-1054"><code>		badTimer()</code></span>
<span class="codeline" id="line-1055"><code>	}</code></span>
<span class="codeline" id="line-1056"><code>	when := t[i].when</code></span>
<span class="codeline" id="line-1057"><code>	tmp := t[i]</code></span>
<span class="codeline" id="line-1058"><code>	for i &gt; 0 {</code></span>
<span class="codeline" id="line-1059"><code>		p := (i - 1) / 4 // parent</code></span>
<span class="codeline" id="line-1060"><code>		if when &gt;= t[p].when {</code></span>
<span class="codeline" id="line-1061"><code>			break</code></span>
<span class="codeline" id="line-1062"><code>		}</code></span>
<span class="codeline" id="line-1063"><code>		t[i] = t[p]</code></span>
<span class="codeline" id="line-1064"><code>		i = p</code></span>
<span class="codeline" id="line-1065"><code>	}</code></span>
<span class="codeline" id="line-1066"><code>	if tmp != t[i] {</code></span>
<span class="codeline" id="line-1067"><code>		t[i] = tmp</code></span>
<span class="codeline" id="line-1068"><code>	}</code></span>
<span class="codeline" id="line-1069"><code>}</code></span>
<span class="codeline" id="line-1070"><code></code></span>
<span class="codeline" id="line-1071"><code>func siftdownTimer(t []*timer, i int) {</code></span>
<span class="codeline" id="line-1072"><code>	n := len(t)</code></span>
<span class="codeline" id="line-1073"><code>	if i &gt;= n {</code></span>
<span class="codeline" id="line-1074"><code>		badTimer()</code></span>
<span class="codeline" id="line-1075"><code>	}</code></span>
<span class="codeline" id="line-1076"><code>	when := t[i].when</code></span>
<span class="codeline" id="line-1077"><code>	tmp := t[i]</code></span>
<span class="codeline" id="line-1078"><code>	for {</code></span>
<span class="codeline" id="line-1079"><code>		c := i*4 + 1 // left child</code></span>
<span class="codeline" id="line-1080"><code>		c3 := c + 2  // mid child</code></span>
<span class="codeline" id="line-1081"><code>		if c &gt;= n {</code></span>
<span class="codeline" id="line-1082"><code>			break</code></span>
<span class="codeline" id="line-1083"><code>		}</code></span>
<span class="codeline" id="line-1084"><code>		w := t[c].when</code></span>
<span class="codeline" id="line-1085"><code>		if c+1 &lt; n &amp;&amp; t[c+1].when &lt; w {</code></span>
<span class="codeline" id="line-1086"><code>			w = t[c+1].when</code></span>
<span class="codeline" id="line-1087"><code>			c++</code></span>
<span class="codeline" id="line-1088"><code>		}</code></span>
<span class="codeline" id="line-1089"><code>		if c3 &lt; n {</code></span>
<span class="codeline" id="line-1090"><code>			w3 := t[c3].when</code></span>
<span class="codeline" id="line-1091"><code>			if c3+1 &lt; n &amp;&amp; t[c3+1].when &lt; w3 {</code></span>
<span class="codeline" id="line-1092"><code>				w3 = t[c3+1].when</code></span>
<span class="codeline" id="line-1093"><code>				c3++</code></span>
<span class="codeline" id="line-1094"><code>			}</code></span>
<span class="codeline" id="line-1095"><code>			if w3 &lt; w {</code></span>
<span class="codeline" id="line-1096"><code>				w = w3</code></span>
<span class="codeline" id="line-1097"><code>				c = c3</code></span>
<span class="codeline" id="line-1098"><code>			}</code></span>
<span class="codeline" id="line-1099"><code>		}</code></span>
<span class="codeline" id="line-1100"><code>		if w &gt;= when {</code></span>
<span class="codeline" id="line-1101"><code>			break</code></span>
<span class="codeline" id="line-1102"><code>		}</code></span>
<span class="codeline" id="line-1103"><code>		t[i] = t[c]</code></span>
<span class="codeline" id="line-1104"><code>		i = c</code></span>
<span class="codeline" id="line-1105"><code>	}</code></span>
<span class="codeline" id="line-1106"><code>	if tmp != t[i] {</code></span>
<span class="codeline" id="line-1107"><code>		t[i] = tmp</code></span>
<span class="codeline" id="line-1108"><code>	}</code></span>
<span class="codeline" id="line-1109"><code>}</code></span>
<span class="codeline" id="line-1110"><code></code></span>
<span class="codeline" id="line-1111"><code>// badTimer is called if the timer data structures have been corrupted,</code></span>
<span class="codeline" id="line-1112"><code>// presumably due to racy use by the program. We panic here rather than</code></span>
<span class="codeline" id="line-1113"><code>// panicing due to invalid slice access while holding locks.</code></span>
<span class="codeline" id="line-1114"><code>// See issue #25686.</code></span>
<span class="codeline" id="line-1115"><code>func badTimer() {</code></span>
<span class="codeline" id="line-1116"><code>	throw("timer data corruption")</code></span>
<span class="codeline" id="line-1117"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.1.6</i>. (GOOS=darwin GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project and developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table
</pre>
</div></body></html>