<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: mgc.go in package runtime</title>
<link href="../../css/light-v0.1.6.css" rel="stylesheet">
<script src="../../jvs/golds-v0.1.6.js"></script>
<body><div>

<pre id="header"><code><span class="title">Source File</span>
	mgc.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/runtime.html">runtime</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>// Garbage collector (GC).</code></span>
<span class="codeline" id="line-6"><code>//</code></span>
<span class="codeline" id="line-7"><code>// The GC runs concurrently with mutator threads, is type accurate (aka precise), allows multiple</code></span>
<span class="codeline" id="line-8"><code>// GC thread to run in parallel. It is a concurrent mark and sweep that uses a write barrier. It is</code></span>
<span class="codeline" id="line-9"><code>// non-generational and non-compacting. Allocation is done using size segregated per P allocation</code></span>
<span class="codeline" id="line-10"><code>// areas to minimize fragmentation while eliminating locks in the common case.</code></span>
<span class="codeline" id="line-11"><code>//</code></span>
<span class="codeline" id="line-12"><code>// The algorithm decomposes into several steps.</code></span>
<span class="codeline" id="line-13"><code>// This is a high level description of the algorithm being used. For an overview of GC a good</code></span>
<span class="codeline" id="line-14"><code>// place to start is Richard Jones' gchandbook.org.</code></span>
<span class="codeline" id="line-15"><code>//</code></span>
<span class="codeline" id="line-16"><code>// The algorithm's intellectual heritage includes Dijkstra's on-the-fly algorithm, see</code></span>
<span class="codeline" id="line-17"><code>// Edsger W. Dijkstra, Leslie Lamport, A. J. Martin, C. S. Scholten, and E. F. M. Steffens. 1978.</code></span>
<span class="codeline" id="line-18"><code>// On-the-fly garbage collection: an exercise in cooperation. Commun. ACM 21, 11 (November 1978),</code></span>
<span class="codeline" id="line-19"><code>// 966-975.</code></span>
<span class="codeline" id="line-20"><code>// For journal quality proofs that these steps are complete, correct, and terminate see</code></span>
<span class="codeline" id="line-21"><code>// Hudson, R., and Moss, J.E.B. Copying Garbage Collection without stopping the world.</code></span>
<span class="codeline" id="line-22"><code>// Concurrency and Computation: Practice and Experience 15(3-5), 2003.</code></span>
<span class="codeline" id="line-23"><code>//</code></span>
<span class="codeline" id="line-24"><code>// 1. GC performs sweep termination.</code></span>
<span class="codeline" id="line-25"><code>//</code></span>
<span class="codeline" id="line-26"><code>//    a. Stop the world. This causes all Ps to reach a GC safe-point.</code></span>
<span class="codeline" id="line-27"><code>//</code></span>
<span class="codeline" id="line-28"><code>//    b. Sweep any unswept spans. There will only be unswept spans if</code></span>
<span class="codeline" id="line-29"><code>//    this GC cycle was forced before the expected time.</code></span>
<span class="codeline" id="line-30"><code>//</code></span>
<span class="codeline" id="line-31"><code>// 2. GC performs the mark phase.</code></span>
<span class="codeline" id="line-32"><code>//</code></span>
<span class="codeline" id="line-33"><code>//    a. Prepare for the mark phase by setting gcphase to _GCmark</code></span>
<span class="codeline" id="line-34"><code>//    (from _GCoff), enabling the write barrier, enabling mutator</code></span>
<span class="codeline" id="line-35"><code>//    assists, and enqueueing root mark jobs. No objects may be</code></span>
<span class="codeline" id="line-36"><code>//    scanned until all Ps have enabled the write barrier, which is</code></span>
<span class="codeline" id="line-37"><code>//    accomplished using STW.</code></span>
<span class="codeline" id="line-38"><code>//</code></span>
<span class="codeline" id="line-39"><code>//    b. Start the world. From this point, GC work is done by mark</code></span>
<span class="codeline" id="line-40"><code>//    workers started by the scheduler and by assists performed as</code></span>
<span class="codeline" id="line-41"><code>//    part of allocation. The write barrier shades both the</code></span>
<span class="codeline" id="line-42"><code>//    overwritten pointer and the new pointer value for any pointer</code></span>
<span class="codeline" id="line-43"><code>//    writes (see mbarrier.go for details). Newly allocated objects</code></span>
<span class="codeline" id="line-44"><code>//    are immediately marked black.</code></span>
<span class="codeline" id="line-45"><code>//</code></span>
<span class="codeline" id="line-46"><code>//    c. GC performs root marking jobs. This includes scanning all</code></span>
<span class="codeline" id="line-47"><code>//    stacks, shading all globals, and shading any heap pointers in</code></span>
<span class="codeline" id="line-48"><code>//    off-heap runtime data structures. Scanning a stack stops a</code></span>
<span class="codeline" id="line-49"><code>//    goroutine, shades any pointers found on its stack, and then</code></span>
<span class="codeline" id="line-50"><code>//    resumes the goroutine.</code></span>
<span class="codeline" id="line-51"><code>//</code></span>
<span class="codeline" id="line-52"><code>//    d. GC drains the work queue of grey objects, scanning each grey</code></span>
<span class="codeline" id="line-53"><code>//    object to black and shading all pointers found in the object</code></span>
<span class="codeline" id="line-54"><code>//    (which in turn may add those pointers to the work queue).</code></span>
<span class="codeline" id="line-55"><code>//</code></span>
<span class="codeline" id="line-56"><code>//    e. Because GC work is spread across local caches, GC uses a</code></span>
<span class="codeline" id="line-57"><code>//    distributed termination algorithm to detect when there are no</code></span>
<span class="codeline" id="line-58"><code>//    more root marking jobs or grey objects (see gcMarkDone). At this</code></span>
<span class="codeline" id="line-59"><code>//    point, GC transitions to mark termination.</code></span>
<span class="codeline" id="line-60"><code>//</code></span>
<span class="codeline" id="line-61"><code>// 3. GC performs mark termination.</code></span>
<span class="codeline" id="line-62"><code>//</code></span>
<span class="codeline" id="line-63"><code>//    a. Stop the world.</code></span>
<span class="codeline" id="line-64"><code>//</code></span>
<span class="codeline" id="line-65"><code>//    b. Set gcphase to _GCmarktermination, and disable workers and</code></span>
<span class="codeline" id="line-66"><code>//    assists.</code></span>
<span class="codeline" id="line-67"><code>//</code></span>
<span class="codeline" id="line-68"><code>//    c. Perform housekeeping like flushing mcaches.</code></span>
<span class="codeline" id="line-69"><code>//</code></span>
<span class="codeline" id="line-70"><code>// 4. GC performs the sweep phase.</code></span>
<span class="codeline" id="line-71"><code>//</code></span>
<span class="codeline" id="line-72"><code>//    a. Prepare for the sweep phase by setting gcphase to _GCoff,</code></span>
<span class="codeline" id="line-73"><code>//    setting up sweep state and disabling the write barrier.</code></span>
<span class="codeline" id="line-74"><code>//</code></span>
<span class="codeline" id="line-75"><code>//    b. Start the world. From this point on, newly allocated objects</code></span>
<span class="codeline" id="line-76"><code>//    are white, and allocating sweeps spans before use if necessary.</code></span>
<span class="codeline" id="line-77"><code>//</code></span>
<span class="codeline" id="line-78"><code>//    c. GC does concurrent sweeping in the background and in response</code></span>
<span class="codeline" id="line-79"><code>//    to allocation. See description below.</code></span>
<span class="codeline" id="line-80"><code>//</code></span>
<span class="codeline" id="line-81"><code>// 5. When sufficient allocation has taken place, replay the sequence</code></span>
<span class="codeline" id="line-82"><code>// starting with 1 above. See discussion of GC rate below.</code></span>
<span class="codeline" id="line-83"><code></code></span>
<span class="codeline" id="line-84"><code>// Concurrent sweep.</code></span>
<span class="codeline" id="line-85"><code>//</code></span>
<span class="codeline" id="line-86"><code>// The sweep phase proceeds concurrently with normal program execution.</code></span>
<span class="codeline" id="line-87"><code>// The heap is swept span-by-span both lazily (when a goroutine needs another span)</code></span>
<span class="codeline" id="line-88"><code>// and concurrently in a background goroutine (this helps programs that are not CPU bound).</code></span>
<span class="codeline" id="line-89"><code>// At the end of STW mark termination all spans are marked as "needs sweeping".</code></span>
<span class="codeline" id="line-90"><code>//</code></span>
<span class="codeline" id="line-91"><code>// The background sweeper goroutine simply sweeps spans one-by-one.</code></span>
<span class="codeline" id="line-92"><code>//</code></span>
<span class="codeline" id="line-93"><code>// To avoid requesting more OS memory while there are unswept spans, when a</code></span>
<span class="codeline" id="line-94"><code>// goroutine needs another span, it first attempts to reclaim that much memory</code></span>
<span class="codeline" id="line-95"><code>// by sweeping. When a goroutine needs to allocate a new small-object span, it</code></span>
<span class="codeline" id="line-96"><code>// sweeps small-object spans for the same object size until it frees at least</code></span>
<span class="codeline" id="line-97"><code>// one object. When a goroutine needs to allocate large-object span from heap,</code></span>
<span class="codeline" id="line-98"><code>// it sweeps spans until it frees at least that many pages into heap. There is</code></span>
<span class="codeline" id="line-99"><code>// one case where this may not suffice: if a goroutine sweeps and frees two</code></span>
<span class="codeline" id="line-100"><code>// nonadjacent one-page spans to the heap, it will allocate a new two-page</code></span>
<span class="codeline" id="line-101"><code>// span, but there can still be other one-page unswept spans which could be</code></span>
<span class="codeline" id="line-102"><code>// combined into a two-page span.</code></span>
<span class="codeline" id="line-103"><code>//</code></span>
<span class="codeline" id="line-104"><code>// It's critical to ensure that no operations proceed on unswept spans (that would corrupt</code></span>
<span class="codeline" id="line-105"><code>// mark bits in GC bitmap). During GC all mcaches are flushed into the central cache,</code></span>
<span class="codeline" id="line-106"><code>// so they are empty. When a goroutine grabs a new span into mcache, it sweeps it.</code></span>
<span class="codeline" id="line-107"><code>// When a goroutine explicitly frees an object or sets a finalizer, it ensures that</code></span>
<span class="codeline" id="line-108"><code>// the span is swept (either by sweeping it, or by waiting for the concurrent sweep to finish).</code></span>
<span class="codeline" id="line-109"><code>// The finalizer goroutine is kicked off only when all spans are swept.</code></span>
<span class="codeline" id="line-110"><code>// When the next GC starts, it sweeps all not-yet-swept spans (if any).</code></span>
<span class="codeline" id="line-111"><code></code></span>
<span class="codeline" id="line-112"><code>// GC rate.</code></span>
<span class="codeline" id="line-113"><code>// Next GC is after we've allocated an extra amount of memory proportional to</code></span>
<span class="codeline" id="line-114"><code>// the amount already in use. The proportion is controlled by GOGC environment variable</code></span>
<span class="codeline" id="line-115"><code>// (100 by default). If GOGC=100 and we're using 4M, we'll GC again when we get to 8M</code></span>
<span class="codeline" id="line-116"><code>// (this mark is tracked in next_gc variable). This keeps the GC cost in linear</code></span>
<span class="codeline" id="line-117"><code>// proportion to the allocation cost. Adjusting GOGC just changes the linear constant</code></span>
<span class="codeline" id="line-118"><code>// (and also the amount of extra memory used).</code></span>
<span class="codeline" id="line-119"><code></code></span>
<span class="codeline" id="line-120"><code>// Oblets</code></span>
<span class="codeline" id="line-121"><code>//</code></span>
<span class="codeline" id="line-122"><code>// In order to prevent long pauses while scanning large objects and to</code></span>
<span class="codeline" id="line-123"><code>// improve parallelism, the garbage collector breaks up scan jobs for</code></span>
<span class="codeline" id="line-124"><code>// objects larger than maxObletBytes into "oblets" of at most</code></span>
<span class="codeline" id="line-125"><code>// maxObletBytes. When scanning encounters the beginning of a large</code></span>
<span class="codeline" id="line-126"><code>// object, it scans only the first oblet and enqueues the remaining</code></span>
<span class="codeline" id="line-127"><code>// oblets as new scan jobs.</code></span>
<span class="codeline" id="line-128"><code></code></span>
<span class="codeline" id="line-129"><code>package runtime</code></span>
<span class="codeline" id="line-130"><code></code></span>
<span class="codeline" id="line-131"><code>import (</code></span>
<span class="codeline" id="line-132"><code>	"internal/cpu"</code></span>
<span class="codeline" id="line-133"><code>	"runtime/internal/atomic"</code></span>
<span class="codeline" id="line-134"><code>	"unsafe"</code></span>
<span class="codeline" id="line-135"><code>)</code></span>
<span class="codeline" id="line-136"><code></code></span>
<span class="codeline" id="line-137"><code>const (</code></span>
<span class="codeline" id="line-138"><code>	_DebugGC         = 0</code></span>
<span class="codeline" id="line-139"><code>	_ConcurrentSweep = true</code></span>
<span class="codeline" id="line-140"><code>	_FinBlockSize    = 4 * 1024</code></span>
<span class="codeline" id="line-141"><code></code></span>
<span class="codeline" id="line-142"><code>	// debugScanConservative enables debug logging for stack</code></span>
<span class="codeline" id="line-143"><code>	// frames that are scanned conservatively.</code></span>
<span class="codeline" id="line-144"><code>	debugScanConservative = false</code></span>
<span class="codeline" id="line-145"><code></code></span>
<span class="codeline" id="line-146"><code>	// sweepMinHeapDistance is a lower bound on the heap distance</code></span>
<span class="codeline" id="line-147"><code>	// (in bytes) reserved for concurrent sweeping between GC</code></span>
<span class="codeline" id="line-148"><code>	// cycles.</code></span>
<span class="codeline" id="line-149"><code>	sweepMinHeapDistance = 1024 * 1024</code></span>
<span class="codeline" id="line-150"><code>)</code></span>
<span class="codeline" id="line-151"><code></code></span>
<span class="codeline" id="line-152"><code>// heapminimum is the minimum heap size at which to trigger GC.</code></span>
<span class="codeline" id="line-153"><code>// For small heaps, this overrides the usual GOGC*live set rule.</code></span>
<span class="codeline" id="line-154"><code>//</code></span>
<span class="codeline" id="line-155"><code>// When there is a very small live set but a lot of allocation, simply</code></span>
<span class="codeline" id="line-156"><code>// collecting when the heap reaches GOGC*live results in many GC</code></span>
<span class="codeline" id="line-157"><code>// cycles and high total per-GC overhead. This minimum amortizes this</code></span>
<span class="codeline" id="line-158"><code>// per-GC overhead while keeping the heap reasonably small.</code></span>
<span class="codeline" id="line-159"><code>//</code></span>
<span class="codeline" id="line-160"><code>// During initialization this is set to 4MB*GOGC/100. In the case of</code></span>
<span class="codeline" id="line-161"><code>// GOGC==0, this will set heapminimum to 0, resulting in constant</code></span>
<span class="codeline" id="line-162"><code>// collection even when the heap size is small, which is useful for</code></span>
<span class="codeline" id="line-163"><code>// debugging.</code></span>
<span class="codeline" id="line-164"><code>var heapminimum uint64 = defaultHeapMinimum</code></span>
<span class="codeline" id="line-165"><code></code></span>
<span class="codeline" id="line-166"><code>// defaultHeapMinimum is the value of heapminimum for GOGC==100.</code></span>
<span class="codeline" id="line-167"><code>const defaultHeapMinimum = 4 &lt;&lt; 20</code></span>
<span class="codeline" id="line-168"><code></code></span>
<span class="codeline" id="line-169"><code>// Initialized from $GOGC.  GOGC=off means no GC.</code></span>
<span class="codeline" id="line-170"><code>var gcpercent int32</code></span>
<span class="codeline" id="line-171"><code></code></span>
<span class="codeline" id="line-172"><code>func gcinit() {</code></span>
<span class="codeline" id="line-173"><code>	if unsafe.Sizeof(workbuf{}) != _WorkbufSize {</code></span>
<span class="codeline" id="line-174"><code>		throw("size of Workbuf is suboptimal")</code></span>
<span class="codeline" id="line-175"><code>	}</code></span>
<span class="codeline" id="line-176"><code></code></span>
<span class="codeline" id="line-177"><code>	// No sweep on the first cycle.</code></span>
<span class="codeline" id="line-178"><code>	mheap_.sweepdone = 1</code></span>
<span class="codeline" id="line-179"><code></code></span>
<span class="codeline" id="line-180"><code>	// Set a reasonable initial GC trigger.</code></span>
<span class="codeline" id="line-181"><code>	memstats.triggerRatio = 7 / 8.0</code></span>
<span class="codeline" id="line-182"><code></code></span>
<span class="codeline" id="line-183"><code>	// Fake a heap_marked value so it looks like a trigger at</code></span>
<span class="codeline" id="line-184"><code>	// heapminimum is the appropriate growth from heap_marked.</code></span>
<span class="codeline" id="line-185"><code>	// This will go into computing the initial GC goal.</code></span>
<span class="codeline" id="line-186"><code>	memstats.heap_marked = uint64(float64(heapminimum) / (1 + memstats.triggerRatio))</code></span>
<span class="codeline" id="line-187"><code></code></span>
<span class="codeline" id="line-188"><code>	// Set gcpercent from the environment. This will also compute</code></span>
<span class="codeline" id="line-189"><code>	// and set the GC trigger and goal.</code></span>
<span class="codeline" id="line-190"><code>	_ = setGCPercent(readgogc())</code></span>
<span class="codeline" id="line-191"><code></code></span>
<span class="codeline" id="line-192"><code>	work.startSema = 1</code></span>
<span class="codeline" id="line-193"><code>	work.markDoneSema = 1</code></span>
<span class="codeline" id="line-194"><code>	lockInit(&amp;work.sweepWaiters.lock, lockRankSweepWaiters)</code></span>
<span class="codeline" id="line-195"><code>	lockInit(&amp;work.assistQueue.lock, lockRankAssistQueue)</code></span>
<span class="codeline" id="line-196"><code>	lockInit(&amp;work.wbufSpans.lock, lockRankWbufSpans)</code></span>
<span class="codeline" id="line-197"><code>}</code></span>
<span class="codeline" id="line-198"><code></code></span>
<span class="codeline" id="line-199"><code>func readgogc() int32 {</code></span>
<span class="codeline" id="line-200"><code>	p := gogetenv("GOGC")</code></span>
<span class="codeline" id="line-201"><code>	if p == "off" {</code></span>
<span class="codeline" id="line-202"><code>		return -1</code></span>
<span class="codeline" id="line-203"><code>	}</code></span>
<span class="codeline" id="line-204"><code>	if n, ok := atoi32(p); ok {</code></span>
<span class="codeline" id="line-205"><code>		return n</code></span>
<span class="codeline" id="line-206"><code>	}</code></span>
<span class="codeline" id="line-207"><code>	return 100</code></span>
<span class="codeline" id="line-208"><code>}</code></span>
<span class="codeline" id="line-209"><code></code></span>
<span class="codeline" id="line-210"><code>// gcenable is called after the bulk of the runtime initialization,</code></span>
<span class="codeline" id="line-211"><code>// just before we're about to start letting user code run.</code></span>
<span class="codeline" id="line-212"><code>// It kicks off the background sweeper goroutine, the background</code></span>
<span class="codeline" id="line-213"><code>// scavenger goroutine, and enables GC.</code></span>
<span class="codeline" id="line-214"><code>func gcenable() {</code></span>
<span class="codeline" id="line-215"><code>	// Kick off sweeping and scavenging.</code></span>
<span class="codeline" id="line-216"><code>	c := make(chan int, 2)</code></span>
<span class="codeline" id="line-217"><code>	go bgsweep(c)</code></span>
<span class="codeline" id="line-218"><code>	go bgscavenge(c)</code></span>
<span class="codeline" id="line-219"><code>	&lt;-c</code></span>
<span class="codeline" id="line-220"><code>	&lt;-c</code></span>
<span class="codeline" id="line-221"><code>	memstats.enablegc = true // now that runtime is initialized, GC is okay</code></span>
<span class="codeline" id="line-222"><code>}</code></span>
<span class="codeline" id="line-223"><code></code></span>
<span class="codeline" id="line-224"><code>//go:linkname setGCPercent runtime/debug.setGCPercent</code></span>
<span class="codeline" id="line-225"><code>func setGCPercent(in int32) (out int32) {</code></span>
<span class="codeline" id="line-226"><code>	// Run on the system stack since we grab the heap lock.</code></span>
<span class="codeline" id="line-227"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-228"><code>		lock(&amp;mheap_.lock)</code></span>
<span class="codeline" id="line-229"><code>		out = gcpercent</code></span>
<span class="codeline" id="line-230"><code>		if in &lt; 0 {</code></span>
<span class="codeline" id="line-231"><code>			in = -1</code></span>
<span class="codeline" id="line-232"><code>		}</code></span>
<span class="codeline" id="line-233"><code>		gcpercent = in</code></span>
<span class="codeline" id="line-234"><code>		heapminimum = defaultHeapMinimum * uint64(gcpercent) / 100</code></span>
<span class="codeline" id="line-235"><code>		// Update pacing in response to gcpercent change.</code></span>
<span class="codeline" id="line-236"><code>		gcSetTriggerRatio(memstats.triggerRatio)</code></span>
<span class="codeline" id="line-237"><code>		unlock(&amp;mheap_.lock)</code></span>
<span class="codeline" id="line-238"><code>	})</code></span>
<span class="codeline" id="line-239"><code></code></span>
<span class="codeline" id="line-240"><code>	// If we just disabled GC, wait for any concurrent GC mark to</code></span>
<span class="codeline" id="line-241"><code>	// finish so we always return with no GC running.</code></span>
<span class="codeline" id="line-242"><code>	if in &lt; 0 {</code></span>
<span class="codeline" id="line-243"><code>		gcWaitOnMark(atomic.Load(&amp;work.cycles))</code></span>
<span class="codeline" id="line-244"><code>	}</code></span>
<span class="codeline" id="line-245"><code></code></span>
<span class="codeline" id="line-246"><code>	return out</code></span>
<span class="codeline" id="line-247"><code>}</code></span>
<span class="codeline" id="line-248"><code></code></span>
<span class="codeline" id="line-249"><code>// Garbage collector phase.</code></span>
<span class="codeline" id="line-250"><code>// Indicates to write barrier and synchronization task to perform.</code></span>
<span class="codeline" id="line-251"><code>var gcphase uint32</code></span>
<span class="codeline" id="line-252"><code></code></span>
<span class="codeline" id="line-253"><code>// The compiler knows about this variable.</code></span>
<span class="codeline" id="line-254"><code>// If you change it, you must change builtin/runtime.go, too.</code></span>
<span class="codeline" id="line-255"><code>// If you change the first four bytes, you must also change the write</code></span>
<span class="codeline" id="line-256"><code>// barrier insertion code.</code></span>
<span class="codeline" id="line-257"><code>var writeBarrier struct {</code></span>
<span class="codeline" id="line-258"><code>	enabled bool    // compiler emits a check of this before calling write barrier</code></span>
<span class="codeline" id="line-259"><code>	pad     [3]byte // compiler uses 32-bit load for "enabled" field</code></span>
<span class="codeline" id="line-260"><code>	needed  bool    // whether we need a write barrier for current GC phase</code></span>
<span class="codeline" id="line-261"><code>	cgo     bool    // whether we need a write barrier for a cgo check</code></span>
<span class="codeline" id="line-262"><code>	alignme uint64  // guarantee alignment so that compiler can use a 32 or 64-bit load</code></span>
<span class="codeline" id="line-263"><code>}</code></span>
<span class="codeline" id="line-264"><code></code></span>
<span class="codeline" id="line-265"><code>// gcBlackenEnabled is 1 if mutator assists and background mark</code></span>
<span class="codeline" id="line-266"><code>// workers are allowed to blacken objects. This must only be set when</code></span>
<span class="codeline" id="line-267"><code>// gcphase == _GCmark.</code></span>
<span class="codeline" id="line-268"><code>var gcBlackenEnabled uint32</code></span>
<span class="codeline" id="line-269"><code></code></span>
<span class="codeline" id="line-270"><code>const (</code></span>
<span class="codeline" id="line-271"><code>	_GCoff             = iota // GC not running; sweeping in background, write barrier disabled</code></span>
<span class="codeline" id="line-272"><code>	_GCmark                   // GC marking roots and workbufs: allocate black, write barrier ENABLED</code></span>
<span class="codeline" id="line-273"><code>	_GCmarktermination        // GC mark termination: allocate black, P's help GC, write barrier ENABLED</code></span>
<span class="codeline" id="line-274"><code>)</code></span>
<span class="codeline" id="line-275"><code></code></span>
<span class="codeline" id="line-276"><code>//go:nosplit</code></span>
<span class="codeline" id="line-277"><code>func setGCPhase(x uint32) {</code></span>
<span class="codeline" id="line-278"><code>	atomic.Store(&amp;gcphase, x)</code></span>
<span class="codeline" id="line-279"><code>	writeBarrier.needed = gcphase == _GCmark || gcphase == _GCmarktermination</code></span>
<span class="codeline" id="line-280"><code>	writeBarrier.enabled = writeBarrier.needed || writeBarrier.cgo</code></span>
<span class="codeline" id="line-281"><code>}</code></span>
<span class="codeline" id="line-282"><code></code></span>
<span class="codeline" id="line-283"><code>// gcMarkWorkerMode represents the mode that a concurrent mark worker</code></span>
<span class="codeline" id="line-284"><code>// should operate in.</code></span>
<span class="codeline" id="line-285"><code>//</code></span>
<span class="codeline" id="line-286"><code>// Concurrent marking happens through four different mechanisms. One</code></span>
<span class="codeline" id="line-287"><code>// is mutator assists, which happen in response to allocations and are</code></span>
<span class="codeline" id="line-288"><code>// not scheduled. The other three are variations in the per-P mark</code></span>
<span class="codeline" id="line-289"><code>// workers and are distinguished by gcMarkWorkerMode.</code></span>
<span class="codeline" id="line-290"><code>type gcMarkWorkerMode int</code></span>
<span class="codeline" id="line-291"><code></code></span>
<span class="codeline" id="line-292"><code>const (</code></span>
<span class="codeline" id="line-293"><code>	// gcMarkWorkerDedicatedMode indicates that the P of a mark</code></span>
<span class="codeline" id="line-294"><code>	// worker is dedicated to running that mark worker. The mark</code></span>
<span class="codeline" id="line-295"><code>	// worker should run without preemption.</code></span>
<span class="codeline" id="line-296"><code>	gcMarkWorkerDedicatedMode gcMarkWorkerMode = iota</code></span>
<span class="codeline" id="line-297"><code></code></span>
<span class="codeline" id="line-298"><code>	// gcMarkWorkerFractionalMode indicates that a P is currently</code></span>
<span class="codeline" id="line-299"><code>	// running the "fractional" mark worker. The fractional worker</code></span>
<span class="codeline" id="line-300"><code>	// is necessary when GOMAXPROCS*gcBackgroundUtilization is not</code></span>
<span class="codeline" id="line-301"><code>	// an integer. The fractional worker should run until it is</code></span>
<span class="codeline" id="line-302"><code>	// preempted and will be scheduled to pick up the fractional</code></span>
<span class="codeline" id="line-303"><code>	// part of GOMAXPROCS*gcBackgroundUtilization.</code></span>
<span class="codeline" id="line-304"><code>	gcMarkWorkerFractionalMode</code></span>
<span class="codeline" id="line-305"><code></code></span>
<span class="codeline" id="line-306"><code>	// gcMarkWorkerIdleMode indicates that a P is running the mark</code></span>
<span class="codeline" id="line-307"><code>	// worker because it has nothing else to do. The idle worker</code></span>
<span class="codeline" id="line-308"><code>	// should run until it is preempted and account its time</code></span>
<span class="codeline" id="line-309"><code>	// against gcController.idleMarkTime.</code></span>
<span class="codeline" id="line-310"><code>	gcMarkWorkerIdleMode</code></span>
<span class="codeline" id="line-311"><code>)</code></span>
<span class="codeline" id="line-312"><code></code></span>
<span class="codeline" id="line-313"><code>// gcMarkWorkerModeStrings are the strings labels of gcMarkWorkerModes</code></span>
<span class="codeline" id="line-314"><code>// to use in execution traces.</code></span>
<span class="codeline" id="line-315"><code>var gcMarkWorkerModeStrings = [...]string{</code></span>
<span class="codeline" id="line-316"><code>	"GC (dedicated)",</code></span>
<span class="codeline" id="line-317"><code>	"GC (fractional)",</code></span>
<span class="codeline" id="line-318"><code>	"GC (idle)",</code></span>
<span class="codeline" id="line-319"><code>}</code></span>
<span class="codeline" id="line-320"><code></code></span>
<span class="codeline" id="line-321"><code>// gcController implements the GC pacing controller that determines</code></span>
<span class="codeline" id="line-322"><code>// when to trigger concurrent garbage collection and how much marking</code></span>
<span class="codeline" id="line-323"><code>// work to do in mutator assists and background marking.</code></span>
<span class="codeline" id="line-324"><code>//</code></span>
<span class="codeline" id="line-325"><code>// It uses a feedback control algorithm to adjust the memstats.gc_trigger</code></span>
<span class="codeline" id="line-326"><code>// trigger based on the heap growth and GC CPU utilization each cycle.</code></span>
<span class="codeline" id="line-327"><code>// This algorithm optimizes for heap growth to match GOGC and for CPU</code></span>
<span class="codeline" id="line-328"><code>// utilization between assist and background marking to be 25% of</code></span>
<span class="codeline" id="line-329"><code>// GOMAXPROCS. The high-level design of this algorithm is documented</code></span>
<span class="codeline" id="line-330"><code>// at https://golang.org/s/go15gcpacing.</code></span>
<span class="codeline" id="line-331"><code>//</code></span>
<span class="codeline" id="line-332"><code>// All fields of gcController are used only during a single mark</code></span>
<span class="codeline" id="line-333"><code>// cycle.</code></span>
<span class="codeline" id="line-334"><code>var gcController gcControllerState</code></span>
<span class="codeline" id="line-335"><code></code></span>
<span class="codeline" id="line-336"><code>type gcControllerState struct {</code></span>
<span class="codeline" id="line-337"><code>	// scanWork is the total scan work performed this cycle. This</code></span>
<span class="codeline" id="line-338"><code>	// is updated atomically during the cycle. Updates occur in</code></span>
<span class="codeline" id="line-339"><code>	// bounded batches, since it is both written and read</code></span>
<span class="codeline" id="line-340"><code>	// throughout the cycle. At the end of the cycle, this is how</code></span>
<span class="codeline" id="line-341"><code>	// much of the retained heap is scannable.</code></span>
<span class="codeline" id="line-342"><code>	//</code></span>
<span class="codeline" id="line-343"><code>	// Currently this is the bytes of heap scanned. For most uses,</code></span>
<span class="codeline" id="line-344"><code>	// this is an opaque unit of work, but for estimation the</code></span>
<span class="codeline" id="line-345"><code>	// definition is important.</code></span>
<span class="codeline" id="line-346"><code>	scanWork int64</code></span>
<span class="codeline" id="line-347"><code></code></span>
<span class="codeline" id="line-348"><code>	// bgScanCredit is the scan work credit accumulated by the</code></span>
<span class="codeline" id="line-349"><code>	// concurrent background scan. This credit is accumulated by</code></span>
<span class="codeline" id="line-350"><code>	// the background scan and stolen by mutator assists. This is</code></span>
<span class="codeline" id="line-351"><code>	// updated atomically. Updates occur in bounded batches, since</code></span>
<span class="codeline" id="line-352"><code>	// it is both written and read throughout the cycle.</code></span>
<span class="codeline" id="line-353"><code>	bgScanCredit int64</code></span>
<span class="codeline" id="line-354"><code></code></span>
<span class="codeline" id="line-355"><code>	// assistTime is the nanoseconds spent in mutator assists</code></span>
<span class="codeline" id="line-356"><code>	// during this cycle. This is updated atomically. Updates</code></span>
<span class="codeline" id="line-357"><code>	// occur in bounded batches, since it is both written and read</code></span>
<span class="codeline" id="line-358"><code>	// throughout the cycle.</code></span>
<span class="codeline" id="line-359"><code>	assistTime int64</code></span>
<span class="codeline" id="line-360"><code></code></span>
<span class="codeline" id="line-361"><code>	// dedicatedMarkTime is the nanoseconds spent in dedicated</code></span>
<span class="codeline" id="line-362"><code>	// mark workers during this cycle. This is updated atomically</code></span>
<span class="codeline" id="line-363"><code>	// at the end of the concurrent mark phase.</code></span>
<span class="codeline" id="line-364"><code>	dedicatedMarkTime int64</code></span>
<span class="codeline" id="line-365"><code></code></span>
<span class="codeline" id="line-366"><code>	// fractionalMarkTime is the nanoseconds spent in the</code></span>
<span class="codeline" id="line-367"><code>	// fractional mark worker during this cycle. This is updated</code></span>
<span class="codeline" id="line-368"><code>	// atomically throughout the cycle and will be up-to-date if</code></span>
<span class="codeline" id="line-369"><code>	// the fractional mark worker is not currently running.</code></span>
<span class="codeline" id="line-370"><code>	fractionalMarkTime int64</code></span>
<span class="codeline" id="line-371"><code></code></span>
<span class="codeline" id="line-372"><code>	// idleMarkTime is the nanoseconds spent in idle marking</code></span>
<span class="codeline" id="line-373"><code>	// during this cycle. This is updated atomically throughout</code></span>
<span class="codeline" id="line-374"><code>	// the cycle.</code></span>
<span class="codeline" id="line-375"><code>	idleMarkTime int64</code></span>
<span class="codeline" id="line-376"><code></code></span>
<span class="codeline" id="line-377"><code>	// markStartTime is the absolute start time in nanoseconds</code></span>
<span class="codeline" id="line-378"><code>	// that assists and background mark workers started.</code></span>
<span class="codeline" id="line-379"><code>	markStartTime int64</code></span>
<span class="codeline" id="line-380"><code></code></span>
<span class="codeline" id="line-381"><code>	// dedicatedMarkWorkersNeeded is the number of dedicated mark</code></span>
<span class="codeline" id="line-382"><code>	// workers that need to be started. This is computed at the</code></span>
<span class="codeline" id="line-383"><code>	// beginning of each cycle and decremented atomically as</code></span>
<span class="codeline" id="line-384"><code>	// dedicated mark workers get started.</code></span>
<span class="codeline" id="line-385"><code>	dedicatedMarkWorkersNeeded int64</code></span>
<span class="codeline" id="line-386"><code></code></span>
<span class="codeline" id="line-387"><code>	// assistWorkPerByte is the ratio of scan work to allocated</code></span>
<span class="codeline" id="line-388"><code>	// bytes that should be performed by mutator assists. This is</code></span>
<span class="codeline" id="line-389"><code>	// computed at the beginning of each cycle and updated every</code></span>
<span class="codeline" id="line-390"><code>	// time heap_scan is updated.</code></span>
<span class="codeline" id="line-391"><code>	assistWorkPerByte float64</code></span>
<span class="codeline" id="line-392"><code></code></span>
<span class="codeline" id="line-393"><code>	// assistBytesPerWork is 1/assistWorkPerByte.</code></span>
<span class="codeline" id="line-394"><code>	assistBytesPerWork float64</code></span>
<span class="codeline" id="line-395"><code></code></span>
<span class="codeline" id="line-396"><code>	// fractionalUtilizationGoal is the fraction of wall clock</code></span>
<span class="codeline" id="line-397"><code>	// time that should be spent in the fractional mark worker on</code></span>
<span class="codeline" id="line-398"><code>	// each P that isn't running a dedicated worker.</code></span>
<span class="codeline" id="line-399"><code>	//</code></span>
<span class="codeline" id="line-400"><code>	// For example, if the utilization goal is 25% and there are</code></span>
<span class="codeline" id="line-401"><code>	// no dedicated workers, this will be 0.25. If the goal is</code></span>
<span class="codeline" id="line-402"><code>	// 25%, there is one dedicated worker, and GOMAXPROCS is 5,</code></span>
<span class="codeline" id="line-403"><code>	// this will be 0.05 to make up the missing 5%.</code></span>
<span class="codeline" id="line-404"><code>	//</code></span>
<span class="codeline" id="line-405"><code>	// If this is zero, no fractional workers are needed.</code></span>
<span class="codeline" id="line-406"><code>	fractionalUtilizationGoal float64</code></span>
<span class="codeline" id="line-407"><code></code></span>
<span class="codeline" id="line-408"><code>	_ cpu.CacheLinePad</code></span>
<span class="codeline" id="line-409"><code>}</code></span>
<span class="codeline" id="line-410"><code></code></span>
<span class="codeline" id="line-411"><code>// startCycle resets the GC controller's state and computes estimates</code></span>
<span class="codeline" id="line-412"><code>// for a new GC cycle. The caller must hold worldsema.</code></span>
<span class="codeline" id="line-413"><code>func (c *gcControllerState) startCycle() {</code></span>
<span class="codeline" id="line-414"><code>	c.scanWork = 0</code></span>
<span class="codeline" id="line-415"><code>	c.bgScanCredit = 0</code></span>
<span class="codeline" id="line-416"><code>	c.assistTime = 0</code></span>
<span class="codeline" id="line-417"><code>	c.dedicatedMarkTime = 0</code></span>
<span class="codeline" id="line-418"><code>	c.fractionalMarkTime = 0</code></span>
<span class="codeline" id="line-419"><code>	c.idleMarkTime = 0</code></span>
<span class="codeline" id="line-420"><code></code></span>
<span class="codeline" id="line-421"><code>	// Ensure that the heap goal is at least a little larger than</code></span>
<span class="codeline" id="line-422"><code>	// the current live heap size. This may not be the case if GC</code></span>
<span class="codeline" id="line-423"><code>	// start is delayed or if the allocation that pushed heap_live</code></span>
<span class="codeline" id="line-424"><code>	// over gc_trigger is large or if the trigger is really close to</code></span>
<span class="codeline" id="line-425"><code>	// GOGC. Assist is proportional to this distance, so enforce a</code></span>
<span class="codeline" id="line-426"><code>	// minimum distance, even if it means going over the GOGC goal</code></span>
<span class="codeline" id="line-427"><code>	// by a tiny bit.</code></span>
<span class="codeline" id="line-428"><code>	if memstats.next_gc &lt; memstats.heap_live+1024*1024 {</code></span>
<span class="codeline" id="line-429"><code>		memstats.next_gc = memstats.heap_live + 1024*1024</code></span>
<span class="codeline" id="line-430"><code>	}</code></span>
<span class="codeline" id="line-431"><code></code></span>
<span class="codeline" id="line-432"><code>	// Compute the background mark utilization goal. In general,</code></span>
<span class="codeline" id="line-433"><code>	// this may not come out exactly. We round the number of</code></span>
<span class="codeline" id="line-434"><code>	// dedicated workers so that the utilization is closest to</code></span>
<span class="codeline" id="line-435"><code>	// 25%. For small GOMAXPROCS, this would introduce too much</code></span>
<span class="codeline" id="line-436"><code>	// error, so we add fractional workers in that case.</code></span>
<span class="codeline" id="line-437"><code>	totalUtilizationGoal := float64(gomaxprocs) * gcBackgroundUtilization</code></span>
<span class="codeline" id="line-438"><code>	c.dedicatedMarkWorkersNeeded = int64(totalUtilizationGoal + 0.5)</code></span>
<span class="codeline" id="line-439"><code>	utilError := float64(c.dedicatedMarkWorkersNeeded)/totalUtilizationGoal - 1</code></span>
<span class="codeline" id="line-440"><code>	const maxUtilError = 0.3</code></span>
<span class="codeline" id="line-441"><code>	if utilError &lt; -maxUtilError || utilError &gt; maxUtilError {</code></span>
<span class="codeline" id="line-442"><code>		// Rounding put us more than 30% off our goal. With</code></span>
<span class="codeline" id="line-443"><code>		// gcBackgroundUtilization of 25%, this happens for</code></span>
<span class="codeline" id="line-444"><code>		// GOMAXPROCS&lt;=3 or GOMAXPROCS=6. Enable fractional</code></span>
<span class="codeline" id="line-445"><code>		// workers to compensate.</code></span>
<span class="codeline" id="line-446"><code>		if float64(c.dedicatedMarkWorkersNeeded) &gt; totalUtilizationGoal {</code></span>
<span class="codeline" id="line-447"><code>			// Too many dedicated workers.</code></span>
<span class="codeline" id="line-448"><code>			c.dedicatedMarkWorkersNeeded--</code></span>
<span class="codeline" id="line-449"><code>		}</code></span>
<span class="codeline" id="line-450"><code>		c.fractionalUtilizationGoal = (totalUtilizationGoal - float64(c.dedicatedMarkWorkersNeeded)) / float64(gomaxprocs)</code></span>
<span class="codeline" id="line-451"><code>	} else {</code></span>
<span class="codeline" id="line-452"><code>		c.fractionalUtilizationGoal = 0</code></span>
<span class="codeline" id="line-453"><code>	}</code></span>
<span class="codeline" id="line-454"><code></code></span>
<span class="codeline" id="line-455"><code>	// In STW mode, we just want dedicated workers.</code></span>
<span class="codeline" id="line-456"><code>	if debug.gcstoptheworld &gt; 0 {</code></span>
<span class="codeline" id="line-457"><code>		c.dedicatedMarkWorkersNeeded = int64(gomaxprocs)</code></span>
<span class="codeline" id="line-458"><code>		c.fractionalUtilizationGoal = 0</code></span>
<span class="codeline" id="line-459"><code>	}</code></span>
<span class="codeline" id="line-460"><code></code></span>
<span class="codeline" id="line-461"><code>	// Clear per-P state</code></span>
<span class="codeline" id="line-462"><code>	for _, p := range allp {</code></span>
<span class="codeline" id="line-463"><code>		p.gcAssistTime = 0</code></span>
<span class="codeline" id="line-464"><code>		p.gcFractionalMarkTime = 0</code></span>
<span class="codeline" id="line-465"><code>	}</code></span>
<span class="codeline" id="line-466"><code></code></span>
<span class="codeline" id="line-467"><code>	// Compute initial values for controls that are updated</code></span>
<span class="codeline" id="line-468"><code>	// throughout the cycle.</code></span>
<span class="codeline" id="line-469"><code>	c.revise()</code></span>
<span class="codeline" id="line-470"><code></code></span>
<span class="codeline" id="line-471"><code>	if debug.gcpacertrace &gt; 0 {</code></span>
<span class="codeline" id="line-472"><code>		print("pacer: assist ratio=", c.assistWorkPerByte,</code></span>
<span class="codeline" id="line-473"><code>			" (scan ", memstats.heap_scan&gt;&gt;20, " MB in ",</code></span>
<span class="codeline" id="line-474"><code>			work.initialHeapLive&gt;&gt;20, "-&gt;",</code></span>
<span class="codeline" id="line-475"><code>			memstats.next_gc&gt;&gt;20, " MB)",</code></span>
<span class="codeline" id="line-476"><code>			" workers=", c.dedicatedMarkWorkersNeeded,</code></span>
<span class="codeline" id="line-477"><code>			"+", c.fractionalUtilizationGoal, "\n")</code></span>
<span class="codeline" id="line-478"><code>	}</code></span>
<span class="codeline" id="line-479"><code>}</code></span>
<span class="codeline" id="line-480"><code></code></span>
<span class="codeline" id="line-481"><code>// revise updates the assist ratio during the GC cycle to account for</code></span>
<span class="codeline" id="line-482"><code>// improved estimates. This should be called either under STW or</code></span>
<span class="codeline" id="line-483"><code>// whenever memstats.heap_scan, memstats.heap_live, or</code></span>
<span class="codeline" id="line-484"><code>// memstats.next_gc is updated (with mheap_.lock held).</code></span>
<span class="codeline" id="line-485"><code>//</code></span>
<span class="codeline" id="line-486"><code>// It should only be called when gcBlackenEnabled != 0 (because this</code></span>
<span class="codeline" id="line-487"><code>// is when assists are enabled and the necessary statistics are</code></span>
<span class="codeline" id="line-488"><code>// available).</code></span>
<span class="codeline" id="line-489"><code>func (c *gcControllerState) revise() {</code></span>
<span class="codeline" id="line-490"><code>	gcpercent := gcpercent</code></span>
<span class="codeline" id="line-491"><code>	if gcpercent &lt; 0 {</code></span>
<span class="codeline" id="line-492"><code>		// If GC is disabled but we're running a forced GC,</code></span>
<span class="codeline" id="line-493"><code>		// act like GOGC is huge for the below calculations.</code></span>
<span class="codeline" id="line-494"><code>		gcpercent = 100000</code></span>
<span class="codeline" id="line-495"><code>	}</code></span>
<span class="codeline" id="line-496"><code>	live := atomic.Load64(&amp;memstats.heap_live)</code></span>
<span class="codeline" id="line-497"><code></code></span>
<span class="codeline" id="line-498"><code>	// Assume we're under the soft goal. Pace GC to complete at</code></span>
<span class="codeline" id="line-499"><code>	// next_gc assuming the heap is in steady-state.</code></span>
<span class="codeline" id="line-500"><code>	heapGoal := int64(memstats.next_gc)</code></span>
<span class="codeline" id="line-501"><code></code></span>
<span class="codeline" id="line-502"><code>	// Compute the expected scan work remaining.</code></span>
<span class="codeline" id="line-503"><code>	//</code></span>
<span class="codeline" id="line-504"><code>	// This is estimated based on the expected</code></span>
<span class="codeline" id="line-505"><code>	// steady-state scannable heap. For example, with</code></span>
<span class="codeline" id="line-506"><code>	// GOGC=100, only half of the scannable heap is</code></span>
<span class="codeline" id="line-507"><code>	// expected to be live, so that's what we target.</code></span>
<span class="codeline" id="line-508"><code>	//</code></span>
<span class="codeline" id="line-509"><code>	// (This is a float calculation to avoid overflowing on</code></span>
<span class="codeline" id="line-510"><code>	// 100*heap_scan.)</code></span>
<span class="codeline" id="line-511"><code>	scanWorkExpected := int64(float64(memstats.heap_scan) * 100 / float64(100+gcpercent))</code></span>
<span class="codeline" id="line-512"><code></code></span>
<span class="codeline" id="line-513"><code>	if live &gt; memstats.next_gc || c.scanWork &gt; scanWorkExpected {</code></span>
<span class="codeline" id="line-514"><code>		// We're past the soft goal, or we've already done more scan</code></span>
<span class="codeline" id="line-515"><code>		// work than we expected. Pace GC so that in the worst case it</code></span>
<span class="codeline" id="line-516"><code>		// will complete by the hard goal.</code></span>
<span class="codeline" id="line-517"><code>		const maxOvershoot = 1.1</code></span>
<span class="codeline" id="line-518"><code>		heapGoal = int64(float64(memstats.next_gc) * maxOvershoot)</code></span>
<span class="codeline" id="line-519"><code></code></span>
<span class="codeline" id="line-520"><code>		// Compute the upper bound on the scan work remaining.</code></span>
<span class="codeline" id="line-521"><code>		scanWorkExpected = int64(memstats.heap_scan)</code></span>
<span class="codeline" id="line-522"><code>	}</code></span>
<span class="codeline" id="line-523"><code></code></span>
<span class="codeline" id="line-524"><code>	// Compute the remaining scan work estimate.</code></span>
<span class="codeline" id="line-525"><code>	//</code></span>
<span class="codeline" id="line-526"><code>	// Note that we currently count allocations during GC as both</code></span>
<span class="codeline" id="line-527"><code>	// scannable heap (heap_scan) and scan work completed</code></span>
<span class="codeline" id="line-528"><code>	// (scanWork), so allocation will change this difference</code></span>
<span class="codeline" id="line-529"><code>	// slowly in the soft regime and not at all in the hard</code></span>
<span class="codeline" id="line-530"><code>	// regime.</code></span>
<span class="codeline" id="line-531"><code>	scanWorkRemaining := scanWorkExpected - c.scanWork</code></span>
<span class="codeline" id="line-532"><code>	if scanWorkRemaining &lt; 1000 {</code></span>
<span class="codeline" id="line-533"><code>		// We set a somewhat arbitrary lower bound on</code></span>
<span class="codeline" id="line-534"><code>		// remaining scan work since if we aim a little high,</code></span>
<span class="codeline" id="line-535"><code>		// we can miss by a little.</code></span>
<span class="codeline" id="line-536"><code>		//</code></span>
<span class="codeline" id="line-537"><code>		// We *do* need to enforce that this is at least 1,</code></span>
<span class="codeline" id="line-538"><code>		// since marking is racy and double-scanning objects</code></span>
<span class="codeline" id="line-539"><code>		// may legitimately make the remaining scan work</code></span>
<span class="codeline" id="line-540"><code>		// negative, even in the hard goal regime.</code></span>
<span class="codeline" id="line-541"><code>		scanWorkRemaining = 1000</code></span>
<span class="codeline" id="line-542"><code>	}</code></span>
<span class="codeline" id="line-543"><code></code></span>
<span class="codeline" id="line-544"><code>	// Compute the heap distance remaining.</code></span>
<span class="codeline" id="line-545"><code>	heapRemaining := heapGoal - int64(live)</code></span>
<span class="codeline" id="line-546"><code>	if heapRemaining &lt;= 0 {</code></span>
<span class="codeline" id="line-547"><code>		// This shouldn't happen, but if it does, avoid</code></span>
<span class="codeline" id="line-548"><code>		// dividing by zero or setting the assist negative.</code></span>
<span class="codeline" id="line-549"><code>		heapRemaining = 1</code></span>
<span class="codeline" id="line-550"><code>	}</code></span>
<span class="codeline" id="line-551"><code></code></span>
<span class="codeline" id="line-552"><code>	// Compute the mutator assist ratio so by the time the mutator</code></span>
<span class="codeline" id="line-553"><code>	// allocates the remaining heap bytes up to next_gc, it will</code></span>
<span class="codeline" id="line-554"><code>	// have done (or stolen) the remaining amount of scan work.</code></span>
<span class="codeline" id="line-555"><code>	c.assistWorkPerByte = float64(scanWorkRemaining) / float64(heapRemaining)</code></span>
<span class="codeline" id="line-556"><code>	c.assistBytesPerWork = float64(heapRemaining) / float64(scanWorkRemaining)</code></span>
<span class="codeline" id="line-557"><code>}</code></span>
<span class="codeline" id="line-558"><code></code></span>
<span class="codeline" id="line-559"><code>// endCycle computes the trigger ratio for the next cycle.</code></span>
<span class="codeline" id="line-560"><code>func (c *gcControllerState) endCycle() float64 {</code></span>
<span class="codeline" id="line-561"><code>	if work.userForced {</code></span>
<span class="codeline" id="line-562"><code>		// Forced GC means this cycle didn't start at the</code></span>
<span class="codeline" id="line-563"><code>		// trigger, so where it finished isn't good</code></span>
<span class="codeline" id="line-564"><code>		// information about how to adjust the trigger.</code></span>
<span class="codeline" id="line-565"><code>		// Just leave it where it is.</code></span>
<span class="codeline" id="line-566"><code>		return memstats.triggerRatio</code></span>
<span class="codeline" id="line-567"><code>	}</code></span>
<span class="codeline" id="line-568"><code></code></span>
<span class="codeline" id="line-569"><code>	// Proportional response gain for the trigger controller. Must</code></span>
<span class="codeline" id="line-570"><code>	// be in [0, 1]. Lower values smooth out transient effects but</code></span>
<span class="codeline" id="line-571"><code>	// take longer to respond to phase changes. Higher values</code></span>
<span class="codeline" id="line-572"><code>	// react to phase changes quickly, but are more affected by</code></span>
<span class="codeline" id="line-573"><code>	// transient changes. Values near 1 may be unstable.</code></span>
<span class="codeline" id="line-574"><code>	const triggerGain = 0.5</code></span>
<span class="codeline" id="line-575"><code></code></span>
<span class="codeline" id="line-576"><code>	// Compute next cycle trigger ratio. First, this computes the</code></span>
<span class="codeline" id="line-577"><code>	// "error" for this cycle; that is, how far off the trigger</code></span>
<span class="codeline" id="line-578"><code>	// was from what it should have been, accounting for both heap</code></span>
<span class="codeline" id="line-579"><code>	// growth and GC CPU utilization. We compute the actual heap</code></span>
<span class="codeline" id="line-580"><code>	// growth during this cycle and scale that by how far off from</code></span>
<span class="codeline" id="line-581"><code>	// the goal CPU utilization we were (to estimate the heap</code></span>
<span class="codeline" id="line-582"><code>	// growth if we had the desired CPU utilization). The</code></span>
<span class="codeline" id="line-583"><code>	// difference between this estimate and the GOGC-based goal</code></span>
<span class="codeline" id="line-584"><code>	// heap growth is the error.</code></span>
<span class="codeline" id="line-585"><code>	goalGrowthRatio := gcEffectiveGrowthRatio()</code></span>
<span class="codeline" id="line-586"><code>	actualGrowthRatio := float64(memstats.heap_live)/float64(memstats.heap_marked) - 1</code></span>
<span class="codeline" id="line-587"><code>	assistDuration := nanotime() - c.markStartTime</code></span>
<span class="codeline" id="line-588"><code></code></span>
<span class="codeline" id="line-589"><code>	// Assume background mark hit its utilization goal.</code></span>
<span class="codeline" id="line-590"><code>	utilization := gcBackgroundUtilization</code></span>
<span class="codeline" id="line-591"><code>	// Add assist utilization; avoid divide by zero.</code></span>
<span class="codeline" id="line-592"><code>	if assistDuration &gt; 0 {</code></span>
<span class="codeline" id="line-593"><code>		utilization += float64(c.assistTime) / float64(assistDuration*int64(gomaxprocs))</code></span>
<span class="codeline" id="line-594"><code>	}</code></span>
<span class="codeline" id="line-595"><code></code></span>
<span class="codeline" id="line-596"><code>	triggerError := goalGrowthRatio - memstats.triggerRatio - utilization/gcGoalUtilization*(actualGrowthRatio-memstats.triggerRatio)</code></span>
<span class="codeline" id="line-597"><code></code></span>
<span class="codeline" id="line-598"><code>	// Finally, we adjust the trigger for next time by this error,</code></span>
<span class="codeline" id="line-599"><code>	// damped by the proportional gain.</code></span>
<span class="codeline" id="line-600"><code>	triggerRatio := memstats.triggerRatio + triggerGain*triggerError</code></span>
<span class="codeline" id="line-601"><code></code></span>
<span class="codeline" id="line-602"><code>	if debug.gcpacertrace &gt; 0 {</code></span>
<span class="codeline" id="line-603"><code>		// Print controller state in terms of the design</code></span>
<span class="codeline" id="line-604"><code>		// document.</code></span>
<span class="codeline" id="line-605"><code>		H_m_prev := memstats.heap_marked</code></span>
<span class="codeline" id="line-606"><code>		h_t := memstats.triggerRatio</code></span>
<span class="codeline" id="line-607"><code>		H_T := memstats.gc_trigger</code></span>
<span class="codeline" id="line-608"><code>		h_a := actualGrowthRatio</code></span>
<span class="codeline" id="line-609"><code>		H_a := memstats.heap_live</code></span>
<span class="codeline" id="line-610"><code>		h_g := goalGrowthRatio</code></span>
<span class="codeline" id="line-611"><code>		H_g := int64(float64(H_m_prev) * (1 + h_g))</code></span>
<span class="codeline" id="line-612"><code>		u_a := utilization</code></span>
<span class="codeline" id="line-613"><code>		u_g := gcGoalUtilization</code></span>
<span class="codeline" id="line-614"><code>		W_a := c.scanWork</code></span>
<span class="codeline" id="line-615"><code>		print("pacer: H_m_prev=", H_m_prev,</code></span>
<span class="codeline" id="line-616"><code>			" h_t=", h_t, " H_T=", H_T,</code></span>
<span class="codeline" id="line-617"><code>			" h_a=", h_a, " H_a=", H_a,</code></span>
<span class="codeline" id="line-618"><code>			" h_g=", h_g, " H_g=", H_g,</code></span>
<span class="codeline" id="line-619"><code>			" u_a=", u_a, " u_g=", u_g,</code></span>
<span class="codeline" id="line-620"><code>			" W_a=", W_a,</code></span>
<span class="codeline" id="line-621"><code>			" goalΔ=", goalGrowthRatio-h_t,</code></span>
<span class="codeline" id="line-622"><code>			" actualΔ=", h_a-h_t,</code></span>
<span class="codeline" id="line-623"><code>			" u_a/u_g=", u_a/u_g,</code></span>
<span class="codeline" id="line-624"><code>			"\n")</code></span>
<span class="codeline" id="line-625"><code>	}</code></span>
<span class="codeline" id="line-626"><code></code></span>
<span class="codeline" id="line-627"><code>	return triggerRatio</code></span>
<span class="codeline" id="line-628"><code>}</code></span>
<span class="codeline" id="line-629"><code></code></span>
<span class="codeline" id="line-630"><code>// enlistWorker encourages another dedicated mark worker to start on</code></span>
<span class="codeline" id="line-631"><code>// another P if there are spare worker slots. It is used by putfull</code></span>
<span class="codeline" id="line-632"><code>// when more work is made available.</code></span>
<span class="codeline" id="line-633"><code>//</code></span>
<span class="codeline" id="line-634"><code>//go:nowritebarrier</code></span>
<span class="codeline" id="line-635"><code>func (c *gcControllerState) enlistWorker() {</code></span>
<span class="codeline" id="line-636"><code>	// If there are idle Ps, wake one so it will run an idle worker.</code></span>
<span class="codeline" id="line-637"><code>	// NOTE: This is suspected of causing deadlocks. See golang.org/issue/19112.</code></span>
<span class="codeline" id="line-638"><code>	//</code></span>
<span class="codeline" id="line-639"><code>	//	if atomic.Load(&amp;sched.npidle) != 0 &amp;&amp; atomic.Load(&amp;sched.nmspinning) == 0 {</code></span>
<span class="codeline" id="line-640"><code>	//		wakep()</code></span>
<span class="codeline" id="line-641"><code>	//		return</code></span>
<span class="codeline" id="line-642"><code>	//	}</code></span>
<span class="codeline" id="line-643"><code></code></span>
<span class="codeline" id="line-644"><code>	// There are no idle Ps. If we need more dedicated workers,</code></span>
<span class="codeline" id="line-645"><code>	// try to preempt a running P so it will switch to a worker.</code></span>
<span class="codeline" id="line-646"><code>	if c.dedicatedMarkWorkersNeeded &lt;= 0 {</code></span>
<span class="codeline" id="line-647"><code>		return</code></span>
<span class="codeline" id="line-648"><code>	}</code></span>
<span class="codeline" id="line-649"><code>	// Pick a random other P to preempt.</code></span>
<span class="codeline" id="line-650"><code>	if gomaxprocs &lt;= 1 {</code></span>
<span class="codeline" id="line-651"><code>		return</code></span>
<span class="codeline" id="line-652"><code>	}</code></span>
<span class="codeline" id="line-653"><code>	gp := getg()</code></span>
<span class="codeline" id="line-654"><code>	if gp == nil || gp.m == nil || gp.m.p == 0 {</code></span>
<span class="codeline" id="line-655"><code>		return</code></span>
<span class="codeline" id="line-656"><code>	}</code></span>
<span class="codeline" id="line-657"><code>	myID := gp.m.p.ptr().id</code></span>
<span class="codeline" id="line-658"><code>	for tries := 0; tries &lt; 5; tries++ {</code></span>
<span class="codeline" id="line-659"><code>		id := int32(fastrandn(uint32(gomaxprocs - 1)))</code></span>
<span class="codeline" id="line-660"><code>		if id &gt;= myID {</code></span>
<span class="codeline" id="line-661"><code>			id++</code></span>
<span class="codeline" id="line-662"><code>		}</code></span>
<span class="codeline" id="line-663"><code>		p := allp[id]</code></span>
<span class="codeline" id="line-664"><code>		if p.status != _Prunning {</code></span>
<span class="codeline" id="line-665"><code>			continue</code></span>
<span class="codeline" id="line-666"><code>		}</code></span>
<span class="codeline" id="line-667"><code>		if preemptone(p) {</code></span>
<span class="codeline" id="line-668"><code>			return</code></span>
<span class="codeline" id="line-669"><code>		}</code></span>
<span class="codeline" id="line-670"><code>	}</code></span>
<span class="codeline" id="line-671"><code>}</code></span>
<span class="codeline" id="line-672"><code></code></span>
<span class="codeline" id="line-673"><code>// findRunnableGCWorker returns the background mark worker for _p_ if it</code></span>
<span class="codeline" id="line-674"><code>// should be run. This must only be called when gcBlackenEnabled != 0.</code></span>
<span class="codeline" id="line-675"><code>func (c *gcControllerState) findRunnableGCWorker(_p_ *p) *g {</code></span>
<span class="codeline" id="line-676"><code>	if gcBlackenEnabled == 0 {</code></span>
<span class="codeline" id="line-677"><code>		throw("gcControllerState.findRunnable: blackening not enabled")</code></span>
<span class="codeline" id="line-678"><code>	}</code></span>
<span class="codeline" id="line-679"><code>	if _p_.gcBgMarkWorker == 0 {</code></span>
<span class="codeline" id="line-680"><code>		// The mark worker associated with this P is blocked</code></span>
<span class="codeline" id="line-681"><code>		// performing a mark transition. We can't run it</code></span>
<span class="codeline" id="line-682"><code>		// because it may be on some other run or wait queue.</code></span>
<span class="codeline" id="line-683"><code>		return nil</code></span>
<span class="codeline" id="line-684"><code>	}</code></span>
<span class="codeline" id="line-685"><code></code></span>
<span class="codeline" id="line-686"><code>	if !gcMarkWorkAvailable(_p_) {</code></span>
<span class="codeline" id="line-687"><code>		// No work to be done right now. This can happen at</code></span>
<span class="codeline" id="line-688"><code>		// the end of the mark phase when there are still</code></span>
<span class="codeline" id="line-689"><code>		// assists tapering off. Don't bother running a worker</code></span>
<span class="codeline" id="line-690"><code>		// now because it'll just return immediately.</code></span>
<span class="codeline" id="line-691"><code>		return nil</code></span>
<span class="codeline" id="line-692"><code>	}</code></span>
<span class="codeline" id="line-693"><code></code></span>
<span class="codeline" id="line-694"><code>	decIfPositive := func(ptr *int64) bool {</code></span>
<span class="codeline" id="line-695"><code>		if *ptr &gt; 0 {</code></span>
<span class="codeline" id="line-696"><code>			if atomic.Xaddint64(ptr, -1) &gt;= 0 {</code></span>
<span class="codeline" id="line-697"><code>				return true</code></span>
<span class="codeline" id="line-698"><code>			}</code></span>
<span class="codeline" id="line-699"><code>			// We lost a race</code></span>
<span class="codeline" id="line-700"><code>			atomic.Xaddint64(ptr, +1)</code></span>
<span class="codeline" id="line-701"><code>		}</code></span>
<span class="codeline" id="line-702"><code>		return false</code></span>
<span class="codeline" id="line-703"><code>	}</code></span>
<span class="codeline" id="line-704"><code></code></span>
<span class="codeline" id="line-705"><code>	if decIfPositive(&amp;c.dedicatedMarkWorkersNeeded) {</code></span>
<span class="codeline" id="line-706"><code>		// This P is now dedicated to marking until the end of</code></span>
<span class="codeline" id="line-707"><code>		// the concurrent mark phase.</code></span>
<span class="codeline" id="line-708"><code>		_p_.gcMarkWorkerMode = gcMarkWorkerDedicatedMode</code></span>
<span class="codeline" id="line-709"><code>	} else if c.fractionalUtilizationGoal == 0 {</code></span>
<span class="codeline" id="line-710"><code>		// No need for fractional workers.</code></span>
<span class="codeline" id="line-711"><code>		return nil</code></span>
<span class="codeline" id="line-712"><code>	} else {</code></span>
<span class="codeline" id="line-713"><code>		// Is this P behind on the fractional utilization</code></span>
<span class="codeline" id="line-714"><code>		// goal?</code></span>
<span class="codeline" id="line-715"><code>		//</code></span>
<span class="codeline" id="line-716"><code>		// This should be kept in sync with pollFractionalWorkerExit.</code></span>
<span class="codeline" id="line-717"><code>		delta := nanotime() - gcController.markStartTime</code></span>
<span class="codeline" id="line-718"><code>		if delta &gt; 0 &amp;&amp; float64(_p_.gcFractionalMarkTime)/float64(delta) &gt; c.fractionalUtilizationGoal {</code></span>
<span class="codeline" id="line-719"><code>			// Nope. No need to run a fractional worker.</code></span>
<span class="codeline" id="line-720"><code>			return nil</code></span>
<span class="codeline" id="line-721"><code>		}</code></span>
<span class="codeline" id="line-722"><code>		// Run a fractional worker.</code></span>
<span class="codeline" id="line-723"><code>		_p_.gcMarkWorkerMode = gcMarkWorkerFractionalMode</code></span>
<span class="codeline" id="line-724"><code>	}</code></span>
<span class="codeline" id="line-725"><code></code></span>
<span class="codeline" id="line-726"><code>	// Run the background mark worker</code></span>
<span class="codeline" id="line-727"><code>	gp := _p_.gcBgMarkWorker.ptr()</code></span>
<span class="codeline" id="line-728"><code>	casgstatus(gp, _Gwaiting, _Grunnable)</code></span>
<span class="codeline" id="line-729"><code>	if trace.enabled {</code></span>
<span class="codeline" id="line-730"><code>		traceGoUnpark(gp, 0)</code></span>
<span class="codeline" id="line-731"><code>	}</code></span>
<span class="codeline" id="line-732"><code>	return gp</code></span>
<span class="codeline" id="line-733"><code>}</code></span>
<span class="codeline" id="line-734"><code></code></span>
<span class="codeline" id="line-735"><code>// pollFractionalWorkerExit reports whether a fractional mark worker</code></span>
<span class="codeline" id="line-736"><code>// should self-preempt. It assumes it is called from the fractional</code></span>
<span class="codeline" id="line-737"><code>// worker.</code></span>
<span class="codeline" id="line-738"><code>func pollFractionalWorkerExit() bool {</code></span>
<span class="codeline" id="line-739"><code>	// This should be kept in sync with the fractional worker</code></span>
<span class="codeline" id="line-740"><code>	// scheduler logic in findRunnableGCWorker.</code></span>
<span class="codeline" id="line-741"><code>	now := nanotime()</code></span>
<span class="codeline" id="line-742"><code>	delta := now - gcController.markStartTime</code></span>
<span class="codeline" id="line-743"><code>	if delta &lt;= 0 {</code></span>
<span class="codeline" id="line-744"><code>		return true</code></span>
<span class="codeline" id="line-745"><code>	}</code></span>
<span class="codeline" id="line-746"><code>	p := getg().m.p.ptr()</code></span>
<span class="codeline" id="line-747"><code>	selfTime := p.gcFractionalMarkTime + (now - p.gcMarkWorkerStartTime)</code></span>
<span class="codeline" id="line-748"><code>	// Add some slack to the utilization goal so that the</code></span>
<span class="codeline" id="line-749"><code>	// fractional worker isn't behind again the instant it exits.</code></span>
<span class="codeline" id="line-750"><code>	return float64(selfTime)/float64(delta) &gt; 1.2*gcController.fractionalUtilizationGoal</code></span>
<span class="codeline" id="line-751"><code>}</code></span>
<span class="codeline" id="line-752"><code></code></span>
<span class="codeline" id="line-753"><code>// gcSetTriggerRatio sets the trigger ratio and updates everything</code></span>
<span class="codeline" id="line-754"><code>// derived from it: the absolute trigger, the heap goal, mark pacing,</code></span>
<span class="codeline" id="line-755"><code>// and sweep pacing.</code></span>
<span class="codeline" id="line-756"><code>//</code></span>
<span class="codeline" id="line-757"><code>// This can be called any time. If GC is the in the middle of a</code></span>
<span class="codeline" id="line-758"><code>// concurrent phase, it will adjust the pacing of that phase.</code></span>
<span class="codeline" id="line-759"><code>//</code></span>
<span class="codeline" id="line-760"><code>// This depends on gcpercent, memstats.heap_marked, and</code></span>
<span class="codeline" id="line-761"><code>// memstats.heap_live. These must be up to date.</code></span>
<span class="codeline" id="line-762"><code>//</code></span>
<span class="codeline" id="line-763"><code>// mheap_.lock must be held or the world must be stopped.</code></span>
<span class="codeline" id="line-764"><code>func gcSetTriggerRatio(triggerRatio float64) {</code></span>
<span class="codeline" id="line-765"><code>	// Compute the next GC goal, which is when the allocated heap</code></span>
<span class="codeline" id="line-766"><code>	// has grown by GOGC/100 over the heap marked by the last</code></span>
<span class="codeline" id="line-767"><code>	// cycle.</code></span>
<span class="codeline" id="line-768"><code>	goal := ^uint64(0)</code></span>
<span class="codeline" id="line-769"><code>	if gcpercent &gt;= 0 {</code></span>
<span class="codeline" id="line-770"><code>		goal = memstats.heap_marked + memstats.heap_marked*uint64(gcpercent)/100</code></span>
<span class="codeline" id="line-771"><code>	}</code></span>
<span class="codeline" id="line-772"><code></code></span>
<span class="codeline" id="line-773"><code>	// Set the trigger ratio, capped to reasonable bounds.</code></span>
<span class="codeline" id="line-774"><code>	if gcpercent &gt;= 0 {</code></span>
<span class="codeline" id="line-775"><code>		scalingFactor := float64(gcpercent) / 100</code></span>
<span class="codeline" id="line-776"><code>		// Ensure there's always a little margin so that the</code></span>
<span class="codeline" id="line-777"><code>		// mutator assist ratio isn't infinity.</code></span>
<span class="codeline" id="line-778"><code>		maxTriggerRatio := 0.95 * scalingFactor</code></span>
<span class="codeline" id="line-779"><code>		if triggerRatio &gt; maxTriggerRatio {</code></span>
<span class="codeline" id="line-780"><code>			triggerRatio = maxTriggerRatio</code></span>
<span class="codeline" id="line-781"><code>		}</code></span>
<span class="codeline" id="line-782"><code></code></span>
<span class="codeline" id="line-783"><code>		// If we let triggerRatio go too low, then if the application</code></span>
<span class="codeline" id="line-784"><code>		// is allocating very rapidly we might end up in a situation</code></span>
<span class="codeline" id="line-785"><code>		// where we're allocating black during a nearly always-on GC.</code></span>
<span class="codeline" id="line-786"><code>		// The result of this is a growing heap and ultimately an</code></span>
<span class="codeline" id="line-787"><code>		// increase in RSS. By capping us at a point &gt;0, we're essentially</code></span>
<span class="codeline" id="line-788"><code>		// saying that we're OK using more CPU during the GC to prevent</code></span>
<span class="codeline" id="line-789"><code>		// this growth in RSS.</code></span>
<span class="codeline" id="line-790"><code>		//</code></span>
<span class="codeline" id="line-791"><code>		// The current constant was chosen empirically: given a sufficiently</code></span>
<span class="codeline" id="line-792"><code>		// fast/scalable allocator with 48 Ps that could drive the trigger ratio</code></span>
<span class="codeline" id="line-793"><code>		// to &lt;0.05, this constant causes applications to retain the same peak</code></span>
<span class="codeline" id="line-794"><code>		// RSS compared to not having this allocator.</code></span>
<span class="codeline" id="line-795"><code>		minTriggerRatio := 0.6 * scalingFactor</code></span>
<span class="codeline" id="line-796"><code>		if triggerRatio &lt; minTriggerRatio {</code></span>
<span class="codeline" id="line-797"><code>			triggerRatio = minTriggerRatio</code></span>
<span class="codeline" id="line-798"><code>		}</code></span>
<span class="codeline" id="line-799"><code>	} else if triggerRatio &lt; 0 {</code></span>
<span class="codeline" id="line-800"><code>		// gcpercent &lt; 0, so just make sure we're not getting a negative</code></span>
<span class="codeline" id="line-801"><code>		// triggerRatio. This case isn't expected to happen in practice,</code></span>
<span class="codeline" id="line-802"><code>		// and doesn't really matter because if gcpercent &lt; 0 then we won't</code></span>
<span class="codeline" id="line-803"><code>		// ever consume triggerRatio further on in this function, but let's</code></span>
<span class="codeline" id="line-804"><code>		// just be defensive here; the triggerRatio being negative is almost</code></span>
<span class="codeline" id="line-805"><code>		// certainly undesirable.</code></span>
<span class="codeline" id="line-806"><code>		triggerRatio = 0</code></span>
<span class="codeline" id="line-807"><code>	}</code></span>
<span class="codeline" id="line-808"><code>	memstats.triggerRatio = triggerRatio</code></span>
<span class="codeline" id="line-809"><code></code></span>
<span class="codeline" id="line-810"><code>	// Compute the absolute GC trigger from the trigger ratio.</code></span>
<span class="codeline" id="line-811"><code>	//</code></span>
<span class="codeline" id="line-812"><code>	// We trigger the next GC cycle when the allocated heap has</code></span>
<span class="codeline" id="line-813"><code>	// grown by the trigger ratio over the marked heap size.</code></span>
<span class="codeline" id="line-814"><code>	trigger := ^uint64(0)</code></span>
<span class="codeline" id="line-815"><code>	if gcpercent &gt;= 0 {</code></span>
<span class="codeline" id="line-816"><code>		trigger = uint64(float64(memstats.heap_marked) * (1 + triggerRatio))</code></span>
<span class="codeline" id="line-817"><code>		// Don't trigger below the minimum heap size.</code></span>
<span class="codeline" id="line-818"><code>		minTrigger := heapminimum</code></span>
<span class="codeline" id="line-819"><code>		if !isSweepDone() {</code></span>
<span class="codeline" id="line-820"><code>			// Concurrent sweep happens in the heap growth</code></span>
<span class="codeline" id="line-821"><code>			// from heap_live to gc_trigger, so ensure</code></span>
<span class="codeline" id="line-822"><code>			// that concurrent sweep has some heap growth</code></span>
<span class="codeline" id="line-823"><code>			// in which to perform sweeping before we</code></span>
<span class="codeline" id="line-824"><code>			// start the next GC cycle.</code></span>
<span class="codeline" id="line-825"><code>			sweepMin := atomic.Load64(&amp;memstats.heap_live) + sweepMinHeapDistance</code></span>
<span class="codeline" id="line-826"><code>			if sweepMin &gt; minTrigger {</code></span>
<span class="codeline" id="line-827"><code>				minTrigger = sweepMin</code></span>
<span class="codeline" id="line-828"><code>			}</code></span>
<span class="codeline" id="line-829"><code>		}</code></span>
<span class="codeline" id="line-830"><code>		if trigger &lt; minTrigger {</code></span>
<span class="codeline" id="line-831"><code>			trigger = minTrigger</code></span>
<span class="codeline" id="line-832"><code>		}</code></span>
<span class="codeline" id="line-833"><code>		if int64(trigger) &lt; 0 {</code></span>
<span class="codeline" id="line-834"><code>			print("runtime: next_gc=", memstats.next_gc, " heap_marked=", memstats.heap_marked, " heap_live=", memstats.heap_live, " initialHeapLive=", work.initialHeapLive, "triggerRatio=", triggerRatio, " minTrigger=", minTrigger, "\n")</code></span>
<span class="codeline" id="line-835"><code>			throw("gc_trigger underflow")</code></span>
<span class="codeline" id="line-836"><code>		}</code></span>
<span class="codeline" id="line-837"><code>		if trigger &gt; goal {</code></span>
<span class="codeline" id="line-838"><code>			// The trigger ratio is always less than GOGC/100, but</code></span>
<span class="codeline" id="line-839"><code>			// other bounds on the trigger may have raised it.</code></span>
<span class="codeline" id="line-840"><code>			// Push up the goal, too.</code></span>
<span class="codeline" id="line-841"><code>			goal = trigger</code></span>
<span class="codeline" id="line-842"><code>		}</code></span>
<span class="codeline" id="line-843"><code>	}</code></span>
<span class="codeline" id="line-844"><code></code></span>
<span class="codeline" id="line-845"><code>	// Commit to the trigger and goal.</code></span>
<span class="codeline" id="line-846"><code>	memstats.gc_trigger = trigger</code></span>
<span class="codeline" id="line-847"><code>	memstats.next_gc = goal</code></span>
<span class="codeline" id="line-848"><code>	if trace.enabled {</code></span>
<span class="codeline" id="line-849"><code>		traceNextGC()</code></span>
<span class="codeline" id="line-850"><code>	}</code></span>
<span class="codeline" id="line-851"><code></code></span>
<span class="codeline" id="line-852"><code>	// Update mark pacing.</code></span>
<span class="codeline" id="line-853"><code>	if gcphase != _GCoff {</code></span>
<span class="codeline" id="line-854"><code>		gcController.revise()</code></span>
<span class="codeline" id="line-855"><code>	}</code></span>
<span class="codeline" id="line-856"><code></code></span>
<span class="codeline" id="line-857"><code>	// Update sweep pacing.</code></span>
<span class="codeline" id="line-858"><code>	if isSweepDone() {</code></span>
<span class="codeline" id="line-859"><code>		mheap_.sweepPagesPerByte = 0</code></span>
<span class="codeline" id="line-860"><code>	} else {</code></span>
<span class="codeline" id="line-861"><code>		// Concurrent sweep needs to sweep all of the in-use</code></span>
<span class="codeline" id="line-862"><code>		// pages by the time the allocated heap reaches the GC</code></span>
<span class="codeline" id="line-863"><code>		// trigger. Compute the ratio of in-use pages to sweep</code></span>
<span class="codeline" id="line-864"><code>		// per byte allocated, accounting for the fact that</code></span>
<span class="codeline" id="line-865"><code>		// some might already be swept.</code></span>
<span class="codeline" id="line-866"><code>		heapLiveBasis := atomic.Load64(&amp;memstats.heap_live)</code></span>
<span class="codeline" id="line-867"><code>		heapDistance := int64(trigger) - int64(heapLiveBasis)</code></span>
<span class="codeline" id="line-868"><code>		// Add a little margin so rounding errors and</code></span>
<span class="codeline" id="line-869"><code>		// concurrent sweep are less likely to leave pages</code></span>
<span class="codeline" id="line-870"><code>		// unswept when GC starts.</code></span>
<span class="codeline" id="line-871"><code>		heapDistance -= 1024 * 1024</code></span>
<span class="codeline" id="line-872"><code>		if heapDistance &lt; _PageSize {</code></span>
<span class="codeline" id="line-873"><code>			// Avoid setting the sweep ratio extremely high</code></span>
<span class="codeline" id="line-874"><code>			heapDistance = _PageSize</code></span>
<span class="codeline" id="line-875"><code>		}</code></span>
<span class="codeline" id="line-876"><code>		pagesSwept := atomic.Load64(&amp;mheap_.pagesSwept)</code></span>
<span class="codeline" id="line-877"><code>		pagesInUse := atomic.Load64(&amp;mheap_.pagesInUse)</code></span>
<span class="codeline" id="line-878"><code>		sweepDistancePages := int64(pagesInUse) - int64(pagesSwept)</code></span>
<span class="codeline" id="line-879"><code>		if sweepDistancePages &lt;= 0 {</code></span>
<span class="codeline" id="line-880"><code>			mheap_.sweepPagesPerByte = 0</code></span>
<span class="codeline" id="line-881"><code>		} else {</code></span>
<span class="codeline" id="line-882"><code>			mheap_.sweepPagesPerByte = float64(sweepDistancePages) / float64(heapDistance)</code></span>
<span class="codeline" id="line-883"><code>			mheap_.sweepHeapLiveBasis = heapLiveBasis</code></span>
<span class="codeline" id="line-884"><code>			// Write pagesSweptBasis last, since this</code></span>
<span class="codeline" id="line-885"><code>			// signals concurrent sweeps to recompute</code></span>
<span class="codeline" id="line-886"><code>			// their debt.</code></span>
<span class="codeline" id="line-887"><code>			atomic.Store64(&amp;mheap_.pagesSweptBasis, pagesSwept)</code></span>
<span class="codeline" id="line-888"><code>		}</code></span>
<span class="codeline" id="line-889"><code>	}</code></span>
<span class="codeline" id="line-890"><code></code></span>
<span class="codeline" id="line-891"><code>	gcPaceScavenger()</code></span>
<span class="codeline" id="line-892"><code>}</code></span>
<span class="codeline" id="line-893"><code></code></span>
<span class="codeline" id="line-894"><code>// gcEffectiveGrowthRatio returns the current effective heap growth</code></span>
<span class="codeline" id="line-895"><code>// ratio (GOGC/100) based on heap_marked from the previous GC and</code></span>
<span class="codeline" id="line-896"><code>// next_gc for the current GC.</code></span>
<span class="codeline" id="line-897"><code>//</code></span>
<span class="codeline" id="line-898"><code>// This may differ from gcpercent/100 because of various upper and</code></span>
<span class="codeline" id="line-899"><code>// lower bounds on gcpercent. For example, if the heap is smaller than</code></span>
<span class="codeline" id="line-900"><code>// heapminimum, this can be higher than gcpercent/100.</code></span>
<span class="codeline" id="line-901"><code>//</code></span>
<span class="codeline" id="line-902"><code>// mheap_.lock must be held or the world must be stopped.</code></span>
<span class="codeline" id="line-903"><code>func gcEffectiveGrowthRatio() float64 {</code></span>
<span class="codeline" id="line-904"><code>	egogc := float64(memstats.next_gc-memstats.heap_marked) / float64(memstats.heap_marked)</code></span>
<span class="codeline" id="line-905"><code>	if egogc &lt; 0 {</code></span>
<span class="codeline" id="line-906"><code>		// Shouldn't happen, but just in case.</code></span>
<span class="codeline" id="line-907"><code>		egogc = 0</code></span>
<span class="codeline" id="line-908"><code>	}</code></span>
<span class="codeline" id="line-909"><code>	return egogc</code></span>
<span class="codeline" id="line-910"><code>}</code></span>
<span class="codeline" id="line-911"><code></code></span>
<span class="codeline" id="line-912"><code>// gcGoalUtilization is the goal CPU utilization for</code></span>
<span class="codeline" id="line-913"><code>// marking as a fraction of GOMAXPROCS.</code></span>
<span class="codeline" id="line-914"><code>const gcGoalUtilization = 0.30</code></span>
<span class="codeline" id="line-915"><code></code></span>
<span class="codeline" id="line-916"><code>// gcBackgroundUtilization is the fixed CPU utilization for background</code></span>
<span class="codeline" id="line-917"><code>// marking. It must be &lt;= gcGoalUtilization. The difference between</code></span>
<span class="codeline" id="line-918"><code>// gcGoalUtilization and gcBackgroundUtilization will be made up by</code></span>
<span class="codeline" id="line-919"><code>// mark assists. The scheduler will aim to use within 50% of this</code></span>
<span class="codeline" id="line-920"><code>// goal.</code></span>
<span class="codeline" id="line-921"><code>//</code></span>
<span class="codeline" id="line-922"><code>// Setting this to &lt; gcGoalUtilization avoids saturating the trigger</code></span>
<span class="codeline" id="line-923"><code>// feedback controller when there are no assists, which allows it to</code></span>
<span class="codeline" id="line-924"><code>// better control CPU and heap growth. However, the larger the gap,</code></span>
<span class="codeline" id="line-925"><code>// the more mutator assists are expected to happen, which impact</code></span>
<span class="codeline" id="line-926"><code>// mutator latency.</code></span>
<span class="codeline" id="line-927"><code>const gcBackgroundUtilization = 0.25</code></span>
<span class="codeline" id="line-928"><code></code></span>
<span class="codeline" id="line-929"><code>// gcCreditSlack is the amount of scan work credit that can</code></span>
<span class="codeline" id="line-930"><code>// accumulate locally before updating gcController.scanWork and,</code></span>
<span class="codeline" id="line-931"><code>// optionally, gcController.bgScanCredit. Lower values give a more</code></span>
<span class="codeline" id="line-932"><code>// accurate assist ratio and make it more likely that assists will</code></span>
<span class="codeline" id="line-933"><code>// successfully steal background credit. Higher values reduce memory</code></span>
<span class="codeline" id="line-934"><code>// contention.</code></span>
<span class="codeline" id="line-935"><code>const gcCreditSlack = 2000</code></span>
<span class="codeline" id="line-936"><code></code></span>
<span class="codeline" id="line-937"><code>// gcAssistTimeSlack is the nanoseconds of mutator assist time that</code></span>
<span class="codeline" id="line-938"><code>// can accumulate on a P before updating gcController.assistTime.</code></span>
<span class="codeline" id="line-939"><code>const gcAssistTimeSlack = 5000</code></span>
<span class="codeline" id="line-940"><code></code></span>
<span class="codeline" id="line-941"><code>// gcOverAssistWork determines how many extra units of scan work a GC</code></span>
<span class="codeline" id="line-942"><code>// assist does when an assist happens. This amortizes the cost of an</code></span>
<span class="codeline" id="line-943"><code>// assist by pre-paying for this many bytes of future allocations.</code></span>
<span class="codeline" id="line-944"><code>const gcOverAssistWork = 64 &lt;&lt; 10</code></span>
<span class="codeline" id="line-945"><code></code></span>
<span class="codeline" id="line-946"><code>var work struct {</code></span>
<span class="codeline" id="line-947"><code>	full  lfstack          // lock-free list of full blocks workbuf</code></span>
<span class="codeline" id="line-948"><code>	empty lfstack          // lock-free list of empty blocks workbuf</code></span>
<span class="codeline" id="line-949"><code>	pad0  cpu.CacheLinePad // prevents false-sharing between full/empty and nproc/nwait</code></span>
<span class="codeline" id="line-950"><code></code></span>
<span class="codeline" id="line-951"><code>	wbufSpans struct {</code></span>
<span class="codeline" id="line-952"><code>		lock mutex</code></span>
<span class="codeline" id="line-953"><code>		// free is a list of spans dedicated to workbufs, but</code></span>
<span class="codeline" id="line-954"><code>		// that don't currently contain any workbufs.</code></span>
<span class="codeline" id="line-955"><code>		free mSpanList</code></span>
<span class="codeline" id="line-956"><code>		// busy is a list of all spans containing workbufs on</code></span>
<span class="codeline" id="line-957"><code>		// one of the workbuf lists.</code></span>
<span class="codeline" id="line-958"><code>		busy mSpanList</code></span>
<span class="codeline" id="line-959"><code>	}</code></span>
<span class="codeline" id="line-960"><code></code></span>
<span class="codeline" id="line-961"><code>	// Restore 64-bit alignment on 32-bit.</code></span>
<span class="codeline" id="line-962"><code>	_ uint32</code></span>
<span class="codeline" id="line-963"><code></code></span>
<span class="codeline" id="line-964"><code>	// bytesMarked is the number of bytes marked this cycle. This</code></span>
<span class="codeline" id="line-965"><code>	// includes bytes blackened in scanned objects, noscan objects</code></span>
<span class="codeline" id="line-966"><code>	// that go straight to black, and permagrey objects scanned by</code></span>
<span class="codeline" id="line-967"><code>	// markroot during the concurrent scan phase. This is updated</code></span>
<span class="codeline" id="line-968"><code>	// atomically during the cycle. Updates may be batched</code></span>
<span class="codeline" id="line-969"><code>	// arbitrarily, since the value is only read at the end of the</code></span>
<span class="codeline" id="line-970"><code>	// cycle.</code></span>
<span class="codeline" id="line-971"><code>	//</code></span>
<span class="codeline" id="line-972"><code>	// Because of benign races during marking, this number may not</code></span>
<span class="codeline" id="line-973"><code>	// be the exact number of marked bytes, but it should be very</code></span>
<span class="codeline" id="line-974"><code>	// close.</code></span>
<span class="codeline" id="line-975"><code>	//</code></span>
<span class="codeline" id="line-976"><code>	// Put this field here because it needs 64-bit atomic access</code></span>
<span class="codeline" id="line-977"><code>	// (and thus 8-byte alignment even on 32-bit architectures).</code></span>
<span class="codeline" id="line-978"><code>	bytesMarked uint64</code></span>
<span class="codeline" id="line-979"><code></code></span>
<span class="codeline" id="line-980"><code>	markrootNext uint32 // next markroot job</code></span>
<span class="codeline" id="line-981"><code>	markrootJobs uint32 // number of markroot jobs</code></span>
<span class="codeline" id="line-982"><code></code></span>
<span class="codeline" id="line-983"><code>	nproc  uint32</code></span>
<span class="codeline" id="line-984"><code>	tstart int64</code></span>
<span class="codeline" id="line-985"><code>	nwait  uint32</code></span>
<span class="codeline" id="line-986"><code>	ndone  uint32</code></span>
<span class="codeline" id="line-987"><code></code></span>
<span class="codeline" id="line-988"><code>	// Number of roots of various root types. Set by gcMarkRootPrepare.</code></span>
<span class="codeline" id="line-989"><code>	nFlushCacheRoots                               int</code></span>
<span class="codeline" id="line-990"><code>	nDataRoots, nBSSRoots, nSpanRoots, nStackRoots int</code></span>
<span class="codeline" id="line-991"><code></code></span>
<span class="codeline" id="line-992"><code>	// Each type of GC state transition is protected by a lock.</code></span>
<span class="codeline" id="line-993"><code>	// Since multiple threads can simultaneously detect the state</code></span>
<span class="codeline" id="line-994"><code>	// transition condition, any thread that detects a transition</code></span>
<span class="codeline" id="line-995"><code>	// condition must acquire the appropriate transition lock,</code></span>
<span class="codeline" id="line-996"><code>	// re-check the transition condition and return if it no</code></span>
<span class="codeline" id="line-997"><code>	// longer holds or perform the transition if it does.</code></span>
<span class="codeline" id="line-998"><code>	// Likewise, any transition must invalidate the transition</code></span>
<span class="codeline" id="line-999"><code>	// condition before releasing the lock. This ensures that each</code></span>
<span class="codeline" id="line-1000"><code>	// transition is performed by exactly one thread and threads</code></span>
<span class="codeline" id="line-1001"><code>	// that need the transition to happen block until it has</code></span>
<span class="codeline" id="line-1002"><code>	// happened.</code></span>
<span class="codeline" id="line-1003"><code>	//</code></span>
<span class="codeline" id="line-1004"><code>	// startSema protects the transition from "off" to mark or</code></span>
<span class="codeline" id="line-1005"><code>	// mark termination.</code></span>
<span class="codeline" id="line-1006"><code>	startSema uint32</code></span>
<span class="codeline" id="line-1007"><code>	// markDoneSema protects transitions from mark to mark termination.</code></span>
<span class="codeline" id="line-1008"><code>	markDoneSema uint32</code></span>
<span class="codeline" id="line-1009"><code></code></span>
<span class="codeline" id="line-1010"><code>	bgMarkReady note   // signal background mark worker has started</code></span>
<span class="codeline" id="line-1011"><code>	bgMarkDone  uint32 // cas to 1 when at a background mark completion point</code></span>
<span class="codeline" id="line-1012"><code>	// Background mark completion signaling</code></span>
<span class="codeline" id="line-1013"><code></code></span>
<span class="codeline" id="line-1014"><code>	// mode is the concurrency mode of the current GC cycle.</code></span>
<span class="codeline" id="line-1015"><code>	mode gcMode</code></span>
<span class="codeline" id="line-1016"><code></code></span>
<span class="codeline" id="line-1017"><code>	// userForced indicates the current GC cycle was forced by an</code></span>
<span class="codeline" id="line-1018"><code>	// explicit user call.</code></span>
<span class="codeline" id="line-1019"><code>	userForced bool</code></span>
<span class="codeline" id="line-1020"><code></code></span>
<span class="codeline" id="line-1021"><code>	// totaltime is the CPU nanoseconds spent in GC since the</code></span>
<span class="codeline" id="line-1022"><code>	// program started if debug.gctrace &gt; 0.</code></span>
<span class="codeline" id="line-1023"><code>	totaltime int64</code></span>
<span class="codeline" id="line-1024"><code></code></span>
<span class="codeline" id="line-1025"><code>	// initialHeapLive is the value of memstats.heap_live at the</code></span>
<span class="codeline" id="line-1026"><code>	// beginning of this GC cycle.</code></span>
<span class="codeline" id="line-1027"><code>	initialHeapLive uint64</code></span>
<span class="codeline" id="line-1028"><code></code></span>
<span class="codeline" id="line-1029"><code>	// assistQueue is a queue of assists that are blocked because</code></span>
<span class="codeline" id="line-1030"><code>	// there was neither enough credit to steal or enough work to</code></span>
<span class="codeline" id="line-1031"><code>	// do.</code></span>
<span class="codeline" id="line-1032"><code>	assistQueue struct {</code></span>
<span class="codeline" id="line-1033"><code>		lock mutex</code></span>
<span class="codeline" id="line-1034"><code>		q    gQueue</code></span>
<span class="codeline" id="line-1035"><code>	}</code></span>
<span class="codeline" id="line-1036"><code></code></span>
<span class="codeline" id="line-1037"><code>	// sweepWaiters is a list of blocked goroutines to wake when</code></span>
<span class="codeline" id="line-1038"><code>	// we transition from mark termination to sweep.</code></span>
<span class="codeline" id="line-1039"><code>	sweepWaiters struct {</code></span>
<span class="codeline" id="line-1040"><code>		lock mutex</code></span>
<span class="codeline" id="line-1041"><code>		list gList</code></span>
<span class="codeline" id="line-1042"><code>	}</code></span>
<span class="codeline" id="line-1043"><code></code></span>
<span class="codeline" id="line-1044"><code>	// cycles is the number of completed GC cycles, where a GC</code></span>
<span class="codeline" id="line-1045"><code>	// cycle is sweep termination, mark, mark termination, and</code></span>
<span class="codeline" id="line-1046"><code>	// sweep. This differs from memstats.numgc, which is</code></span>
<span class="codeline" id="line-1047"><code>	// incremented at mark termination.</code></span>
<span class="codeline" id="line-1048"><code>	cycles uint32</code></span>
<span class="codeline" id="line-1049"><code></code></span>
<span class="codeline" id="line-1050"><code>	// Timing/utilization stats for this cycle.</code></span>
<span class="codeline" id="line-1051"><code>	stwprocs, maxprocs                 int32</code></span>
<span class="codeline" id="line-1052"><code>	tSweepTerm, tMark, tMarkTerm, tEnd int64 // nanotime() of phase start</code></span>
<span class="codeline" id="line-1053"><code></code></span>
<span class="codeline" id="line-1054"><code>	pauseNS    int64 // total STW time this cycle</code></span>
<span class="codeline" id="line-1055"><code>	pauseStart int64 // nanotime() of last STW</code></span>
<span class="codeline" id="line-1056"><code></code></span>
<span class="codeline" id="line-1057"><code>	// debug.gctrace heap sizes for this cycle.</code></span>
<span class="codeline" id="line-1058"><code>	heap0, heap1, heap2, heapGoal uint64</code></span>
<span class="codeline" id="line-1059"><code>}</code></span>
<span class="codeline" id="line-1060"><code></code></span>
<span class="codeline" id="line-1061"><code>// GC runs a garbage collection and blocks the caller until the</code></span>
<span class="codeline" id="line-1062"><code>// garbage collection is complete. It may also block the entire</code></span>
<span class="codeline" id="line-1063"><code>// program.</code></span>
<span class="codeline" id="line-1064"><code>func GC() {</code></span>
<span class="codeline" id="line-1065"><code>	// We consider a cycle to be: sweep termination, mark, mark</code></span>
<span class="codeline" id="line-1066"><code>	// termination, and sweep. This function shouldn't return</code></span>
<span class="codeline" id="line-1067"><code>	// until a full cycle has been completed, from beginning to</code></span>
<span class="codeline" id="line-1068"><code>	// end. Hence, we always want to finish up the current cycle</code></span>
<span class="codeline" id="line-1069"><code>	// and start a new one. That means:</code></span>
<span class="codeline" id="line-1070"><code>	//</code></span>
<span class="codeline" id="line-1071"><code>	// 1. In sweep termination, mark, or mark termination of cycle</code></span>
<span class="codeline" id="line-1072"><code>	// N, wait until mark termination N completes and transitions</code></span>
<span class="codeline" id="line-1073"><code>	// to sweep N.</code></span>
<span class="codeline" id="line-1074"><code>	//</code></span>
<span class="codeline" id="line-1075"><code>	// 2. In sweep N, help with sweep N.</code></span>
<span class="codeline" id="line-1076"><code>	//</code></span>
<span class="codeline" id="line-1077"><code>	// At this point we can begin a full cycle N+1.</code></span>
<span class="codeline" id="line-1078"><code>	//</code></span>
<span class="codeline" id="line-1079"><code>	// 3. Trigger cycle N+1 by starting sweep termination N+1.</code></span>
<span class="codeline" id="line-1080"><code>	//</code></span>
<span class="codeline" id="line-1081"><code>	// 4. Wait for mark termination N+1 to complete.</code></span>
<span class="codeline" id="line-1082"><code>	//</code></span>
<span class="codeline" id="line-1083"><code>	// 5. Help with sweep N+1 until it's done.</code></span>
<span class="codeline" id="line-1084"><code>	//</code></span>
<span class="codeline" id="line-1085"><code>	// This all has to be written to deal with the fact that the</code></span>
<span class="codeline" id="line-1086"><code>	// GC may move ahead on its own. For example, when we block</code></span>
<span class="codeline" id="line-1087"><code>	// until mark termination N, we may wake up in cycle N+2.</code></span>
<span class="codeline" id="line-1088"><code></code></span>
<span class="codeline" id="line-1089"><code>	// Wait until the current sweep termination, mark, and mark</code></span>
<span class="codeline" id="line-1090"><code>	// termination complete.</code></span>
<span class="codeline" id="line-1091"><code>	n := atomic.Load(&amp;work.cycles)</code></span>
<span class="codeline" id="line-1092"><code>	gcWaitOnMark(n)</code></span>
<span class="codeline" id="line-1093"><code></code></span>
<span class="codeline" id="line-1094"><code>	// We're now in sweep N or later. Trigger GC cycle N+1, which</code></span>
<span class="codeline" id="line-1095"><code>	// will first finish sweep N if necessary and then enter sweep</code></span>
<span class="codeline" id="line-1096"><code>	// termination N+1.</code></span>
<span class="codeline" id="line-1097"><code>	gcStart(gcTrigger{kind: gcTriggerCycle, n: n + 1})</code></span>
<span class="codeline" id="line-1098"><code></code></span>
<span class="codeline" id="line-1099"><code>	// Wait for mark termination N+1 to complete.</code></span>
<span class="codeline" id="line-1100"><code>	gcWaitOnMark(n + 1)</code></span>
<span class="codeline" id="line-1101"><code></code></span>
<span class="codeline" id="line-1102"><code>	// Finish sweep N+1 before returning. We do this both to</code></span>
<span class="codeline" id="line-1103"><code>	// complete the cycle and because runtime.GC() is often used</code></span>
<span class="codeline" id="line-1104"><code>	// as part of tests and benchmarks to get the system into a</code></span>
<span class="codeline" id="line-1105"><code>	// relatively stable and isolated state.</code></span>
<span class="codeline" id="line-1106"><code>	for atomic.Load(&amp;work.cycles) == n+1 &amp;&amp; sweepone() != ^uintptr(0) {</code></span>
<span class="codeline" id="line-1107"><code>		sweep.nbgsweep++</code></span>
<span class="codeline" id="line-1108"><code>		Gosched()</code></span>
<span class="codeline" id="line-1109"><code>	}</code></span>
<span class="codeline" id="line-1110"><code></code></span>
<span class="codeline" id="line-1111"><code>	// Callers may assume that the heap profile reflects the</code></span>
<span class="codeline" id="line-1112"><code>	// just-completed cycle when this returns (historically this</code></span>
<span class="codeline" id="line-1113"><code>	// happened because this was a STW GC), but right now the</code></span>
<span class="codeline" id="line-1114"><code>	// profile still reflects mark termination N, not N+1.</code></span>
<span class="codeline" id="line-1115"><code>	//</code></span>
<span class="codeline" id="line-1116"><code>	// As soon as all of the sweep frees from cycle N+1 are done,</code></span>
<span class="codeline" id="line-1117"><code>	// we can go ahead and publish the heap profile.</code></span>
<span class="codeline" id="line-1118"><code>	//</code></span>
<span class="codeline" id="line-1119"><code>	// First, wait for sweeping to finish. (We know there are no</code></span>
<span class="codeline" id="line-1120"><code>	// more spans on the sweep queue, but we may be concurrently</code></span>
<span class="codeline" id="line-1121"><code>	// sweeping spans, so we have to wait.)</code></span>
<span class="codeline" id="line-1122"><code>	for atomic.Load(&amp;work.cycles) == n+1 &amp;&amp; atomic.Load(&amp;mheap_.sweepers) != 0 {</code></span>
<span class="codeline" id="line-1123"><code>		Gosched()</code></span>
<span class="codeline" id="line-1124"><code>	}</code></span>
<span class="codeline" id="line-1125"><code></code></span>
<span class="codeline" id="line-1126"><code>	// Now we're really done with sweeping, so we can publish the</code></span>
<span class="codeline" id="line-1127"><code>	// stable heap profile. Only do this if we haven't already hit</code></span>
<span class="codeline" id="line-1128"><code>	// another mark termination.</code></span>
<span class="codeline" id="line-1129"><code>	mp := acquirem()</code></span>
<span class="codeline" id="line-1130"><code>	cycle := atomic.Load(&amp;work.cycles)</code></span>
<span class="codeline" id="line-1131"><code>	if cycle == n+1 || (gcphase == _GCmark &amp;&amp; cycle == n+2) {</code></span>
<span class="codeline" id="line-1132"><code>		mProf_PostSweep()</code></span>
<span class="codeline" id="line-1133"><code>	}</code></span>
<span class="codeline" id="line-1134"><code>	releasem(mp)</code></span>
<span class="codeline" id="line-1135"><code>}</code></span>
<span class="codeline" id="line-1136"><code></code></span>
<span class="codeline" id="line-1137"><code>// gcWaitOnMark blocks until GC finishes the Nth mark phase. If GC has</code></span>
<span class="codeline" id="line-1138"><code>// already completed this mark phase, it returns immediately.</code></span>
<span class="codeline" id="line-1139"><code>func gcWaitOnMark(n uint32) {</code></span>
<span class="codeline" id="line-1140"><code>	for {</code></span>
<span class="codeline" id="line-1141"><code>		// Disable phase transitions.</code></span>
<span class="codeline" id="line-1142"><code>		lock(&amp;work.sweepWaiters.lock)</code></span>
<span class="codeline" id="line-1143"><code>		nMarks := atomic.Load(&amp;work.cycles)</code></span>
<span class="codeline" id="line-1144"><code>		if gcphase != _GCmark {</code></span>
<span class="codeline" id="line-1145"><code>			// We've already completed this cycle's mark.</code></span>
<span class="codeline" id="line-1146"><code>			nMarks++</code></span>
<span class="codeline" id="line-1147"><code>		}</code></span>
<span class="codeline" id="line-1148"><code>		if nMarks &gt; n {</code></span>
<span class="codeline" id="line-1149"><code>			// We're done.</code></span>
<span class="codeline" id="line-1150"><code>			unlock(&amp;work.sweepWaiters.lock)</code></span>
<span class="codeline" id="line-1151"><code>			return</code></span>
<span class="codeline" id="line-1152"><code>		}</code></span>
<span class="codeline" id="line-1153"><code></code></span>
<span class="codeline" id="line-1154"><code>		// Wait until sweep termination, mark, and mark</code></span>
<span class="codeline" id="line-1155"><code>		// termination of cycle N complete.</code></span>
<span class="codeline" id="line-1156"><code>		work.sweepWaiters.list.push(getg())</code></span>
<span class="codeline" id="line-1157"><code>		goparkunlock(&amp;work.sweepWaiters.lock, waitReasonWaitForGCCycle, traceEvGoBlock, 1)</code></span>
<span class="codeline" id="line-1158"><code>	}</code></span>
<span class="codeline" id="line-1159"><code>}</code></span>
<span class="codeline" id="line-1160"><code></code></span>
<span class="codeline" id="line-1161"><code>// gcMode indicates how concurrent a GC cycle should be.</code></span>
<span class="codeline" id="line-1162"><code>type gcMode int</code></span>
<span class="codeline" id="line-1163"><code></code></span>
<span class="codeline" id="line-1164"><code>const (</code></span>
<span class="codeline" id="line-1165"><code>	gcBackgroundMode gcMode = iota // concurrent GC and sweep</code></span>
<span class="codeline" id="line-1166"><code>	gcForceMode                    // stop-the-world GC now, concurrent sweep</code></span>
<span class="codeline" id="line-1167"><code>	gcForceBlockMode               // stop-the-world GC now and STW sweep (forced by user)</code></span>
<span class="codeline" id="line-1168"><code>)</code></span>
<span class="codeline" id="line-1169"><code></code></span>
<span class="codeline" id="line-1170"><code>// A gcTrigger is a predicate for starting a GC cycle. Specifically,</code></span>
<span class="codeline" id="line-1171"><code>// it is an exit condition for the _GCoff phase.</code></span>
<span class="codeline" id="line-1172"><code>type gcTrigger struct {</code></span>
<span class="codeline" id="line-1173"><code>	kind gcTriggerKind</code></span>
<span class="codeline" id="line-1174"><code>	now  int64  // gcTriggerTime: current time</code></span>
<span class="codeline" id="line-1175"><code>	n    uint32 // gcTriggerCycle: cycle number to start</code></span>
<span class="codeline" id="line-1176"><code>}</code></span>
<span class="codeline" id="line-1177"><code></code></span>
<span class="codeline" id="line-1178"><code>type gcTriggerKind int</code></span>
<span class="codeline" id="line-1179"><code></code></span>
<span class="codeline" id="line-1180"><code>const (</code></span>
<span class="codeline" id="line-1181"><code>	// gcTriggerHeap indicates that a cycle should be started when</code></span>
<span class="codeline" id="line-1182"><code>	// the heap size reaches the trigger heap size computed by the</code></span>
<span class="codeline" id="line-1183"><code>	// controller.</code></span>
<span class="codeline" id="line-1184"><code>	gcTriggerHeap gcTriggerKind = iota</code></span>
<span class="codeline" id="line-1185"><code></code></span>
<span class="codeline" id="line-1186"><code>	// gcTriggerTime indicates that a cycle should be started when</code></span>
<span class="codeline" id="line-1187"><code>	// it's been more than forcegcperiod nanoseconds since the</code></span>
<span class="codeline" id="line-1188"><code>	// previous GC cycle.</code></span>
<span class="codeline" id="line-1189"><code>	gcTriggerTime</code></span>
<span class="codeline" id="line-1190"><code></code></span>
<span class="codeline" id="line-1191"><code>	// gcTriggerCycle indicates that a cycle should be started if</code></span>
<span class="codeline" id="line-1192"><code>	// we have not yet started cycle number gcTrigger.n (relative</code></span>
<span class="codeline" id="line-1193"><code>	// to work.cycles).</code></span>
<span class="codeline" id="line-1194"><code>	gcTriggerCycle</code></span>
<span class="codeline" id="line-1195"><code>)</code></span>
<span class="codeline" id="line-1196"><code></code></span>
<span class="codeline" id="line-1197"><code>// test reports whether the trigger condition is satisfied, meaning</code></span>
<span class="codeline" id="line-1198"><code>// that the exit condition for the _GCoff phase has been met. The exit</code></span>
<span class="codeline" id="line-1199"><code>// condition should be tested when allocating.</code></span>
<span class="codeline" id="line-1200"><code>func (t gcTrigger) test() bool {</code></span>
<span class="codeline" id="line-1201"><code>	if !memstats.enablegc || panicking != 0 || gcphase != _GCoff {</code></span>
<span class="codeline" id="line-1202"><code>		return false</code></span>
<span class="codeline" id="line-1203"><code>	}</code></span>
<span class="codeline" id="line-1204"><code>	switch t.kind {</code></span>
<span class="codeline" id="line-1205"><code>	case gcTriggerHeap:</code></span>
<span class="codeline" id="line-1206"><code>		// Non-atomic access to heap_live for performance. If</code></span>
<span class="codeline" id="line-1207"><code>		// we are going to trigger on this, this thread just</code></span>
<span class="codeline" id="line-1208"><code>		// atomically wrote heap_live anyway and we'll see our</code></span>
<span class="codeline" id="line-1209"><code>		// own write.</code></span>
<span class="codeline" id="line-1210"><code>		return memstats.heap_live &gt;= memstats.gc_trigger</code></span>
<span class="codeline" id="line-1211"><code>	case gcTriggerTime:</code></span>
<span class="codeline" id="line-1212"><code>		if gcpercent &lt; 0 {</code></span>
<span class="codeline" id="line-1213"><code>			return false</code></span>
<span class="codeline" id="line-1214"><code>		}</code></span>
<span class="codeline" id="line-1215"><code>		lastgc := int64(atomic.Load64(&amp;memstats.last_gc_nanotime))</code></span>
<span class="codeline" id="line-1216"><code>		return lastgc != 0 &amp;&amp; t.now-lastgc &gt; forcegcperiod</code></span>
<span class="codeline" id="line-1217"><code>	case gcTriggerCycle:</code></span>
<span class="codeline" id="line-1218"><code>		// t.n &gt; work.cycles, but accounting for wraparound.</code></span>
<span class="codeline" id="line-1219"><code>		return int32(t.n-work.cycles) &gt; 0</code></span>
<span class="codeline" id="line-1220"><code>	}</code></span>
<span class="codeline" id="line-1221"><code>	return true</code></span>
<span class="codeline" id="line-1222"><code>}</code></span>
<span class="codeline" id="line-1223"><code></code></span>
<span class="codeline" id="line-1224"><code>// gcStart starts the GC. It transitions from _GCoff to _GCmark (if</code></span>
<span class="codeline" id="line-1225"><code>// debug.gcstoptheworld == 0) or performs all of GC (if</code></span>
<span class="codeline" id="line-1226"><code>// debug.gcstoptheworld != 0).</code></span>
<span class="codeline" id="line-1227"><code>//</code></span>
<span class="codeline" id="line-1228"><code>// This may return without performing this transition in some cases,</code></span>
<span class="codeline" id="line-1229"><code>// such as when called on a system stack or with locks held.</code></span>
<span class="codeline" id="line-1230"><code>func gcStart(trigger gcTrigger) {</code></span>
<span class="codeline" id="line-1231"><code>	// Since this is called from malloc and malloc is called in</code></span>
<span class="codeline" id="line-1232"><code>	// the guts of a number of libraries that might be holding</code></span>
<span class="codeline" id="line-1233"><code>	// locks, don't attempt to start GC in non-preemptible or</code></span>
<span class="codeline" id="line-1234"><code>	// potentially unstable situations.</code></span>
<span class="codeline" id="line-1235"><code>	mp := acquirem()</code></span>
<span class="codeline" id="line-1236"><code>	if gp := getg(); gp == mp.g0 || mp.locks &gt; 1 || mp.preemptoff != "" {</code></span>
<span class="codeline" id="line-1237"><code>		releasem(mp)</code></span>
<span class="codeline" id="line-1238"><code>		return</code></span>
<span class="codeline" id="line-1239"><code>	}</code></span>
<span class="codeline" id="line-1240"><code>	releasem(mp)</code></span>
<span class="codeline" id="line-1241"><code>	mp = nil</code></span>
<span class="codeline" id="line-1242"><code></code></span>
<span class="codeline" id="line-1243"><code>	// Pick up the remaining unswept/not being swept spans concurrently</code></span>
<span class="codeline" id="line-1244"><code>	//</code></span>
<span class="codeline" id="line-1245"><code>	// This shouldn't happen if we're being invoked in background</code></span>
<span class="codeline" id="line-1246"><code>	// mode since proportional sweep should have just finished</code></span>
<span class="codeline" id="line-1247"><code>	// sweeping everything, but rounding errors, etc, may leave a</code></span>
<span class="codeline" id="line-1248"><code>	// few spans unswept. In forced mode, this is necessary since</code></span>
<span class="codeline" id="line-1249"><code>	// GC can be forced at any point in the sweeping cycle.</code></span>
<span class="codeline" id="line-1250"><code>	//</code></span>
<span class="codeline" id="line-1251"><code>	// We check the transition condition continuously here in case</code></span>
<span class="codeline" id="line-1252"><code>	// this G gets delayed in to the next GC cycle.</code></span>
<span class="codeline" id="line-1253"><code>	for trigger.test() &amp;&amp; sweepone() != ^uintptr(0) {</code></span>
<span class="codeline" id="line-1254"><code>		sweep.nbgsweep++</code></span>
<span class="codeline" id="line-1255"><code>	}</code></span>
<span class="codeline" id="line-1256"><code></code></span>
<span class="codeline" id="line-1257"><code>	// Perform GC initialization and the sweep termination</code></span>
<span class="codeline" id="line-1258"><code>	// transition.</code></span>
<span class="codeline" id="line-1259"><code>	semacquire(&amp;work.startSema)</code></span>
<span class="codeline" id="line-1260"><code>	// Re-check transition condition under transition lock.</code></span>
<span class="codeline" id="line-1261"><code>	if !trigger.test() {</code></span>
<span class="codeline" id="line-1262"><code>		semrelease(&amp;work.startSema)</code></span>
<span class="codeline" id="line-1263"><code>		return</code></span>
<span class="codeline" id="line-1264"><code>	}</code></span>
<span class="codeline" id="line-1265"><code></code></span>
<span class="codeline" id="line-1266"><code>	// For stats, check if this GC was forced by the user.</code></span>
<span class="codeline" id="line-1267"><code>	work.userForced = trigger.kind == gcTriggerCycle</code></span>
<span class="codeline" id="line-1268"><code></code></span>
<span class="codeline" id="line-1269"><code>	// In gcstoptheworld debug mode, upgrade the mode accordingly.</code></span>
<span class="codeline" id="line-1270"><code>	// We do this after re-checking the transition condition so</code></span>
<span class="codeline" id="line-1271"><code>	// that multiple goroutines that detect the heap trigger don't</code></span>
<span class="codeline" id="line-1272"><code>	// start multiple STW GCs.</code></span>
<span class="codeline" id="line-1273"><code>	mode := gcBackgroundMode</code></span>
<span class="codeline" id="line-1274"><code>	if debug.gcstoptheworld == 1 {</code></span>
<span class="codeline" id="line-1275"><code>		mode = gcForceMode</code></span>
<span class="codeline" id="line-1276"><code>	} else if debug.gcstoptheworld == 2 {</code></span>
<span class="codeline" id="line-1277"><code>		mode = gcForceBlockMode</code></span>
<span class="codeline" id="line-1278"><code>	}</code></span>
<span class="codeline" id="line-1279"><code></code></span>
<span class="codeline" id="line-1280"><code>	// Ok, we're doing it! Stop everybody else</code></span>
<span class="codeline" id="line-1281"><code>	semacquire(&amp;gcsema)</code></span>
<span class="codeline" id="line-1282"><code>	semacquire(&amp;worldsema)</code></span>
<span class="codeline" id="line-1283"><code></code></span>
<span class="codeline" id="line-1284"><code>	if trace.enabled {</code></span>
<span class="codeline" id="line-1285"><code>		traceGCStart()</code></span>
<span class="codeline" id="line-1286"><code>	}</code></span>
<span class="codeline" id="line-1287"><code></code></span>
<span class="codeline" id="line-1288"><code>	// Check that all Ps have finished deferred mcache flushes.</code></span>
<span class="codeline" id="line-1289"><code>	for _, p := range allp {</code></span>
<span class="codeline" id="line-1290"><code>		if fg := atomic.Load(&amp;p.mcache.flushGen); fg != mheap_.sweepgen {</code></span>
<span class="codeline" id="line-1291"><code>			println("runtime: p", p.id, "flushGen", fg, "!= sweepgen", mheap_.sweepgen)</code></span>
<span class="codeline" id="line-1292"><code>			throw("p mcache not flushed")</code></span>
<span class="codeline" id="line-1293"><code>		}</code></span>
<span class="codeline" id="line-1294"><code>	}</code></span>
<span class="codeline" id="line-1295"><code></code></span>
<span class="codeline" id="line-1296"><code>	gcBgMarkStartWorkers()</code></span>
<span class="codeline" id="line-1297"><code></code></span>
<span class="codeline" id="line-1298"><code>	systemstack(gcResetMarkState)</code></span>
<span class="codeline" id="line-1299"><code></code></span>
<span class="codeline" id="line-1300"><code>	work.stwprocs, work.maxprocs = gomaxprocs, gomaxprocs</code></span>
<span class="codeline" id="line-1301"><code>	if work.stwprocs &gt; ncpu {</code></span>
<span class="codeline" id="line-1302"><code>		// This is used to compute CPU time of the STW phases,</code></span>
<span class="codeline" id="line-1303"><code>		// so it can't be more than ncpu, even if GOMAXPROCS is.</code></span>
<span class="codeline" id="line-1304"><code>		work.stwprocs = ncpu</code></span>
<span class="codeline" id="line-1305"><code>	}</code></span>
<span class="codeline" id="line-1306"><code>	work.heap0 = atomic.Load64(&amp;memstats.heap_live)</code></span>
<span class="codeline" id="line-1307"><code>	work.pauseNS = 0</code></span>
<span class="codeline" id="line-1308"><code>	work.mode = mode</code></span>
<span class="codeline" id="line-1309"><code></code></span>
<span class="codeline" id="line-1310"><code>	now := nanotime()</code></span>
<span class="codeline" id="line-1311"><code>	work.tSweepTerm = now</code></span>
<span class="codeline" id="line-1312"><code>	work.pauseStart = now</code></span>
<span class="codeline" id="line-1313"><code>	if trace.enabled {</code></span>
<span class="codeline" id="line-1314"><code>		traceGCSTWStart(1)</code></span>
<span class="codeline" id="line-1315"><code>	}</code></span>
<span class="codeline" id="line-1316"><code>	systemstack(stopTheWorldWithSema)</code></span>
<span class="codeline" id="line-1317"><code>	// Finish sweep before we start concurrent scan.</code></span>
<span class="codeline" id="line-1318"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-1319"><code>		finishsweep_m()</code></span>
<span class="codeline" id="line-1320"><code>	})</code></span>
<span class="codeline" id="line-1321"><code></code></span>
<span class="codeline" id="line-1322"><code>	// clearpools before we start the GC. If we wait they memory will not be</code></span>
<span class="codeline" id="line-1323"><code>	// reclaimed until the next GC cycle.</code></span>
<span class="codeline" id="line-1324"><code>	clearpools()</code></span>
<span class="codeline" id="line-1325"><code></code></span>
<span class="codeline" id="line-1326"><code>	work.cycles++</code></span>
<span class="codeline" id="line-1327"><code></code></span>
<span class="codeline" id="line-1328"><code>	gcController.startCycle()</code></span>
<span class="codeline" id="line-1329"><code>	work.heapGoal = memstats.next_gc</code></span>
<span class="codeline" id="line-1330"><code></code></span>
<span class="codeline" id="line-1331"><code>	// In STW mode, disable scheduling of user Gs. This may also</code></span>
<span class="codeline" id="line-1332"><code>	// disable scheduling of this goroutine, so it may block as</code></span>
<span class="codeline" id="line-1333"><code>	// soon as we start the world again.</code></span>
<span class="codeline" id="line-1334"><code>	if mode != gcBackgroundMode {</code></span>
<span class="codeline" id="line-1335"><code>		schedEnableUser(false)</code></span>
<span class="codeline" id="line-1336"><code>	}</code></span>
<span class="codeline" id="line-1337"><code></code></span>
<span class="codeline" id="line-1338"><code>	// Enter concurrent mark phase and enable</code></span>
<span class="codeline" id="line-1339"><code>	// write barriers.</code></span>
<span class="codeline" id="line-1340"><code>	//</code></span>
<span class="codeline" id="line-1341"><code>	// Because the world is stopped, all Ps will</code></span>
<span class="codeline" id="line-1342"><code>	// observe that write barriers are enabled by</code></span>
<span class="codeline" id="line-1343"><code>	// the time we start the world and begin</code></span>
<span class="codeline" id="line-1344"><code>	// scanning.</code></span>
<span class="codeline" id="line-1345"><code>	//</code></span>
<span class="codeline" id="line-1346"><code>	// Write barriers must be enabled before assists are</code></span>
<span class="codeline" id="line-1347"><code>	// enabled because they must be enabled before</code></span>
<span class="codeline" id="line-1348"><code>	// any non-leaf heap objects are marked. Since</code></span>
<span class="codeline" id="line-1349"><code>	// allocations are blocked until assists can</code></span>
<span class="codeline" id="line-1350"><code>	// happen, we want enable assists as early as</code></span>
<span class="codeline" id="line-1351"><code>	// possible.</code></span>
<span class="codeline" id="line-1352"><code>	setGCPhase(_GCmark)</code></span>
<span class="codeline" id="line-1353"><code></code></span>
<span class="codeline" id="line-1354"><code>	gcBgMarkPrepare() // Must happen before assist enable.</code></span>
<span class="codeline" id="line-1355"><code>	gcMarkRootPrepare()</code></span>
<span class="codeline" id="line-1356"><code></code></span>
<span class="codeline" id="line-1357"><code>	// Mark all active tinyalloc blocks. Since we're</code></span>
<span class="codeline" id="line-1358"><code>	// allocating from these, they need to be black like</code></span>
<span class="codeline" id="line-1359"><code>	// other allocations. The alternative is to blacken</code></span>
<span class="codeline" id="line-1360"><code>	// the tiny block on every allocation from it, which</code></span>
<span class="codeline" id="line-1361"><code>	// would slow down the tiny allocator.</code></span>
<span class="codeline" id="line-1362"><code>	gcMarkTinyAllocs()</code></span>
<span class="codeline" id="line-1363"><code></code></span>
<span class="codeline" id="line-1364"><code>	// At this point all Ps have enabled the write</code></span>
<span class="codeline" id="line-1365"><code>	// barrier, thus maintaining the no white to</code></span>
<span class="codeline" id="line-1366"><code>	// black invariant. Enable mutator assists to</code></span>
<span class="codeline" id="line-1367"><code>	// put back-pressure on fast allocating</code></span>
<span class="codeline" id="line-1368"><code>	// mutators.</code></span>
<span class="codeline" id="line-1369"><code>	atomic.Store(&amp;gcBlackenEnabled, 1)</code></span>
<span class="codeline" id="line-1370"><code></code></span>
<span class="codeline" id="line-1371"><code>	// Assists and workers can start the moment we start</code></span>
<span class="codeline" id="line-1372"><code>	// the world.</code></span>
<span class="codeline" id="line-1373"><code>	gcController.markStartTime = now</code></span>
<span class="codeline" id="line-1374"><code></code></span>
<span class="codeline" id="line-1375"><code>	// In STW mode, we could block the instant systemstack</code></span>
<span class="codeline" id="line-1376"><code>	// returns, so make sure we're not preemptible.</code></span>
<span class="codeline" id="line-1377"><code>	mp = acquirem()</code></span>
<span class="codeline" id="line-1378"><code></code></span>
<span class="codeline" id="line-1379"><code>	// Concurrent mark.</code></span>
<span class="codeline" id="line-1380"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-1381"><code>		now = startTheWorldWithSema(trace.enabled)</code></span>
<span class="codeline" id="line-1382"><code>		work.pauseNS += now - work.pauseStart</code></span>
<span class="codeline" id="line-1383"><code>		work.tMark = now</code></span>
<span class="codeline" id="line-1384"><code>	})</code></span>
<span class="codeline" id="line-1385"><code></code></span>
<span class="codeline" id="line-1386"><code>	// Release the world sema before Gosched() in STW mode</code></span>
<span class="codeline" id="line-1387"><code>	// because we will need to reacquire it later but before</code></span>
<span class="codeline" id="line-1388"><code>	// this goroutine becomes runnable again, and we could</code></span>
<span class="codeline" id="line-1389"><code>	// self-deadlock otherwise.</code></span>
<span class="codeline" id="line-1390"><code>	semrelease(&amp;worldsema)</code></span>
<span class="codeline" id="line-1391"><code>	releasem(mp)</code></span>
<span class="codeline" id="line-1392"><code></code></span>
<span class="codeline" id="line-1393"><code>	// Make sure we block instead of returning to user code</code></span>
<span class="codeline" id="line-1394"><code>	// in STW mode.</code></span>
<span class="codeline" id="line-1395"><code>	if mode != gcBackgroundMode {</code></span>
<span class="codeline" id="line-1396"><code>		Gosched()</code></span>
<span class="codeline" id="line-1397"><code>	}</code></span>
<span class="codeline" id="line-1398"><code></code></span>
<span class="codeline" id="line-1399"><code>	semrelease(&amp;work.startSema)</code></span>
<span class="codeline" id="line-1400"><code>}</code></span>
<span class="codeline" id="line-1401"><code></code></span>
<span class="codeline" id="line-1402"><code>// gcMarkDoneFlushed counts the number of P's with flushed work.</code></span>
<span class="codeline" id="line-1403"><code>//</code></span>
<span class="codeline" id="line-1404"><code>// Ideally this would be a captured local in gcMarkDone, but forEachP</code></span>
<span class="codeline" id="line-1405"><code>// escapes its callback closure, so it can't capture anything.</code></span>
<span class="codeline" id="line-1406"><code>//</code></span>
<span class="codeline" id="line-1407"><code>// This is protected by markDoneSema.</code></span>
<span class="codeline" id="line-1408"><code>var gcMarkDoneFlushed uint32</code></span>
<span class="codeline" id="line-1409"><code></code></span>
<span class="codeline" id="line-1410"><code>// debugCachedWork enables extra checks for debugging premature mark</code></span>
<span class="codeline" id="line-1411"><code>// termination.</code></span>
<span class="codeline" id="line-1412"><code>//</code></span>
<span class="codeline" id="line-1413"><code>// For debugging issue #27993.</code></span>
<span class="codeline" id="line-1414"><code>const debugCachedWork = false</code></span>
<span class="codeline" id="line-1415"><code></code></span>
<span class="codeline" id="line-1416"><code>// gcWorkPauseGen is for debugging the mark completion algorithm.</code></span>
<span class="codeline" id="line-1417"><code>// gcWork put operations spin while gcWork.pauseGen == gcWorkPauseGen.</code></span>
<span class="codeline" id="line-1418"><code>// Only used if debugCachedWork is true.</code></span>
<span class="codeline" id="line-1419"><code>//</code></span>
<span class="codeline" id="line-1420"><code>// For debugging issue #27993.</code></span>
<span class="codeline" id="line-1421"><code>var gcWorkPauseGen uint32 = 1</code></span>
<span class="codeline" id="line-1422"><code></code></span>
<span class="codeline" id="line-1423"><code>// gcMarkDone transitions the GC from mark to mark termination if all</code></span>
<span class="codeline" id="line-1424"><code>// reachable objects have been marked (that is, there are no grey</code></span>
<span class="codeline" id="line-1425"><code>// objects and can be no more in the future). Otherwise, it flushes</code></span>
<span class="codeline" id="line-1426"><code>// all local work to the global queues where it can be discovered by</code></span>
<span class="codeline" id="line-1427"><code>// other workers.</code></span>
<span class="codeline" id="line-1428"><code>//</code></span>
<span class="codeline" id="line-1429"><code>// This should be called when all local mark work has been drained and</code></span>
<span class="codeline" id="line-1430"><code>// there are no remaining workers. Specifically, when</code></span>
<span class="codeline" id="line-1431"><code>//</code></span>
<span class="codeline" id="line-1432"><code>//   work.nwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(p)</code></span>
<span class="codeline" id="line-1433"><code>//</code></span>
<span class="codeline" id="line-1434"><code>// The calling context must be preemptible.</code></span>
<span class="codeline" id="line-1435"><code>//</code></span>
<span class="codeline" id="line-1436"><code>// Flushing local work is important because idle Ps may have local</code></span>
<span class="codeline" id="line-1437"><code>// work queued. This is the only way to make that work visible and</code></span>
<span class="codeline" id="line-1438"><code>// drive GC to completion.</code></span>
<span class="codeline" id="line-1439"><code>//</code></span>
<span class="codeline" id="line-1440"><code>// It is explicitly okay to have write barriers in this function. If</code></span>
<span class="codeline" id="line-1441"><code>// it does transition to mark termination, then all reachable objects</code></span>
<span class="codeline" id="line-1442"><code>// have been marked, so the write barrier cannot shade any more</code></span>
<span class="codeline" id="line-1443"><code>// objects.</code></span>
<span class="codeline" id="line-1444"><code>func gcMarkDone() {</code></span>
<span class="codeline" id="line-1445"><code>	// Ensure only one thread is running the ragged barrier at a</code></span>
<span class="codeline" id="line-1446"><code>	// time.</code></span>
<span class="codeline" id="line-1447"><code>	semacquire(&amp;work.markDoneSema)</code></span>
<span class="codeline" id="line-1448"><code></code></span>
<span class="codeline" id="line-1449"><code>top:</code></span>
<span class="codeline" id="line-1450"><code>	// Re-check transition condition under transition lock.</code></span>
<span class="codeline" id="line-1451"><code>	//</code></span>
<span class="codeline" id="line-1452"><code>	// It's critical that this checks the global work queues are</code></span>
<span class="codeline" id="line-1453"><code>	// empty before performing the ragged barrier. Otherwise,</code></span>
<span class="codeline" id="line-1454"><code>	// there could be global work that a P could take after the P</code></span>
<span class="codeline" id="line-1455"><code>	// has passed the ragged barrier.</code></span>
<span class="codeline" id="line-1456"><code>	if !(gcphase == _GCmark &amp;&amp; work.nwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(nil)) {</code></span>
<span class="codeline" id="line-1457"><code>		semrelease(&amp;work.markDoneSema)</code></span>
<span class="codeline" id="line-1458"><code>		return</code></span>
<span class="codeline" id="line-1459"><code>	}</code></span>
<span class="codeline" id="line-1460"><code></code></span>
<span class="codeline" id="line-1461"><code>	// forEachP needs worldsema to execute, and we'll need it to</code></span>
<span class="codeline" id="line-1462"><code>	// stop the world later, so acquire worldsema now.</code></span>
<span class="codeline" id="line-1463"><code>	semacquire(&amp;worldsema)</code></span>
<span class="codeline" id="line-1464"><code></code></span>
<span class="codeline" id="line-1465"><code>	// Flush all local buffers and collect flushedWork flags.</code></span>
<span class="codeline" id="line-1466"><code>	gcMarkDoneFlushed = 0</code></span>
<span class="codeline" id="line-1467"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-1468"><code>		gp := getg().m.curg</code></span>
<span class="codeline" id="line-1469"><code>		// Mark the user stack as preemptible so that it may be scanned.</code></span>
<span class="codeline" id="line-1470"><code>		// Otherwise, our attempt to force all P's to a safepoint could</code></span>
<span class="codeline" id="line-1471"><code>		// result in a deadlock as we attempt to preempt a worker that's</code></span>
<span class="codeline" id="line-1472"><code>		// trying to preempt us (e.g. for a stack scan).</code></span>
<span class="codeline" id="line-1473"><code>		casgstatus(gp, _Grunning, _Gwaiting)</code></span>
<span class="codeline" id="line-1474"><code>		forEachP(func(_p_ *p) {</code></span>
<span class="codeline" id="line-1475"><code>			// Flush the write barrier buffer, since this may add</code></span>
<span class="codeline" id="line-1476"><code>			// work to the gcWork.</code></span>
<span class="codeline" id="line-1477"><code>			wbBufFlush1(_p_)</code></span>
<span class="codeline" id="line-1478"><code>			// For debugging, shrink the write barrier</code></span>
<span class="codeline" id="line-1479"><code>			// buffer so it flushes immediately.</code></span>
<span class="codeline" id="line-1480"><code>			// wbBuf.reset will keep it at this size as</code></span>
<span class="codeline" id="line-1481"><code>			// long as throwOnGCWork is set.</code></span>
<span class="codeline" id="line-1482"><code>			if debugCachedWork {</code></span>
<span class="codeline" id="line-1483"><code>				b := &amp;_p_.wbBuf</code></span>
<span class="codeline" id="line-1484"><code>				b.end = uintptr(unsafe.Pointer(&amp;b.buf[wbBufEntryPointers]))</code></span>
<span class="codeline" id="line-1485"><code>				b.debugGen = gcWorkPauseGen</code></span>
<span class="codeline" id="line-1486"><code>			}</code></span>
<span class="codeline" id="line-1487"><code>			// Flush the gcWork, since this may create global work</code></span>
<span class="codeline" id="line-1488"><code>			// and set the flushedWork flag.</code></span>
<span class="codeline" id="line-1489"><code>			//</code></span>
<span class="codeline" id="line-1490"><code>			// TODO(austin): Break up these workbufs to</code></span>
<span class="codeline" id="line-1491"><code>			// better distribute work.</code></span>
<span class="codeline" id="line-1492"><code>			_p_.gcw.dispose()</code></span>
<span class="codeline" id="line-1493"><code>			// Collect the flushedWork flag.</code></span>
<span class="codeline" id="line-1494"><code>			if _p_.gcw.flushedWork {</code></span>
<span class="codeline" id="line-1495"><code>				atomic.Xadd(&amp;gcMarkDoneFlushed, 1)</code></span>
<span class="codeline" id="line-1496"><code>				_p_.gcw.flushedWork = false</code></span>
<span class="codeline" id="line-1497"><code>			} else if debugCachedWork {</code></span>
<span class="codeline" id="line-1498"><code>				// For debugging, freeze the gcWork</code></span>
<span class="codeline" id="line-1499"><code>				// until we know whether we've reached</code></span>
<span class="codeline" id="line-1500"><code>				// completion or not. If we think</code></span>
<span class="codeline" id="line-1501"><code>				// we've reached completion, but</code></span>
<span class="codeline" id="line-1502"><code>				// there's a paused gcWork, then</code></span>
<span class="codeline" id="line-1503"><code>				// that's a bug.</code></span>
<span class="codeline" id="line-1504"><code>				_p_.gcw.pauseGen = gcWorkPauseGen</code></span>
<span class="codeline" id="line-1505"><code>				// Capture the G's stack.</code></span>
<span class="codeline" id="line-1506"><code>				for i := range _p_.gcw.pauseStack {</code></span>
<span class="codeline" id="line-1507"><code>					_p_.gcw.pauseStack[i] = 0</code></span>
<span class="codeline" id="line-1508"><code>				}</code></span>
<span class="codeline" id="line-1509"><code>				callers(1, _p_.gcw.pauseStack[:])</code></span>
<span class="codeline" id="line-1510"><code>			}</code></span>
<span class="codeline" id="line-1511"><code>		})</code></span>
<span class="codeline" id="line-1512"><code>		casgstatus(gp, _Gwaiting, _Grunning)</code></span>
<span class="codeline" id="line-1513"><code>	})</code></span>
<span class="codeline" id="line-1514"><code></code></span>
<span class="codeline" id="line-1515"><code>	if gcMarkDoneFlushed != 0 {</code></span>
<span class="codeline" id="line-1516"><code>		if debugCachedWork {</code></span>
<span class="codeline" id="line-1517"><code>			// Release paused gcWorks.</code></span>
<span class="codeline" id="line-1518"><code>			atomic.Xadd(&amp;gcWorkPauseGen, 1)</code></span>
<span class="codeline" id="line-1519"><code>		}</code></span>
<span class="codeline" id="line-1520"><code>		// More grey objects were discovered since the</code></span>
<span class="codeline" id="line-1521"><code>		// previous termination check, so there may be more</code></span>
<span class="codeline" id="line-1522"><code>		// work to do. Keep going. It's possible the</code></span>
<span class="codeline" id="line-1523"><code>		// transition condition became true again during the</code></span>
<span class="codeline" id="line-1524"><code>		// ragged barrier, so re-check it.</code></span>
<span class="codeline" id="line-1525"><code>		semrelease(&amp;worldsema)</code></span>
<span class="codeline" id="line-1526"><code>		goto top</code></span>
<span class="codeline" id="line-1527"><code>	}</code></span>
<span class="codeline" id="line-1528"><code></code></span>
<span class="codeline" id="line-1529"><code>	if debugCachedWork {</code></span>
<span class="codeline" id="line-1530"><code>		throwOnGCWork = true</code></span>
<span class="codeline" id="line-1531"><code>		// Release paused gcWorks. If there are any, they</code></span>
<span class="codeline" id="line-1532"><code>		// should now observe throwOnGCWork and panic.</code></span>
<span class="codeline" id="line-1533"><code>		atomic.Xadd(&amp;gcWorkPauseGen, 1)</code></span>
<span class="codeline" id="line-1534"><code>	}</code></span>
<span class="codeline" id="line-1535"><code></code></span>
<span class="codeline" id="line-1536"><code>	// There was no global work, no local work, and no Ps</code></span>
<span class="codeline" id="line-1537"><code>	// communicated work since we took markDoneSema. Therefore</code></span>
<span class="codeline" id="line-1538"><code>	// there are no grey objects and no more objects can be</code></span>
<span class="codeline" id="line-1539"><code>	// shaded. Transition to mark termination.</code></span>
<span class="codeline" id="line-1540"><code>	now := nanotime()</code></span>
<span class="codeline" id="line-1541"><code>	work.tMarkTerm = now</code></span>
<span class="codeline" id="line-1542"><code>	work.pauseStart = now</code></span>
<span class="codeline" id="line-1543"><code>	getg().m.preemptoff = "gcing"</code></span>
<span class="codeline" id="line-1544"><code>	if trace.enabled {</code></span>
<span class="codeline" id="line-1545"><code>		traceGCSTWStart(0)</code></span>
<span class="codeline" id="line-1546"><code>	}</code></span>
<span class="codeline" id="line-1547"><code>	systemstack(stopTheWorldWithSema)</code></span>
<span class="codeline" id="line-1548"><code>	// The gcphase is _GCmark, it will transition to _GCmarktermination</code></span>
<span class="codeline" id="line-1549"><code>	// below. The important thing is that the wb remains active until</code></span>
<span class="codeline" id="line-1550"><code>	// all marking is complete. This includes writes made by the GC.</code></span>
<span class="codeline" id="line-1551"><code></code></span>
<span class="codeline" id="line-1552"><code>	if debugCachedWork {</code></span>
<span class="codeline" id="line-1553"><code>		// For debugging, double check that no work was added after we</code></span>
<span class="codeline" id="line-1554"><code>		// went around above and disable write barrier buffering.</code></span>
<span class="codeline" id="line-1555"><code>		for _, p := range allp {</code></span>
<span class="codeline" id="line-1556"><code>			gcw := &amp;p.gcw</code></span>
<span class="codeline" id="line-1557"><code>			if !gcw.empty() {</code></span>
<span class="codeline" id="line-1558"><code>				printlock()</code></span>
<span class="codeline" id="line-1559"><code>				print("runtime: P ", p.id, " flushedWork ", gcw.flushedWork)</code></span>
<span class="codeline" id="line-1560"><code>				if gcw.wbuf1 == nil {</code></span>
<span class="codeline" id="line-1561"><code>					print(" wbuf1=&lt;nil&gt;")</code></span>
<span class="codeline" id="line-1562"><code>				} else {</code></span>
<span class="codeline" id="line-1563"><code>					print(" wbuf1.n=", gcw.wbuf1.nobj)</code></span>
<span class="codeline" id="line-1564"><code>				}</code></span>
<span class="codeline" id="line-1565"><code>				if gcw.wbuf2 == nil {</code></span>
<span class="codeline" id="line-1566"><code>					print(" wbuf2=&lt;nil&gt;")</code></span>
<span class="codeline" id="line-1567"><code>				} else {</code></span>
<span class="codeline" id="line-1568"><code>					print(" wbuf2.n=", gcw.wbuf2.nobj)</code></span>
<span class="codeline" id="line-1569"><code>				}</code></span>
<span class="codeline" id="line-1570"><code>				print("\n")</code></span>
<span class="codeline" id="line-1571"><code>				if gcw.pauseGen == gcw.putGen {</code></span>
<span class="codeline" id="line-1572"><code>					println("runtime: checkPut already failed at this generation")</code></span>
<span class="codeline" id="line-1573"><code>				}</code></span>
<span class="codeline" id="line-1574"><code>				throw("throwOnGCWork")</code></span>
<span class="codeline" id="line-1575"><code>			}</code></span>
<span class="codeline" id="line-1576"><code>		}</code></span>
<span class="codeline" id="line-1577"><code>	} else {</code></span>
<span class="codeline" id="line-1578"><code>		// For unknown reasons (see issue #27993), there is</code></span>
<span class="codeline" id="line-1579"><code>		// sometimes work left over when we enter mark</code></span>
<span class="codeline" id="line-1580"><code>		// termination. Detect this and resume concurrent</code></span>
<span class="codeline" id="line-1581"><code>		// mark. This is obviously unfortunate.</code></span>
<span class="codeline" id="line-1582"><code>		//</code></span>
<span class="codeline" id="line-1583"><code>		// Switch to the system stack to call wbBufFlush1,</code></span>
<span class="codeline" id="line-1584"><code>		// though in this case it doesn't matter because we're</code></span>
<span class="codeline" id="line-1585"><code>		// non-preemptible anyway.</code></span>
<span class="codeline" id="line-1586"><code>		restart := false</code></span>
<span class="codeline" id="line-1587"><code>		systemstack(func() {</code></span>
<span class="codeline" id="line-1588"><code>			for _, p := range allp {</code></span>
<span class="codeline" id="line-1589"><code>				wbBufFlush1(p)</code></span>
<span class="codeline" id="line-1590"><code>				if !p.gcw.empty() {</code></span>
<span class="codeline" id="line-1591"><code>					restart = true</code></span>
<span class="codeline" id="line-1592"><code>					break</code></span>
<span class="codeline" id="line-1593"><code>				}</code></span>
<span class="codeline" id="line-1594"><code>			}</code></span>
<span class="codeline" id="line-1595"><code>		})</code></span>
<span class="codeline" id="line-1596"><code>		if restart {</code></span>
<span class="codeline" id="line-1597"><code>			getg().m.preemptoff = ""</code></span>
<span class="codeline" id="line-1598"><code>			systemstack(func() {</code></span>
<span class="codeline" id="line-1599"><code>				now := startTheWorldWithSema(true)</code></span>
<span class="codeline" id="line-1600"><code>				work.pauseNS += now - work.pauseStart</code></span>
<span class="codeline" id="line-1601"><code>			})</code></span>
<span class="codeline" id="line-1602"><code>			semrelease(&amp;worldsema)</code></span>
<span class="codeline" id="line-1603"><code>			goto top</code></span>
<span class="codeline" id="line-1604"><code>		}</code></span>
<span class="codeline" id="line-1605"><code>	}</code></span>
<span class="codeline" id="line-1606"><code></code></span>
<span class="codeline" id="line-1607"><code>	// Disable assists and background workers. We must do</code></span>
<span class="codeline" id="line-1608"><code>	// this before waking blocked assists.</code></span>
<span class="codeline" id="line-1609"><code>	atomic.Store(&amp;gcBlackenEnabled, 0)</code></span>
<span class="codeline" id="line-1610"><code></code></span>
<span class="codeline" id="line-1611"><code>	// Wake all blocked assists. These will run when we</code></span>
<span class="codeline" id="line-1612"><code>	// start the world again.</code></span>
<span class="codeline" id="line-1613"><code>	gcWakeAllAssists()</code></span>
<span class="codeline" id="line-1614"><code></code></span>
<span class="codeline" id="line-1615"><code>	// Likewise, release the transition lock. Blocked</code></span>
<span class="codeline" id="line-1616"><code>	// workers and assists will run when we start the</code></span>
<span class="codeline" id="line-1617"><code>	// world again.</code></span>
<span class="codeline" id="line-1618"><code>	semrelease(&amp;work.markDoneSema)</code></span>
<span class="codeline" id="line-1619"><code></code></span>
<span class="codeline" id="line-1620"><code>	// In STW mode, re-enable user goroutines. These will be</code></span>
<span class="codeline" id="line-1621"><code>	// queued to run after we start the world.</code></span>
<span class="codeline" id="line-1622"><code>	schedEnableUser(true)</code></span>
<span class="codeline" id="line-1623"><code></code></span>
<span class="codeline" id="line-1624"><code>	// endCycle depends on all gcWork cache stats being flushed.</code></span>
<span class="codeline" id="line-1625"><code>	// The termination algorithm above ensured that up to</code></span>
<span class="codeline" id="line-1626"><code>	// allocations since the ragged barrier.</code></span>
<span class="codeline" id="line-1627"><code>	nextTriggerRatio := gcController.endCycle()</code></span>
<span class="codeline" id="line-1628"><code></code></span>
<span class="codeline" id="line-1629"><code>	// Perform mark termination. This will restart the world.</code></span>
<span class="codeline" id="line-1630"><code>	gcMarkTermination(nextTriggerRatio)</code></span>
<span class="codeline" id="line-1631"><code>}</code></span>
<span class="codeline" id="line-1632"><code></code></span>
<span class="codeline" id="line-1633"><code>func gcMarkTermination(nextTriggerRatio float64) {</code></span>
<span class="codeline" id="line-1634"><code>	// World is stopped.</code></span>
<span class="codeline" id="line-1635"><code>	// Start marktermination which includes enabling the write barrier.</code></span>
<span class="codeline" id="line-1636"><code>	atomic.Store(&amp;gcBlackenEnabled, 0)</code></span>
<span class="codeline" id="line-1637"><code>	setGCPhase(_GCmarktermination)</code></span>
<span class="codeline" id="line-1638"><code></code></span>
<span class="codeline" id="line-1639"><code>	work.heap1 = memstats.heap_live</code></span>
<span class="codeline" id="line-1640"><code>	startTime := nanotime()</code></span>
<span class="codeline" id="line-1641"><code></code></span>
<span class="codeline" id="line-1642"><code>	mp := acquirem()</code></span>
<span class="codeline" id="line-1643"><code>	mp.preemptoff = "gcing"</code></span>
<span class="codeline" id="line-1644"><code>	_g_ := getg()</code></span>
<span class="codeline" id="line-1645"><code>	_g_.m.traceback = 2</code></span>
<span class="codeline" id="line-1646"><code>	gp := _g_.m.curg</code></span>
<span class="codeline" id="line-1647"><code>	casgstatus(gp, _Grunning, _Gwaiting)</code></span>
<span class="codeline" id="line-1648"><code>	gp.waitreason = waitReasonGarbageCollection</code></span>
<span class="codeline" id="line-1649"><code></code></span>
<span class="codeline" id="line-1650"><code>	// Run gc on the g0 stack. We do this so that the g stack</code></span>
<span class="codeline" id="line-1651"><code>	// we're currently running on will no longer change. Cuts</code></span>
<span class="codeline" id="line-1652"><code>	// the root set down a bit (g0 stacks are not scanned, and</code></span>
<span class="codeline" id="line-1653"><code>	// we don't need to scan gc's internal state).  We also</code></span>
<span class="codeline" id="line-1654"><code>	// need to switch to g0 so we can shrink the stack.</code></span>
<span class="codeline" id="line-1655"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-1656"><code>		gcMark(startTime)</code></span>
<span class="codeline" id="line-1657"><code>		// Must return immediately.</code></span>
<span class="codeline" id="line-1658"><code>		// The outer function's stack may have moved</code></span>
<span class="codeline" id="line-1659"><code>		// during gcMark (it shrinks stacks, including the</code></span>
<span class="codeline" id="line-1660"><code>		// outer function's stack), so we must not refer</code></span>
<span class="codeline" id="line-1661"><code>		// to any of its variables. Return back to the</code></span>
<span class="codeline" id="line-1662"><code>		// non-system stack to pick up the new addresses</code></span>
<span class="codeline" id="line-1663"><code>		// before continuing.</code></span>
<span class="codeline" id="line-1664"><code>	})</code></span>
<span class="codeline" id="line-1665"><code></code></span>
<span class="codeline" id="line-1666"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-1667"><code>		work.heap2 = work.bytesMarked</code></span>
<span class="codeline" id="line-1668"><code>		if debug.gccheckmark &gt; 0 {</code></span>
<span class="codeline" id="line-1669"><code>			// Run a full non-parallel, stop-the-world</code></span>
<span class="codeline" id="line-1670"><code>			// mark using checkmark bits, to check that we</code></span>
<span class="codeline" id="line-1671"><code>			// didn't forget to mark anything during the</code></span>
<span class="codeline" id="line-1672"><code>			// concurrent mark process.</code></span>
<span class="codeline" id="line-1673"><code>			gcResetMarkState()</code></span>
<span class="codeline" id="line-1674"><code>			initCheckmarks()</code></span>
<span class="codeline" id="line-1675"><code>			gcw := &amp;getg().m.p.ptr().gcw</code></span>
<span class="codeline" id="line-1676"><code>			gcDrain(gcw, 0)</code></span>
<span class="codeline" id="line-1677"><code>			wbBufFlush1(getg().m.p.ptr())</code></span>
<span class="codeline" id="line-1678"><code>			gcw.dispose()</code></span>
<span class="codeline" id="line-1679"><code>			clearCheckmarks()</code></span>
<span class="codeline" id="line-1680"><code>		}</code></span>
<span class="codeline" id="line-1681"><code></code></span>
<span class="codeline" id="line-1682"><code>		// marking is complete so we can turn the write barrier off</code></span>
<span class="codeline" id="line-1683"><code>		setGCPhase(_GCoff)</code></span>
<span class="codeline" id="line-1684"><code>		gcSweep(work.mode)</code></span>
<span class="codeline" id="line-1685"><code>	})</code></span>
<span class="codeline" id="line-1686"><code></code></span>
<span class="codeline" id="line-1687"><code>	_g_.m.traceback = 0</code></span>
<span class="codeline" id="line-1688"><code>	casgstatus(gp, _Gwaiting, _Grunning)</code></span>
<span class="codeline" id="line-1689"><code></code></span>
<span class="codeline" id="line-1690"><code>	if trace.enabled {</code></span>
<span class="codeline" id="line-1691"><code>		traceGCDone()</code></span>
<span class="codeline" id="line-1692"><code>	}</code></span>
<span class="codeline" id="line-1693"><code></code></span>
<span class="codeline" id="line-1694"><code>	// all done</code></span>
<span class="codeline" id="line-1695"><code>	mp.preemptoff = ""</code></span>
<span class="codeline" id="line-1696"><code></code></span>
<span class="codeline" id="line-1697"><code>	if gcphase != _GCoff {</code></span>
<span class="codeline" id="line-1698"><code>		throw("gc done but gcphase != _GCoff")</code></span>
<span class="codeline" id="line-1699"><code>	}</code></span>
<span class="codeline" id="line-1700"><code></code></span>
<span class="codeline" id="line-1701"><code>	// Record next_gc and heap_inuse for scavenger.</code></span>
<span class="codeline" id="line-1702"><code>	memstats.last_next_gc = memstats.next_gc</code></span>
<span class="codeline" id="line-1703"><code>	memstats.last_heap_inuse = memstats.heap_inuse</code></span>
<span class="codeline" id="line-1704"><code></code></span>
<span class="codeline" id="line-1705"><code>	// Update GC trigger and pacing for the next cycle.</code></span>
<span class="codeline" id="line-1706"><code>	gcSetTriggerRatio(nextTriggerRatio)</code></span>
<span class="codeline" id="line-1707"><code></code></span>
<span class="codeline" id="line-1708"><code>	// Update timing memstats</code></span>
<span class="codeline" id="line-1709"><code>	now := nanotime()</code></span>
<span class="codeline" id="line-1710"><code>	sec, nsec, _ := time_now()</code></span>
<span class="codeline" id="line-1711"><code>	unixNow := sec*1e9 + int64(nsec)</code></span>
<span class="codeline" id="line-1712"><code>	work.pauseNS += now - work.pauseStart</code></span>
<span class="codeline" id="line-1713"><code>	work.tEnd = now</code></span>
<span class="codeline" id="line-1714"><code>	atomic.Store64(&amp;memstats.last_gc_unix, uint64(unixNow)) // must be Unix time to make sense to user</code></span>
<span class="codeline" id="line-1715"><code>	atomic.Store64(&amp;memstats.last_gc_nanotime, uint64(now)) // monotonic time for us</code></span>
<span class="codeline" id="line-1716"><code>	memstats.pause_ns[memstats.numgc%uint32(len(memstats.pause_ns))] = uint64(work.pauseNS)</code></span>
<span class="codeline" id="line-1717"><code>	memstats.pause_end[memstats.numgc%uint32(len(memstats.pause_end))] = uint64(unixNow)</code></span>
<span class="codeline" id="line-1718"><code>	memstats.pause_total_ns += uint64(work.pauseNS)</code></span>
<span class="codeline" id="line-1719"><code></code></span>
<span class="codeline" id="line-1720"><code>	// Update work.totaltime.</code></span>
<span class="codeline" id="line-1721"><code>	sweepTermCpu := int64(work.stwprocs) * (work.tMark - work.tSweepTerm)</code></span>
<span class="codeline" id="line-1722"><code>	// We report idle marking time below, but omit it from the</code></span>
<span class="codeline" id="line-1723"><code>	// overall utilization here since it's "free".</code></span>
<span class="codeline" id="line-1724"><code>	markCpu := gcController.assistTime + gcController.dedicatedMarkTime + gcController.fractionalMarkTime</code></span>
<span class="codeline" id="line-1725"><code>	markTermCpu := int64(work.stwprocs) * (work.tEnd - work.tMarkTerm)</code></span>
<span class="codeline" id="line-1726"><code>	cycleCpu := sweepTermCpu + markCpu + markTermCpu</code></span>
<span class="codeline" id="line-1727"><code>	work.totaltime += cycleCpu</code></span>
<span class="codeline" id="line-1728"><code></code></span>
<span class="codeline" id="line-1729"><code>	// Compute overall GC CPU utilization.</code></span>
<span class="codeline" id="line-1730"><code>	totalCpu := sched.totaltime + (now-sched.procresizetime)*int64(gomaxprocs)</code></span>
<span class="codeline" id="line-1731"><code>	memstats.gc_cpu_fraction = float64(work.totaltime) / float64(totalCpu)</code></span>
<span class="codeline" id="line-1732"><code></code></span>
<span class="codeline" id="line-1733"><code>	// Reset sweep state.</code></span>
<span class="codeline" id="line-1734"><code>	sweep.nbgsweep = 0</code></span>
<span class="codeline" id="line-1735"><code>	sweep.npausesweep = 0</code></span>
<span class="codeline" id="line-1736"><code></code></span>
<span class="codeline" id="line-1737"><code>	if work.userForced {</code></span>
<span class="codeline" id="line-1738"><code>		memstats.numforcedgc++</code></span>
<span class="codeline" id="line-1739"><code>	}</code></span>
<span class="codeline" id="line-1740"><code></code></span>
<span class="codeline" id="line-1741"><code>	// Bump GC cycle count and wake goroutines waiting on sweep.</code></span>
<span class="codeline" id="line-1742"><code>	lock(&amp;work.sweepWaiters.lock)</code></span>
<span class="codeline" id="line-1743"><code>	memstats.numgc++</code></span>
<span class="codeline" id="line-1744"><code>	injectglist(&amp;work.sweepWaiters.list)</code></span>
<span class="codeline" id="line-1745"><code>	unlock(&amp;work.sweepWaiters.lock)</code></span>
<span class="codeline" id="line-1746"><code></code></span>
<span class="codeline" id="line-1747"><code>	// Finish the current heap profiling cycle and start a new</code></span>
<span class="codeline" id="line-1748"><code>	// heap profiling cycle. We do this before starting the world</code></span>
<span class="codeline" id="line-1749"><code>	// so events don't leak into the wrong cycle.</code></span>
<span class="codeline" id="line-1750"><code>	mProf_NextCycle()</code></span>
<span class="codeline" id="line-1751"><code></code></span>
<span class="codeline" id="line-1752"><code>	systemstack(func() { startTheWorldWithSema(true) })</code></span>
<span class="codeline" id="line-1753"><code></code></span>
<span class="codeline" id="line-1754"><code>	// Flush the heap profile so we can start a new cycle next GC.</code></span>
<span class="codeline" id="line-1755"><code>	// This is relatively expensive, so we don't do it with the</code></span>
<span class="codeline" id="line-1756"><code>	// world stopped.</code></span>
<span class="codeline" id="line-1757"><code>	mProf_Flush()</code></span>
<span class="codeline" id="line-1758"><code></code></span>
<span class="codeline" id="line-1759"><code>	// Prepare workbufs for freeing by the sweeper. We do this</code></span>
<span class="codeline" id="line-1760"><code>	// asynchronously because it can take non-trivial time.</code></span>
<span class="codeline" id="line-1761"><code>	prepareFreeWorkbufs()</code></span>
<span class="codeline" id="line-1762"><code></code></span>
<span class="codeline" id="line-1763"><code>	// Free stack spans. This must be done between GC cycles.</code></span>
<span class="codeline" id="line-1764"><code>	systemstack(freeStackSpans)</code></span>
<span class="codeline" id="line-1765"><code></code></span>
<span class="codeline" id="line-1766"><code>	// Ensure all mcaches are flushed. Each P will flush its own</code></span>
<span class="codeline" id="line-1767"><code>	// mcache before allocating, but idle Ps may not. Since this</code></span>
<span class="codeline" id="line-1768"><code>	// is necessary to sweep all spans, we need to ensure all</code></span>
<span class="codeline" id="line-1769"><code>	// mcaches are flushed before we start the next GC cycle.</code></span>
<span class="codeline" id="line-1770"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-1771"><code>		forEachP(func(_p_ *p) {</code></span>
<span class="codeline" id="line-1772"><code>			_p_.mcache.prepareForSweep()</code></span>
<span class="codeline" id="line-1773"><code>		})</code></span>
<span class="codeline" id="line-1774"><code>	})</code></span>
<span class="codeline" id="line-1775"><code></code></span>
<span class="codeline" id="line-1776"><code>	// Print gctrace before dropping worldsema. As soon as we drop</code></span>
<span class="codeline" id="line-1777"><code>	// worldsema another cycle could start and smash the stats</code></span>
<span class="codeline" id="line-1778"><code>	// we're trying to print.</code></span>
<span class="codeline" id="line-1779"><code>	if debug.gctrace &gt; 0 {</code></span>
<span class="codeline" id="line-1780"><code>		util := int(memstats.gc_cpu_fraction * 100)</code></span>
<span class="codeline" id="line-1781"><code></code></span>
<span class="codeline" id="line-1782"><code>		var sbuf [24]byte</code></span>
<span class="codeline" id="line-1783"><code>		printlock()</code></span>
<span class="codeline" id="line-1784"><code>		print("gc ", memstats.numgc,</code></span>
<span class="codeline" id="line-1785"><code>			" @", string(itoaDiv(sbuf[:], uint64(work.tSweepTerm-runtimeInitTime)/1e6, 3)), "s ",</code></span>
<span class="codeline" id="line-1786"><code>			util, "%: ")</code></span>
<span class="codeline" id="line-1787"><code>		prev := work.tSweepTerm</code></span>
<span class="codeline" id="line-1788"><code>		for i, ns := range []int64{work.tMark, work.tMarkTerm, work.tEnd} {</code></span>
<span class="codeline" id="line-1789"><code>			if i != 0 {</code></span>
<span class="codeline" id="line-1790"><code>				print("+")</code></span>
<span class="codeline" id="line-1791"><code>			}</code></span>
<span class="codeline" id="line-1792"><code>			print(string(fmtNSAsMS(sbuf[:], uint64(ns-prev))))</code></span>
<span class="codeline" id="line-1793"><code>			prev = ns</code></span>
<span class="codeline" id="line-1794"><code>		}</code></span>
<span class="codeline" id="line-1795"><code>		print(" ms clock, ")</code></span>
<span class="codeline" id="line-1796"><code>		for i, ns := range []int64{sweepTermCpu, gcController.assistTime, gcController.dedicatedMarkTime + gcController.fractionalMarkTime, gcController.idleMarkTime, markTermCpu} {</code></span>
<span class="codeline" id="line-1797"><code>			if i == 2 || i == 3 {</code></span>
<span class="codeline" id="line-1798"><code>				// Separate mark time components with /.</code></span>
<span class="codeline" id="line-1799"><code>				print("/")</code></span>
<span class="codeline" id="line-1800"><code>			} else if i != 0 {</code></span>
<span class="codeline" id="line-1801"><code>				print("+")</code></span>
<span class="codeline" id="line-1802"><code>			}</code></span>
<span class="codeline" id="line-1803"><code>			print(string(fmtNSAsMS(sbuf[:], uint64(ns))))</code></span>
<span class="codeline" id="line-1804"><code>		}</code></span>
<span class="codeline" id="line-1805"><code>		print(" ms cpu, ",</code></span>
<span class="codeline" id="line-1806"><code>			work.heap0&gt;&gt;20, "-&gt;", work.heap1&gt;&gt;20, "-&gt;", work.heap2&gt;&gt;20, " MB, ",</code></span>
<span class="codeline" id="line-1807"><code>			work.heapGoal&gt;&gt;20, " MB goal, ",</code></span>
<span class="codeline" id="line-1808"><code>			work.maxprocs, " P")</code></span>
<span class="codeline" id="line-1809"><code>		if work.userForced {</code></span>
<span class="codeline" id="line-1810"><code>			print(" (forced)")</code></span>
<span class="codeline" id="line-1811"><code>		}</code></span>
<span class="codeline" id="line-1812"><code>		print("\n")</code></span>
<span class="codeline" id="line-1813"><code>		printunlock()</code></span>
<span class="codeline" id="line-1814"><code>	}</code></span>
<span class="codeline" id="line-1815"><code></code></span>
<span class="codeline" id="line-1816"><code>	semrelease(&amp;worldsema)</code></span>
<span class="codeline" id="line-1817"><code>	semrelease(&amp;gcsema)</code></span>
<span class="codeline" id="line-1818"><code>	// Careful: another GC cycle may start now.</code></span>
<span class="codeline" id="line-1819"><code></code></span>
<span class="codeline" id="line-1820"><code>	releasem(mp)</code></span>
<span class="codeline" id="line-1821"><code>	mp = nil</code></span>
<span class="codeline" id="line-1822"><code></code></span>
<span class="codeline" id="line-1823"><code>	// now that gc is done, kick off finalizer thread if needed</code></span>
<span class="codeline" id="line-1824"><code>	if !concurrentSweep {</code></span>
<span class="codeline" id="line-1825"><code>		// give the queued finalizers, if any, a chance to run</code></span>
<span class="codeline" id="line-1826"><code>		Gosched()</code></span>
<span class="codeline" id="line-1827"><code>	}</code></span>
<span class="codeline" id="line-1828"><code>}</code></span>
<span class="codeline" id="line-1829"><code></code></span>
<span class="codeline" id="line-1830"><code>// gcBgMarkStartWorkers prepares background mark worker goroutines.</code></span>
<span class="codeline" id="line-1831"><code>// These goroutines will not run until the mark phase, but they must</code></span>
<span class="codeline" id="line-1832"><code>// be started while the work is not stopped and from a regular G</code></span>
<span class="codeline" id="line-1833"><code>// stack. The caller must hold worldsema.</code></span>
<span class="codeline" id="line-1834"><code>func gcBgMarkStartWorkers() {</code></span>
<span class="codeline" id="line-1835"><code>	// Background marking is performed by per-P G's. Ensure that</code></span>
<span class="codeline" id="line-1836"><code>	// each P has a background GC G.</code></span>
<span class="codeline" id="line-1837"><code>	for _, p := range allp {</code></span>
<span class="codeline" id="line-1838"><code>		if p.gcBgMarkWorker == 0 {</code></span>
<span class="codeline" id="line-1839"><code>			go gcBgMarkWorker(p)</code></span>
<span class="codeline" id="line-1840"><code>			notetsleepg(&amp;work.bgMarkReady, -1)</code></span>
<span class="codeline" id="line-1841"><code>			noteclear(&amp;work.bgMarkReady)</code></span>
<span class="codeline" id="line-1842"><code>		}</code></span>
<span class="codeline" id="line-1843"><code>	}</code></span>
<span class="codeline" id="line-1844"><code>}</code></span>
<span class="codeline" id="line-1845"><code></code></span>
<span class="codeline" id="line-1846"><code>// gcBgMarkPrepare sets up state for background marking.</code></span>
<span class="codeline" id="line-1847"><code>// Mutator assists must not yet be enabled.</code></span>
<span class="codeline" id="line-1848"><code>func gcBgMarkPrepare() {</code></span>
<span class="codeline" id="line-1849"><code>	// Background marking will stop when the work queues are empty</code></span>
<span class="codeline" id="line-1850"><code>	// and there are no more workers (note that, since this is</code></span>
<span class="codeline" id="line-1851"><code>	// concurrent, this may be a transient state, but mark</code></span>
<span class="codeline" id="line-1852"><code>	// termination will clean it up). Between background workers</code></span>
<span class="codeline" id="line-1853"><code>	// and assists, we don't really know how many workers there</code></span>
<span class="codeline" id="line-1854"><code>	// will be, so we pretend to have an arbitrarily large number</code></span>
<span class="codeline" id="line-1855"><code>	// of workers, almost all of which are "waiting". While a</code></span>
<span class="codeline" id="line-1856"><code>	// worker is working it decrements nwait. If nproc == nwait,</code></span>
<span class="codeline" id="line-1857"><code>	// there are no workers.</code></span>
<span class="codeline" id="line-1858"><code>	work.nproc = ^uint32(0)</code></span>
<span class="codeline" id="line-1859"><code>	work.nwait = ^uint32(0)</code></span>
<span class="codeline" id="line-1860"><code>}</code></span>
<span class="codeline" id="line-1861"><code></code></span>
<span class="codeline" id="line-1862"><code>func gcBgMarkWorker(_p_ *p) {</code></span>
<span class="codeline" id="line-1863"><code>	gp := getg()</code></span>
<span class="codeline" id="line-1864"><code></code></span>
<span class="codeline" id="line-1865"><code>	type parkInfo struct {</code></span>
<span class="codeline" id="line-1866"><code>		m      muintptr // Release this m on park.</code></span>
<span class="codeline" id="line-1867"><code>		attach puintptr // If non-nil, attach to this p on park.</code></span>
<span class="codeline" id="line-1868"><code>	}</code></span>
<span class="codeline" id="line-1869"><code>	// We pass park to a gopark unlock function, so it can't be on</code></span>
<span class="codeline" id="line-1870"><code>	// the stack (see gopark). Prevent deadlock from recursively</code></span>
<span class="codeline" id="line-1871"><code>	// starting GC by disabling preemption.</code></span>
<span class="codeline" id="line-1872"><code>	gp.m.preemptoff = "GC worker init"</code></span>
<span class="codeline" id="line-1873"><code>	park := new(parkInfo)</code></span>
<span class="codeline" id="line-1874"><code>	gp.m.preemptoff = ""</code></span>
<span class="codeline" id="line-1875"><code></code></span>
<span class="codeline" id="line-1876"><code>	park.m.set(acquirem())</code></span>
<span class="codeline" id="line-1877"><code>	park.attach.set(_p_)</code></span>
<span class="codeline" id="line-1878"><code>	// Inform gcBgMarkStartWorkers that this worker is ready.</code></span>
<span class="codeline" id="line-1879"><code>	// After this point, the background mark worker is scheduled</code></span>
<span class="codeline" id="line-1880"><code>	// cooperatively by gcController.findRunnable. Hence, it must</code></span>
<span class="codeline" id="line-1881"><code>	// never be preempted, as this would put it into _Grunnable</code></span>
<span class="codeline" id="line-1882"><code>	// and put it on a run queue. Instead, when the preempt flag</code></span>
<span class="codeline" id="line-1883"><code>	// is set, this puts itself into _Gwaiting to be woken up by</code></span>
<span class="codeline" id="line-1884"><code>	// gcController.findRunnable at the appropriate time.</code></span>
<span class="codeline" id="line-1885"><code>	notewakeup(&amp;work.bgMarkReady)</code></span>
<span class="codeline" id="line-1886"><code></code></span>
<span class="codeline" id="line-1887"><code>	for {</code></span>
<span class="codeline" id="line-1888"><code>		// Go to sleep until woken by gcController.findRunnable.</code></span>
<span class="codeline" id="line-1889"><code>		// We can't releasem yet since even the call to gopark</code></span>
<span class="codeline" id="line-1890"><code>		// may be preempted.</code></span>
<span class="codeline" id="line-1891"><code>		gopark(func(g *g, parkp unsafe.Pointer) bool {</code></span>
<span class="codeline" id="line-1892"><code>			park := (*parkInfo)(parkp)</code></span>
<span class="codeline" id="line-1893"><code></code></span>
<span class="codeline" id="line-1894"><code>			// The worker G is no longer running, so it's</code></span>
<span class="codeline" id="line-1895"><code>			// now safe to allow preemption.</code></span>
<span class="codeline" id="line-1896"><code>			releasem(park.m.ptr())</code></span>
<span class="codeline" id="line-1897"><code></code></span>
<span class="codeline" id="line-1898"><code>			// If the worker isn't attached to its P,</code></span>
<span class="codeline" id="line-1899"><code>			// attach now. During initialization and after</code></span>
<span class="codeline" id="line-1900"><code>			// a phase change, the worker may have been</code></span>
<span class="codeline" id="line-1901"><code>			// running on a different P. As soon as we</code></span>
<span class="codeline" id="line-1902"><code>			// attach, the owner P may schedule the</code></span>
<span class="codeline" id="line-1903"><code>			// worker, so this must be done after the G is</code></span>
<span class="codeline" id="line-1904"><code>			// stopped.</code></span>
<span class="codeline" id="line-1905"><code>			if park.attach != 0 {</code></span>
<span class="codeline" id="line-1906"><code>				p := park.attach.ptr()</code></span>
<span class="codeline" id="line-1907"><code>				park.attach.set(nil)</code></span>
<span class="codeline" id="line-1908"><code>				// cas the worker because we may be</code></span>
<span class="codeline" id="line-1909"><code>				// racing with a new worker starting</code></span>
<span class="codeline" id="line-1910"><code>				// on this P.</code></span>
<span class="codeline" id="line-1911"><code>				if !p.gcBgMarkWorker.cas(0, guintptr(unsafe.Pointer(g))) {</code></span>
<span class="codeline" id="line-1912"><code>					// The P got a new worker.</code></span>
<span class="codeline" id="line-1913"><code>					// Exit this worker.</code></span>
<span class="codeline" id="line-1914"><code>					return false</code></span>
<span class="codeline" id="line-1915"><code>				}</code></span>
<span class="codeline" id="line-1916"><code>			}</code></span>
<span class="codeline" id="line-1917"><code>			return true</code></span>
<span class="codeline" id="line-1918"><code>		}, unsafe.Pointer(park), waitReasonGCWorkerIdle, traceEvGoBlock, 0)</code></span>
<span class="codeline" id="line-1919"><code></code></span>
<span class="codeline" id="line-1920"><code>		// Loop until the P dies and disassociates this</code></span>
<span class="codeline" id="line-1921"><code>		// worker (the P may later be reused, in which case</code></span>
<span class="codeline" id="line-1922"><code>		// it will get a new worker) or we failed to associate.</code></span>
<span class="codeline" id="line-1923"><code>		if _p_.gcBgMarkWorker.ptr() != gp {</code></span>
<span class="codeline" id="line-1924"><code>			break</code></span>
<span class="codeline" id="line-1925"><code>		}</code></span>
<span class="codeline" id="line-1926"><code></code></span>
<span class="codeline" id="line-1927"><code>		// Disable preemption so we can use the gcw. If the</code></span>
<span class="codeline" id="line-1928"><code>		// scheduler wants to preempt us, we'll stop draining,</code></span>
<span class="codeline" id="line-1929"><code>		// dispose the gcw, and then preempt.</code></span>
<span class="codeline" id="line-1930"><code>		park.m.set(acquirem())</code></span>
<span class="codeline" id="line-1931"><code></code></span>
<span class="codeline" id="line-1932"><code>		if gcBlackenEnabled == 0 {</code></span>
<span class="codeline" id="line-1933"><code>			throw("gcBgMarkWorker: blackening not enabled")</code></span>
<span class="codeline" id="line-1934"><code>		}</code></span>
<span class="codeline" id="line-1935"><code></code></span>
<span class="codeline" id="line-1936"><code>		startTime := nanotime()</code></span>
<span class="codeline" id="line-1937"><code>		_p_.gcMarkWorkerStartTime = startTime</code></span>
<span class="codeline" id="line-1938"><code></code></span>
<span class="codeline" id="line-1939"><code>		decnwait := atomic.Xadd(&amp;work.nwait, -1)</code></span>
<span class="codeline" id="line-1940"><code>		if decnwait == work.nproc {</code></span>
<span class="codeline" id="line-1941"><code>			println("runtime: work.nwait=", decnwait, "work.nproc=", work.nproc)</code></span>
<span class="codeline" id="line-1942"><code>			throw("work.nwait was &gt; work.nproc")</code></span>
<span class="codeline" id="line-1943"><code>		}</code></span>
<span class="codeline" id="line-1944"><code></code></span>
<span class="codeline" id="line-1945"><code>		systemstack(func() {</code></span>
<span class="codeline" id="line-1946"><code>			// Mark our goroutine preemptible so its stack</code></span>
<span class="codeline" id="line-1947"><code>			// can be scanned. This lets two mark workers</code></span>
<span class="codeline" id="line-1948"><code>			// scan each other (otherwise, they would</code></span>
<span class="codeline" id="line-1949"><code>			// deadlock). We must not modify anything on</code></span>
<span class="codeline" id="line-1950"><code>			// the G stack. However, stack shrinking is</code></span>
<span class="codeline" id="line-1951"><code>			// disabled for mark workers, so it is safe to</code></span>
<span class="codeline" id="line-1952"><code>			// read from the G stack.</code></span>
<span class="codeline" id="line-1953"><code>			casgstatus(gp, _Grunning, _Gwaiting)</code></span>
<span class="codeline" id="line-1954"><code>			switch _p_.gcMarkWorkerMode {</code></span>
<span class="codeline" id="line-1955"><code>			default:</code></span>
<span class="codeline" id="line-1956"><code>				throw("gcBgMarkWorker: unexpected gcMarkWorkerMode")</code></span>
<span class="codeline" id="line-1957"><code>			case gcMarkWorkerDedicatedMode:</code></span>
<span class="codeline" id="line-1958"><code>				gcDrain(&amp;_p_.gcw, gcDrainUntilPreempt|gcDrainFlushBgCredit)</code></span>
<span class="codeline" id="line-1959"><code>				if gp.preempt {</code></span>
<span class="codeline" id="line-1960"><code>					// We were preempted. This is</code></span>
<span class="codeline" id="line-1961"><code>					// a useful signal to kick</code></span>
<span class="codeline" id="line-1962"><code>					// everything out of the run</code></span>
<span class="codeline" id="line-1963"><code>					// queue so it can run</code></span>
<span class="codeline" id="line-1964"><code>					// somewhere else.</code></span>
<span class="codeline" id="line-1965"><code>					lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1966"><code>					for {</code></span>
<span class="codeline" id="line-1967"><code>						gp, _ := runqget(_p_)</code></span>
<span class="codeline" id="line-1968"><code>						if gp == nil {</code></span>
<span class="codeline" id="line-1969"><code>							break</code></span>
<span class="codeline" id="line-1970"><code>						}</code></span>
<span class="codeline" id="line-1971"><code>						globrunqput(gp)</code></span>
<span class="codeline" id="line-1972"><code>					}</code></span>
<span class="codeline" id="line-1973"><code>					unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1974"><code>				}</code></span>
<span class="codeline" id="line-1975"><code>				// Go back to draining, this time</code></span>
<span class="codeline" id="line-1976"><code>				// without preemption.</code></span>
<span class="codeline" id="line-1977"><code>				gcDrain(&amp;_p_.gcw, gcDrainFlushBgCredit)</code></span>
<span class="codeline" id="line-1978"><code>			case gcMarkWorkerFractionalMode:</code></span>
<span class="codeline" id="line-1979"><code>				gcDrain(&amp;_p_.gcw, gcDrainFractional|gcDrainUntilPreempt|gcDrainFlushBgCredit)</code></span>
<span class="codeline" id="line-1980"><code>			case gcMarkWorkerIdleMode:</code></span>
<span class="codeline" id="line-1981"><code>				gcDrain(&amp;_p_.gcw, gcDrainIdle|gcDrainUntilPreempt|gcDrainFlushBgCredit)</code></span>
<span class="codeline" id="line-1982"><code>			}</code></span>
<span class="codeline" id="line-1983"><code>			casgstatus(gp, _Gwaiting, _Grunning)</code></span>
<span class="codeline" id="line-1984"><code>		})</code></span>
<span class="codeline" id="line-1985"><code></code></span>
<span class="codeline" id="line-1986"><code>		// Account for time.</code></span>
<span class="codeline" id="line-1987"><code>		duration := nanotime() - startTime</code></span>
<span class="codeline" id="line-1988"><code>		switch _p_.gcMarkWorkerMode {</code></span>
<span class="codeline" id="line-1989"><code>		case gcMarkWorkerDedicatedMode:</code></span>
<span class="codeline" id="line-1990"><code>			atomic.Xaddint64(&amp;gcController.dedicatedMarkTime, duration)</code></span>
<span class="codeline" id="line-1991"><code>			atomic.Xaddint64(&amp;gcController.dedicatedMarkWorkersNeeded, 1)</code></span>
<span class="codeline" id="line-1992"><code>		case gcMarkWorkerFractionalMode:</code></span>
<span class="codeline" id="line-1993"><code>			atomic.Xaddint64(&amp;gcController.fractionalMarkTime, duration)</code></span>
<span class="codeline" id="line-1994"><code>			atomic.Xaddint64(&amp;_p_.gcFractionalMarkTime, duration)</code></span>
<span class="codeline" id="line-1995"><code>		case gcMarkWorkerIdleMode:</code></span>
<span class="codeline" id="line-1996"><code>			atomic.Xaddint64(&amp;gcController.idleMarkTime, duration)</code></span>
<span class="codeline" id="line-1997"><code>		}</code></span>
<span class="codeline" id="line-1998"><code></code></span>
<span class="codeline" id="line-1999"><code>		// Was this the last worker and did we run out</code></span>
<span class="codeline" id="line-2000"><code>		// of work?</code></span>
<span class="codeline" id="line-2001"><code>		incnwait := atomic.Xadd(&amp;work.nwait, +1)</code></span>
<span class="codeline" id="line-2002"><code>		if incnwait &gt; work.nproc {</code></span>
<span class="codeline" id="line-2003"><code>			println("runtime: p.gcMarkWorkerMode=", _p_.gcMarkWorkerMode,</code></span>
<span class="codeline" id="line-2004"><code>				"work.nwait=", incnwait, "work.nproc=", work.nproc)</code></span>
<span class="codeline" id="line-2005"><code>			throw("work.nwait &gt; work.nproc")</code></span>
<span class="codeline" id="line-2006"><code>		}</code></span>
<span class="codeline" id="line-2007"><code></code></span>
<span class="codeline" id="line-2008"><code>		// If this worker reached a background mark completion</code></span>
<span class="codeline" id="line-2009"><code>		// point, signal the main GC goroutine.</code></span>
<span class="codeline" id="line-2010"><code>		if incnwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(nil) {</code></span>
<span class="codeline" id="line-2011"><code>			// Make this G preemptible and disassociate it</code></span>
<span class="codeline" id="line-2012"><code>			// as the worker for this P so</code></span>
<span class="codeline" id="line-2013"><code>			// findRunnableGCWorker doesn't try to</code></span>
<span class="codeline" id="line-2014"><code>			// schedule it.</code></span>
<span class="codeline" id="line-2015"><code>			_p_.gcBgMarkWorker.set(nil)</code></span>
<span class="codeline" id="line-2016"><code>			releasem(park.m.ptr())</code></span>
<span class="codeline" id="line-2017"><code></code></span>
<span class="codeline" id="line-2018"><code>			gcMarkDone()</code></span>
<span class="codeline" id="line-2019"><code></code></span>
<span class="codeline" id="line-2020"><code>			// Disable preemption and prepare to reattach</code></span>
<span class="codeline" id="line-2021"><code>			// to the P.</code></span>
<span class="codeline" id="line-2022"><code>			//</code></span>
<span class="codeline" id="line-2023"><code>			// We may be running on a different P at this</code></span>
<span class="codeline" id="line-2024"><code>			// point, so we can't reattach until this G is</code></span>
<span class="codeline" id="line-2025"><code>			// parked.</code></span>
<span class="codeline" id="line-2026"><code>			park.m.set(acquirem())</code></span>
<span class="codeline" id="line-2027"><code>			park.attach.set(_p_)</code></span>
<span class="codeline" id="line-2028"><code>		}</code></span>
<span class="codeline" id="line-2029"><code>	}</code></span>
<span class="codeline" id="line-2030"><code>}</code></span>
<span class="codeline" id="line-2031"><code></code></span>
<span class="codeline" id="line-2032"><code>// gcMarkWorkAvailable reports whether executing a mark worker</code></span>
<span class="codeline" id="line-2033"><code>// on p is potentially useful. p may be nil, in which case it only</code></span>
<span class="codeline" id="line-2034"><code>// checks the global sources of work.</code></span>
<span class="codeline" id="line-2035"><code>func gcMarkWorkAvailable(p *p) bool {</code></span>
<span class="codeline" id="line-2036"><code>	if p != nil &amp;&amp; !p.gcw.empty() {</code></span>
<span class="codeline" id="line-2037"><code>		return true</code></span>
<span class="codeline" id="line-2038"><code>	}</code></span>
<span class="codeline" id="line-2039"><code>	if !work.full.empty() {</code></span>
<span class="codeline" id="line-2040"><code>		return true // global work available</code></span>
<span class="codeline" id="line-2041"><code>	}</code></span>
<span class="codeline" id="line-2042"><code>	if work.markrootNext &lt; work.markrootJobs {</code></span>
<span class="codeline" id="line-2043"><code>		return true // root scan work available</code></span>
<span class="codeline" id="line-2044"><code>	}</code></span>
<span class="codeline" id="line-2045"><code>	return false</code></span>
<span class="codeline" id="line-2046"><code>}</code></span>
<span class="codeline" id="line-2047"><code></code></span>
<span class="codeline" id="line-2048"><code>// gcMark runs the mark (or, for concurrent GC, mark termination)</code></span>
<span class="codeline" id="line-2049"><code>// All gcWork caches must be empty.</code></span>
<span class="codeline" id="line-2050"><code>// STW is in effect at this point.</code></span>
<span class="codeline" id="line-2051"><code>func gcMark(start_time int64) {</code></span>
<span class="codeline" id="line-2052"><code>	if debug.allocfreetrace &gt; 0 {</code></span>
<span class="codeline" id="line-2053"><code>		tracegc()</code></span>
<span class="codeline" id="line-2054"><code>	}</code></span>
<span class="codeline" id="line-2055"><code></code></span>
<span class="codeline" id="line-2056"><code>	if gcphase != _GCmarktermination {</code></span>
<span class="codeline" id="line-2057"><code>		throw("in gcMark expecting to see gcphase as _GCmarktermination")</code></span>
<span class="codeline" id="line-2058"><code>	}</code></span>
<span class="codeline" id="line-2059"><code>	work.tstart = start_time</code></span>
<span class="codeline" id="line-2060"><code></code></span>
<span class="codeline" id="line-2061"><code>	// Check that there's no marking work remaining.</code></span>
<span class="codeline" id="line-2062"><code>	if work.full != 0 || work.markrootNext &lt; work.markrootJobs {</code></span>
<span class="codeline" id="line-2063"><code>		print("runtime: full=", hex(work.full), " next=", work.markrootNext, " jobs=", work.markrootJobs, " nDataRoots=", work.nDataRoots, " nBSSRoots=", work.nBSSRoots, " nSpanRoots=", work.nSpanRoots, " nStackRoots=", work.nStackRoots, "\n")</code></span>
<span class="codeline" id="line-2064"><code>		panic("non-empty mark queue after concurrent mark")</code></span>
<span class="codeline" id="line-2065"><code>	}</code></span>
<span class="codeline" id="line-2066"><code></code></span>
<span class="codeline" id="line-2067"><code>	if debug.gccheckmark &gt; 0 {</code></span>
<span class="codeline" id="line-2068"><code>		// This is expensive when there's a large number of</code></span>
<span class="codeline" id="line-2069"><code>		// Gs, so only do it if checkmark is also enabled.</code></span>
<span class="codeline" id="line-2070"><code>		gcMarkRootCheck()</code></span>
<span class="codeline" id="line-2071"><code>	}</code></span>
<span class="codeline" id="line-2072"><code>	if work.full != 0 {</code></span>
<span class="codeline" id="line-2073"><code>		throw("work.full != 0")</code></span>
<span class="codeline" id="line-2074"><code>	}</code></span>
<span class="codeline" id="line-2075"><code></code></span>
<span class="codeline" id="line-2076"><code>	// Clear out buffers and double-check that all gcWork caches</code></span>
<span class="codeline" id="line-2077"><code>	// are empty. This should be ensured by gcMarkDone before we</code></span>
<span class="codeline" id="line-2078"><code>	// enter mark termination.</code></span>
<span class="codeline" id="line-2079"><code>	//</code></span>
<span class="codeline" id="line-2080"><code>	// TODO: We could clear out buffers just before mark if this</code></span>
<span class="codeline" id="line-2081"><code>	// has a non-negligible impact on STW time.</code></span>
<span class="codeline" id="line-2082"><code>	for _, p := range allp {</code></span>
<span class="codeline" id="line-2083"><code>		// The write barrier may have buffered pointers since</code></span>
<span class="codeline" id="line-2084"><code>		// the gcMarkDone barrier. However, since the barrier</code></span>
<span class="codeline" id="line-2085"><code>		// ensured all reachable objects were marked, all of</code></span>
<span class="codeline" id="line-2086"><code>		// these must be pointers to black objects. Hence we</code></span>
<span class="codeline" id="line-2087"><code>		// can just discard the write barrier buffer.</code></span>
<span class="codeline" id="line-2088"><code>		if debug.gccheckmark &gt; 0 || throwOnGCWork {</code></span>
<span class="codeline" id="line-2089"><code>			// For debugging, flush the buffer and make</code></span>
<span class="codeline" id="line-2090"><code>			// sure it really was all marked.</code></span>
<span class="codeline" id="line-2091"><code>			wbBufFlush1(p)</code></span>
<span class="codeline" id="line-2092"><code>		} else {</code></span>
<span class="codeline" id="line-2093"><code>			p.wbBuf.reset()</code></span>
<span class="codeline" id="line-2094"><code>		}</code></span>
<span class="codeline" id="line-2095"><code></code></span>
<span class="codeline" id="line-2096"><code>		gcw := &amp;p.gcw</code></span>
<span class="codeline" id="line-2097"><code>		if !gcw.empty() {</code></span>
<span class="codeline" id="line-2098"><code>			printlock()</code></span>
<span class="codeline" id="line-2099"><code>			print("runtime: P ", p.id, " flushedWork ", gcw.flushedWork)</code></span>
<span class="codeline" id="line-2100"><code>			if gcw.wbuf1 == nil {</code></span>
<span class="codeline" id="line-2101"><code>				print(" wbuf1=&lt;nil&gt;")</code></span>
<span class="codeline" id="line-2102"><code>			} else {</code></span>
<span class="codeline" id="line-2103"><code>				print(" wbuf1.n=", gcw.wbuf1.nobj)</code></span>
<span class="codeline" id="line-2104"><code>			}</code></span>
<span class="codeline" id="line-2105"><code>			if gcw.wbuf2 == nil {</code></span>
<span class="codeline" id="line-2106"><code>				print(" wbuf2=&lt;nil&gt;")</code></span>
<span class="codeline" id="line-2107"><code>			} else {</code></span>
<span class="codeline" id="line-2108"><code>				print(" wbuf2.n=", gcw.wbuf2.nobj)</code></span>
<span class="codeline" id="line-2109"><code>			}</code></span>
<span class="codeline" id="line-2110"><code>			print("\n")</code></span>
<span class="codeline" id="line-2111"><code>			throw("P has cached GC work at end of mark termination")</code></span>
<span class="codeline" id="line-2112"><code>		}</code></span>
<span class="codeline" id="line-2113"><code>		// There may still be cached empty buffers, which we</code></span>
<span class="codeline" id="line-2114"><code>		// need to flush since we're going to free them. Also,</code></span>
<span class="codeline" id="line-2115"><code>		// there may be non-zero stats because we allocated</code></span>
<span class="codeline" id="line-2116"><code>		// black after the gcMarkDone barrier.</code></span>
<span class="codeline" id="line-2117"><code>		gcw.dispose()</code></span>
<span class="codeline" id="line-2118"><code>	}</code></span>
<span class="codeline" id="line-2119"><code></code></span>
<span class="codeline" id="line-2120"><code>	throwOnGCWork = false</code></span>
<span class="codeline" id="line-2121"><code></code></span>
<span class="codeline" id="line-2122"><code>	cachestats()</code></span>
<span class="codeline" id="line-2123"><code></code></span>
<span class="codeline" id="line-2124"><code>	// Update the marked heap stat.</code></span>
<span class="codeline" id="line-2125"><code>	memstats.heap_marked = work.bytesMarked</code></span>
<span class="codeline" id="line-2126"><code></code></span>
<span class="codeline" id="line-2127"><code>	// Update other GC heap size stats. This must happen after</code></span>
<span class="codeline" id="line-2128"><code>	// cachestats (which flushes local statistics to these) and</code></span>
<span class="codeline" id="line-2129"><code>	// flushallmcaches (which modifies heap_live).</code></span>
<span class="codeline" id="line-2130"><code>	memstats.heap_live = work.bytesMarked</code></span>
<span class="codeline" id="line-2131"><code>	memstats.heap_scan = uint64(gcController.scanWork)</code></span>
<span class="codeline" id="line-2132"><code></code></span>
<span class="codeline" id="line-2133"><code>	if trace.enabled {</code></span>
<span class="codeline" id="line-2134"><code>		traceHeapAlloc()</code></span>
<span class="codeline" id="line-2135"><code>	}</code></span>
<span class="codeline" id="line-2136"><code>}</code></span>
<span class="codeline" id="line-2137"><code></code></span>
<span class="codeline" id="line-2138"><code>// gcSweep must be called on the system stack because it acquires the heap</code></span>
<span class="codeline" id="line-2139"><code>// lock. See mheap for details.</code></span>
<span class="codeline" id="line-2140"><code>//</code></span>
<span class="codeline" id="line-2141"><code>// The world must be stopped.</code></span>
<span class="codeline" id="line-2142"><code>//</code></span>
<span class="codeline" id="line-2143"><code>//go:systemstack</code></span>
<span class="codeline" id="line-2144"><code>func gcSweep(mode gcMode) {</code></span>
<span class="codeline" id="line-2145"><code>	if gcphase != _GCoff {</code></span>
<span class="codeline" id="line-2146"><code>		throw("gcSweep being done but phase is not GCoff")</code></span>
<span class="codeline" id="line-2147"><code>	}</code></span>
<span class="codeline" id="line-2148"><code></code></span>
<span class="codeline" id="line-2149"><code>	lock(&amp;mheap_.lock)</code></span>
<span class="codeline" id="line-2150"><code>	mheap_.sweepgen += 2</code></span>
<span class="codeline" id="line-2151"><code>	mheap_.sweepdone = 0</code></span>
<span class="codeline" id="line-2152"><code>	if !go115NewMCentralImpl &amp;&amp; mheap_.sweepSpans[mheap_.sweepgen/2%2].index != 0 {</code></span>
<span class="codeline" id="line-2153"><code>		// We should have drained this list during the last</code></span>
<span class="codeline" id="line-2154"><code>		// sweep phase. We certainly need to start this phase</code></span>
<span class="codeline" id="line-2155"><code>		// with an empty swept list.</code></span>
<span class="codeline" id="line-2156"><code>		throw("non-empty swept list")</code></span>
<span class="codeline" id="line-2157"><code>	}</code></span>
<span class="codeline" id="line-2158"><code>	mheap_.pagesSwept = 0</code></span>
<span class="codeline" id="line-2159"><code>	mheap_.sweepArenas = mheap_.allArenas</code></span>
<span class="codeline" id="line-2160"><code>	mheap_.reclaimIndex = 0</code></span>
<span class="codeline" id="line-2161"><code>	mheap_.reclaimCredit = 0</code></span>
<span class="codeline" id="line-2162"><code>	unlock(&amp;mheap_.lock)</code></span>
<span class="codeline" id="line-2163"><code></code></span>
<span class="codeline" id="line-2164"><code>	if go115NewMCentralImpl {</code></span>
<span class="codeline" id="line-2165"><code>		sweep.centralIndex.clear()</code></span>
<span class="codeline" id="line-2166"><code>	}</code></span>
<span class="codeline" id="line-2167"><code></code></span>
<span class="codeline" id="line-2168"><code>	if !_ConcurrentSweep || mode == gcForceBlockMode {</code></span>
<span class="codeline" id="line-2169"><code>		// Special case synchronous sweep.</code></span>
<span class="codeline" id="line-2170"><code>		// Record that no proportional sweeping has to happen.</code></span>
<span class="codeline" id="line-2171"><code>		lock(&amp;mheap_.lock)</code></span>
<span class="codeline" id="line-2172"><code>		mheap_.sweepPagesPerByte = 0</code></span>
<span class="codeline" id="line-2173"><code>		unlock(&amp;mheap_.lock)</code></span>
<span class="codeline" id="line-2174"><code>		// Sweep all spans eagerly.</code></span>
<span class="codeline" id="line-2175"><code>		for sweepone() != ^uintptr(0) {</code></span>
<span class="codeline" id="line-2176"><code>			sweep.npausesweep++</code></span>
<span class="codeline" id="line-2177"><code>		}</code></span>
<span class="codeline" id="line-2178"><code>		// Free workbufs eagerly.</code></span>
<span class="codeline" id="line-2179"><code>		prepareFreeWorkbufs()</code></span>
<span class="codeline" id="line-2180"><code>		for freeSomeWbufs(false) {</code></span>
<span class="codeline" id="line-2181"><code>		}</code></span>
<span class="codeline" id="line-2182"><code>		// All "free" events for this mark/sweep cycle have</code></span>
<span class="codeline" id="line-2183"><code>		// now happened, so we can make this profile cycle</code></span>
<span class="codeline" id="line-2184"><code>		// available immediately.</code></span>
<span class="codeline" id="line-2185"><code>		mProf_NextCycle()</code></span>
<span class="codeline" id="line-2186"><code>		mProf_Flush()</code></span>
<span class="codeline" id="line-2187"><code>		return</code></span>
<span class="codeline" id="line-2188"><code>	}</code></span>
<span class="codeline" id="line-2189"><code></code></span>
<span class="codeline" id="line-2190"><code>	// Background sweep.</code></span>
<span class="codeline" id="line-2191"><code>	lock(&amp;sweep.lock)</code></span>
<span class="codeline" id="line-2192"><code>	if sweep.parked {</code></span>
<span class="codeline" id="line-2193"><code>		sweep.parked = false</code></span>
<span class="codeline" id="line-2194"><code>		ready(sweep.g, 0, true)</code></span>
<span class="codeline" id="line-2195"><code>	}</code></span>
<span class="codeline" id="line-2196"><code>	unlock(&amp;sweep.lock)</code></span>
<span class="codeline" id="line-2197"><code>}</code></span>
<span class="codeline" id="line-2198"><code></code></span>
<span class="codeline" id="line-2199"><code>// gcResetMarkState resets global state prior to marking (concurrent</code></span>
<span class="codeline" id="line-2200"><code>// or STW) and resets the stack scan state of all Gs.</code></span>
<span class="codeline" id="line-2201"><code>//</code></span>
<span class="codeline" id="line-2202"><code>// This is safe to do without the world stopped because any Gs created</code></span>
<span class="codeline" id="line-2203"><code>// during or after this will start out in the reset state.</code></span>
<span class="codeline" id="line-2204"><code>//</code></span>
<span class="codeline" id="line-2205"><code>// gcResetMarkState must be called on the system stack because it acquires</code></span>
<span class="codeline" id="line-2206"><code>// the heap lock. See mheap for details.</code></span>
<span class="codeline" id="line-2207"><code>//</code></span>
<span class="codeline" id="line-2208"><code>//go:systemstack</code></span>
<span class="codeline" id="line-2209"><code>func gcResetMarkState() {</code></span>
<span class="codeline" id="line-2210"><code>	// This may be called during a concurrent phase, so make sure</code></span>
<span class="codeline" id="line-2211"><code>	// allgs doesn't change.</code></span>
<span class="codeline" id="line-2212"><code>	lock(&amp;allglock)</code></span>
<span class="codeline" id="line-2213"><code>	for _, gp := range allgs {</code></span>
<span class="codeline" id="line-2214"><code>		gp.gcscandone = false // set to true in gcphasework</code></span>
<span class="codeline" id="line-2215"><code>		gp.gcAssistBytes = 0</code></span>
<span class="codeline" id="line-2216"><code>	}</code></span>
<span class="codeline" id="line-2217"><code>	unlock(&amp;allglock)</code></span>
<span class="codeline" id="line-2218"><code></code></span>
<span class="codeline" id="line-2219"><code>	// Clear page marks. This is just 1MB per 64GB of heap, so the</code></span>
<span class="codeline" id="line-2220"><code>	// time here is pretty trivial.</code></span>
<span class="codeline" id="line-2221"><code>	lock(&amp;mheap_.lock)</code></span>
<span class="codeline" id="line-2222"><code>	arenas := mheap_.allArenas</code></span>
<span class="codeline" id="line-2223"><code>	unlock(&amp;mheap_.lock)</code></span>
<span class="codeline" id="line-2224"><code>	for _, ai := range arenas {</code></span>
<span class="codeline" id="line-2225"><code>		ha := mheap_.arenas[ai.l1()][ai.l2()]</code></span>
<span class="codeline" id="line-2226"><code>		for i := range ha.pageMarks {</code></span>
<span class="codeline" id="line-2227"><code>			ha.pageMarks[i] = 0</code></span>
<span class="codeline" id="line-2228"><code>		}</code></span>
<span class="codeline" id="line-2229"><code>	}</code></span>
<span class="codeline" id="line-2230"><code></code></span>
<span class="codeline" id="line-2231"><code>	work.bytesMarked = 0</code></span>
<span class="codeline" id="line-2232"><code>	work.initialHeapLive = atomic.Load64(&amp;memstats.heap_live)</code></span>
<span class="codeline" id="line-2233"><code>}</code></span>
<span class="codeline" id="line-2234"><code></code></span>
<span class="codeline" id="line-2235"><code>// Hooks for other packages</code></span>
<span class="codeline" id="line-2236"><code></code></span>
<span class="codeline" id="line-2237"><code>var poolcleanup func()</code></span>
<span class="codeline" id="line-2238"><code></code></span>
<span class="codeline" id="line-2239"><code>//go:linkname sync_runtime_registerPoolCleanup sync.runtime_registerPoolCleanup</code></span>
<span class="codeline" id="line-2240"><code>func sync_runtime_registerPoolCleanup(f func()) {</code></span>
<span class="codeline" id="line-2241"><code>	poolcleanup = f</code></span>
<span class="codeline" id="line-2242"><code>}</code></span>
<span class="codeline" id="line-2243"><code></code></span>
<span class="codeline" id="line-2244"><code>func clearpools() {</code></span>
<span class="codeline" id="line-2245"><code>	// clear sync.Pools</code></span>
<span class="codeline" id="line-2246"><code>	if poolcleanup != nil {</code></span>
<span class="codeline" id="line-2247"><code>		poolcleanup()</code></span>
<span class="codeline" id="line-2248"><code>	}</code></span>
<span class="codeline" id="line-2249"><code></code></span>
<span class="codeline" id="line-2250"><code>	// Clear central sudog cache.</code></span>
<span class="codeline" id="line-2251"><code>	// Leave per-P caches alone, they have strictly bounded size.</code></span>
<span class="codeline" id="line-2252"><code>	// Disconnect cached list before dropping it on the floor,</code></span>
<span class="codeline" id="line-2253"><code>	// so that a dangling ref to one entry does not pin all of them.</code></span>
<span class="codeline" id="line-2254"><code>	lock(&amp;sched.sudoglock)</code></span>
<span class="codeline" id="line-2255"><code>	var sg, sgnext *sudog</code></span>
<span class="codeline" id="line-2256"><code>	for sg = sched.sudogcache; sg != nil; sg = sgnext {</code></span>
<span class="codeline" id="line-2257"><code>		sgnext = sg.next</code></span>
<span class="codeline" id="line-2258"><code>		sg.next = nil</code></span>
<span class="codeline" id="line-2259"><code>	}</code></span>
<span class="codeline" id="line-2260"><code>	sched.sudogcache = nil</code></span>
<span class="codeline" id="line-2261"><code>	unlock(&amp;sched.sudoglock)</code></span>
<span class="codeline" id="line-2262"><code></code></span>
<span class="codeline" id="line-2263"><code>	// Clear central defer pools.</code></span>
<span class="codeline" id="line-2264"><code>	// Leave per-P pools alone, they have strictly bounded size.</code></span>
<span class="codeline" id="line-2265"><code>	lock(&amp;sched.deferlock)</code></span>
<span class="codeline" id="line-2266"><code>	for i := range sched.deferpool {</code></span>
<span class="codeline" id="line-2267"><code>		// disconnect cached list before dropping it on the floor,</code></span>
<span class="codeline" id="line-2268"><code>		// so that a dangling ref to one entry does not pin all of them.</code></span>
<span class="codeline" id="line-2269"><code>		var d, dlink *_defer</code></span>
<span class="codeline" id="line-2270"><code>		for d = sched.deferpool[i]; d != nil; d = dlink {</code></span>
<span class="codeline" id="line-2271"><code>			dlink = d.link</code></span>
<span class="codeline" id="line-2272"><code>			d.link = nil</code></span>
<span class="codeline" id="line-2273"><code>		}</code></span>
<span class="codeline" id="line-2274"><code>		sched.deferpool[i] = nil</code></span>
<span class="codeline" id="line-2275"><code>	}</code></span>
<span class="codeline" id="line-2276"><code>	unlock(&amp;sched.deferlock)</code></span>
<span class="codeline" id="line-2277"><code>}</code></span>
<span class="codeline" id="line-2278"><code></code></span>
<span class="codeline" id="line-2279"><code>// Timing</code></span>
<span class="codeline" id="line-2280"><code></code></span>
<span class="codeline" id="line-2281"><code>// itoaDiv formats val/(10**dec) into buf.</code></span>
<span class="codeline" id="line-2282"><code>func itoaDiv(buf []byte, val uint64, dec int) []byte {</code></span>
<span class="codeline" id="line-2283"><code>	i := len(buf) - 1</code></span>
<span class="codeline" id="line-2284"><code>	idec := i - dec</code></span>
<span class="codeline" id="line-2285"><code>	for val &gt;= 10 || i &gt;= idec {</code></span>
<span class="codeline" id="line-2286"><code>		buf[i] = byte(val%10 + '0')</code></span>
<span class="codeline" id="line-2287"><code>		i--</code></span>
<span class="codeline" id="line-2288"><code>		if i == idec {</code></span>
<span class="codeline" id="line-2289"><code>			buf[i] = '.'</code></span>
<span class="codeline" id="line-2290"><code>			i--</code></span>
<span class="codeline" id="line-2291"><code>		}</code></span>
<span class="codeline" id="line-2292"><code>		val /= 10</code></span>
<span class="codeline" id="line-2293"><code>	}</code></span>
<span class="codeline" id="line-2294"><code>	buf[i] = byte(val + '0')</code></span>
<span class="codeline" id="line-2295"><code>	return buf[i:]</code></span>
<span class="codeline" id="line-2296"><code>}</code></span>
<span class="codeline" id="line-2297"><code></code></span>
<span class="codeline" id="line-2298"><code>// fmtNSAsMS nicely formats ns nanoseconds as milliseconds.</code></span>
<span class="codeline" id="line-2299"><code>func fmtNSAsMS(buf []byte, ns uint64) []byte {</code></span>
<span class="codeline" id="line-2300"><code>	if ns &gt;= 10e6 {</code></span>
<span class="codeline" id="line-2301"><code>		// Format as whole milliseconds.</code></span>
<span class="codeline" id="line-2302"><code>		return itoaDiv(buf, ns/1e6, 0)</code></span>
<span class="codeline" id="line-2303"><code>	}</code></span>
<span class="codeline" id="line-2304"><code>	// Format two digits of precision, with at most three decimal places.</code></span>
<span class="codeline" id="line-2305"><code>	x := ns / 1e3</code></span>
<span class="codeline" id="line-2306"><code>	if x == 0 {</code></span>
<span class="codeline" id="line-2307"><code>		buf[0] = '0'</code></span>
<span class="codeline" id="line-2308"><code>		return buf[:1]</code></span>
<span class="codeline" id="line-2309"><code>	}</code></span>
<span class="codeline" id="line-2310"><code>	dec := 3</code></span>
<span class="codeline" id="line-2311"><code>	for x &gt;= 100 {</code></span>
<span class="codeline" id="line-2312"><code>		x /= 10</code></span>
<span class="codeline" id="line-2313"><code>		dec--</code></span>
<span class="codeline" id="line-2314"><code>	}</code></span>
<span class="codeline" id="line-2315"><code>	return itoaDiv(buf, x, dec)</code></span>
<span class="codeline" id="line-2316"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.1.6</i>. (GOOS=darwin GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project and developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table
</pre>
</div></body></html>