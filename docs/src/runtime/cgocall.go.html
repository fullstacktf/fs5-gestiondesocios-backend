<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: cgocall.go in package runtime</title>
<link href="../../css/light-v0.1.6.css" rel="stylesheet">
<script src="../../jvs/golds-v0.1.6.js"></script>
<body><div>

<pre id="header"><code><span class="title">Source File</span>
	cgocall.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/runtime.html">runtime</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>// Cgo call and callback support.</code></span>
<span class="codeline" id="line-6"><code>//</code></span>
<span class="codeline" id="line-7"><code>// To call into the C function f from Go, the cgo-generated code calls</code></span>
<span class="codeline" id="line-8"><code>// runtime.cgocall(_cgo_Cfunc_f, frame), where _cgo_Cfunc_f is a</code></span>
<span class="codeline" id="line-9"><code>// gcc-compiled function written by cgo.</code></span>
<span class="codeline" id="line-10"><code>//</code></span>
<span class="codeline" id="line-11"><code>// runtime.cgocall (below) calls entersyscall so as not to block</code></span>
<span class="codeline" id="line-12"><code>// other goroutines or the garbage collector, and then calls</code></span>
<span class="codeline" id="line-13"><code>// runtime.asmcgocall(_cgo_Cfunc_f, frame).</code></span>
<span class="codeline" id="line-14"><code>//</code></span>
<span class="codeline" id="line-15"><code>// runtime.asmcgocall (in asm_$GOARCH.s) switches to the m-&gt;g0 stack</code></span>
<span class="codeline" id="line-16"><code>// (assumed to be an operating system-allocated stack, so safe to run</code></span>
<span class="codeline" id="line-17"><code>// gcc-compiled code on) and calls _cgo_Cfunc_f(frame).</code></span>
<span class="codeline" id="line-18"><code>//</code></span>
<span class="codeline" id="line-19"><code>// _cgo_Cfunc_f invokes the actual C function f with arguments</code></span>
<span class="codeline" id="line-20"><code>// taken from the frame structure, records the results in the frame,</code></span>
<span class="codeline" id="line-21"><code>// and returns to runtime.asmcgocall.</code></span>
<span class="codeline" id="line-22"><code>//</code></span>
<span class="codeline" id="line-23"><code>// After it regains control, runtime.asmcgocall switches back to the</code></span>
<span class="codeline" id="line-24"><code>// original g (m-&gt;curg)'s stack and returns to runtime.cgocall.</code></span>
<span class="codeline" id="line-25"><code>//</code></span>
<span class="codeline" id="line-26"><code>// After it regains control, runtime.cgocall calls exitsyscall, which blocks</code></span>
<span class="codeline" id="line-27"><code>// until this m can run Go code without violating the $GOMAXPROCS limit,</code></span>
<span class="codeline" id="line-28"><code>// and then unlocks g from m.</code></span>
<span class="codeline" id="line-29"><code>//</code></span>
<span class="codeline" id="line-30"><code>// The above description skipped over the possibility of the gcc-compiled</code></span>
<span class="codeline" id="line-31"><code>// function f calling back into Go. If that happens, we continue down</code></span>
<span class="codeline" id="line-32"><code>// the rabbit hole during the execution of f.</code></span>
<span class="codeline" id="line-33"><code>//</code></span>
<span class="codeline" id="line-34"><code>// To make it possible for gcc-compiled C code to call a Go function p.GoF,</code></span>
<span class="codeline" id="line-35"><code>// cgo writes a gcc-compiled function named GoF (not p.GoF, since gcc doesn't</code></span>
<span class="codeline" id="line-36"><code>// know about packages).  The gcc-compiled C function f calls GoF.</code></span>
<span class="codeline" id="line-37"><code>//</code></span>
<span class="codeline" id="line-38"><code>// GoF calls crosscall2(_cgoexp_GoF, frame, framesize).  Crosscall2</code></span>
<span class="codeline" id="line-39"><code>// (in cgo/gcc_$GOARCH.S, a gcc-compiled assembly file) is a two-argument</code></span>
<span class="codeline" id="line-40"><code>// adapter from the gcc function call ABI to the 6c function call ABI.</code></span>
<span class="codeline" id="line-41"><code>// It is called from gcc to call 6c functions. In this case it calls</code></span>
<span class="codeline" id="line-42"><code>// _cgoexp_GoF(frame, framesize), still running on m-&gt;g0's stack</code></span>
<span class="codeline" id="line-43"><code>// and outside the $GOMAXPROCS limit. Thus, this code cannot yet</code></span>
<span class="codeline" id="line-44"><code>// call arbitrary Go code directly and must be careful not to allocate</code></span>
<span class="codeline" id="line-45"><code>// memory or use up m-&gt;g0's stack.</code></span>
<span class="codeline" id="line-46"><code>//</code></span>
<span class="codeline" id="line-47"><code>// _cgoexp_GoF calls runtime.cgocallback(p.GoF, frame, framesize, ctxt).</code></span>
<span class="codeline" id="line-48"><code>// (The reason for having _cgoexp_GoF instead of writing a crosscall3</code></span>
<span class="codeline" id="line-49"><code>// to make this call directly is that _cgoexp_GoF, because it is compiled</code></span>
<span class="codeline" id="line-50"><code>// with 6c instead of gcc, can refer to dotted names like</code></span>
<span class="codeline" id="line-51"><code>// runtime.cgocallback and p.GoF.)</code></span>
<span class="codeline" id="line-52"><code>//</code></span>
<span class="codeline" id="line-53"><code>// runtime.cgocallback (in asm_$GOARCH.s) switches from m-&gt;g0's</code></span>
<span class="codeline" id="line-54"><code>// stack to the original g (m-&gt;curg)'s stack, on which it calls</code></span>
<span class="codeline" id="line-55"><code>// runtime.cgocallbackg(p.GoF, frame, framesize).</code></span>
<span class="codeline" id="line-56"><code>// As part of the stack switch, runtime.cgocallback saves the current</code></span>
<span class="codeline" id="line-57"><code>// SP as m-&gt;g0-&gt;sched.sp, so that any use of m-&gt;g0's stack during the</code></span>
<span class="codeline" id="line-58"><code>// execution of the callback will be done below the existing stack frames.</code></span>
<span class="codeline" id="line-59"><code>// Before overwriting m-&gt;g0-&gt;sched.sp, it pushes the old value on the</code></span>
<span class="codeline" id="line-60"><code>// m-&gt;g0 stack, so that it can be restored later.</code></span>
<span class="codeline" id="line-61"><code>//</code></span>
<span class="codeline" id="line-62"><code>// runtime.cgocallbackg (below) is now running on a real goroutine</code></span>
<span class="codeline" id="line-63"><code>// stack (not an m-&gt;g0 stack).  First it calls runtime.exitsyscall, which will</code></span>
<span class="codeline" id="line-64"><code>// block until the $GOMAXPROCS limit allows running this goroutine.</code></span>
<span class="codeline" id="line-65"><code>// Once exitsyscall has returned, it is safe to do things like call the memory</code></span>
<span class="codeline" id="line-66"><code>// allocator or invoke the Go callback function p.GoF.  runtime.cgocallbackg</code></span>
<span class="codeline" id="line-67"><code>// first defers a function to unwind m-&gt;g0.sched.sp, so that if p.GoF</code></span>
<span class="codeline" id="line-68"><code>// panics, m-&gt;g0.sched.sp will be restored to its old value: the m-&gt;g0 stack</code></span>
<span class="codeline" id="line-69"><code>// and the m-&gt;curg stack will be unwound in lock step.</code></span>
<span class="codeline" id="line-70"><code>// Then it calls p.GoF.  Finally it pops but does not execute the deferred</code></span>
<span class="codeline" id="line-71"><code>// function, calls runtime.entersyscall, and returns to runtime.cgocallback.</code></span>
<span class="codeline" id="line-72"><code>//</code></span>
<span class="codeline" id="line-73"><code>// After it regains control, runtime.cgocallback switches back to</code></span>
<span class="codeline" id="line-74"><code>// m-&gt;g0's stack (the pointer is still in m-&gt;g0.sched.sp), restores the old</code></span>
<span class="codeline" id="line-75"><code>// m-&gt;g0.sched.sp value from the stack, and returns to _cgoexp_GoF.</code></span>
<span class="codeline" id="line-76"><code>//</code></span>
<span class="codeline" id="line-77"><code>// _cgoexp_GoF immediately returns to crosscall2, which restores the</code></span>
<span class="codeline" id="line-78"><code>// callee-save registers for gcc and returns to GoF, which returns to f.</code></span>
<span class="codeline" id="line-79"><code></code></span>
<span class="codeline" id="line-80"><code>package runtime</code></span>
<span class="codeline" id="line-81"><code></code></span>
<span class="codeline" id="line-82"><code>import (</code></span>
<span class="codeline" id="line-83"><code>	"runtime/internal/atomic"</code></span>
<span class="codeline" id="line-84"><code>	"runtime/internal/sys"</code></span>
<span class="codeline" id="line-85"><code>	"unsafe"</code></span>
<span class="codeline" id="line-86"><code>)</code></span>
<span class="codeline" id="line-87"><code></code></span>
<span class="codeline" id="line-88"><code>// Addresses collected in a cgo backtrace when crashing.</code></span>
<span class="codeline" id="line-89"><code>// Length must match arg.Max in x_cgo_callers in runtime/cgo/gcc_traceback.c.</code></span>
<span class="codeline" id="line-90"><code>type cgoCallers [32]uintptr</code></span>
<span class="codeline" id="line-91"><code></code></span>
<span class="codeline" id="line-92"><code>// Call from Go to C.</code></span>
<span class="codeline" id="line-93"><code>//</code></span>
<span class="codeline" id="line-94"><code>// This must be nosplit because it's used for syscalls on some</code></span>
<span class="codeline" id="line-95"><code>// platforms. Syscalls may have untyped arguments on the stack, so</code></span>
<span class="codeline" id="line-96"><code>// it's not safe to grow or scan the stack.</code></span>
<span class="codeline" id="line-97"><code>//</code></span>
<span class="codeline" id="line-98"><code>//go:nosplit</code></span>
<span class="codeline" id="line-99"><code>func cgocall(fn, arg unsafe.Pointer) int32 {</code></span>
<span class="codeline" id="line-100"><code>	if !iscgo &amp;&amp; GOOS != "solaris" &amp;&amp; GOOS != "illumos" &amp;&amp; GOOS != "windows" {</code></span>
<span class="codeline" id="line-101"><code>		throw("cgocall unavailable")</code></span>
<span class="codeline" id="line-102"><code>	}</code></span>
<span class="codeline" id="line-103"><code></code></span>
<span class="codeline" id="line-104"><code>	if fn == nil {</code></span>
<span class="codeline" id="line-105"><code>		throw("cgocall nil")</code></span>
<span class="codeline" id="line-106"><code>	}</code></span>
<span class="codeline" id="line-107"><code></code></span>
<span class="codeline" id="line-108"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-109"><code>		racereleasemerge(unsafe.Pointer(&amp;racecgosync))</code></span>
<span class="codeline" id="line-110"><code>	}</code></span>
<span class="codeline" id="line-111"><code></code></span>
<span class="codeline" id="line-112"><code>	mp := getg().m</code></span>
<span class="codeline" id="line-113"><code>	mp.ncgocall++</code></span>
<span class="codeline" id="line-114"><code>	mp.ncgo++</code></span>
<span class="codeline" id="line-115"><code></code></span>
<span class="codeline" id="line-116"><code>	// Reset traceback.</code></span>
<span class="codeline" id="line-117"><code>	mp.cgoCallers[0] = 0</code></span>
<span class="codeline" id="line-118"><code></code></span>
<span class="codeline" id="line-119"><code>	// Announce we are entering a system call</code></span>
<span class="codeline" id="line-120"><code>	// so that the scheduler knows to create another</code></span>
<span class="codeline" id="line-121"><code>	// M to run goroutines while we are in the</code></span>
<span class="codeline" id="line-122"><code>	// foreign code.</code></span>
<span class="codeline" id="line-123"><code>	//</code></span>
<span class="codeline" id="line-124"><code>	// The call to asmcgocall is guaranteed not to</code></span>
<span class="codeline" id="line-125"><code>	// grow the stack and does not allocate memory,</code></span>
<span class="codeline" id="line-126"><code>	// so it is safe to call while "in a system call", outside</code></span>
<span class="codeline" id="line-127"><code>	// the $GOMAXPROCS accounting.</code></span>
<span class="codeline" id="line-128"><code>	//</code></span>
<span class="codeline" id="line-129"><code>	// fn may call back into Go code, in which case we'll exit the</code></span>
<span class="codeline" id="line-130"><code>	// "system call", run the Go code (which may grow the stack),</code></span>
<span class="codeline" id="line-131"><code>	// and then re-enter the "system call" reusing the PC and SP</code></span>
<span class="codeline" id="line-132"><code>	// saved by entersyscall here.</code></span>
<span class="codeline" id="line-133"><code>	entersyscall()</code></span>
<span class="codeline" id="line-134"><code></code></span>
<span class="codeline" id="line-135"><code>	// Tell asynchronous preemption that we're entering external</code></span>
<span class="codeline" id="line-136"><code>	// code. We do this after entersyscall because this may block</code></span>
<span class="codeline" id="line-137"><code>	// and cause an async preemption to fail, but at this point a</code></span>
<span class="codeline" id="line-138"><code>	// sync preemption will succeed (though this is not a matter</code></span>
<span class="codeline" id="line-139"><code>	// of correctness).</code></span>
<span class="codeline" id="line-140"><code>	osPreemptExtEnter(mp)</code></span>
<span class="codeline" id="line-141"><code></code></span>
<span class="codeline" id="line-142"><code>	mp.incgo = true</code></span>
<span class="codeline" id="line-143"><code>	errno := asmcgocall(fn, arg)</code></span>
<span class="codeline" id="line-144"><code></code></span>
<span class="codeline" id="line-145"><code>	// Update accounting before exitsyscall because exitsyscall may</code></span>
<span class="codeline" id="line-146"><code>	// reschedule us on to a different M.</code></span>
<span class="codeline" id="line-147"><code>	mp.incgo = false</code></span>
<span class="codeline" id="line-148"><code>	mp.ncgo--</code></span>
<span class="codeline" id="line-149"><code></code></span>
<span class="codeline" id="line-150"><code>	osPreemptExtExit(mp)</code></span>
<span class="codeline" id="line-151"><code></code></span>
<span class="codeline" id="line-152"><code>	exitsyscall()</code></span>
<span class="codeline" id="line-153"><code></code></span>
<span class="codeline" id="line-154"><code>	// Note that raceacquire must be called only after exitsyscall has</code></span>
<span class="codeline" id="line-155"><code>	// wired this M to a P.</code></span>
<span class="codeline" id="line-156"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-157"><code>		raceacquire(unsafe.Pointer(&amp;racecgosync))</code></span>
<span class="codeline" id="line-158"><code>	}</code></span>
<span class="codeline" id="line-159"><code></code></span>
<span class="codeline" id="line-160"><code>	// From the garbage collector's perspective, time can move</code></span>
<span class="codeline" id="line-161"><code>	// backwards in the sequence above. If there's a callback into</code></span>
<span class="codeline" id="line-162"><code>	// Go code, GC will see this function at the call to</code></span>
<span class="codeline" id="line-163"><code>	// asmcgocall. When the Go call later returns to C, the</code></span>
<span class="codeline" id="line-164"><code>	// syscall PC/SP is rolled back and the GC sees this function</code></span>
<span class="codeline" id="line-165"><code>	// back at the call to entersyscall. Normally, fn and arg</code></span>
<span class="codeline" id="line-166"><code>	// would be live at entersyscall and dead at asmcgocall, so if</code></span>
<span class="codeline" id="line-167"><code>	// time moved backwards, GC would see these arguments as dead</code></span>
<span class="codeline" id="line-168"><code>	// and then live. Prevent these undead arguments from crashing</code></span>
<span class="codeline" id="line-169"><code>	// GC by forcing them to stay live across this time warp.</code></span>
<span class="codeline" id="line-170"><code>	KeepAlive(fn)</code></span>
<span class="codeline" id="line-171"><code>	KeepAlive(arg)</code></span>
<span class="codeline" id="line-172"><code>	KeepAlive(mp)</code></span>
<span class="codeline" id="line-173"><code></code></span>
<span class="codeline" id="line-174"><code>	return errno</code></span>
<span class="codeline" id="line-175"><code>}</code></span>
<span class="codeline" id="line-176"><code></code></span>
<span class="codeline" id="line-177"><code>// Call from C back to Go.</code></span>
<span class="codeline" id="line-178"><code>//go:nosplit</code></span>
<span class="codeline" id="line-179"><code>func cgocallbackg(ctxt uintptr) {</code></span>
<span class="codeline" id="line-180"><code>	gp := getg()</code></span>
<span class="codeline" id="line-181"><code>	if gp != gp.m.curg {</code></span>
<span class="codeline" id="line-182"><code>		println("runtime: bad g in cgocallback")</code></span>
<span class="codeline" id="line-183"><code>		exit(2)</code></span>
<span class="codeline" id="line-184"><code>	}</code></span>
<span class="codeline" id="line-185"><code></code></span>
<span class="codeline" id="line-186"><code>	// The call from C is on gp.m's g0 stack, so we must ensure</code></span>
<span class="codeline" id="line-187"><code>	// that we stay on that M. We have to do this before calling</code></span>
<span class="codeline" id="line-188"><code>	// exitsyscall, since it would otherwise be free to move us to</code></span>
<span class="codeline" id="line-189"><code>	// a different M. The call to unlockOSThread is in unwindm.</code></span>
<span class="codeline" id="line-190"><code>	lockOSThread()</code></span>
<span class="codeline" id="line-191"><code></code></span>
<span class="codeline" id="line-192"><code>	// Save current syscall parameters, so m.syscall can be</code></span>
<span class="codeline" id="line-193"><code>	// used again if callback decide to make syscall.</code></span>
<span class="codeline" id="line-194"><code>	syscall := gp.m.syscall</code></span>
<span class="codeline" id="line-195"><code></code></span>
<span class="codeline" id="line-196"><code>	// entersyscall saves the caller's SP to allow the GC to trace the Go</code></span>
<span class="codeline" id="line-197"><code>	// stack. However, since we're returning to an earlier stack frame and</code></span>
<span class="codeline" id="line-198"><code>	// need to pair with the entersyscall() call made by cgocall, we must</code></span>
<span class="codeline" id="line-199"><code>	// save syscall* and let reentersyscall restore them.</code></span>
<span class="codeline" id="line-200"><code>	savedsp := unsafe.Pointer(gp.syscallsp)</code></span>
<span class="codeline" id="line-201"><code>	savedpc := gp.syscallpc</code></span>
<span class="codeline" id="line-202"><code>	exitsyscall() // coming out of cgo call</code></span>
<span class="codeline" id="line-203"><code>	gp.m.incgo = false</code></span>
<span class="codeline" id="line-204"><code></code></span>
<span class="codeline" id="line-205"><code>	osPreemptExtExit(gp.m)</code></span>
<span class="codeline" id="line-206"><code></code></span>
<span class="codeline" id="line-207"><code>	cgocallbackg1(ctxt)</code></span>
<span class="codeline" id="line-208"><code></code></span>
<span class="codeline" id="line-209"><code>	// At this point unlockOSThread has been called.</code></span>
<span class="codeline" id="line-210"><code>	// The following code must not change to a different m.</code></span>
<span class="codeline" id="line-211"><code>	// This is enforced by checking incgo in the schedule function.</code></span>
<span class="codeline" id="line-212"><code></code></span>
<span class="codeline" id="line-213"><code>	osPreemptExtEnter(gp.m)</code></span>
<span class="codeline" id="line-214"><code></code></span>
<span class="codeline" id="line-215"><code>	gp.m.incgo = true</code></span>
<span class="codeline" id="line-216"><code>	// going back to cgo call</code></span>
<span class="codeline" id="line-217"><code>	reentersyscall(savedpc, uintptr(savedsp))</code></span>
<span class="codeline" id="line-218"><code></code></span>
<span class="codeline" id="line-219"><code>	gp.m.syscall = syscall</code></span>
<span class="codeline" id="line-220"><code>}</code></span>
<span class="codeline" id="line-221"><code></code></span>
<span class="codeline" id="line-222"><code>func cgocallbackg1(ctxt uintptr) {</code></span>
<span class="codeline" id="line-223"><code>	gp := getg()</code></span>
<span class="codeline" id="line-224"><code>	if gp.m.needextram || atomic.Load(&amp;extraMWaiters) &gt; 0 {</code></span>
<span class="codeline" id="line-225"><code>		gp.m.needextram = false</code></span>
<span class="codeline" id="line-226"><code>		systemstack(newextram)</code></span>
<span class="codeline" id="line-227"><code>	}</code></span>
<span class="codeline" id="line-228"><code></code></span>
<span class="codeline" id="line-229"><code>	if ctxt != 0 {</code></span>
<span class="codeline" id="line-230"><code>		s := append(gp.cgoCtxt, ctxt)</code></span>
<span class="codeline" id="line-231"><code></code></span>
<span class="codeline" id="line-232"><code>		// Now we need to set gp.cgoCtxt = s, but we could get</code></span>
<span class="codeline" id="line-233"><code>		// a SIGPROF signal while manipulating the slice, and</code></span>
<span class="codeline" id="line-234"><code>		// the SIGPROF handler could pick up gp.cgoCtxt while</code></span>
<span class="codeline" id="line-235"><code>		// tracing up the stack.  We need to ensure that the</code></span>
<span class="codeline" id="line-236"><code>		// handler always sees a valid slice, so set the</code></span>
<span class="codeline" id="line-237"><code>		// values in an order such that it always does.</code></span>
<span class="codeline" id="line-238"><code>		p := (*slice)(unsafe.Pointer(&amp;gp.cgoCtxt))</code></span>
<span class="codeline" id="line-239"><code>		atomicstorep(unsafe.Pointer(&amp;p.array), unsafe.Pointer(&amp;s[0]))</code></span>
<span class="codeline" id="line-240"><code>		p.cap = cap(s)</code></span>
<span class="codeline" id="line-241"><code>		p.len = len(s)</code></span>
<span class="codeline" id="line-242"><code></code></span>
<span class="codeline" id="line-243"><code>		defer func(gp *g) {</code></span>
<span class="codeline" id="line-244"><code>			// Decrease the length of the slice by one, safely.</code></span>
<span class="codeline" id="line-245"><code>			p := (*slice)(unsafe.Pointer(&amp;gp.cgoCtxt))</code></span>
<span class="codeline" id="line-246"><code>			p.len--</code></span>
<span class="codeline" id="line-247"><code>		}(gp)</code></span>
<span class="codeline" id="line-248"><code>	}</code></span>
<span class="codeline" id="line-249"><code></code></span>
<span class="codeline" id="line-250"><code>	if gp.m.ncgo == 0 {</code></span>
<span class="codeline" id="line-251"><code>		// The C call to Go came from a thread not currently running</code></span>
<span class="codeline" id="line-252"><code>		// any Go. In the case of -buildmode=c-archive or c-shared,</code></span>
<span class="codeline" id="line-253"><code>		// this call may be coming in before package initialization</code></span>
<span class="codeline" id="line-254"><code>		// is complete. Wait until it is.</code></span>
<span class="codeline" id="line-255"><code>		&lt;-main_init_done</code></span>
<span class="codeline" id="line-256"><code>	}</code></span>
<span class="codeline" id="line-257"><code></code></span>
<span class="codeline" id="line-258"><code>	// Add entry to defer stack in case of panic.</code></span>
<span class="codeline" id="line-259"><code>	restore := true</code></span>
<span class="codeline" id="line-260"><code>	defer unwindm(&amp;restore)</code></span>
<span class="codeline" id="line-261"><code></code></span>
<span class="codeline" id="line-262"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-263"><code>		raceacquire(unsafe.Pointer(&amp;racecgosync))</code></span>
<span class="codeline" id="line-264"><code>	}</code></span>
<span class="codeline" id="line-265"><code></code></span>
<span class="codeline" id="line-266"><code>	type args struct {</code></span>
<span class="codeline" id="line-267"><code>		fn      *funcval</code></span>
<span class="codeline" id="line-268"><code>		arg     unsafe.Pointer</code></span>
<span class="codeline" id="line-269"><code>		argsize uintptr</code></span>
<span class="codeline" id="line-270"><code>	}</code></span>
<span class="codeline" id="line-271"><code>	var cb *args</code></span>
<span class="codeline" id="line-272"><code></code></span>
<span class="codeline" id="line-273"><code>	// Location of callback arguments depends on stack frame layout</code></span>
<span class="codeline" id="line-274"><code>	// and size of stack frame of cgocallback_gofunc.</code></span>
<span class="codeline" id="line-275"><code>	sp := gp.m.g0.sched.sp</code></span>
<span class="codeline" id="line-276"><code>	switch GOARCH {</code></span>
<span class="codeline" id="line-277"><code>	default:</code></span>
<span class="codeline" id="line-278"><code>		throw("cgocallbackg is unimplemented on arch")</code></span>
<span class="codeline" id="line-279"><code>	case "arm":</code></span>
<span class="codeline" id="line-280"><code>		// On arm, stack frame is two words and there's a saved LR between</code></span>
<span class="codeline" id="line-281"><code>		// SP and the stack frame and between the stack frame and the arguments.</code></span>
<span class="codeline" id="line-282"><code>		cb = (*args)(unsafe.Pointer(sp + 4*sys.PtrSize))</code></span>
<span class="codeline" id="line-283"><code>	case "arm64":</code></span>
<span class="codeline" id="line-284"><code>		// On arm64, stack frame is four words and there's a saved LR between</code></span>
<span class="codeline" id="line-285"><code>		// SP and the stack frame and between the stack frame and the arguments.</code></span>
<span class="codeline" id="line-286"><code>		// Additional two words (16-byte alignment) are for saving FP.</code></span>
<span class="codeline" id="line-287"><code>		cb = (*args)(unsafe.Pointer(sp + 7*sys.PtrSize))</code></span>
<span class="codeline" id="line-288"><code>	case "amd64":</code></span>
<span class="codeline" id="line-289"><code>		// On amd64, stack frame is two words, plus caller PC.</code></span>
<span class="codeline" id="line-290"><code>		if framepointer_enabled {</code></span>
<span class="codeline" id="line-291"><code>			// In this case, there's also saved BP.</code></span>
<span class="codeline" id="line-292"><code>			cb = (*args)(unsafe.Pointer(sp + 4*sys.PtrSize))</code></span>
<span class="codeline" id="line-293"><code>			break</code></span>
<span class="codeline" id="line-294"><code>		}</code></span>
<span class="codeline" id="line-295"><code>		cb = (*args)(unsafe.Pointer(sp + 3*sys.PtrSize))</code></span>
<span class="codeline" id="line-296"><code>	case "386":</code></span>
<span class="codeline" id="line-297"><code>		// On 386, stack frame is three words, plus caller PC.</code></span>
<span class="codeline" id="line-298"><code>		cb = (*args)(unsafe.Pointer(sp + 4*sys.PtrSize))</code></span>
<span class="codeline" id="line-299"><code>	case "ppc64", "ppc64le", "s390x":</code></span>
<span class="codeline" id="line-300"><code>		// On ppc64 and s390x, the callback arguments are in the arguments area of</code></span>
<span class="codeline" id="line-301"><code>		// cgocallback's stack frame. The stack looks like this:</code></span>
<span class="codeline" id="line-302"><code>		// +--------------------+------------------------------+</code></span>
<span class="codeline" id="line-303"><code>		// |                    | ...                          |</code></span>
<span class="codeline" id="line-304"><code>		// | cgoexp_$fn         +------------------------------+</code></span>
<span class="codeline" id="line-305"><code>		// |                    | fixed frame area             |</code></span>
<span class="codeline" id="line-306"><code>		// +--------------------+------------------------------+</code></span>
<span class="codeline" id="line-307"><code>		// |                    | arguments area               |</code></span>
<span class="codeline" id="line-308"><code>		// | cgocallback        +------------------------------+ &lt;- sp + 2*minFrameSize + 2*ptrSize</code></span>
<span class="codeline" id="line-309"><code>		// |                    | fixed frame area             |</code></span>
<span class="codeline" id="line-310"><code>		// +--------------------+------------------------------+ &lt;- sp + minFrameSize + 2*ptrSize</code></span>
<span class="codeline" id="line-311"><code>		// |                    | local variables (2 pointers) |</code></span>
<span class="codeline" id="line-312"><code>		// | cgocallback_gofunc +------------------------------+ &lt;- sp + minFrameSize</code></span>
<span class="codeline" id="line-313"><code>		// |                    | fixed frame area             |</code></span>
<span class="codeline" id="line-314"><code>		// +--------------------+------------------------------+ &lt;- sp</code></span>
<span class="codeline" id="line-315"><code>		cb = (*args)(unsafe.Pointer(sp + 2*sys.MinFrameSize + 2*sys.PtrSize))</code></span>
<span class="codeline" id="line-316"><code>	case "mips64", "mips64le":</code></span>
<span class="codeline" id="line-317"><code>		// On mips64x, stack frame is two words and there's a saved LR between</code></span>
<span class="codeline" id="line-318"><code>		// SP and the stack frame and between the stack frame and the arguments.</code></span>
<span class="codeline" id="line-319"><code>		cb = (*args)(unsafe.Pointer(sp + 4*sys.PtrSize))</code></span>
<span class="codeline" id="line-320"><code>	case "mips", "mipsle":</code></span>
<span class="codeline" id="line-321"><code>		// On mipsx, stack frame is two words and there's a saved LR between</code></span>
<span class="codeline" id="line-322"><code>		// SP and the stack frame and between the stack frame and the arguments.</code></span>
<span class="codeline" id="line-323"><code>		cb = (*args)(unsafe.Pointer(sp + 4*sys.PtrSize))</code></span>
<span class="codeline" id="line-324"><code>	}</code></span>
<span class="codeline" id="line-325"><code></code></span>
<span class="codeline" id="line-326"><code>	// Invoke callback.</code></span>
<span class="codeline" id="line-327"><code>	// NOTE(rsc): passing nil for argtype means that the copying of the</code></span>
<span class="codeline" id="line-328"><code>	// results back into cb.arg happens without any corresponding write barriers.</code></span>
<span class="codeline" id="line-329"><code>	// For cgo, cb.arg points into a C stack frame and therefore doesn't</code></span>
<span class="codeline" id="line-330"><code>	// hold any pointers that the GC can find anyway - the write barrier</code></span>
<span class="codeline" id="line-331"><code>	// would be a no-op.</code></span>
<span class="codeline" id="line-332"><code>	reflectcall(nil, unsafe.Pointer(cb.fn), cb.arg, uint32(cb.argsize), 0)</code></span>
<span class="codeline" id="line-333"><code></code></span>
<span class="codeline" id="line-334"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-335"><code>		racereleasemerge(unsafe.Pointer(&amp;racecgosync))</code></span>
<span class="codeline" id="line-336"><code>	}</code></span>
<span class="codeline" id="line-337"><code>	if msanenabled {</code></span>
<span class="codeline" id="line-338"><code>		// Tell msan that we wrote to the entire argument block.</code></span>
<span class="codeline" id="line-339"><code>		// This tells msan that we set the results.</code></span>
<span class="codeline" id="line-340"><code>		// Since we have already called the function it doesn't</code></span>
<span class="codeline" id="line-341"><code>		// matter that we are writing to the non-result parameters.</code></span>
<span class="codeline" id="line-342"><code>		msanwrite(cb.arg, cb.argsize)</code></span>
<span class="codeline" id="line-343"><code>	}</code></span>
<span class="codeline" id="line-344"><code></code></span>
<span class="codeline" id="line-345"><code>	// Do not unwind m-&gt;g0-&gt;sched.sp.</code></span>
<span class="codeline" id="line-346"><code>	// Our caller, cgocallback, will do that.</code></span>
<span class="codeline" id="line-347"><code>	restore = false</code></span>
<span class="codeline" id="line-348"><code>}</code></span>
<span class="codeline" id="line-349"><code></code></span>
<span class="codeline" id="line-350"><code>func unwindm(restore *bool) {</code></span>
<span class="codeline" id="line-351"><code>	if *restore {</code></span>
<span class="codeline" id="line-352"><code>		// Restore sp saved by cgocallback during</code></span>
<span class="codeline" id="line-353"><code>		// unwind of g's stack (see comment at top of file).</code></span>
<span class="codeline" id="line-354"><code>		mp := acquirem()</code></span>
<span class="codeline" id="line-355"><code>		sched := &amp;mp.g0.sched</code></span>
<span class="codeline" id="line-356"><code>		switch GOARCH {</code></span>
<span class="codeline" id="line-357"><code>		default:</code></span>
<span class="codeline" id="line-358"><code>			throw("unwindm not implemented")</code></span>
<span class="codeline" id="line-359"><code>		case "386", "amd64", "arm", "ppc64", "ppc64le", "mips64", "mips64le", "s390x", "mips", "mipsle":</code></span>
<span class="codeline" id="line-360"><code>			sched.sp = *(*uintptr)(unsafe.Pointer(sched.sp + sys.MinFrameSize))</code></span>
<span class="codeline" id="line-361"><code>		case "arm64":</code></span>
<span class="codeline" id="line-362"><code>			sched.sp = *(*uintptr)(unsafe.Pointer(sched.sp + 16))</code></span>
<span class="codeline" id="line-363"><code>		}</code></span>
<span class="codeline" id="line-364"><code></code></span>
<span class="codeline" id="line-365"><code>		// Do the accounting that cgocall will not have a chance to do</code></span>
<span class="codeline" id="line-366"><code>		// during an unwind.</code></span>
<span class="codeline" id="line-367"><code>		//</code></span>
<span class="codeline" id="line-368"><code>		// In the case where a Go call originates from C, ncgo is 0</code></span>
<span class="codeline" id="line-369"><code>		// and there is no matching cgocall to end.</code></span>
<span class="codeline" id="line-370"><code>		if mp.ncgo &gt; 0 {</code></span>
<span class="codeline" id="line-371"><code>			mp.incgo = false</code></span>
<span class="codeline" id="line-372"><code>			mp.ncgo--</code></span>
<span class="codeline" id="line-373"><code>			osPreemptExtExit(mp)</code></span>
<span class="codeline" id="line-374"><code>		}</code></span>
<span class="codeline" id="line-375"><code></code></span>
<span class="codeline" id="line-376"><code>		releasem(mp)</code></span>
<span class="codeline" id="line-377"><code>	}</code></span>
<span class="codeline" id="line-378"><code></code></span>
<span class="codeline" id="line-379"><code>	// Undo the call to lockOSThread in cgocallbackg.</code></span>
<span class="codeline" id="line-380"><code>	// We must still stay on the same m.</code></span>
<span class="codeline" id="line-381"><code>	unlockOSThread()</code></span>
<span class="codeline" id="line-382"><code>}</code></span>
<span class="codeline" id="line-383"><code></code></span>
<span class="codeline" id="line-384"><code>// called from assembly</code></span>
<span class="codeline" id="line-385"><code>func badcgocallback() {</code></span>
<span class="codeline" id="line-386"><code>	throw("misaligned stack in cgocallback")</code></span>
<span class="codeline" id="line-387"><code>}</code></span>
<span class="codeline" id="line-388"><code></code></span>
<span class="codeline" id="line-389"><code>// called from (incomplete) assembly</code></span>
<span class="codeline" id="line-390"><code>func cgounimpl() {</code></span>
<span class="codeline" id="line-391"><code>	throw("cgo not implemented")</code></span>
<span class="codeline" id="line-392"><code>}</code></span>
<span class="codeline" id="line-393"><code></code></span>
<span class="codeline" id="line-394"><code>var racecgosync uint64 // represents possible synchronization in C code</code></span>
<span class="codeline" id="line-395"><code></code></span>
<span class="codeline" id="line-396"><code>// Pointer checking for cgo code.</code></span>
<span class="codeline" id="line-397"><code></code></span>
<span class="codeline" id="line-398"><code>// We want to detect all cases where a program that does not use</code></span>
<span class="codeline" id="line-399"><code>// unsafe makes a cgo call passing a Go pointer to memory that</code></span>
<span class="codeline" id="line-400"><code>// contains a Go pointer. Here a Go pointer is defined as a pointer</code></span>
<span class="codeline" id="line-401"><code>// to memory allocated by the Go runtime. Programs that use unsafe</code></span>
<span class="codeline" id="line-402"><code>// can evade this restriction easily, so we don't try to catch them.</code></span>
<span class="codeline" id="line-403"><code>// The cgo program will rewrite all possibly bad pointer arguments to</code></span>
<span class="codeline" id="line-404"><code>// call cgoCheckPointer, where we can catch cases of a Go pointer</code></span>
<span class="codeline" id="line-405"><code>// pointing to a Go pointer.</code></span>
<span class="codeline" id="line-406"><code></code></span>
<span class="codeline" id="line-407"><code>// Complicating matters, taking the address of a slice or array</code></span>
<span class="codeline" id="line-408"><code>// element permits the C program to access all elements of the slice</code></span>
<span class="codeline" id="line-409"><code>// or array. In that case we will see a pointer to a single element,</code></span>
<span class="codeline" id="line-410"><code>// but we need to check the entire data structure.</code></span>
<span class="codeline" id="line-411"><code></code></span>
<span class="codeline" id="line-412"><code>// The cgoCheckPointer call takes additional arguments indicating that</code></span>
<span class="codeline" id="line-413"><code>// it was called on an address expression. An additional argument of</code></span>
<span class="codeline" id="line-414"><code>// true means that it only needs to check a single element. An</code></span>
<span class="codeline" id="line-415"><code>// additional argument of a slice or array means that it needs to</code></span>
<span class="codeline" id="line-416"><code>// check the entire slice/array, but nothing else. Otherwise, the</code></span>
<span class="codeline" id="line-417"><code>// pointer could be anything, and we check the entire heap object,</code></span>
<span class="codeline" id="line-418"><code>// which is conservative but safe.</code></span>
<span class="codeline" id="line-419"><code></code></span>
<span class="codeline" id="line-420"><code>// When and if we implement a moving garbage collector,</code></span>
<span class="codeline" id="line-421"><code>// cgoCheckPointer will pin the pointer for the duration of the cgo</code></span>
<span class="codeline" id="line-422"><code>// call.  (This is necessary but not sufficient; the cgo program will</code></span>
<span class="codeline" id="line-423"><code>// also have to change to pin Go pointers that cannot point to Go</code></span>
<span class="codeline" id="line-424"><code>// pointers.)</code></span>
<span class="codeline" id="line-425"><code></code></span>
<span class="codeline" id="line-426"><code>// cgoCheckPointer checks if the argument contains a Go pointer that</code></span>
<span class="codeline" id="line-427"><code>// points to a Go pointer, and panics if it does.</code></span>
<span class="codeline" id="line-428"><code>func cgoCheckPointer(ptr interface{}, arg interface{}) {</code></span>
<span class="codeline" id="line-429"><code>	if debug.cgocheck == 0 {</code></span>
<span class="codeline" id="line-430"><code>		return</code></span>
<span class="codeline" id="line-431"><code>	}</code></span>
<span class="codeline" id="line-432"><code></code></span>
<span class="codeline" id="line-433"><code>	ep := efaceOf(&amp;ptr)</code></span>
<span class="codeline" id="line-434"><code>	t := ep._type</code></span>
<span class="codeline" id="line-435"><code></code></span>
<span class="codeline" id="line-436"><code>	top := true</code></span>
<span class="codeline" id="line-437"><code>	if arg != nil &amp;&amp; (t.kind&amp;kindMask == kindPtr || t.kind&amp;kindMask == kindUnsafePointer) {</code></span>
<span class="codeline" id="line-438"><code>		p := ep.data</code></span>
<span class="codeline" id="line-439"><code>		if t.kind&amp;kindDirectIface == 0 {</code></span>
<span class="codeline" id="line-440"><code>			p = *(*unsafe.Pointer)(p)</code></span>
<span class="codeline" id="line-441"><code>		}</code></span>
<span class="codeline" id="line-442"><code>		if p == nil || !cgoIsGoPointer(p) {</code></span>
<span class="codeline" id="line-443"><code>			return</code></span>
<span class="codeline" id="line-444"><code>		}</code></span>
<span class="codeline" id="line-445"><code>		aep := efaceOf(&amp;arg)</code></span>
<span class="codeline" id="line-446"><code>		switch aep._type.kind &amp; kindMask {</code></span>
<span class="codeline" id="line-447"><code>		case kindBool:</code></span>
<span class="codeline" id="line-448"><code>			if t.kind&amp;kindMask == kindUnsafePointer {</code></span>
<span class="codeline" id="line-449"><code>				// We don't know the type of the element.</code></span>
<span class="codeline" id="line-450"><code>				break</code></span>
<span class="codeline" id="line-451"><code>			}</code></span>
<span class="codeline" id="line-452"><code>			pt := (*ptrtype)(unsafe.Pointer(t))</code></span>
<span class="codeline" id="line-453"><code>			cgoCheckArg(pt.elem, p, true, false, cgoCheckPointerFail)</code></span>
<span class="codeline" id="line-454"><code>			return</code></span>
<span class="codeline" id="line-455"><code>		case kindSlice:</code></span>
<span class="codeline" id="line-456"><code>			// Check the slice rather than the pointer.</code></span>
<span class="codeline" id="line-457"><code>			ep = aep</code></span>
<span class="codeline" id="line-458"><code>			t = ep._type</code></span>
<span class="codeline" id="line-459"><code>		case kindArray:</code></span>
<span class="codeline" id="line-460"><code>			// Check the array rather than the pointer.</code></span>
<span class="codeline" id="line-461"><code>			// Pass top as false since we have a pointer</code></span>
<span class="codeline" id="line-462"><code>			// to the array.</code></span>
<span class="codeline" id="line-463"><code>			ep = aep</code></span>
<span class="codeline" id="line-464"><code>			t = ep._type</code></span>
<span class="codeline" id="line-465"><code>			top = false</code></span>
<span class="codeline" id="line-466"><code>		default:</code></span>
<span class="codeline" id="line-467"><code>			throw("can't happen")</code></span>
<span class="codeline" id="line-468"><code>		}</code></span>
<span class="codeline" id="line-469"><code>	}</code></span>
<span class="codeline" id="line-470"><code></code></span>
<span class="codeline" id="line-471"><code>	cgoCheckArg(t, ep.data, t.kind&amp;kindDirectIface == 0, top, cgoCheckPointerFail)</code></span>
<span class="codeline" id="line-472"><code>}</code></span>
<span class="codeline" id="line-473"><code></code></span>
<span class="codeline" id="line-474"><code>const cgoCheckPointerFail = "cgo argument has Go pointer to Go pointer"</code></span>
<span class="codeline" id="line-475"><code>const cgoResultFail = "cgo result has Go pointer"</code></span>
<span class="codeline" id="line-476"><code></code></span>
<span class="codeline" id="line-477"><code>// cgoCheckArg is the real work of cgoCheckPointer. The argument p</code></span>
<span class="codeline" id="line-478"><code>// is either a pointer to the value (of type t), or the value itself,</code></span>
<span class="codeline" id="line-479"><code>// depending on indir. The top parameter is whether we are at the top</code></span>
<span class="codeline" id="line-480"><code>// level, where Go pointers are allowed.</code></span>
<span class="codeline" id="line-481"><code>func cgoCheckArg(t *_type, p unsafe.Pointer, indir, top bool, msg string) {</code></span>
<span class="codeline" id="line-482"><code>	if t.ptrdata == 0 || p == nil {</code></span>
<span class="codeline" id="line-483"><code>		// If the type has no pointers there is nothing to do.</code></span>
<span class="codeline" id="line-484"><code>		return</code></span>
<span class="codeline" id="line-485"><code>	}</code></span>
<span class="codeline" id="line-486"><code></code></span>
<span class="codeline" id="line-487"><code>	switch t.kind &amp; kindMask {</code></span>
<span class="codeline" id="line-488"><code>	default:</code></span>
<span class="codeline" id="line-489"><code>		throw("can't happen")</code></span>
<span class="codeline" id="line-490"><code>	case kindArray:</code></span>
<span class="codeline" id="line-491"><code>		at := (*arraytype)(unsafe.Pointer(t))</code></span>
<span class="codeline" id="line-492"><code>		if !indir {</code></span>
<span class="codeline" id="line-493"><code>			if at.len != 1 {</code></span>
<span class="codeline" id="line-494"><code>				throw("can't happen")</code></span>
<span class="codeline" id="line-495"><code>			}</code></span>
<span class="codeline" id="line-496"><code>			cgoCheckArg(at.elem, p, at.elem.kind&amp;kindDirectIface == 0, top, msg)</code></span>
<span class="codeline" id="line-497"><code>			return</code></span>
<span class="codeline" id="line-498"><code>		}</code></span>
<span class="codeline" id="line-499"><code>		for i := uintptr(0); i &lt; at.len; i++ {</code></span>
<span class="codeline" id="line-500"><code>			cgoCheckArg(at.elem, p, true, top, msg)</code></span>
<span class="codeline" id="line-501"><code>			p = add(p, at.elem.size)</code></span>
<span class="codeline" id="line-502"><code>		}</code></span>
<span class="codeline" id="line-503"><code>	case kindChan, kindMap:</code></span>
<span class="codeline" id="line-504"><code>		// These types contain internal pointers that will</code></span>
<span class="codeline" id="line-505"><code>		// always be allocated in the Go heap. It's never OK</code></span>
<span class="codeline" id="line-506"><code>		// to pass them to C.</code></span>
<span class="codeline" id="line-507"><code>		panic(errorString(msg))</code></span>
<span class="codeline" id="line-508"><code>	case kindFunc:</code></span>
<span class="codeline" id="line-509"><code>		if indir {</code></span>
<span class="codeline" id="line-510"><code>			p = *(*unsafe.Pointer)(p)</code></span>
<span class="codeline" id="line-511"><code>		}</code></span>
<span class="codeline" id="line-512"><code>		if !cgoIsGoPointer(p) {</code></span>
<span class="codeline" id="line-513"><code>			return</code></span>
<span class="codeline" id="line-514"><code>		}</code></span>
<span class="codeline" id="line-515"><code>		panic(errorString(msg))</code></span>
<span class="codeline" id="line-516"><code>	case kindInterface:</code></span>
<span class="codeline" id="line-517"><code>		it := *(**_type)(p)</code></span>
<span class="codeline" id="line-518"><code>		if it == nil {</code></span>
<span class="codeline" id="line-519"><code>			return</code></span>
<span class="codeline" id="line-520"><code>		}</code></span>
<span class="codeline" id="line-521"><code>		// A type known at compile time is OK since it's</code></span>
<span class="codeline" id="line-522"><code>		// constant. A type not known at compile time will be</code></span>
<span class="codeline" id="line-523"><code>		// in the heap and will not be OK.</code></span>
<span class="codeline" id="line-524"><code>		if inheap(uintptr(unsafe.Pointer(it))) {</code></span>
<span class="codeline" id="line-525"><code>			panic(errorString(msg))</code></span>
<span class="codeline" id="line-526"><code>		}</code></span>
<span class="codeline" id="line-527"><code>		p = *(*unsafe.Pointer)(add(p, sys.PtrSize))</code></span>
<span class="codeline" id="line-528"><code>		if !cgoIsGoPointer(p) {</code></span>
<span class="codeline" id="line-529"><code>			return</code></span>
<span class="codeline" id="line-530"><code>		}</code></span>
<span class="codeline" id="line-531"><code>		if !top {</code></span>
<span class="codeline" id="line-532"><code>			panic(errorString(msg))</code></span>
<span class="codeline" id="line-533"><code>		}</code></span>
<span class="codeline" id="line-534"><code>		cgoCheckArg(it, p, it.kind&amp;kindDirectIface == 0, false, msg)</code></span>
<span class="codeline" id="line-535"><code>	case kindSlice:</code></span>
<span class="codeline" id="line-536"><code>		st := (*slicetype)(unsafe.Pointer(t))</code></span>
<span class="codeline" id="line-537"><code>		s := (*slice)(p)</code></span>
<span class="codeline" id="line-538"><code>		p = s.array</code></span>
<span class="codeline" id="line-539"><code>		if p == nil || !cgoIsGoPointer(p) {</code></span>
<span class="codeline" id="line-540"><code>			return</code></span>
<span class="codeline" id="line-541"><code>		}</code></span>
<span class="codeline" id="line-542"><code>		if !top {</code></span>
<span class="codeline" id="line-543"><code>			panic(errorString(msg))</code></span>
<span class="codeline" id="line-544"><code>		}</code></span>
<span class="codeline" id="line-545"><code>		if st.elem.ptrdata == 0 {</code></span>
<span class="codeline" id="line-546"><code>			return</code></span>
<span class="codeline" id="line-547"><code>		}</code></span>
<span class="codeline" id="line-548"><code>		for i := 0; i &lt; s.cap; i++ {</code></span>
<span class="codeline" id="line-549"><code>			cgoCheckArg(st.elem, p, true, false, msg)</code></span>
<span class="codeline" id="line-550"><code>			p = add(p, st.elem.size)</code></span>
<span class="codeline" id="line-551"><code>		}</code></span>
<span class="codeline" id="line-552"><code>	case kindString:</code></span>
<span class="codeline" id="line-553"><code>		ss := (*stringStruct)(p)</code></span>
<span class="codeline" id="line-554"><code>		if !cgoIsGoPointer(ss.str) {</code></span>
<span class="codeline" id="line-555"><code>			return</code></span>
<span class="codeline" id="line-556"><code>		}</code></span>
<span class="codeline" id="line-557"><code>		if !top {</code></span>
<span class="codeline" id="line-558"><code>			panic(errorString(msg))</code></span>
<span class="codeline" id="line-559"><code>		}</code></span>
<span class="codeline" id="line-560"><code>	case kindStruct:</code></span>
<span class="codeline" id="line-561"><code>		st := (*structtype)(unsafe.Pointer(t))</code></span>
<span class="codeline" id="line-562"><code>		if !indir {</code></span>
<span class="codeline" id="line-563"><code>			if len(st.fields) != 1 {</code></span>
<span class="codeline" id="line-564"><code>				throw("can't happen")</code></span>
<span class="codeline" id="line-565"><code>			}</code></span>
<span class="codeline" id="line-566"><code>			cgoCheckArg(st.fields[0].typ, p, st.fields[0].typ.kind&amp;kindDirectIface == 0, top, msg)</code></span>
<span class="codeline" id="line-567"><code>			return</code></span>
<span class="codeline" id="line-568"><code>		}</code></span>
<span class="codeline" id="line-569"><code>		for _, f := range st.fields {</code></span>
<span class="codeline" id="line-570"><code>			if f.typ.ptrdata == 0 {</code></span>
<span class="codeline" id="line-571"><code>				continue</code></span>
<span class="codeline" id="line-572"><code>			}</code></span>
<span class="codeline" id="line-573"><code>			cgoCheckArg(f.typ, add(p, f.offset()), true, top, msg)</code></span>
<span class="codeline" id="line-574"><code>		}</code></span>
<span class="codeline" id="line-575"><code>	case kindPtr, kindUnsafePointer:</code></span>
<span class="codeline" id="line-576"><code>		if indir {</code></span>
<span class="codeline" id="line-577"><code>			p = *(*unsafe.Pointer)(p)</code></span>
<span class="codeline" id="line-578"><code>			if p == nil {</code></span>
<span class="codeline" id="line-579"><code>				return</code></span>
<span class="codeline" id="line-580"><code>			}</code></span>
<span class="codeline" id="line-581"><code>		}</code></span>
<span class="codeline" id="line-582"><code></code></span>
<span class="codeline" id="line-583"><code>		if !cgoIsGoPointer(p) {</code></span>
<span class="codeline" id="line-584"><code>			return</code></span>
<span class="codeline" id="line-585"><code>		}</code></span>
<span class="codeline" id="line-586"><code>		if !top {</code></span>
<span class="codeline" id="line-587"><code>			panic(errorString(msg))</code></span>
<span class="codeline" id="line-588"><code>		}</code></span>
<span class="codeline" id="line-589"><code></code></span>
<span class="codeline" id="line-590"><code>		cgoCheckUnknownPointer(p, msg)</code></span>
<span class="codeline" id="line-591"><code>	}</code></span>
<span class="codeline" id="line-592"><code>}</code></span>
<span class="codeline" id="line-593"><code></code></span>
<span class="codeline" id="line-594"><code>// cgoCheckUnknownPointer is called for an arbitrary pointer into Go</code></span>
<span class="codeline" id="line-595"><code>// memory. It checks whether that Go memory contains any other</code></span>
<span class="codeline" id="line-596"><code>// pointer into Go memory. If it does, we panic.</code></span>
<span class="codeline" id="line-597"><code>// The return values are unused but useful to see in panic tracebacks.</code></span>
<span class="codeline" id="line-598"><code>func cgoCheckUnknownPointer(p unsafe.Pointer, msg string) (base, i uintptr) {</code></span>
<span class="codeline" id="line-599"><code>	if inheap(uintptr(p)) {</code></span>
<span class="codeline" id="line-600"><code>		b, span, _ := findObject(uintptr(p), 0, 0)</code></span>
<span class="codeline" id="line-601"><code>		base = b</code></span>
<span class="codeline" id="line-602"><code>		if base == 0 {</code></span>
<span class="codeline" id="line-603"><code>			return</code></span>
<span class="codeline" id="line-604"><code>		}</code></span>
<span class="codeline" id="line-605"><code>		hbits := heapBitsForAddr(base)</code></span>
<span class="codeline" id="line-606"><code>		n := span.elemsize</code></span>
<span class="codeline" id="line-607"><code>		for i = uintptr(0); i &lt; n; i += sys.PtrSize {</code></span>
<span class="codeline" id="line-608"><code>			if i != 1*sys.PtrSize &amp;&amp; !hbits.morePointers() {</code></span>
<span class="codeline" id="line-609"><code>				// No more possible pointers.</code></span>
<span class="codeline" id="line-610"><code>				break</code></span>
<span class="codeline" id="line-611"><code>			}</code></span>
<span class="codeline" id="line-612"><code>			if hbits.isPointer() &amp;&amp; cgoIsGoPointer(*(*unsafe.Pointer)(unsafe.Pointer(base + i))) {</code></span>
<span class="codeline" id="line-613"><code>				panic(errorString(msg))</code></span>
<span class="codeline" id="line-614"><code>			}</code></span>
<span class="codeline" id="line-615"><code>			hbits = hbits.next()</code></span>
<span class="codeline" id="line-616"><code>		}</code></span>
<span class="codeline" id="line-617"><code></code></span>
<span class="codeline" id="line-618"><code>		return</code></span>
<span class="codeline" id="line-619"><code>	}</code></span>
<span class="codeline" id="line-620"><code></code></span>
<span class="codeline" id="line-621"><code>	for _, datap := range activeModules() {</code></span>
<span class="codeline" id="line-622"><code>		if cgoInRange(p, datap.data, datap.edata) || cgoInRange(p, datap.bss, datap.ebss) {</code></span>
<span class="codeline" id="line-623"><code>			// We have no way to know the size of the object.</code></span>
<span class="codeline" id="line-624"><code>			// We have to assume that it might contain a pointer.</code></span>
<span class="codeline" id="line-625"><code>			panic(errorString(msg))</code></span>
<span class="codeline" id="line-626"><code>		}</code></span>
<span class="codeline" id="line-627"><code>		// In the text or noptr sections, we know that the</code></span>
<span class="codeline" id="line-628"><code>		// pointer does not point to a Go pointer.</code></span>
<span class="codeline" id="line-629"><code>	}</code></span>
<span class="codeline" id="line-630"><code></code></span>
<span class="codeline" id="line-631"><code>	return</code></span>
<span class="codeline" id="line-632"><code>}</code></span>
<span class="codeline" id="line-633"><code></code></span>
<span class="codeline" id="line-634"><code>// cgoIsGoPointer reports whether the pointer is a Go pointer--a</code></span>
<span class="codeline" id="line-635"><code>// pointer to Go memory. We only care about Go memory that might</code></span>
<span class="codeline" id="line-636"><code>// contain pointers.</code></span>
<span class="codeline" id="line-637"><code>//go:nosplit</code></span>
<span class="codeline" id="line-638"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-639"><code>func cgoIsGoPointer(p unsafe.Pointer) bool {</code></span>
<span class="codeline" id="line-640"><code>	if p == nil {</code></span>
<span class="codeline" id="line-641"><code>		return false</code></span>
<span class="codeline" id="line-642"><code>	}</code></span>
<span class="codeline" id="line-643"><code></code></span>
<span class="codeline" id="line-644"><code>	if inHeapOrStack(uintptr(p)) {</code></span>
<span class="codeline" id="line-645"><code>		return true</code></span>
<span class="codeline" id="line-646"><code>	}</code></span>
<span class="codeline" id="line-647"><code></code></span>
<span class="codeline" id="line-648"><code>	for _, datap := range activeModules() {</code></span>
<span class="codeline" id="line-649"><code>		if cgoInRange(p, datap.data, datap.edata) || cgoInRange(p, datap.bss, datap.ebss) {</code></span>
<span class="codeline" id="line-650"><code>			return true</code></span>
<span class="codeline" id="line-651"><code>		}</code></span>
<span class="codeline" id="line-652"><code>	}</code></span>
<span class="codeline" id="line-653"><code></code></span>
<span class="codeline" id="line-654"><code>	return false</code></span>
<span class="codeline" id="line-655"><code>}</code></span>
<span class="codeline" id="line-656"><code></code></span>
<span class="codeline" id="line-657"><code>// cgoInRange reports whether p is between start and end.</code></span>
<span class="codeline" id="line-658"><code>//go:nosplit</code></span>
<span class="codeline" id="line-659"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-660"><code>func cgoInRange(p unsafe.Pointer, start, end uintptr) bool {</code></span>
<span class="codeline" id="line-661"><code>	return start &lt;= uintptr(p) &amp;&amp; uintptr(p) &lt; end</code></span>
<span class="codeline" id="line-662"><code>}</code></span>
<span class="codeline" id="line-663"><code></code></span>
<span class="codeline" id="line-664"><code>// cgoCheckResult is called to check the result parameter of an</code></span>
<span class="codeline" id="line-665"><code>// exported Go function. It panics if the result is or contains a Go</code></span>
<span class="codeline" id="line-666"><code>// pointer.</code></span>
<span class="codeline" id="line-667"><code>func cgoCheckResult(val interface{}) {</code></span>
<span class="codeline" id="line-668"><code>	if debug.cgocheck == 0 {</code></span>
<span class="codeline" id="line-669"><code>		return</code></span>
<span class="codeline" id="line-670"><code>	}</code></span>
<span class="codeline" id="line-671"><code></code></span>
<span class="codeline" id="line-672"><code>	ep := efaceOf(&amp;val)</code></span>
<span class="codeline" id="line-673"><code>	t := ep._type</code></span>
<span class="codeline" id="line-674"><code>	cgoCheckArg(t, ep.data, t.kind&amp;kindDirectIface == 0, false, cgoResultFail)</code></span>
<span class="codeline" id="line-675"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.1.6</i>. (GOOS=darwin GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project and developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table
</pre>
</div></body></html>