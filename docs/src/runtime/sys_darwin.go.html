<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: sys_darwin.go in package runtime</title>
<link href="../../css/light-v0.1.6.css" rel="stylesheet">
<script src="../../jvs/golds-v0.1.6.js"></script>
<body><div>

<pre id="header"><code><span class="title">Source File</span>
	sys_darwin.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/runtime.html">runtime</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2018 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>package runtime</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>import "unsafe"</code></span>
<span class="codeline" id="line-8"><code></code></span>
<span class="codeline" id="line-9"><code>// Call fn with arg as its argument. Return what fn returns.</code></span>
<span class="codeline" id="line-10"><code>// fn is the raw pc value of the entry point of the desired function.</code></span>
<span class="codeline" id="line-11"><code>// Switches to the system stack, if not already there.</code></span>
<span class="codeline" id="line-12"><code>// Preserves the calling point as the location where a profiler traceback will begin.</code></span>
<span class="codeline" id="line-13"><code>//go:nosplit</code></span>
<span class="codeline" id="line-14"><code>func libcCall(fn, arg unsafe.Pointer) int32 {</code></span>
<span class="codeline" id="line-15"><code>	// Leave caller's PC/SP/G around for traceback.</code></span>
<span class="codeline" id="line-16"><code>	gp := getg()</code></span>
<span class="codeline" id="line-17"><code>	var mp *m</code></span>
<span class="codeline" id="line-18"><code>	if gp != nil {</code></span>
<span class="codeline" id="line-19"><code>		mp = gp.m</code></span>
<span class="codeline" id="line-20"><code>	}</code></span>
<span class="codeline" id="line-21"><code>	if mp != nil &amp;&amp; mp.libcallsp == 0 {</code></span>
<span class="codeline" id="line-22"><code>		mp.libcallg.set(gp)</code></span>
<span class="codeline" id="line-23"><code>		mp.libcallpc = getcallerpc()</code></span>
<span class="codeline" id="line-24"><code>		// sp must be the last, because once async cpu profiler finds</code></span>
<span class="codeline" id="line-25"><code>		// all three values to be non-zero, it will use them</code></span>
<span class="codeline" id="line-26"><code>		mp.libcallsp = getcallersp()</code></span>
<span class="codeline" id="line-27"><code>	} else {</code></span>
<span class="codeline" id="line-28"><code>		// Make sure we don't reset libcallsp. This makes</code></span>
<span class="codeline" id="line-29"><code>		// libcCall reentrant; We remember the g/pc/sp for the</code></span>
<span class="codeline" id="line-30"><code>		// first call on an M, until that libcCall instance</code></span>
<span class="codeline" id="line-31"><code>		// returns.  Reentrance only matters for signals, as</code></span>
<span class="codeline" id="line-32"><code>		// libc never calls back into Go.  The tricky case is</code></span>
<span class="codeline" id="line-33"><code>		// where we call libcX from an M and record g/pc/sp.</code></span>
<span class="codeline" id="line-34"><code>		// Before that call returns, a signal arrives on the</code></span>
<span class="codeline" id="line-35"><code>		// same M and the signal handling code calls another</code></span>
<span class="codeline" id="line-36"><code>		// libc function.  We don't want that second libcCall</code></span>
<span class="codeline" id="line-37"><code>		// from within the handler to be recorded, and we</code></span>
<span class="codeline" id="line-38"><code>		// don't want that call's completion to zero</code></span>
<span class="codeline" id="line-39"><code>		// libcallsp.</code></span>
<span class="codeline" id="line-40"><code>		// We don't need to set libcall* while we're in a sighandler</code></span>
<span class="codeline" id="line-41"><code>		// (even if we're not currently in libc) because we block all</code></span>
<span class="codeline" id="line-42"><code>		// signals while we're handling a signal. That includes the</code></span>
<span class="codeline" id="line-43"><code>		// profile signal, which is the one that uses the libcall* info.</code></span>
<span class="codeline" id="line-44"><code>		mp = nil</code></span>
<span class="codeline" id="line-45"><code>	}</code></span>
<span class="codeline" id="line-46"><code>	res := asmcgocall(fn, arg)</code></span>
<span class="codeline" id="line-47"><code>	if mp != nil {</code></span>
<span class="codeline" id="line-48"><code>		mp.libcallsp = 0</code></span>
<span class="codeline" id="line-49"><code>	}</code></span>
<span class="codeline" id="line-50"><code>	return res</code></span>
<span class="codeline" id="line-51"><code>}</code></span>
<span class="codeline" id="line-52"><code></code></span>
<span class="codeline" id="line-53"><code>// The X versions of syscall expect the libc call to return a 64-bit result.</code></span>
<span class="codeline" id="line-54"><code>// Otherwise (the non-X version) expects a 32-bit result.</code></span>
<span class="codeline" id="line-55"><code>// This distinction is required because an error is indicated by returning -1,</code></span>
<span class="codeline" id="line-56"><code>// and we need to know whether to check 32 or 64 bits of the result.</code></span>
<span class="codeline" id="line-57"><code>// (Some libc functions that return 32 bits put junk in the upper 32 bits of AX.)</code></span>
<span class="codeline" id="line-58"><code></code></span>
<span class="codeline" id="line-59"><code>//go:linkname syscall_syscall syscall.syscall</code></span>
<span class="codeline" id="line-60"><code>//go:nosplit</code></span>
<span class="codeline" id="line-61"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-62"><code>func syscall_syscall(fn, a1, a2, a3 uintptr) (r1, r2, err uintptr) {</code></span>
<span class="codeline" id="line-63"><code>	entersyscall()</code></span>
<span class="codeline" id="line-64"><code>	libcCall(unsafe.Pointer(funcPC(syscall)), unsafe.Pointer(&amp;fn))</code></span>
<span class="codeline" id="line-65"><code>	exitsyscall()</code></span>
<span class="codeline" id="line-66"><code>	return</code></span>
<span class="codeline" id="line-67"><code>}</code></span>
<span class="codeline" id="line-68"><code>func syscall()</code></span>
<span class="codeline" id="line-69"><code></code></span>
<span class="codeline" id="line-70"><code>//go:linkname syscall_syscallX syscall.syscallX</code></span>
<span class="codeline" id="line-71"><code>//go:nosplit</code></span>
<span class="codeline" id="line-72"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-73"><code>func syscall_syscallX(fn, a1, a2, a3 uintptr) (r1, r2, err uintptr) {</code></span>
<span class="codeline" id="line-74"><code>	entersyscallblock()</code></span>
<span class="codeline" id="line-75"><code>	libcCall(unsafe.Pointer(funcPC(syscallX)), unsafe.Pointer(&amp;fn))</code></span>
<span class="codeline" id="line-76"><code>	exitsyscall()</code></span>
<span class="codeline" id="line-77"><code>	return</code></span>
<span class="codeline" id="line-78"><code>}</code></span>
<span class="codeline" id="line-79"><code>func syscallX()</code></span>
<span class="codeline" id="line-80"><code></code></span>
<span class="codeline" id="line-81"><code>//go:linkname syscall_syscall6 syscall.syscall6</code></span>
<span class="codeline" id="line-82"><code>//go:nosplit</code></span>
<span class="codeline" id="line-83"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-84"><code>func syscall_syscall6(fn, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr) {</code></span>
<span class="codeline" id="line-85"><code>	entersyscall()</code></span>
<span class="codeline" id="line-86"><code>	libcCall(unsafe.Pointer(funcPC(syscall6)), unsafe.Pointer(&amp;fn))</code></span>
<span class="codeline" id="line-87"><code>	exitsyscall()</code></span>
<span class="codeline" id="line-88"><code>	return</code></span>
<span class="codeline" id="line-89"><code>}</code></span>
<span class="codeline" id="line-90"><code>func syscall6()</code></span>
<span class="codeline" id="line-91"><code></code></span>
<span class="codeline" id="line-92"><code>//go:linkname syscall_syscall6X syscall.syscall6X</code></span>
<span class="codeline" id="line-93"><code>//go:nosplit</code></span>
<span class="codeline" id="line-94"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-95"><code>func syscall_syscall6X(fn, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr) {</code></span>
<span class="codeline" id="line-96"><code>	entersyscall()</code></span>
<span class="codeline" id="line-97"><code>	libcCall(unsafe.Pointer(funcPC(syscall6X)), unsafe.Pointer(&amp;fn))</code></span>
<span class="codeline" id="line-98"><code>	exitsyscall()</code></span>
<span class="codeline" id="line-99"><code>	return</code></span>
<span class="codeline" id="line-100"><code>}</code></span>
<span class="codeline" id="line-101"><code>func syscall6X()</code></span>
<span class="codeline" id="line-102"><code></code></span>
<span class="codeline" id="line-103"><code>//go:linkname syscall_syscallPtr syscall.syscallPtr</code></span>
<span class="codeline" id="line-104"><code>//go:nosplit</code></span>
<span class="codeline" id="line-105"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-106"><code>func syscall_syscallPtr(fn, a1, a2, a3 uintptr) (r1, r2, err uintptr) {</code></span>
<span class="codeline" id="line-107"><code>	entersyscall()</code></span>
<span class="codeline" id="line-108"><code>	libcCall(unsafe.Pointer(funcPC(syscallPtr)), unsafe.Pointer(&amp;fn))</code></span>
<span class="codeline" id="line-109"><code>	exitsyscall()</code></span>
<span class="codeline" id="line-110"><code>	return</code></span>
<span class="codeline" id="line-111"><code>}</code></span>
<span class="codeline" id="line-112"><code>func syscallPtr()</code></span>
<span class="codeline" id="line-113"><code></code></span>
<span class="codeline" id="line-114"><code>//go:linkname syscall_rawSyscall syscall.rawSyscall</code></span>
<span class="codeline" id="line-115"><code>//go:nosplit</code></span>
<span class="codeline" id="line-116"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-117"><code>func syscall_rawSyscall(fn, a1, a2, a3 uintptr) (r1, r2, err uintptr) {</code></span>
<span class="codeline" id="line-118"><code>	libcCall(unsafe.Pointer(funcPC(syscall)), unsafe.Pointer(&amp;fn))</code></span>
<span class="codeline" id="line-119"><code>	return</code></span>
<span class="codeline" id="line-120"><code>}</code></span>
<span class="codeline" id="line-121"><code></code></span>
<span class="codeline" id="line-122"><code>//go:linkname syscall_rawSyscall6 syscall.rawSyscall6</code></span>
<span class="codeline" id="line-123"><code>//go:nosplit</code></span>
<span class="codeline" id="line-124"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-125"><code>func syscall_rawSyscall6(fn, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr) {</code></span>
<span class="codeline" id="line-126"><code>	libcCall(unsafe.Pointer(funcPC(syscall6)), unsafe.Pointer(&amp;fn))</code></span>
<span class="codeline" id="line-127"><code>	return</code></span>
<span class="codeline" id="line-128"><code>}</code></span>
<span class="codeline" id="line-129"><code></code></span>
<span class="codeline" id="line-130"><code>// syscallNoErr is used in crypto/x509 to call into Security.framework and CF.</code></span>
<span class="codeline" id="line-131"><code></code></span>
<span class="codeline" id="line-132"><code>//go:linkname crypto_x509_syscall crypto/x509/internal/macos.syscall</code></span>
<span class="codeline" id="line-133"><code>//go:nosplit</code></span>
<span class="codeline" id="line-134"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-135"><code>func crypto_x509_syscall(fn, a1, a2, a3, a4, a5, a6 uintptr) (r1 uintptr) {</code></span>
<span class="codeline" id="line-136"><code>	entersyscall()</code></span>
<span class="codeline" id="line-137"><code>	libcCall(unsafe.Pointer(funcPC(syscallNoErr)), unsafe.Pointer(&amp;fn))</code></span>
<span class="codeline" id="line-138"><code>	exitsyscall()</code></span>
<span class="codeline" id="line-139"><code>	return</code></span>
<span class="codeline" id="line-140"><code>}</code></span>
<span class="codeline" id="line-141"><code>func syscallNoErr()</code></span>
<span class="codeline" id="line-142"><code></code></span>
<span class="codeline" id="line-143"><code>// The *_trampoline functions convert from the Go calling convention to the C calling convention</code></span>
<span class="codeline" id="line-144"><code>// and then call the underlying libc function.  They are defined in sys_darwin_$ARCH.s.</code></span>
<span class="codeline" id="line-145"><code></code></span>
<span class="codeline" id="line-146"><code>//go:nosplit</code></span>
<span class="codeline" id="line-147"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-148"><code>func pthread_attr_init(attr *pthreadattr) int32 {</code></span>
<span class="codeline" id="line-149"><code>	return libcCall(unsafe.Pointer(funcPC(pthread_attr_init_trampoline)), unsafe.Pointer(&amp;attr))</code></span>
<span class="codeline" id="line-150"><code>}</code></span>
<span class="codeline" id="line-151"><code>func pthread_attr_init_trampoline()</code></span>
<span class="codeline" id="line-152"><code></code></span>
<span class="codeline" id="line-153"><code>//go:nosplit</code></span>
<span class="codeline" id="line-154"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-155"><code>func pthread_attr_getstacksize(attr *pthreadattr, size *uintptr) int32 {</code></span>
<span class="codeline" id="line-156"><code>	return libcCall(unsafe.Pointer(funcPC(pthread_attr_getstacksize_trampoline)), unsafe.Pointer(&amp;attr))</code></span>
<span class="codeline" id="line-157"><code>}</code></span>
<span class="codeline" id="line-158"><code>func pthread_attr_getstacksize_trampoline()</code></span>
<span class="codeline" id="line-159"><code></code></span>
<span class="codeline" id="line-160"><code>//go:nosplit</code></span>
<span class="codeline" id="line-161"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-162"><code>func pthread_attr_setdetachstate(attr *pthreadattr, state int) int32 {</code></span>
<span class="codeline" id="line-163"><code>	return libcCall(unsafe.Pointer(funcPC(pthread_attr_setdetachstate_trampoline)), unsafe.Pointer(&amp;attr))</code></span>
<span class="codeline" id="line-164"><code>}</code></span>
<span class="codeline" id="line-165"><code>func pthread_attr_setdetachstate_trampoline()</code></span>
<span class="codeline" id="line-166"><code></code></span>
<span class="codeline" id="line-167"><code>//go:nosplit</code></span>
<span class="codeline" id="line-168"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-169"><code>func pthread_create(attr *pthreadattr, start uintptr, arg unsafe.Pointer) int32 {</code></span>
<span class="codeline" id="line-170"><code>	return libcCall(unsafe.Pointer(funcPC(pthread_create_trampoline)), unsafe.Pointer(&amp;attr))</code></span>
<span class="codeline" id="line-171"><code>}</code></span>
<span class="codeline" id="line-172"><code>func pthread_create_trampoline()</code></span>
<span class="codeline" id="line-173"><code></code></span>
<span class="codeline" id="line-174"><code>//go:nosplit</code></span>
<span class="codeline" id="line-175"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-176"><code>func raise(sig uint32) {</code></span>
<span class="codeline" id="line-177"><code>	libcCall(unsafe.Pointer(funcPC(raise_trampoline)), unsafe.Pointer(&amp;sig))</code></span>
<span class="codeline" id="line-178"><code>}</code></span>
<span class="codeline" id="line-179"><code>func raise_trampoline()</code></span>
<span class="codeline" id="line-180"><code></code></span>
<span class="codeline" id="line-181"><code>//go:nosplit</code></span>
<span class="codeline" id="line-182"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-183"><code>func pthread_self() (t pthread) {</code></span>
<span class="codeline" id="line-184"><code>	libcCall(unsafe.Pointer(funcPC(pthread_self_trampoline)), unsafe.Pointer(&amp;t))</code></span>
<span class="codeline" id="line-185"><code>	return</code></span>
<span class="codeline" id="line-186"><code>}</code></span>
<span class="codeline" id="line-187"><code>func pthread_self_trampoline()</code></span>
<span class="codeline" id="line-188"><code></code></span>
<span class="codeline" id="line-189"><code>//go:nosplit</code></span>
<span class="codeline" id="line-190"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-191"><code>func pthread_kill(t pthread, sig uint32) {</code></span>
<span class="codeline" id="line-192"><code>	libcCall(unsafe.Pointer(funcPC(pthread_kill_trampoline)), unsafe.Pointer(&amp;t))</code></span>
<span class="codeline" id="line-193"><code>	return</code></span>
<span class="codeline" id="line-194"><code>}</code></span>
<span class="codeline" id="line-195"><code>func pthread_kill_trampoline()</code></span>
<span class="codeline" id="line-196"><code></code></span>
<span class="codeline" id="line-197"><code>// mmap is used to do low-level memory allocation via mmap. Don't allow stack</code></span>
<span class="codeline" id="line-198"><code>// splits, since this function (used by sysAlloc) is called in a lot of low-level</code></span>
<span class="codeline" id="line-199"><code>// parts of the runtime and callers often assume it won't acquire any locks.</code></span>
<span class="codeline" id="line-200"><code>// go:nosplit</code></span>
<span class="codeline" id="line-201"><code>func mmap(addr unsafe.Pointer, n uintptr, prot, flags, fd int32, off uint32) (unsafe.Pointer, int) {</code></span>
<span class="codeline" id="line-202"><code>	args := struct {</code></span>
<span class="codeline" id="line-203"><code>		addr            unsafe.Pointer</code></span>
<span class="codeline" id="line-204"><code>		n               uintptr</code></span>
<span class="codeline" id="line-205"><code>		prot, flags, fd int32</code></span>
<span class="codeline" id="line-206"><code>		off             uint32</code></span>
<span class="codeline" id="line-207"><code>		ret1            unsafe.Pointer</code></span>
<span class="codeline" id="line-208"><code>		ret2            int</code></span>
<span class="codeline" id="line-209"><code>	}{addr, n, prot, flags, fd, off, nil, 0}</code></span>
<span class="codeline" id="line-210"><code>	libcCall(unsafe.Pointer(funcPC(mmap_trampoline)), unsafe.Pointer(&amp;args))</code></span>
<span class="codeline" id="line-211"><code>	return args.ret1, args.ret2</code></span>
<span class="codeline" id="line-212"><code>}</code></span>
<span class="codeline" id="line-213"><code>func mmap_trampoline()</code></span>
<span class="codeline" id="line-214"><code></code></span>
<span class="codeline" id="line-215"><code>//go:nosplit</code></span>
<span class="codeline" id="line-216"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-217"><code>func munmap(addr unsafe.Pointer, n uintptr) {</code></span>
<span class="codeline" id="line-218"><code>	libcCall(unsafe.Pointer(funcPC(munmap_trampoline)), unsafe.Pointer(&amp;addr))</code></span>
<span class="codeline" id="line-219"><code>}</code></span>
<span class="codeline" id="line-220"><code>func munmap_trampoline()</code></span>
<span class="codeline" id="line-221"><code></code></span>
<span class="codeline" id="line-222"><code>//go:nosplit</code></span>
<span class="codeline" id="line-223"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-224"><code>func madvise(addr unsafe.Pointer, n uintptr, flags int32) {</code></span>
<span class="codeline" id="line-225"><code>	libcCall(unsafe.Pointer(funcPC(madvise_trampoline)), unsafe.Pointer(&amp;addr))</code></span>
<span class="codeline" id="line-226"><code>}</code></span>
<span class="codeline" id="line-227"><code>func madvise_trampoline()</code></span>
<span class="codeline" id="line-228"><code></code></span>
<span class="codeline" id="line-229"><code>//go:nosplit</code></span>
<span class="codeline" id="line-230"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-231"><code>func read(fd int32, p unsafe.Pointer, n int32) int32 {</code></span>
<span class="codeline" id="line-232"><code>	return libcCall(unsafe.Pointer(funcPC(read_trampoline)), unsafe.Pointer(&amp;fd))</code></span>
<span class="codeline" id="line-233"><code>}</code></span>
<span class="codeline" id="line-234"><code>func read_trampoline()</code></span>
<span class="codeline" id="line-235"><code></code></span>
<span class="codeline" id="line-236"><code>func pipe() (r, w int32, errno int32) {</code></span>
<span class="codeline" id="line-237"><code>	var p [2]int32</code></span>
<span class="codeline" id="line-238"><code>	errno = libcCall(unsafe.Pointer(funcPC(pipe_trampoline)), noescape(unsafe.Pointer(&amp;p)))</code></span>
<span class="codeline" id="line-239"><code>	return p[0], p[1], errno</code></span>
<span class="codeline" id="line-240"><code>}</code></span>
<span class="codeline" id="line-241"><code>func pipe_trampoline()</code></span>
<span class="codeline" id="line-242"><code></code></span>
<span class="codeline" id="line-243"><code>//go:nosplit</code></span>
<span class="codeline" id="line-244"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-245"><code>func closefd(fd int32) int32 {</code></span>
<span class="codeline" id="line-246"><code>	return libcCall(unsafe.Pointer(funcPC(close_trampoline)), unsafe.Pointer(&amp;fd))</code></span>
<span class="codeline" id="line-247"><code>}</code></span>
<span class="codeline" id="line-248"><code>func close_trampoline()</code></span>
<span class="codeline" id="line-249"><code></code></span>
<span class="codeline" id="line-250"><code>//go:nosplit</code></span>
<span class="codeline" id="line-251"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-252"><code>//</code></span>
<span class="codeline" id="line-253"><code>// This is exported via linkname to assembly in runtime/cgo.</code></span>
<span class="codeline" id="line-254"><code>//go:linkname exit</code></span>
<span class="codeline" id="line-255"><code>func exit(code int32) {</code></span>
<span class="codeline" id="line-256"><code>	libcCall(unsafe.Pointer(funcPC(exit_trampoline)), unsafe.Pointer(&amp;code))</code></span>
<span class="codeline" id="line-257"><code>}</code></span>
<span class="codeline" id="line-258"><code>func exit_trampoline()</code></span>
<span class="codeline" id="line-259"><code></code></span>
<span class="codeline" id="line-260"><code>//go:nosplit</code></span>
<span class="codeline" id="line-261"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-262"><code>func usleep(usec uint32) {</code></span>
<span class="codeline" id="line-263"><code>	libcCall(unsafe.Pointer(funcPC(usleep_trampoline)), unsafe.Pointer(&amp;usec))</code></span>
<span class="codeline" id="line-264"><code>}</code></span>
<span class="codeline" id="line-265"><code>func usleep_trampoline()</code></span>
<span class="codeline" id="line-266"><code></code></span>
<span class="codeline" id="line-267"><code>//go:nosplit</code></span>
<span class="codeline" id="line-268"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-269"><code>func write1(fd uintptr, p unsafe.Pointer, n int32) int32 {</code></span>
<span class="codeline" id="line-270"><code>	return libcCall(unsafe.Pointer(funcPC(write_trampoline)), unsafe.Pointer(&amp;fd))</code></span>
<span class="codeline" id="line-271"><code>}</code></span>
<span class="codeline" id="line-272"><code>func write_trampoline()</code></span>
<span class="codeline" id="line-273"><code></code></span>
<span class="codeline" id="line-274"><code>//go:nosplit</code></span>
<span class="codeline" id="line-275"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-276"><code>func open(name *byte, mode, perm int32) (ret int32) {</code></span>
<span class="codeline" id="line-277"><code>	return libcCall(unsafe.Pointer(funcPC(open_trampoline)), unsafe.Pointer(&amp;name))</code></span>
<span class="codeline" id="line-278"><code>}</code></span>
<span class="codeline" id="line-279"><code>func open_trampoline()</code></span>
<span class="codeline" id="line-280"><code></code></span>
<span class="codeline" id="line-281"><code>//go:nosplit</code></span>
<span class="codeline" id="line-282"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-283"><code>func nanotime1() int64 {</code></span>
<span class="codeline" id="line-284"><code>	var r struct {</code></span>
<span class="codeline" id="line-285"><code>		t            int64  // raw timer</code></span>
<span class="codeline" id="line-286"><code>		numer, denom uint32 // conversion factors. nanoseconds = t * numer / denom.</code></span>
<span class="codeline" id="line-287"><code>	}</code></span>
<span class="codeline" id="line-288"><code>	libcCall(unsafe.Pointer(funcPC(nanotime_trampoline)), unsafe.Pointer(&amp;r))</code></span>
<span class="codeline" id="line-289"><code>	// Note: Apple seems unconcerned about overflow here. See</code></span>
<span class="codeline" id="line-290"><code>	// https://developer.apple.com/library/content/qa/qa1398/_index.html</code></span>
<span class="codeline" id="line-291"><code>	// Note also, numer == denom == 1 is common.</code></span>
<span class="codeline" id="line-292"><code>	t := r.t</code></span>
<span class="codeline" id="line-293"><code>	if r.numer != 1 {</code></span>
<span class="codeline" id="line-294"><code>		t *= int64(r.numer)</code></span>
<span class="codeline" id="line-295"><code>	}</code></span>
<span class="codeline" id="line-296"><code>	if r.denom != 1 {</code></span>
<span class="codeline" id="line-297"><code>		t /= int64(r.denom)</code></span>
<span class="codeline" id="line-298"><code>	}</code></span>
<span class="codeline" id="line-299"><code>	return t</code></span>
<span class="codeline" id="line-300"><code>}</code></span>
<span class="codeline" id="line-301"><code>func nanotime_trampoline()</code></span>
<span class="codeline" id="line-302"><code></code></span>
<span class="codeline" id="line-303"><code>//go:nosplit</code></span>
<span class="codeline" id="line-304"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-305"><code>func walltime1() (int64, int32) {</code></span>
<span class="codeline" id="line-306"><code>	var t timeval</code></span>
<span class="codeline" id="line-307"><code>	libcCall(unsafe.Pointer(funcPC(walltime_trampoline)), unsafe.Pointer(&amp;t))</code></span>
<span class="codeline" id="line-308"><code>	return int64(t.tv_sec), 1000 * t.tv_usec</code></span>
<span class="codeline" id="line-309"><code>}</code></span>
<span class="codeline" id="line-310"><code>func walltime_trampoline()</code></span>
<span class="codeline" id="line-311"><code></code></span>
<span class="codeline" id="line-312"><code>//go:nosplit</code></span>
<span class="codeline" id="line-313"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-314"><code>func sigaction(sig uint32, new *usigactiont, old *usigactiont) {</code></span>
<span class="codeline" id="line-315"><code>	libcCall(unsafe.Pointer(funcPC(sigaction_trampoline)), unsafe.Pointer(&amp;sig))</code></span>
<span class="codeline" id="line-316"><code>}</code></span>
<span class="codeline" id="line-317"><code>func sigaction_trampoline()</code></span>
<span class="codeline" id="line-318"><code></code></span>
<span class="codeline" id="line-319"><code>//go:nosplit</code></span>
<span class="codeline" id="line-320"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-321"><code>func sigprocmask(how uint32, new *sigset, old *sigset) {</code></span>
<span class="codeline" id="line-322"><code>	libcCall(unsafe.Pointer(funcPC(sigprocmask_trampoline)), unsafe.Pointer(&amp;how))</code></span>
<span class="codeline" id="line-323"><code>}</code></span>
<span class="codeline" id="line-324"><code>func sigprocmask_trampoline()</code></span>
<span class="codeline" id="line-325"><code></code></span>
<span class="codeline" id="line-326"><code>//go:nosplit</code></span>
<span class="codeline" id="line-327"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-328"><code>func sigaltstack(new *stackt, old *stackt) {</code></span>
<span class="codeline" id="line-329"><code>	if new != nil &amp;&amp; new.ss_flags&amp;_SS_DISABLE != 0 &amp;&amp; new.ss_size == 0 {</code></span>
<span class="codeline" id="line-330"><code>		// Despite the fact that Darwin's sigaltstack man page says it ignores the size</code></span>
<span class="codeline" id="line-331"><code>		// when SS_DISABLE is set, it doesn't. sigaltstack returns ENOMEM</code></span>
<span class="codeline" id="line-332"><code>		// if we don't give it a reasonable size.</code></span>
<span class="codeline" id="line-333"><code>		// ref: http://lists.llvm.org/pipermail/llvm-commits/Week-of-Mon-20140421/214296.html</code></span>
<span class="codeline" id="line-334"><code>		new.ss_size = 32768</code></span>
<span class="codeline" id="line-335"><code>	}</code></span>
<span class="codeline" id="line-336"><code>	libcCall(unsafe.Pointer(funcPC(sigaltstack_trampoline)), unsafe.Pointer(&amp;new))</code></span>
<span class="codeline" id="line-337"><code>}</code></span>
<span class="codeline" id="line-338"><code>func sigaltstack_trampoline()</code></span>
<span class="codeline" id="line-339"><code></code></span>
<span class="codeline" id="line-340"><code>//go:nosplit</code></span>
<span class="codeline" id="line-341"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-342"><code>func raiseproc(sig uint32) {</code></span>
<span class="codeline" id="line-343"><code>	libcCall(unsafe.Pointer(funcPC(raiseproc_trampoline)), unsafe.Pointer(&amp;sig))</code></span>
<span class="codeline" id="line-344"><code>}</code></span>
<span class="codeline" id="line-345"><code>func raiseproc_trampoline()</code></span>
<span class="codeline" id="line-346"><code></code></span>
<span class="codeline" id="line-347"><code>//go:nosplit</code></span>
<span class="codeline" id="line-348"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-349"><code>func setitimer(mode int32, new, old *itimerval) {</code></span>
<span class="codeline" id="line-350"><code>	libcCall(unsafe.Pointer(funcPC(setitimer_trampoline)), unsafe.Pointer(&amp;mode))</code></span>
<span class="codeline" id="line-351"><code>}</code></span>
<span class="codeline" id="line-352"><code>func setitimer_trampoline()</code></span>
<span class="codeline" id="line-353"><code></code></span>
<span class="codeline" id="line-354"><code>//go:nosplit</code></span>
<span class="codeline" id="line-355"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-356"><code>func sysctl(mib *uint32, miblen uint32, out *byte, size *uintptr, dst *byte, ndst uintptr) int32 {</code></span>
<span class="codeline" id="line-357"><code>	return libcCall(unsafe.Pointer(funcPC(sysctl_trampoline)), unsafe.Pointer(&amp;mib))</code></span>
<span class="codeline" id="line-358"><code>}</code></span>
<span class="codeline" id="line-359"><code>func sysctl_trampoline()</code></span>
<span class="codeline" id="line-360"><code></code></span>
<span class="codeline" id="line-361"><code>//go:nosplit</code></span>
<span class="codeline" id="line-362"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-363"><code>func fcntl(fd, cmd, arg int32) int32 {</code></span>
<span class="codeline" id="line-364"><code>	return libcCall(unsafe.Pointer(funcPC(fcntl_trampoline)), unsafe.Pointer(&amp;fd))</code></span>
<span class="codeline" id="line-365"><code>}</code></span>
<span class="codeline" id="line-366"><code>func fcntl_trampoline()</code></span>
<span class="codeline" id="line-367"><code></code></span>
<span class="codeline" id="line-368"><code>//go:nosplit</code></span>
<span class="codeline" id="line-369"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-370"><code>func kqueue() int32 {</code></span>
<span class="codeline" id="line-371"><code>	v := libcCall(unsafe.Pointer(funcPC(kqueue_trampoline)), nil)</code></span>
<span class="codeline" id="line-372"><code>	return v</code></span>
<span class="codeline" id="line-373"><code>}</code></span>
<span class="codeline" id="line-374"><code>func kqueue_trampoline()</code></span>
<span class="codeline" id="line-375"><code></code></span>
<span class="codeline" id="line-376"><code>//go:nosplit</code></span>
<span class="codeline" id="line-377"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-378"><code>func kevent(kq int32, ch *keventt, nch int32, ev *keventt, nev int32, ts *timespec) int32 {</code></span>
<span class="codeline" id="line-379"><code>	return libcCall(unsafe.Pointer(funcPC(kevent_trampoline)), unsafe.Pointer(&amp;kq))</code></span>
<span class="codeline" id="line-380"><code>}</code></span>
<span class="codeline" id="line-381"><code>func kevent_trampoline()</code></span>
<span class="codeline" id="line-382"><code></code></span>
<span class="codeline" id="line-383"><code>//go:nosplit</code></span>
<span class="codeline" id="line-384"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-385"><code>func pthread_mutex_init(m *pthreadmutex, attr *pthreadmutexattr) int32 {</code></span>
<span class="codeline" id="line-386"><code>	return libcCall(unsafe.Pointer(funcPC(pthread_mutex_init_trampoline)), unsafe.Pointer(&amp;m))</code></span>
<span class="codeline" id="line-387"><code>}</code></span>
<span class="codeline" id="line-388"><code>func pthread_mutex_init_trampoline()</code></span>
<span class="codeline" id="line-389"><code></code></span>
<span class="codeline" id="line-390"><code>//go:nosplit</code></span>
<span class="codeline" id="line-391"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-392"><code>func pthread_mutex_lock(m *pthreadmutex) int32 {</code></span>
<span class="codeline" id="line-393"><code>	return libcCall(unsafe.Pointer(funcPC(pthread_mutex_lock_trampoline)), unsafe.Pointer(&amp;m))</code></span>
<span class="codeline" id="line-394"><code>}</code></span>
<span class="codeline" id="line-395"><code>func pthread_mutex_lock_trampoline()</code></span>
<span class="codeline" id="line-396"><code></code></span>
<span class="codeline" id="line-397"><code>//go:nosplit</code></span>
<span class="codeline" id="line-398"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-399"><code>func pthread_mutex_unlock(m *pthreadmutex) int32 {</code></span>
<span class="codeline" id="line-400"><code>	return libcCall(unsafe.Pointer(funcPC(pthread_mutex_unlock_trampoline)), unsafe.Pointer(&amp;m))</code></span>
<span class="codeline" id="line-401"><code>}</code></span>
<span class="codeline" id="line-402"><code>func pthread_mutex_unlock_trampoline()</code></span>
<span class="codeline" id="line-403"><code></code></span>
<span class="codeline" id="line-404"><code>//go:nosplit</code></span>
<span class="codeline" id="line-405"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-406"><code>func pthread_cond_init(c *pthreadcond, attr *pthreadcondattr) int32 {</code></span>
<span class="codeline" id="line-407"><code>	return libcCall(unsafe.Pointer(funcPC(pthread_cond_init_trampoline)), unsafe.Pointer(&amp;c))</code></span>
<span class="codeline" id="line-408"><code>}</code></span>
<span class="codeline" id="line-409"><code>func pthread_cond_init_trampoline()</code></span>
<span class="codeline" id="line-410"><code></code></span>
<span class="codeline" id="line-411"><code>//go:nosplit</code></span>
<span class="codeline" id="line-412"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-413"><code>func pthread_cond_wait(c *pthreadcond, m *pthreadmutex) int32 {</code></span>
<span class="codeline" id="line-414"><code>	return libcCall(unsafe.Pointer(funcPC(pthread_cond_wait_trampoline)), unsafe.Pointer(&amp;c))</code></span>
<span class="codeline" id="line-415"><code>}</code></span>
<span class="codeline" id="line-416"><code>func pthread_cond_wait_trampoline()</code></span>
<span class="codeline" id="line-417"><code></code></span>
<span class="codeline" id="line-418"><code>//go:nosplit</code></span>
<span class="codeline" id="line-419"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-420"><code>func pthread_cond_timedwait_relative_np(c *pthreadcond, m *pthreadmutex, t *timespec) int32 {</code></span>
<span class="codeline" id="line-421"><code>	return libcCall(unsafe.Pointer(funcPC(pthread_cond_timedwait_relative_np_trampoline)), unsafe.Pointer(&amp;c))</code></span>
<span class="codeline" id="line-422"><code>}</code></span>
<span class="codeline" id="line-423"><code>func pthread_cond_timedwait_relative_np_trampoline()</code></span>
<span class="codeline" id="line-424"><code></code></span>
<span class="codeline" id="line-425"><code>//go:nosplit</code></span>
<span class="codeline" id="line-426"><code>//go:cgo_unsafe_args</code></span>
<span class="codeline" id="line-427"><code>func pthread_cond_signal(c *pthreadcond) int32 {</code></span>
<span class="codeline" id="line-428"><code>	return libcCall(unsafe.Pointer(funcPC(pthread_cond_signal_trampoline)), unsafe.Pointer(&amp;c))</code></span>
<span class="codeline" id="line-429"><code>}</code></span>
<span class="codeline" id="line-430"><code>func pthread_cond_signal_trampoline()</code></span>
<span class="codeline" id="line-431"><code></code></span>
<span class="codeline" id="line-432"><code>// Not used on Darwin, but must be defined.</code></span>
<span class="codeline" id="line-433"><code>func exitThread(wait *uint32) {</code></span>
<span class="codeline" id="line-434"><code>}</code></span>
<span class="codeline" id="line-435"><code></code></span>
<span class="codeline" id="line-436"><code>//go:nosplit</code></span>
<span class="codeline" id="line-437"><code>func closeonexec(fd int32) {</code></span>
<span class="codeline" id="line-438"><code>	fcntl(fd, _F_SETFD, _FD_CLOEXEC)</code></span>
<span class="codeline" id="line-439"><code>}</code></span>
<span class="codeline" id="line-440"><code></code></span>
<span class="codeline" id="line-441"><code>//go:nosplit</code></span>
<span class="codeline" id="line-442"><code>func setNonblock(fd int32) {</code></span>
<span class="codeline" id="line-443"><code>	flags := fcntl(fd, _F_GETFL, 0)</code></span>
<span class="codeline" id="line-444"><code>	fcntl(fd, _F_SETFL, flags|_O_NONBLOCK)</code></span>
<span class="codeline" id="line-445"><code>}</code></span>
<span class="codeline" id="line-446"><code></code></span>
<span class="codeline" id="line-447"><code>// Tell the linker that the libc_* functions are to be found</code></span>
<span class="codeline" id="line-448"><code>// in a system library, with the libc_ prefix missing.</code></span>
<span class="codeline" id="line-449"><code></code></span>
<span class="codeline" id="line-450"><code>//go:cgo_import_dynamic libc_pthread_attr_init pthread_attr_init "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-451"><code>//go:cgo_import_dynamic libc_pthread_attr_getstacksize pthread_attr_getstacksize "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-452"><code>//go:cgo_import_dynamic libc_pthread_attr_setdetachstate pthread_attr_setdetachstate "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-453"><code>//go:cgo_import_dynamic libc_pthread_create pthread_create "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-454"><code>//go:cgo_import_dynamic libc_pthread_self pthread_self "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-455"><code>//go:cgo_import_dynamic libc_pthread_kill pthread_kill "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-456"><code>//go:cgo_import_dynamic libc_exit exit "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-457"><code>//go:cgo_import_dynamic libc_raise raise "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-458"><code></code></span>
<span class="codeline" id="line-459"><code>//go:cgo_import_dynamic libc_open open "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-460"><code>//go:cgo_import_dynamic libc_close close "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-461"><code>//go:cgo_import_dynamic libc_read read "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-462"><code>//go:cgo_import_dynamic libc_write write "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-463"><code>//go:cgo_import_dynamic libc_pipe pipe "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-464"><code></code></span>
<span class="codeline" id="line-465"><code>//go:cgo_import_dynamic libc_mmap mmap "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-466"><code>//go:cgo_import_dynamic libc_munmap munmap "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-467"><code>//go:cgo_import_dynamic libc_madvise madvise "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-468"><code>//go:cgo_import_dynamic libc_error __error "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-469"><code>//go:cgo_import_dynamic libc_usleep usleep "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-470"><code></code></span>
<span class="codeline" id="line-471"><code>//go:cgo_import_dynamic libc_mach_timebase_info mach_timebase_info "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-472"><code>//go:cgo_import_dynamic libc_mach_absolute_time mach_absolute_time "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-473"><code>//go:cgo_import_dynamic libc_gettimeofday gettimeofday "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-474"><code>//go:cgo_import_dynamic libc_sigaction sigaction "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-475"><code>//go:cgo_import_dynamic libc_pthread_sigmask pthread_sigmask "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-476"><code>//go:cgo_import_dynamic libc_sigaltstack sigaltstack "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-477"><code>//go:cgo_import_dynamic libc_getpid getpid "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-478"><code>//go:cgo_import_dynamic libc_kill kill "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-479"><code>//go:cgo_import_dynamic libc_setitimer setitimer "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-480"><code>//go:cgo_import_dynamic libc_sysctl sysctl "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-481"><code>//go:cgo_import_dynamic libc_fcntl fcntl "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-482"><code>//go:cgo_import_dynamic libc_kqueue kqueue "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-483"><code>//go:cgo_import_dynamic libc_kevent kevent "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-484"><code></code></span>
<span class="codeline" id="line-485"><code>//go:cgo_import_dynamic libc_pthread_mutex_init pthread_mutex_init "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-486"><code>//go:cgo_import_dynamic libc_pthread_mutex_lock pthread_mutex_lock "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-487"><code>//go:cgo_import_dynamic libc_pthread_mutex_unlock pthread_mutex_unlock "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-488"><code>//go:cgo_import_dynamic libc_pthread_cond_init pthread_cond_init "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-489"><code>//go:cgo_import_dynamic libc_pthread_cond_wait pthread_cond_wait "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-490"><code>//go:cgo_import_dynamic libc_pthread_cond_timedwait_relative_np pthread_cond_timedwait_relative_np "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-491"><code>//go:cgo_import_dynamic libc_pthread_cond_signal pthread_cond_signal "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-492"><code></code></span>
<span class="codeline" id="line-493"><code>// Magic incantation to get libSystem and friends actually dynamically linked.</code></span>
<span class="codeline" id="line-494"><code>// TODO: Why does the code require this?  See cmd/link/internal/ld/go.go</code></span>
<span class="codeline" id="line-495"><code>//go:cgo_import_dynamic _ _ "/usr/lib/libSystem.B.dylib"</code></span>
<span class="codeline" id="line-496"><code>//go:cgo_import_dynamic _ _ "/System/Library/Frameworks/Security.framework/Versions/A/Security"</code></span>
<span class="codeline" id="line-497"><code>//go:cgo_import_dynamic _ _ "/System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation"</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.1.6</i>. (GOOS=darwin GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project and developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table
</pre>
</div></body></html>