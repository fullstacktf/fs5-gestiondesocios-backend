<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: os_darwin.go in package runtime</title>
<link href="../../css/light-v0.1.6.css" rel="stylesheet">
<script src="../../jvs/golds-v0.1.6.js"></script>
<body><div>

<pre id="header"><code><span class="title">Source File</span>
	os_darwin.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/runtime.html">runtime</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>package runtime</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>import "unsafe"</code></span>
<span class="codeline" id="line-8"><code></code></span>
<span class="codeline" id="line-9"><code>type mOS struct {</code></span>
<span class="codeline" id="line-10"><code>	initialized bool</code></span>
<span class="codeline" id="line-11"><code>	mutex       pthreadmutex</code></span>
<span class="codeline" id="line-12"><code>	cond        pthreadcond</code></span>
<span class="codeline" id="line-13"><code>	count       int</code></span>
<span class="codeline" id="line-14"><code>}</code></span>
<span class="codeline" id="line-15"><code></code></span>
<span class="codeline" id="line-16"><code>func unimplemented(name string) {</code></span>
<span class="codeline" id="line-17"><code>	println(name, "not implemented")</code></span>
<span class="codeline" id="line-18"><code>	*(*int)(unsafe.Pointer(uintptr(1231))) = 1231</code></span>
<span class="codeline" id="line-19"><code>}</code></span>
<span class="codeline" id="line-20"><code></code></span>
<span class="codeline" id="line-21"><code>//go:nosplit</code></span>
<span class="codeline" id="line-22"><code>func semacreate(mp *m) {</code></span>
<span class="codeline" id="line-23"><code>	if mp.initialized {</code></span>
<span class="codeline" id="line-24"><code>		return</code></span>
<span class="codeline" id="line-25"><code>	}</code></span>
<span class="codeline" id="line-26"><code>	mp.initialized = true</code></span>
<span class="codeline" id="line-27"><code>	if err := pthread_mutex_init(&amp;mp.mutex, nil); err != 0 {</code></span>
<span class="codeline" id="line-28"><code>		throw("pthread_mutex_init")</code></span>
<span class="codeline" id="line-29"><code>	}</code></span>
<span class="codeline" id="line-30"><code>	if err := pthread_cond_init(&amp;mp.cond, nil); err != 0 {</code></span>
<span class="codeline" id="line-31"><code>		throw("pthread_cond_init")</code></span>
<span class="codeline" id="line-32"><code>	}</code></span>
<span class="codeline" id="line-33"><code>}</code></span>
<span class="codeline" id="line-34"><code></code></span>
<span class="codeline" id="line-35"><code>//go:nosplit</code></span>
<span class="codeline" id="line-36"><code>func semasleep(ns int64) int32 {</code></span>
<span class="codeline" id="line-37"><code>	var start int64</code></span>
<span class="codeline" id="line-38"><code>	if ns &gt;= 0 {</code></span>
<span class="codeline" id="line-39"><code>		start = nanotime()</code></span>
<span class="codeline" id="line-40"><code>	}</code></span>
<span class="codeline" id="line-41"><code>	mp := getg().m</code></span>
<span class="codeline" id="line-42"><code>	pthread_mutex_lock(&amp;mp.mutex)</code></span>
<span class="codeline" id="line-43"><code>	for {</code></span>
<span class="codeline" id="line-44"><code>		if mp.count &gt; 0 {</code></span>
<span class="codeline" id="line-45"><code>			mp.count--</code></span>
<span class="codeline" id="line-46"><code>			pthread_mutex_unlock(&amp;mp.mutex)</code></span>
<span class="codeline" id="line-47"><code>			return 0</code></span>
<span class="codeline" id="line-48"><code>		}</code></span>
<span class="codeline" id="line-49"><code>		if ns &gt;= 0 {</code></span>
<span class="codeline" id="line-50"><code>			spent := nanotime() - start</code></span>
<span class="codeline" id="line-51"><code>			if spent &gt;= ns {</code></span>
<span class="codeline" id="line-52"><code>				pthread_mutex_unlock(&amp;mp.mutex)</code></span>
<span class="codeline" id="line-53"><code>				return -1</code></span>
<span class="codeline" id="line-54"><code>			}</code></span>
<span class="codeline" id="line-55"><code>			var t timespec</code></span>
<span class="codeline" id="line-56"><code>			t.setNsec(ns - spent)</code></span>
<span class="codeline" id="line-57"><code>			err := pthread_cond_timedwait_relative_np(&amp;mp.cond, &amp;mp.mutex, &amp;t)</code></span>
<span class="codeline" id="line-58"><code>			if err == _ETIMEDOUT {</code></span>
<span class="codeline" id="line-59"><code>				pthread_mutex_unlock(&amp;mp.mutex)</code></span>
<span class="codeline" id="line-60"><code>				return -1</code></span>
<span class="codeline" id="line-61"><code>			}</code></span>
<span class="codeline" id="line-62"><code>		} else {</code></span>
<span class="codeline" id="line-63"><code>			pthread_cond_wait(&amp;mp.cond, &amp;mp.mutex)</code></span>
<span class="codeline" id="line-64"><code>		}</code></span>
<span class="codeline" id="line-65"><code>	}</code></span>
<span class="codeline" id="line-66"><code>}</code></span>
<span class="codeline" id="line-67"><code></code></span>
<span class="codeline" id="line-68"><code>//go:nosplit</code></span>
<span class="codeline" id="line-69"><code>func semawakeup(mp *m) {</code></span>
<span class="codeline" id="line-70"><code>	pthread_mutex_lock(&amp;mp.mutex)</code></span>
<span class="codeline" id="line-71"><code>	mp.count++</code></span>
<span class="codeline" id="line-72"><code>	if mp.count &gt; 0 {</code></span>
<span class="codeline" id="line-73"><code>		pthread_cond_signal(&amp;mp.cond)</code></span>
<span class="codeline" id="line-74"><code>	}</code></span>
<span class="codeline" id="line-75"><code>	pthread_mutex_unlock(&amp;mp.mutex)</code></span>
<span class="codeline" id="line-76"><code>}</code></span>
<span class="codeline" id="line-77"><code></code></span>
<span class="codeline" id="line-78"><code>// The read and write file descriptors used by the sigNote functions.</code></span>
<span class="codeline" id="line-79"><code>var sigNoteRead, sigNoteWrite int32</code></span>
<span class="codeline" id="line-80"><code></code></span>
<span class="codeline" id="line-81"><code>// sigNoteSetup initializes an async-signal-safe note.</code></span>
<span class="codeline" id="line-82"><code>//</code></span>
<span class="codeline" id="line-83"><code>// The current implementation of notes on Darwin is not async-signal-safe,</code></span>
<span class="codeline" id="line-84"><code>// because the functions pthread_mutex_lock, pthread_cond_signal, and</code></span>
<span class="codeline" id="line-85"><code>// pthread_mutex_unlock, called by semawakeup, are not async-signal-safe.</code></span>
<span class="codeline" id="line-86"><code>// There is only one case where we need to wake up a note from a signal</code></span>
<span class="codeline" id="line-87"><code>// handler: the sigsend function. The signal handler code does not require</code></span>
<span class="codeline" id="line-88"><code>// all the features of notes: it does not need to do a timed wait.</code></span>
<span class="codeline" id="line-89"><code>// This is a separate implementation of notes, based on a pipe, that does</code></span>
<span class="codeline" id="line-90"><code>// not support timed waits but is async-signal-safe.</code></span>
<span class="codeline" id="line-91"><code>func sigNoteSetup(*note) {</code></span>
<span class="codeline" id="line-92"><code>	if sigNoteRead != 0 || sigNoteWrite != 0 {</code></span>
<span class="codeline" id="line-93"><code>		throw("duplicate sigNoteSetup")</code></span>
<span class="codeline" id="line-94"><code>	}</code></span>
<span class="codeline" id="line-95"><code>	var errno int32</code></span>
<span class="codeline" id="line-96"><code>	sigNoteRead, sigNoteWrite, errno = pipe()</code></span>
<span class="codeline" id="line-97"><code>	if errno != 0 {</code></span>
<span class="codeline" id="line-98"><code>		throw("pipe failed")</code></span>
<span class="codeline" id="line-99"><code>	}</code></span>
<span class="codeline" id="line-100"><code>	closeonexec(sigNoteRead)</code></span>
<span class="codeline" id="line-101"><code>	closeonexec(sigNoteWrite)</code></span>
<span class="codeline" id="line-102"><code></code></span>
<span class="codeline" id="line-103"><code>	// Make the write end of the pipe non-blocking, so that if the pipe</code></span>
<span class="codeline" id="line-104"><code>	// buffer is somehow full we will not block in the signal handler.</code></span>
<span class="codeline" id="line-105"><code>	// Leave the read end of the pipe blocking so that we will block</code></span>
<span class="codeline" id="line-106"><code>	// in sigNoteSleep.</code></span>
<span class="codeline" id="line-107"><code>	setNonblock(sigNoteWrite)</code></span>
<span class="codeline" id="line-108"><code>}</code></span>
<span class="codeline" id="line-109"><code></code></span>
<span class="codeline" id="line-110"><code>// sigNoteWakeup wakes up a thread sleeping on a note created by sigNoteSetup.</code></span>
<span class="codeline" id="line-111"><code>func sigNoteWakeup(*note) {</code></span>
<span class="codeline" id="line-112"><code>	var b byte</code></span>
<span class="codeline" id="line-113"><code>	write(uintptr(sigNoteWrite), unsafe.Pointer(&amp;b), 1)</code></span>
<span class="codeline" id="line-114"><code>}</code></span>
<span class="codeline" id="line-115"><code></code></span>
<span class="codeline" id="line-116"><code>// sigNoteSleep waits for a note created by sigNoteSetup to be woken.</code></span>
<span class="codeline" id="line-117"><code>func sigNoteSleep(*note) {</code></span>
<span class="codeline" id="line-118"><code>	entersyscallblock()</code></span>
<span class="codeline" id="line-119"><code>	var b byte</code></span>
<span class="codeline" id="line-120"><code>	read(sigNoteRead, unsafe.Pointer(&amp;b), 1)</code></span>
<span class="codeline" id="line-121"><code>	exitsyscall()</code></span>
<span class="codeline" id="line-122"><code>}</code></span>
<span class="codeline" id="line-123"><code></code></span>
<span class="codeline" id="line-124"><code>// BSD interface for threading.</code></span>
<span class="codeline" id="line-125"><code>func osinit() {</code></span>
<span class="codeline" id="line-126"><code>	// pthread_create delayed until end of goenvs so that we</code></span>
<span class="codeline" id="line-127"><code>	// can look at the environment first.</code></span>
<span class="codeline" id="line-128"><code></code></span>
<span class="codeline" id="line-129"><code>	ncpu = getncpu()</code></span>
<span class="codeline" id="line-130"><code>	physPageSize = getPageSize()</code></span>
<span class="codeline" id="line-131"><code>}</code></span>
<span class="codeline" id="line-132"><code></code></span>
<span class="codeline" id="line-133"><code>const (</code></span>
<span class="codeline" id="line-134"><code>	_CTL_HW      = 6</code></span>
<span class="codeline" id="line-135"><code>	_HW_NCPU     = 3</code></span>
<span class="codeline" id="line-136"><code>	_HW_PAGESIZE = 7</code></span>
<span class="codeline" id="line-137"><code>)</code></span>
<span class="codeline" id="line-138"><code></code></span>
<span class="codeline" id="line-139"><code>func getncpu() int32 {</code></span>
<span class="codeline" id="line-140"><code>	// Use sysctl to fetch hw.ncpu.</code></span>
<span class="codeline" id="line-141"><code>	mib := [2]uint32{_CTL_HW, _HW_NCPU}</code></span>
<span class="codeline" id="line-142"><code>	out := uint32(0)</code></span>
<span class="codeline" id="line-143"><code>	nout := unsafe.Sizeof(out)</code></span>
<span class="codeline" id="line-144"><code>	ret := sysctl(&amp;mib[0], 2, (*byte)(unsafe.Pointer(&amp;out)), &amp;nout, nil, 0)</code></span>
<span class="codeline" id="line-145"><code>	if ret &gt;= 0 &amp;&amp; int32(out) &gt; 0 {</code></span>
<span class="codeline" id="line-146"><code>		return int32(out)</code></span>
<span class="codeline" id="line-147"><code>	}</code></span>
<span class="codeline" id="line-148"><code>	return 1</code></span>
<span class="codeline" id="line-149"><code>}</code></span>
<span class="codeline" id="line-150"><code></code></span>
<span class="codeline" id="line-151"><code>func getPageSize() uintptr {</code></span>
<span class="codeline" id="line-152"><code>	// Use sysctl to fetch hw.pagesize.</code></span>
<span class="codeline" id="line-153"><code>	mib := [2]uint32{_CTL_HW, _HW_PAGESIZE}</code></span>
<span class="codeline" id="line-154"><code>	out := uint32(0)</code></span>
<span class="codeline" id="line-155"><code>	nout := unsafe.Sizeof(out)</code></span>
<span class="codeline" id="line-156"><code>	ret := sysctl(&amp;mib[0], 2, (*byte)(unsafe.Pointer(&amp;out)), &amp;nout, nil, 0)</code></span>
<span class="codeline" id="line-157"><code>	if ret &gt;= 0 &amp;&amp; int32(out) &gt; 0 {</code></span>
<span class="codeline" id="line-158"><code>		return uintptr(out)</code></span>
<span class="codeline" id="line-159"><code>	}</code></span>
<span class="codeline" id="line-160"><code>	return 0</code></span>
<span class="codeline" id="line-161"><code>}</code></span>
<span class="codeline" id="line-162"><code></code></span>
<span class="codeline" id="line-163"><code>var urandom_dev = []byte("/dev/urandom\x00")</code></span>
<span class="codeline" id="line-164"><code></code></span>
<span class="codeline" id="line-165"><code>//go:nosplit</code></span>
<span class="codeline" id="line-166"><code>func getRandomData(r []byte) {</code></span>
<span class="codeline" id="line-167"><code>	fd := open(&amp;urandom_dev[0], 0 /* O_RDONLY */, 0)</code></span>
<span class="codeline" id="line-168"><code>	n := read(fd, unsafe.Pointer(&amp;r[0]), int32(len(r)))</code></span>
<span class="codeline" id="line-169"><code>	closefd(fd)</code></span>
<span class="codeline" id="line-170"><code>	extendRandom(r, int(n))</code></span>
<span class="codeline" id="line-171"><code>}</code></span>
<span class="codeline" id="line-172"><code></code></span>
<span class="codeline" id="line-173"><code>func goenvs() {</code></span>
<span class="codeline" id="line-174"><code>	goenvs_unix()</code></span>
<span class="codeline" id="line-175"><code>}</code></span>
<span class="codeline" id="line-176"><code></code></span>
<span class="codeline" id="line-177"><code>// May run with m.p==nil, so write barriers are not allowed.</code></span>
<span class="codeline" id="line-178"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-179"><code>func newosproc(mp *m) {</code></span>
<span class="codeline" id="line-180"><code>	stk := unsafe.Pointer(mp.g0.stack.hi)</code></span>
<span class="codeline" id="line-181"><code>	if false {</code></span>
<span class="codeline" id="line-182"><code>		print("newosproc stk=", stk, " m=", mp, " g=", mp.g0, " id=", mp.id, " ostk=", &amp;mp, "\n")</code></span>
<span class="codeline" id="line-183"><code>	}</code></span>
<span class="codeline" id="line-184"><code></code></span>
<span class="codeline" id="line-185"><code>	// Initialize an attribute object.</code></span>
<span class="codeline" id="line-186"><code>	var attr pthreadattr</code></span>
<span class="codeline" id="line-187"><code>	var err int32</code></span>
<span class="codeline" id="line-188"><code>	err = pthread_attr_init(&amp;attr)</code></span>
<span class="codeline" id="line-189"><code>	if err != 0 {</code></span>
<span class="codeline" id="line-190"><code>		write(2, unsafe.Pointer(&amp;failthreadcreate[0]), int32(len(failthreadcreate)))</code></span>
<span class="codeline" id="line-191"><code>		exit(1)</code></span>
<span class="codeline" id="line-192"><code>	}</code></span>
<span class="codeline" id="line-193"><code></code></span>
<span class="codeline" id="line-194"><code>	// Find out OS stack size for our own stack guard.</code></span>
<span class="codeline" id="line-195"><code>	var stacksize uintptr</code></span>
<span class="codeline" id="line-196"><code>	if pthread_attr_getstacksize(&amp;attr, &amp;stacksize) != 0 {</code></span>
<span class="codeline" id="line-197"><code>		write(2, unsafe.Pointer(&amp;failthreadcreate[0]), int32(len(failthreadcreate)))</code></span>
<span class="codeline" id="line-198"><code>		exit(1)</code></span>
<span class="codeline" id="line-199"><code>	}</code></span>
<span class="codeline" id="line-200"><code>	mp.g0.stack.hi = stacksize // for mstart</code></span>
<span class="codeline" id="line-201"><code>	//mSysStatInc(&amp;memstats.stacks_sys, stacksize) //TODO: do this?</code></span>
<span class="codeline" id="line-202"><code></code></span>
<span class="codeline" id="line-203"><code>	// Tell the pthread library we won't join with this thread.</code></span>
<span class="codeline" id="line-204"><code>	if pthread_attr_setdetachstate(&amp;attr, _PTHREAD_CREATE_DETACHED) != 0 {</code></span>
<span class="codeline" id="line-205"><code>		write(2, unsafe.Pointer(&amp;failthreadcreate[0]), int32(len(failthreadcreate)))</code></span>
<span class="codeline" id="line-206"><code>		exit(1)</code></span>
<span class="codeline" id="line-207"><code>	}</code></span>
<span class="codeline" id="line-208"><code></code></span>
<span class="codeline" id="line-209"><code>	// Finally, create the thread. It starts at mstart_stub, which does some low-level</code></span>
<span class="codeline" id="line-210"><code>	// setup and then calls mstart.</code></span>
<span class="codeline" id="line-211"><code>	var oset sigset</code></span>
<span class="codeline" id="line-212"><code>	sigprocmask(_SIG_SETMASK, &amp;sigset_all, &amp;oset)</code></span>
<span class="codeline" id="line-213"><code>	err = pthread_create(&amp;attr, funcPC(mstart_stub), unsafe.Pointer(mp))</code></span>
<span class="codeline" id="line-214"><code>	sigprocmask(_SIG_SETMASK, &amp;oset, nil)</code></span>
<span class="codeline" id="line-215"><code>	if err != 0 {</code></span>
<span class="codeline" id="line-216"><code>		write(2, unsafe.Pointer(&amp;failthreadcreate[0]), int32(len(failthreadcreate)))</code></span>
<span class="codeline" id="line-217"><code>		exit(1)</code></span>
<span class="codeline" id="line-218"><code>	}</code></span>
<span class="codeline" id="line-219"><code>}</code></span>
<span class="codeline" id="line-220"><code></code></span>
<span class="codeline" id="line-221"><code>// glue code to call mstart from pthread_create.</code></span>
<span class="codeline" id="line-222"><code>func mstart_stub()</code></span>
<span class="codeline" id="line-223"><code></code></span>
<span class="codeline" id="line-224"><code>// newosproc0 is a version of newosproc that can be called before the runtime</code></span>
<span class="codeline" id="line-225"><code>// is initialized.</code></span>
<span class="codeline" id="line-226"><code>//</code></span>
<span class="codeline" id="line-227"><code>// This function is not safe to use after initialization as it does not pass an M as fnarg.</code></span>
<span class="codeline" id="line-228"><code>//</code></span>
<span class="codeline" id="line-229"><code>//go:nosplit</code></span>
<span class="codeline" id="line-230"><code>func newosproc0(stacksize uintptr, fn uintptr) {</code></span>
<span class="codeline" id="line-231"><code>	// Initialize an attribute object.</code></span>
<span class="codeline" id="line-232"><code>	var attr pthreadattr</code></span>
<span class="codeline" id="line-233"><code>	var err int32</code></span>
<span class="codeline" id="line-234"><code>	err = pthread_attr_init(&amp;attr)</code></span>
<span class="codeline" id="line-235"><code>	if err != 0 {</code></span>
<span class="codeline" id="line-236"><code>		write(2, unsafe.Pointer(&amp;failthreadcreate[0]), int32(len(failthreadcreate)))</code></span>
<span class="codeline" id="line-237"><code>		exit(1)</code></span>
<span class="codeline" id="line-238"><code>	}</code></span>
<span class="codeline" id="line-239"><code></code></span>
<span class="codeline" id="line-240"><code>	// The caller passes in a suggested stack size,</code></span>
<span class="codeline" id="line-241"><code>	// from when we allocated the stack and thread ourselves,</code></span>
<span class="codeline" id="line-242"><code>	// without libpthread. Now that we're using libpthread,</code></span>
<span class="codeline" id="line-243"><code>	// we use the OS default stack size instead of the suggestion.</code></span>
<span class="codeline" id="line-244"><code>	// Find out that stack size for our own stack guard.</code></span>
<span class="codeline" id="line-245"><code>	if pthread_attr_getstacksize(&amp;attr, &amp;stacksize) != 0 {</code></span>
<span class="codeline" id="line-246"><code>		write(2, unsafe.Pointer(&amp;failthreadcreate[0]), int32(len(failthreadcreate)))</code></span>
<span class="codeline" id="line-247"><code>		exit(1)</code></span>
<span class="codeline" id="line-248"><code>	}</code></span>
<span class="codeline" id="line-249"><code>	g0.stack.hi = stacksize // for mstart</code></span>
<span class="codeline" id="line-250"><code>	mSysStatInc(&amp;memstats.stacks_sys, stacksize)</code></span>
<span class="codeline" id="line-251"><code></code></span>
<span class="codeline" id="line-252"><code>	// Tell the pthread library we won't join with this thread.</code></span>
<span class="codeline" id="line-253"><code>	if pthread_attr_setdetachstate(&amp;attr, _PTHREAD_CREATE_DETACHED) != 0 {</code></span>
<span class="codeline" id="line-254"><code>		write(2, unsafe.Pointer(&amp;failthreadcreate[0]), int32(len(failthreadcreate)))</code></span>
<span class="codeline" id="line-255"><code>		exit(1)</code></span>
<span class="codeline" id="line-256"><code>	}</code></span>
<span class="codeline" id="line-257"><code></code></span>
<span class="codeline" id="line-258"><code>	// Finally, create the thread. It starts at mstart_stub, which does some low-level</code></span>
<span class="codeline" id="line-259"><code>	// setup and then calls mstart.</code></span>
<span class="codeline" id="line-260"><code>	var oset sigset</code></span>
<span class="codeline" id="line-261"><code>	sigprocmask(_SIG_SETMASK, &amp;sigset_all, &amp;oset)</code></span>
<span class="codeline" id="line-262"><code>	err = pthread_create(&amp;attr, fn, nil)</code></span>
<span class="codeline" id="line-263"><code>	sigprocmask(_SIG_SETMASK, &amp;oset, nil)</code></span>
<span class="codeline" id="line-264"><code>	if err != 0 {</code></span>
<span class="codeline" id="line-265"><code>		write(2, unsafe.Pointer(&amp;failthreadcreate[0]), int32(len(failthreadcreate)))</code></span>
<span class="codeline" id="line-266"><code>		exit(1)</code></span>
<span class="codeline" id="line-267"><code>	}</code></span>
<span class="codeline" id="line-268"><code>}</code></span>
<span class="codeline" id="line-269"><code></code></span>
<span class="codeline" id="line-270"><code>var failallocatestack = []byte("runtime: failed to allocate stack for the new OS thread\n")</code></span>
<span class="codeline" id="line-271"><code>var failthreadcreate = []byte("runtime: failed to create new OS thread\n")</code></span>
<span class="codeline" id="line-272"><code></code></span>
<span class="codeline" id="line-273"><code>// Called to do synchronous initialization of Go code built with</code></span>
<span class="codeline" id="line-274"><code>// -buildmode=c-archive or -buildmode=c-shared.</code></span>
<span class="codeline" id="line-275"><code>// None of the Go runtime is initialized.</code></span>
<span class="codeline" id="line-276"><code>//go:nosplit</code></span>
<span class="codeline" id="line-277"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-278"><code>func libpreinit() {</code></span>
<span class="codeline" id="line-279"><code>	initsig(true)</code></span>
<span class="codeline" id="line-280"><code>}</code></span>
<span class="codeline" id="line-281"><code></code></span>
<span class="codeline" id="line-282"><code>// Called to initialize a new m (including the bootstrap m).</code></span>
<span class="codeline" id="line-283"><code>// Called on the parent thread (main thread in case of bootstrap), can allocate memory.</code></span>
<span class="codeline" id="line-284"><code>func mpreinit(mp *m) {</code></span>
<span class="codeline" id="line-285"><code>	mp.gsignal = malg(32 * 1024) // OS X wants &gt;= 8K</code></span>
<span class="codeline" id="line-286"><code>	mp.gsignal.m = mp</code></span>
<span class="codeline" id="line-287"><code>}</code></span>
<span class="codeline" id="line-288"><code></code></span>
<span class="codeline" id="line-289"><code>// Called to initialize a new m (including the bootstrap m).</code></span>
<span class="codeline" id="line-290"><code>// Called on the new thread, cannot allocate memory.</code></span>
<span class="codeline" id="line-291"><code>func minit() {</code></span>
<span class="codeline" id="line-292"><code>	// The alternate signal stack is buggy on arm64.</code></span>
<span class="codeline" id="line-293"><code>	// The signal handler handles it directly.</code></span>
<span class="codeline" id="line-294"><code>	if GOARCH != "arm64" {</code></span>
<span class="codeline" id="line-295"><code>		minitSignalStack()</code></span>
<span class="codeline" id="line-296"><code>	}</code></span>
<span class="codeline" id="line-297"><code>	minitSignalMask()</code></span>
<span class="codeline" id="line-298"><code>	getg().m.procid = uint64(pthread_self())</code></span>
<span class="codeline" id="line-299"><code>}</code></span>
<span class="codeline" id="line-300"><code></code></span>
<span class="codeline" id="line-301"><code>// Called from dropm to undo the effect of an minit.</code></span>
<span class="codeline" id="line-302"><code>//go:nosplit</code></span>
<span class="codeline" id="line-303"><code>func unminit() {</code></span>
<span class="codeline" id="line-304"><code>	// The alternate signal stack is buggy on arm64.</code></span>
<span class="codeline" id="line-305"><code>	// See minit.</code></span>
<span class="codeline" id="line-306"><code>	if GOARCH != "arm64" {</code></span>
<span class="codeline" id="line-307"><code>		unminitSignals()</code></span>
<span class="codeline" id="line-308"><code>	}</code></span>
<span class="codeline" id="line-309"><code>}</code></span>
<span class="codeline" id="line-310"><code></code></span>
<span class="codeline" id="line-311"><code>//go:nosplit</code></span>
<span class="codeline" id="line-312"><code>func osyield() {</code></span>
<span class="codeline" id="line-313"><code>	usleep(1)</code></span>
<span class="codeline" id="line-314"><code>}</code></span>
<span class="codeline" id="line-315"><code></code></span>
<span class="codeline" id="line-316"><code>const (</code></span>
<span class="codeline" id="line-317"><code>	_NSIG        = 32</code></span>
<span class="codeline" id="line-318"><code>	_SI_USER     = 0 /* empirically true, but not what headers say */</code></span>
<span class="codeline" id="line-319"><code>	_SIG_BLOCK   = 1</code></span>
<span class="codeline" id="line-320"><code>	_SIG_UNBLOCK = 2</code></span>
<span class="codeline" id="line-321"><code>	_SIG_SETMASK = 3</code></span>
<span class="codeline" id="line-322"><code>	_SS_DISABLE  = 4</code></span>
<span class="codeline" id="line-323"><code>)</code></span>
<span class="codeline" id="line-324"><code></code></span>
<span class="codeline" id="line-325"><code>//extern SigTabTT runtime·sigtab[];</code></span>
<span class="codeline" id="line-326"><code></code></span>
<span class="codeline" id="line-327"><code>type sigset uint32</code></span>
<span class="codeline" id="line-328"><code></code></span>
<span class="codeline" id="line-329"><code>var sigset_all = ^sigset(0)</code></span>
<span class="codeline" id="line-330"><code></code></span>
<span class="codeline" id="line-331"><code>//go:nosplit</code></span>
<span class="codeline" id="line-332"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-333"><code>func setsig(i uint32, fn uintptr) {</code></span>
<span class="codeline" id="line-334"><code>	var sa usigactiont</code></span>
<span class="codeline" id="line-335"><code>	sa.sa_flags = _SA_SIGINFO | _SA_ONSTACK | _SA_RESTART</code></span>
<span class="codeline" id="line-336"><code>	sa.sa_mask = ^uint32(0)</code></span>
<span class="codeline" id="line-337"><code>	if fn == funcPC(sighandler) {</code></span>
<span class="codeline" id="line-338"><code>		if iscgo {</code></span>
<span class="codeline" id="line-339"><code>			fn = funcPC(cgoSigtramp)</code></span>
<span class="codeline" id="line-340"><code>		} else {</code></span>
<span class="codeline" id="line-341"><code>			fn = funcPC(sigtramp)</code></span>
<span class="codeline" id="line-342"><code>		}</code></span>
<span class="codeline" id="line-343"><code>	}</code></span>
<span class="codeline" id="line-344"><code>	*(*uintptr)(unsafe.Pointer(&amp;sa.__sigaction_u)) = fn</code></span>
<span class="codeline" id="line-345"><code>	sigaction(i, &amp;sa, nil)</code></span>
<span class="codeline" id="line-346"><code>}</code></span>
<span class="codeline" id="line-347"><code></code></span>
<span class="codeline" id="line-348"><code>// sigtramp is the callback from libc when a signal is received.</code></span>
<span class="codeline" id="line-349"><code>// It is called with the C calling convention.</code></span>
<span class="codeline" id="line-350"><code>func sigtramp()</code></span>
<span class="codeline" id="line-351"><code>func cgoSigtramp()</code></span>
<span class="codeline" id="line-352"><code></code></span>
<span class="codeline" id="line-353"><code>//go:nosplit</code></span>
<span class="codeline" id="line-354"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-355"><code>func setsigstack(i uint32) {</code></span>
<span class="codeline" id="line-356"><code>	var osa usigactiont</code></span>
<span class="codeline" id="line-357"><code>	sigaction(i, nil, &amp;osa)</code></span>
<span class="codeline" id="line-358"><code>	handler := *(*uintptr)(unsafe.Pointer(&amp;osa.__sigaction_u))</code></span>
<span class="codeline" id="line-359"><code>	if osa.sa_flags&amp;_SA_ONSTACK != 0 {</code></span>
<span class="codeline" id="line-360"><code>		return</code></span>
<span class="codeline" id="line-361"><code>	}</code></span>
<span class="codeline" id="line-362"><code>	var sa usigactiont</code></span>
<span class="codeline" id="line-363"><code>	*(*uintptr)(unsafe.Pointer(&amp;sa.__sigaction_u)) = handler</code></span>
<span class="codeline" id="line-364"><code>	sa.sa_mask = osa.sa_mask</code></span>
<span class="codeline" id="line-365"><code>	sa.sa_flags = osa.sa_flags | _SA_ONSTACK</code></span>
<span class="codeline" id="line-366"><code>	sigaction(i, &amp;sa, nil)</code></span>
<span class="codeline" id="line-367"><code>}</code></span>
<span class="codeline" id="line-368"><code></code></span>
<span class="codeline" id="line-369"><code>//go:nosplit</code></span>
<span class="codeline" id="line-370"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-371"><code>func getsig(i uint32) uintptr {</code></span>
<span class="codeline" id="line-372"><code>	var sa usigactiont</code></span>
<span class="codeline" id="line-373"><code>	sigaction(i, nil, &amp;sa)</code></span>
<span class="codeline" id="line-374"><code>	return *(*uintptr)(unsafe.Pointer(&amp;sa.__sigaction_u))</code></span>
<span class="codeline" id="line-375"><code>}</code></span>
<span class="codeline" id="line-376"><code></code></span>
<span class="codeline" id="line-377"><code>// setSignaltstackSP sets the ss_sp field of a stackt.</code></span>
<span class="codeline" id="line-378"><code>//go:nosplit</code></span>
<span class="codeline" id="line-379"><code>func setSignalstackSP(s *stackt, sp uintptr) {</code></span>
<span class="codeline" id="line-380"><code>	*(*uintptr)(unsafe.Pointer(&amp;s.ss_sp)) = sp</code></span>
<span class="codeline" id="line-381"><code>}</code></span>
<span class="codeline" id="line-382"><code></code></span>
<span class="codeline" id="line-383"><code>//go:nosplit</code></span>
<span class="codeline" id="line-384"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-385"><code>func sigaddset(mask *sigset, i int) {</code></span>
<span class="codeline" id="line-386"><code>	*mask |= 1 &lt;&lt; (uint32(i) - 1)</code></span>
<span class="codeline" id="line-387"><code>}</code></span>
<span class="codeline" id="line-388"><code></code></span>
<span class="codeline" id="line-389"><code>func sigdelset(mask *sigset, i int) {</code></span>
<span class="codeline" id="line-390"><code>	*mask &amp;^= 1 &lt;&lt; (uint32(i) - 1)</code></span>
<span class="codeline" id="line-391"><code>}</code></span>
<span class="codeline" id="line-392"><code></code></span>
<span class="codeline" id="line-393"><code>//go:linkname executablePath os.executablePath</code></span>
<span class="codeline" id="line-394"><code>var executablePath string</code></span>
<span class="codeline" id="line-395"><code></code></span>
<span class="codeline" id="line-396"><code>func sysargs(argc int32, argv **byte) {</code></span>
<span class="codeline" id="line-397"><code>	// skip over argv, envv and the first string will be the path</code></span>
<span class="codeline" id="line-398"><code>	n := argc + 1</code></span>
<span class="codeline" id="line-399"><code>	for argv_index(argv, n) != nil {</code></span>
<span class="codeline" id="line-400"><code>		n++</code></span>
<span class="codeline" id="line-401"><code>	}</code></span>
<span class="codeline" id="line-402"><code>	executablePath = gostringnocopy(argv_index(argv, n+1))</code></span>
<span class="codeline" id="line-403"><code></code></span>
<span class="codeline" id="line-404"><code>	// strip "executable_path=" prefix if available, it's added after OS X 10.11.</code></span>
<span class="codeline" id="line-405"><code>	const prefix = "executable_path="</code></span>
<span class="codeline" id="line-406"><code>	if len(executablePath) &gt; len(prefix) &amp;&amp; executablePath[:len(prefix)] == prefix {</code></span>
<span class="codeline" id="line-407"><code>		executablePath = executablePath[len(prefix):]</code></span>
<span class="codeline" id="line-408"><code>	}</code></span>
<span class="codeline" id="line-409"><code>}</code></span>
<span class="codeline" id="line-410"><code></code></span>
<span class="codeline" id="line-411"><code>func signalM(mp *m, sig int) {</code></span>
<span class="codeline" id="line-412"><code>	pthread_kill(pthread(mp.procid), uint32(sig))</code></span>
<span class="codeline" id="line-413"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/article/tool-golds.html"><b>Golds</b></a> <i>v0.1.6</i>. (GOOS=darwin GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project and developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table
</pre>
</div></body></html>